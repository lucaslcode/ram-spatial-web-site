/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/detect-browser/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/detect-browser/es/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserInfo": function() { return /* binding */ BrowserInfo; },
/* harmony export */   "NodeInfo": function() { return /* binding */ NodeInfo; },
/* harmony export */   "SearchBotDeviceInfo": function() { return /* binding */ SearchBotDeviceInfo; },
/* harmony export */   "BotInfo": function() { return /* binding */ BotInfo; },
/* harmony export */   "ReactNativeInfo": function() { return /* binding */ ReactNativeInfo; },
/* harmony export */   "detect": function() { return /* binding */ detect; },
/* harmony export */   "browserName": function() { return /* binding */ browserName; },
/* harmony export */   "parseUserAgent": function() { return /* binding */ parseUserAgent; },
/* harmony export */   "detectOS": function() { return /* binding */ detectOS; },
/* harmony export */   "getNodeVersion": function() { return /* binding */ getNodeVersion; }
/* harmony export */ });
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


/***/ }),

/***/ "./node_modules/nunjucks/browser/nunjucks.js":
/*!***************************************************!*\
  !*** ./node_modules/nunjucks/browser/nunjucks.js ***!
  \***************************************************/
/***/ (function(module) {

/*! Browser bundle of nunjucks 3.2.3  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_617__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_617__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_617__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_617__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_617__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_617__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_617__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_617__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_617__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_617__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_617__(__nested_webpack_require_617__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};
var escapeRegex = /[&"'<>]/g;
var exports = module.exports = {};

function hasOwnProp(obj, k) {
  return ObjProto.hasOwnProperty.call(obj, k);
}

exports.hasOwnProp = hasOwnProp;

function lookupEscape(ch) {
  return escapeMap[ch];
}

function _prettifyError(path, withInternals, err) {
  if (!err.Update) {
    // not one of ours, cast it
    err = new exports.TemplateError(err);
  }

  err.Update(path); // Unless they marked the dev flag, show them a trace from here

  if (!withInternals) {
    var old = err;
    err = new Error(old.message);
    err.name = old.name;
  }

  return err;
}

exports._prettifyError = _prettifyError;

function TemplateError(message, lineno, colno) {
  var err;
  var cause;

  if (message instanceof Error) {
    cause = message;
    message = cause.name + ": " + cause.message;
  }

  if (Object.setPrototypeOf) {
    err = new Error(message);
    Object.setPrototypeOf(err, TemplateError.prototype);
  } else {
    err = this;
    Object.defineProperty(err, 'message', {
      enumerable: false,
      writable: true,
      value: message
    });
  }

  Object.defineProperty(err, 'name', {
    value: 'Template render error'
  });

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, this.constructor);
  }

  var getStack;

  if (cause) {
    var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

    getStack = stackDescriptor && (stackDescriptor.get || function () {
      return stackDescriptor.value;
    });

    if (!getStack) {
      getStack = function getStack() {
        return cause.stack;
      };
    }
  } else {
    var stack = new Error(message).stack;

    getStack = function getStack() {
      return stack;
    };
  }

  Object.defineProperty(err, 'stack', {
    get: function get() {
      return getStack.call(err);
    }
  });
  Object.defineProperty(err, 'cause', {
    value: cause
  });
  err.lineno = lineno;
  err.colno = colno;
  err.firstUpdate = true;

  err.Update = function Update(path) {
    var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
    // where error occurred

    if (this.firstUpdate) {
      if (this.lineno && this.colno) {
        msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
      } else if (this.lineno) {
        msg += " [Line " + this.lineno + "]";
      }
    }

    msg += '\n ';

    if (this.firstUpdate) {
      msg += ' ';
    }

    this.message = msg + (this.message || '');
    this.firstUpdate = false;
    return this;
  };

  return err;
}

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
  TemplateError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: TemplateError
    }
  });
}

exports.TemplateError = TemplateError;

function escape(val) {
  return val.replace(escapeRegex, lookupEscape);
}

exports.escape = escape;

function isFunction(obj) {
  return ObjProto.toString.call(obj) === '[object Function]';
}

exports.isFunction = isFunction;

function isArray(obj) {
  return ObjProto.toString.call(obj) === '[object Array]';
}

exports.isArray = isArray;

function isString(obj) {
  return ObjProto.toString.call(obj) === '[object String]';
}

exports.isString = isString;

function isObject(obj) {
  return ObjProto.toString.call(obj) === '[object Object]';
}

exports.isObject = isObject;
/**
 * @param {string|number} attr
 * @returns {(string|number)[]}
 * @private
 */

function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }

  if (typeof attr === 'string') {
    return attr.split('.');
  }

  return [attr];
}
/**
 * @param {string}   attribute      Attribute value. Dots allowed.
 * @returns {function(Object): *}
 */


function getAttrGetter(attribute) {
  var parts = _prepareAttributeParts(attribute);

  return function attrGetter(item) {
    var _item = item;

    for (var i = 0; i < parts.length; i++) {
      var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
      // that something goes wrong. Just roll out to undefined in that case.

      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return undefined;
      }
    }

    return _item;
  };
}

exports.getAttrGetter = getAttrGetter;

function groupBy(obj, val, throwOnUndefined) {
  var result = {};
  var iterator = isFunction(val) ? val : getAttrGetter(val);

  for (var i = 0; i < obj.length; i++) {
    var value = obj[i];
    var key = iterator(value, i);

    if (key === undefined && throwOnUndefined === true) {
      throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
    }

    (result[key] || (result[key] = [])).push(value);
  }

  return result;
}

exports.groupBy = groupBy;

function toArray(obj) {
  return Array.prototype.slice.call(obj);
}

exports.toArray = toArray;

function without(array) {
  var result = [];

  if (!array) {
    return result;
  }

  var length = array.length;
  var contains = toArray(arguments).slice(1);
  var index = -1;

  while (++index < length) {
    if (indexOf(contains, array[index]) === -1) {
      result.push(array[index]);
    }
  }

  return result;
}

exports.without = without;

function repeat(char_, n) {
  var str = '';

  for (var i = 0; i < n; i++) {
    str += char_;
  }

  return str;
}

exports.repeat = repeat;

function each(obj, func, context) {
  if (obj == null) {
    return;
  }

  if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
    obj.forEach(func, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      func.call(context, obj[i], i, obj);
    }
  }
}

exports.each = each;

function map(obj, func) {
  var results = [];

  if (obj == null) {
    return results;
  }

  if (ArrayProto.map && obj.map === ArrayProto.map) {
    return obj.map(func);
  }

  for (var i = 0; i < obj.length; i++) {
    results[results.length] = func(obj[i], i);
  }

  if (obj.length === +obj.length) {
    results.length = obj.length;
  }

  return results;
}

exports.map = map;

function asyncIter(arr, iter, cb) {
  var i = -1;

  function next() {
    i++;

    if (i < arr.length) {
      iter(arr[i], i, next, cb);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncIter = asyncIter;

function asyncFor(obj, iter, cb) {
  var keys = keys_(obj || {});
  var len = keys.length;
  var i = -1;

  function next() {
    i++;
    var k = keys[i];

    if (i < len) {
      iter(k, obj[k], i, len, next);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncFor = asyncFor;

function indexOf(arr, searchElement, fromIndex) {
  return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}

exports.indexOf = indexOf;

function keys_(obj) {
  /* eslint-disable no-restricted-syntax */
  var arr = [];

  for (var k in obj) {
    if (hasOwnProp(obj, k)) {
      arr.push(k);
    }
  }

  return arr;
}

exports.keys = keys_;

function _entries(obj) {
  return keys_(obj).map(function (k) {
    return [k, obj[k]];
  });
}

exports._entries = _entries;

function _values(obj) {
  return keys_(obj).map(function (k) {
    return obj[k];
  });
}

exports._values = _values;

function extend(obj1, obj2) {
  obj1 = obj1 || {};
  keys_(obj2).forEach(function (k) {
    obj1[k] = obj2[k];
  });
  return obj1;
}

exports._assign = exports.extend = extend;

function inOperator(key, val) {
  if (isArray(val) || isString(val)) {
    return val.indexOf(key) !== -1;
  } else if (isObject(val)) {
    return key in val;
  }

  throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}

exports.inOperator = inOperator;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_10865__) {

"use strict";
 // A simple class system, more documentation to come

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = __nested_webpack_require_10865__(16);

var lib = __nested_webpack_require_10865__(0);

function parentWrap(parent, prop) {
  if (typeof parent !== 'function' || typeof prop !== 'function') {
    return prop;
  }

  return function wrap() {
    // Save the current parent method
    var tmp = this.parent; // Set parent to the previous method, call, and restore

    this.parent = parent;
    var res = prop.apply(this, arguments);
    this.parent = tmp;
    return res;
  };
}

function extendClass(cls, name, props) {
  props = props || {};
  lib.keys(props).forEach(function (k) {
    props[k] = parentWrap(cls.prototype[k], props[k]);
  });

  var subclass = /*#__PURE__*/function (_cls) {
    _inheritsLoose(subclass, _cls);

    function subclass() {
      return _cls.apply(this, arguments) || this;
    }

    _createClass(subclass, [{
      key: "typename",
      get: function get() {
        return name;
      }
    }]);

    return subclass;
  }(cls);

  lib._assign(subclass.prototype, props);

  return subclass;
}

var Obj = /*#__PURE__*/function () {
  function Obj() {
    // Unfortunately necessary for backwards compatibility
    this.init.apply(this, arguments);
  }

  var _proto = Obj.prototype;

  _proto.init = function init() {};

  Obj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(Obj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Obj;
}();

var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(EmitterObj, _EventEmitter);

  function EmitterObj() {
    var _this2;

    var _this;

    _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

    (_this2 = _this).init.apply(_this2, arguments);

    return _this;
  }

  var _proto2 = EmitterObj.prototype;

  _proto2.init = function init() {};

  EmitterObj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(EmitterObj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return EmitterObj;
}(EventEmitter);

module.exports = {
  Obj: Obj,
  EmitterObj: EmitterObj
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_14315__) {

"use strict";


var lib = __nested_webpack_require_14315__(0);

var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
// we know how to access variables. Block tags can introduce special
// variables, for example.

var Frame = /*#__PURE__*/function () {
  function Frame(parent, isolateWrites) {
    this.variables = Object.create(null);
    this.parent = parent;
    this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
    // this frame to its parent (though reads may).

    this.isolateWrites = isolateWrites;
  }

  var _proto = Frame.prototype;

  _proto.set = function set(name, val, resolveUp) {
    // Allow variables with dots by automatically creating the
    // nested structure
    var parts = name.split('.');
    var obj = this.variables;
    var frame = this;

    if (resolveUp) {
      if (frame = this.resolve(parts[0], true)) {
        frame.set(name, val);
        return;
      }
    }

    for (var i = 0; i < parts.length - 1; i++) {
      var id = parts[i];

      if (!obj[id]) {
        obj[id] = {};
      }

      obj = obj[id];
    }

    obj[parts[parts.length - 1]] = val;
  };

  _proto.get = function get(name) {
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return null;
  };

  _proto.lookup = function lookup(name) {
    var p = this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return p && p.lookup(name);
  };

  _proto.resolve = function resolve(name, forWrite) {
    var p = forWrite && this.isolateWrites ? undefined : this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return this;
    }

    return p && p.resolve(name);
  };

  _proto.push = function push(isolateWrites) {
    return new Frame(this, isolateWrites);
  };

  _proto.pop = function pop() {
    return this.parent;
  };

  return Frame;
}();

function makeMacro(argNames, kwargNames, func) {
  return function macro() {
    for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      macroArgs[_key] = arguments[_key];
    }

    var argCount = numArgs(macroArgs);
    var args;
    var kwargs = getKeywordArgs(macroArgs);

    if (argCount > argNames.length) {
      args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
      // keyword arguments (essentially default values)

      macroArgs.slice(args.length, argCount).forEach(function (val, i) {
        if (i < kwargNames.length) {
          kwargs[kwargNames[i]] = val;
        }
      });
      args.push(kwargs);
    } else if (argCount < argNames.length) {
      args = macroArgs.slice(0, argCount);

      for (var i = argCount; i < argNames.length; i++) {
        var arg = argNames[i]; // Keyword arguments that should be passed as
        // positional arguments, i.e. the caller explicitly
        // used the name of a positional arg

        args.push(kwargs[arg]);
        delete kwargs[arg];
      }

      args.push(kwargs);
    } else {
      args = macroArgs;
    }

    return func.apply(this, args);
  };
}

function makeKeywordArgs(obj) {
  obj.__keywords = true;
  return obj;
}

function isKeywordArgs(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
}

function getKeywordArgs(args) {
  var len = args.length;

  if (len) {
    var lastArg = args[len - 1];

    if (isKeywordArgs(lastArg)) {
      return lastArg;
    }
  }

  return {};
}

function numArgs(args) {
  var len = args.length;

  if (len === 0) {
    return 0;
  }

  var lastArg = args[len - 1];

  if (isKeywordArgs(lastArg)) {
    return len - 1;
  } else {
    return len;
  }
} // A SafeString object indicates that the string should not be
// autoescaped. This happens magically because autoescaping only
// occurs on primitive string objects.


function SafeString(val) {
  if (typeof val !== 'string') {
    return val;
  }

  this.val = val;
  this.length = val.length;
}

SafeString.prototype = Object.create(String.prototype, {
  length: {
    writable: true,
    configurable: true,
    value: 0
  }
});

SafeString.prototype.valueOf = function valueOf() {
  return this.val;
};

SafeString.prototype.toString = function toString() {
  return this.val;
};

function copySafeness(dest, target) {
  if (dest instanceof SafeString) {
    return new SafeString(target);
  }

  return target.toString();
}

function markSafe(val) {
  var type = typeof val;

  if (type === 'string') {
    return new SafeString(val);
  } else if (type !== 'function') {
    return val;
  } else {
    return function wrapSafe(args) {
      var ret = val.apply(this, arguments);

      if (typeof ret === 'string') {
        return new SafeString(ret);
      }

      return ret;
    };
  }
}

function suppressValue(val, autoescape) {
  val = val !== undefined && val !== null ? val : '';

  if (autoescape && !(val instanceof SafeString)) {
    val = lib.escape(val.toString());
  }

  return val;
}

function ensureDefined(val, lineno, colno) {
  if (val === null || val === undefined) {
    throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
  }

  return val;
}

function memberLookup(obj, val) {
  if (obj === undefined || obj === null) {
    return undefined;
  }

  if (typeof obj[val] === 'function') {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return obj[val].apply(obj, args);
    };
  }

  return obj[val];
}

function callWrap(obj, name, context, args) {
  if (!obj) {
    throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
  } else if (typeof obj !== 'function') {
    throw new Error('Unable to call `' + name + '`, which is not a function');
  }

  return obj.apply(context, args);
}

function contextOrFrameLookup(context, frame, name) {
  var val = frame.lookup(name);
  return val !== undefined ? val : context.lookup(name);
}

function handleError(error, lineno, colno) {
  if (error.lineno) {
    return error;
  } else {
    return new lib.TemplateError(error, lineno, colno);
  }
}

function asyncEach(arr, dimen, iter, cb) {
  if (lib.isArray(arr)) {
    var len = arr.length;
    lib.asyncIter(arr, function iterCallback(item, i, next) {
      switch (dimen) {
        case 1:
          iter(item, i, len, next);
          break;

        case 2:
          iter(item[0], item[1], i, len, next);
          break;

        case 3:
          iter(item[0], item[1], item[2], i, len, next);
          break;

        default:
          item.push(i, len, next);
          iter.apply(this, item);
      }
    }, cb);
  } else {
    lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
      iter(key, val, i, len, next);
    }, cb);
  }
}

function asyncAll(arr, dimen, func, cb) {
  var finished = 0;
  var len;
  var outputArr;

  function done(i, output) {
    finished++;
    outputArr[i] = output;

    if (finished === len) {
      cb(null, outputArr.join(''));
    }
  }

  if (lib.isArray(arr)) {
    len = arr.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        switch (dimen) {
          case 1:
            func(item, i, len, done);
            break;

          case 2:
            func(item[0], item[1], i, len, done);
            break;

          case 3:
            func(item[0], item[1], item[2], i, len, done);
            break;

          default:
            item.push(i, len, done);
            func.apply(this, item);
        }
      }
    }
  } else {
    var keys = lib.keys(arr || {});
    len = keys.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var _i = 0; _i < keys.length; _i++) {
        var k = keys[_i];
        func(k, arr[k], _i, len, done);
      }
    }
  }
}

function fromIterator(arr) {
  if (typeof arr !== 'object' || arr === null || lib.isArray(arr)) {
    return arr;
  } else if (supportsIterators && Symbol.iterator in arr) {
    return arrayFrom(arr);
  } else {
    return arr;
  }
}

module.exports = {
  Frame: Frame,
  makeMacro: makeMacro,
  makeKeywordArgs: makeKeywordArgs,
  numArgs: numArgs,
  suppressValue: suppressValue,
  ensureDefined: ensureDefined,
  memberLookup: memberLookup,
  contextOrFrameLookup: contextOrFrameLookup,
  callWrap: callWrap,
  handleError: handleError,
  isArray: lib.isArray,
  keys: lib.keys,
  SafeString: SafeString,
  copySafeness: copySafeness,
  markSafe: markSafe,
  asyncEach: asyncEach,
  asyncAll: asyncAll,
  inOperator: lib.inOperator,
  fromIterator: fromIterator
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_23363__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = __nested_webpack_require_23363__(1),
    Obj = _require.Obj;

function traverseAndCheck(obj, type, results) {
  if (obj instanceof type) {
    results.push(obj);
  }

  if (obj instanceof Node) {
    obj.findAll(type, results);
  }
}

var Node = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Node, _Obj);

  function Node() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Node.prototype;

  _proto.init = function init(lineno, colno) {
    var _arguments = arguments,
        _this = this;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.lineno = lineno;
    this.colno = colno;
    this.fields.forEach(function (field, i) {
      // The first two args are line/col numbers, so offset by 2
      var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
      // testing easier to normalize values.

      if (val === undefined) {
        val = null;
      }

      _this[field] = val;
    });
  };

  _proto.findAll = function findAll(type, results) {
    var _this2 = this;

    results = results || [];

    if (this instanceof NodeList) {
      this.children.forEach(function (child) {
        return traverseAndCheck(child, type, results);
      });
    } else {
      this.fields.forEach(function (field) {
        return traverseAndCheck(_this2[field], type, results);
      });
    }

    return results;
  };

  _proto.iterFields = function iterFields(func) {
    var _this3 = this;

    this.fields.forEach(function (field) {
      func(_this3[field], field);
    });
  };

  return Node;
}(Obj); // Abstract nodes


var Value = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Value, _Node);

  function Value() {
    return _Node.apply(this, arguments) || this;
  }

  _createClass(Value, [{
    key: "typename",
    get: function get() {
      return 'Value';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['value'];
    }
  }]);

  return Value;
}(Node); // Concrete nodes


var NodeList = /*#__PURE__*/function (_Node2) {
  _inheritsLoose(NodeList, _Node2);

  function NodeList() {
    return _Node2.apply(this, arguments) || this;
  }

  var _proto2 = NodeList.prototype;

  _proto2.init = function init(lineno, colno, nodes) {
    _Node2.prototype.init.call(this, lineno, colno, nodes || []);
  };

  _proto2.addChild = function addChild(node) {
    this.children.push(node);
  };

  _createClass(NodeList, [{
    key: "typename",
    get: function get() {
      return 'NodeList';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['children'];
    }
  }]);

  return NodeList;
}(Node);

var Root = NodeList.extend('Root');
var Literal = Value.extend('Literal');
var Symbol = Value.extend('Symbol');
var Group = NodeList.extend('Group');
var ArrayNode = NodeList.extend('Array');
var Pair = Node.extend('Pair', {
  fields: ['key', 'value']
});
var Dict = NodeList.extend('Dict');
var LookupVal = Node.extend('LookupVal', {
  fields: ['target', 'val']
});
var If = Node.extend('If', {
  fields: ['cond', 'body', 'else_']
});
var IfAsync = If.extend('IfAsync');
var InlineIf = Node.extend('InlineIf', {
  fields: ['cond', 'body', 'else_']
});
var For = Node.extend('For', {
  fields: ['arr', 'name', 'body', 'else_']
});
var AsyncEach = For.extend('AsyncEach');
var AsyncAll = For.extend('AsyncAll');
var Macro = Node.extend('Macro', {
  fields: ['name', 'args', 'body']
});
var Caller = Macro.extend('Caller');
var Import = Node.extend('Import', {
  fields: ['template', 'target', 'withContext']
});

var FromImport = /*#__PURE__*/function (_Node3) {
  _inheritsLoose(FromImport, _Node3);

  function FromImport() {
    return _Node3.apply(this, arguments) || this;
  }

  var _proto3 = FromImport.prototype;

  _proto3.init = function init(lineno, colno, template, names, withContext) {
    _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
  };

  _createClass(FromImport, [{
    key: "typename",
    get: function get() {
      return 'FromImport';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['template', 'names', 'withContext'];
    }
  }]);

  return FromImport;
}(Node);

var FunCall = Node.extend('FunCall', {
  fields: ['name', 'args']
});
var Filter = FunCall.extend('Filter');
var FilterAsync = Filter.extend('FilterAsync', {
  fields: ['name', 'args', 'symbol']
});
var KeywordArgs = Dict.extend('KeywordArgs');
var Block = Node.extend('Block', {
  fields: ['name', 'body']
});
var Super = Node.extend('Super', {
  fields: ['blockName', 'symbol']
});
var TemplateRef = Node.extend('TemplateRef', {
  fields: ['template']
});
var Extends = TemplateRef.extend('Extends');
var Include = Node.extend('Include', {
  fields: ['template', 'ignoreMissing']
});
var Set = Node.extend('Set', {
  fields: ['targets', 'value']
});
var Switch = Node.extend('Switch', {
  fields: ['expr', 'cases', 'default']
});
var Case = Node.extend('Case', {
  fields: ['cond', 'body']
});
var Output = NodeList.extend('Output');
var Capture = Node.extend('Capture', {
  fields: ['body']
});
var TemplateData = Literal.extend('TemplateData');
var UnaryOp = Node.extend('UnaryOp', {
  fields: ['target']
});
var BinOp = Node.extend('BinOp', {
  fields: ['left', 'right']
});
var In = BinOp.extend('In');
var Is = BinOp.extend('Is');
var Or = BinOp.extend('Or');
var And = BinOp.extend('And');
var Not = UnaryOp.extend('Not');
var Add = BinOp.extend('Add');
var Concat = BinOp.extend('Concat');
var Sub = BinOp.extend('Sub');
var Mul = BinOp.extend('Mul');
var Div = BinOp.extend('Div');
var FloorDiv = BinOp.extend('FloorDiv');
var Mod = BinOp.extend('Mod');
var Pow = BinOp.extend('Pow');
var Neg = UnaryOp.extend('Neg');
var Pos = UnaryOp.extend('Pos');
var Compare = Node.extend('Compare', {
  fields: ['expr', 'ops']
});
var CompareOperand = Node.extend('CompareOperand', {
  fields: ['expr', 'type']
});
var CallExtension = Node.extend('CallExtension', {
  init: function init(ext, prop, args, contentArgs) {
    this.parent();
    this.extName = ext.__name || ext;
    this.prop = prop;
    this.args = args || new NodeList();
    this.contentArgs = contentArgs || [];
    this.autoescape = ext.autoescape;
  },
  fields: ['extName', 'prop', 'args', 'contentArgs']
});
var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

function print(str, indent, inline) {
  var lines = str.split('\n');
  lines.forEach(function (line, i) {
    if (line && (inline && i > 0 || !inline)) {
      process.stdout.write(' '.repeat(indent));
    }

    var nl = i === lines.length - 1 ? '' : '\n';
    process.stdout.write("" + line + nl);
  });
} // Print the AST in a nicely formatted tree format for debuggin


function printNodes(node, indent) {
  indent = indent || 0;
  print(node.typename + ': ', indent);

  if (node instanceof NodeList) {
    print('\n');
    node.children.forEach(function (n) {
      printNodes(n, indent + 2);
    });
  } else if (node instanceof CallExtension) {
    print(node.extName + "." + node.prop + "\n");

    if (node.args) {
      printNodes(node.args, indent + 2);
    }

    if (node.contentArgs) {
      node.contentArgs.forEach(function (n) {
        printNodes(n, indent + 2);
      });
    }
  } else {
    var nodes = [];
    var props = null;
    node.iterFields(function (val, fieldName) {
      if (val instanceof Node) {
        nodes.push([fieldName, val]);
      } else {
        props = props || {};
        props[fieldName] = val;
      }
    });

    if (props) {
      print(JSON.stringify(props, null, 2) + '\n', null, true);
    } else {
      print('\n');
    }

    nodes.forEach(function (_ref) {
      var fieldName = _ref[0],
          n = _ref[1];
      print("[" + fieldName + "] =>", indent + 2);
      printNodes(n, indent + 4);
    });
  }
}

module.exports = {
  Node: Node,
  Root: Root,
  NodeList: NodeList,
  Value: Value,
  Literal: Literal,
  Symbol: Symbol,
  Group: Group,
  Array: ArrayNode,
  Pair: Pair,
  Dict: Dict,
  Output: Output,
  Capture: Capture,
  TemplateData: TemplateData,
  If: If,
  IfAsync: IfAsync,
  InlineIf: InlineIf,
  For: For,
  AsyncEach: AsyncEach,
  AsyncAll: AsyncAll,
  Macro: Macro,
  Caller: Caller,
  Import: Import,
  FromImport: FromImport,
  FunCall: FunCall,
  Filter: Filter,
  FilterAsync: FilterAsync,
  KeywordArgs: KeywordArgs,
  Block: Block,
  Super: Super,
  Extends: Extends,
  Include: Include,
  Set: Set,
  Switch: Switch,
  Case: Case,
  LookupVal: LookupVal,
  BinOp: BinOp,
  In: In,
  Is: Is,
  Or: Or,
  And: And,
  Not: Not,
  Add: Add,
  Concat: Concat,
  Sub: Sub,
  Mul: Mul,
  Div: Div,
  FloorDiv: FloorDiv,
  Mod: Mod,
  Pow: Pow,
  Neg: Neg,
  Pos: Pos,
  Compare: Compare,
  CompareOperand: CompareOperand,
  CallExtension: CallExtension,
  CallExtensionAsync: CallExtensionAsync,
  printNodes: printNodes
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {



/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_33427__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var parser = __nested_webpack_require_33427__(8);

var transformer = __nested_webpack_require_33427__(17);

var nodes = __nested_webpack_require_33427__(3);

var _require = __nested_webpack_require_33427__(0),
    TemplateError = _require.TemplateError;

var _require2 = __nested_webpack_require_33427__(2),
    Frame = _require2.Frame;

var _require3 = __nested_webpack_require_33427__(1),
    Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
// through


var compareOps = {
  '==': '==',
  '===': '===',
  '!=': '!=',
  '!==': '!==',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>='
};

var Compiler = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Compiler, _Obj);

  function Compiler() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Compiler.prototype;

  _proto.init = function init(templateName, throwOnUndefined) {
    this.templateName = templateName;
    this.codebuf = [];
    this.lastId = 0;
    this.buffer = null;
    this.bufferStack = [];
    this._scopeClosers = '';
    this.inBlock = false;
    this.throwOnUndefined = throwOnUndefined;
  };

  _proto.fail = function fail(msg, lineno, colno) {
    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    throw new TemplateError(msg, lineno, colno);
  };

  _proto._pushBuffer = function _pushBuffer() {
    var id = this._tmpid();

    this.bufferStack.push(this.buffer);
    this.buffer = id;

    this._emit("var " + this.buffer + " = \"\";");

    return id;
  };

  _proto._popBuffer = function _popBuffer() {
    this.buffer = this.bufferStack.pop();
  };

  _proto._emit = function _emit(code) {
    this.codebuf.push(code);
  };

  _proto._emitLine = function _emitLine(code) {
    this._emit(code + '\n');
  };

  _proto._emitLines = function _emitLines() {
    var _this = this;

    for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
      lines[_key] = arguments[_key];
    }

    lines.forEach(function (line) {
      return _this._emitLine(line);
    });
  };

  _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
    this.buffer = 'output';
    this._scopeClosers = '';

    this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

    this._emitLine("var lineno = " + node.lineno + ";");

    this._emitLine("var colno = " + node.colno + ";");

    this._emitLine("var " + this.buffer + " = \"\";");

    this._emitLine('try {');
  };

  _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
    if (!noReturn) {
      this._emitLine('cb(null, ' + this.buffer + ');');
    }

    this._closeScopeLevels();

    this._emitLine('} catch (e) {');

    this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

    this._emitLine('}');

    this._emitLine('}');

    this.buffer = null;
  };

  _proto._addScopeLevel = function _addScopeLevel() {
    this._scopeClosers += '})';
  };

  _proto._closeScopeLevels = function _closeScopeLevels() {
    this._emitLine(this._scopeClosers + ';');

    this._scopeClosers = '';
  };

  _proto._withScopedSyntax = function _withScopedSyntax(func) {
    var _scopeClosers = this._scopeClosers;
    this._scopeClosers = '';
    func.call(this);

    this._closeScopeLevels();

    this._scopeClosers = _scopeClosers;
  };

  _proto._makeCallback = function _makeCallback(res) {
    var err = this._tmpid();

    return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
  };

  _proto._tmpid = function _tmpid() {
    this.lastId++;
    return 't_' + this.lastId;
  };

  _proto._templateName = function _templateName() {
    return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
  };

  _proto._compileChildren = function _compileChildren(node, frame) {
    var _this2 = this;

    node.children.forEach(function (child) {
      _this2.compile(child, frame);
    });
  };

  _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
    var _this3 = this;

    if (startChar) {
      this._emit(startChar);
    }

    node.children.forEach(function (child, i) {
      if (i > 0) {
        _this3._emit(',');
      }

      _this3.compile(child, frame);
    });

    if (endChar) {
      this._emit(endChar);
    }
  };

  _proto._compileExpression = function _compileExpression(node, frame) {
    // TODO: I'm not really sure if this type check is worth it or
    // not.
    this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
    this.compile(node, frame);
  };

  _proto.assertType = function assertType(node) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      types[_key2 - 1] = arguments[_key2];
    }

    if (!types.some(function (t) {
      return node instanceof t;
    })) {
      this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
    var _this4 = this;

    var args = node.args;
    var contentArgs = node.contentArgs;
    var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

    if (!async) {
      this._emit(this.buffer + " += runtime.suppressValue(");
    }

    this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

    this._emit('context');

    if (args || contentArgs) {
      this._emit(',');
    }

    if (args) {
      if (!(args instanceof nodes.NodeList)) {
        this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
      }

      args.children.forEach(function (arg, i) {
        // Tag arguments are passed normally to the call. Note
        // that keyword arguments are turned into a single js
        // object as the last argument, if they exist.
        _this4._compileExpression(arg, frame);

        if (i !== args.children.length - 1 || contentArgs.length) {
          _this4._emit(',');
        }
      });
    }

    if (contentArgs.length) {
      contentArgs.forEach(function (arg, i) {
        if (i > 0) {
          _this4._emit(',');
        }

        if (arg) {
          _this4._emitLine('function(cb) {');

          _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

          var id = _this4._pushBuffer();

          _this4._withScopedSyntax(function () {
            _this4.compile(arg, frame);

            _this4._emitLine("cb(null, " + id + ");");
          });

          _this4._popBuffer();

          _this4._emitLine("return " + id + ";");

          _this4._emitLine('}');
        } else {
          _this4._emit('null');
        }
      });
    }

    if (async) {
      var res = this._tmpid();

      this._emitLine(', ' + this._makeCallback(res));

      this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

      this._addScopeLevel();
    } else {
      this._emit(')');

      this._emit(", " + autoescape + " && env.opts.autoescape);\n");
    }
  };

  _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
    this.compileCallExtension(node, frame, true);
  };

  _proto.compileNodeList = function compileNodeList(node, frame) {
    this._compileChildren(node, frame);
  };

  _proto.compileLiteral = function compileLiteral(node) {
    if (typeof node.value === 'string') {
      var val = node.value.replace(/\\/g, '\\\\');
      val = val.replace(/"/g, '\\"');
      val = val.replace(/\n/g, '\\n');
      val = val.replace(/\r/g, '\\r');
      val = val.replace(/\t/g, '\\t');
      val = val.replace(/\u2028/g, "\\u2028");

      this._emit("\"" + val + "\"");
    } else if (node.value === null) {
      this._emit('null');
    } else {
      this._emit(node.value.toString());
    }
  };

  _proto.compileSymbol = function compileSymbol(node, frame) {
    var name = node.value;
    var v = frame.lookup(name);

    if (v) {
      this._emit(v);
    } else {
      this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
    }
  };

  _proto.compileGroup = function compileGroup(node, frame) {
    this._compileAggregate(node, frame, '(', ')');
  };

  _proto.compileArray = function compileArray(node, frame) {
    this._compileAggregate(node, frame, '[', ']');
  };

  _proto.compileDict = function compileDict(node, frame) {
    this._compileAggregate(node, frame, '{', '}');
  };

  _proto.compilePair = function compilePair(node, frame) {
    var key = node.key;
    var val = node.value;

    if (key instanceof nodes.Symbol) {
      key = new nodes.Literal(key.lineno, key.colno, key.value);
    } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
      this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
    }

    this.compile(key, frame);

    this._emit(': ');

    this._compileExpression(val, frame);
  };

  _proto.compileInlineIf = function compileInlineIf(node, frame) {
    this._emit('(');

    this.compile(node.cond, frame);

    this._emit('?');

    this.compile(node.body, frame);

    this._emit(':');

    if (node.else_ !== null) {
      this.compile(node.else_, frame);
    } else {
      this._emit('""');
    }

    this._emit(')');
  };

  _proto.compileIn = function compileIn(node, frame) {
    this._emit('runtime.inOperator(');

    this.compile(node.left, frame);

    this._emit(',');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileIs = function compileIs(node, frame) {
    // first, we need to try to get the name of the test function, if it's a
    // callable (i.e., has args) and not a symbol.
    var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
    : node.right.value;

    this._emit('env.getTest("' + right + '").call(context, ');

    this.compile(node.left, frame); // compile the arguments for the callable if they exist

    if (node.right.args) {
      this._emit(',');

      this.compile(node.right.args, frame);
    }

    this._emit(') === true');
  };

  _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
    this.compile(node.left, frame);

    this._emit(str);

    this.compile(node.right, frame);
  } // ensure concatenation instead of addition
  // by adding empty string in between
  ;

  _proto.compileOr = function compileOr(node, frame) {
    return this._binOpEmitter(node, frame, ' || ');
  };

  _proto.compileAnd = function compileAnd(node, frame) {
    return this._binOpEmitter(node, frame, ' && ');
  };

  _proto.compileAdd = function compileAdd(node, frame) {
    return this._binOpEmitter(node, frame, ' + ');
  };

  _proto.compileConcat = function compileConcat(node, frame) {
    return this._binOpEmitter(node, frame, ' + "" + ');
  };

  _proto.compileSub = function compileSub(node, frame) {
    return this._binOpEmitter(node, frame, ' - ');
  };

  _proto.compileMul = function compileMul(node, frame) {
    return this._binOpEmitter(node, frame, ' * ');
  };

  _proto.compileDiv = function compileDiv(node, frame) {
    return this._binOpEmitter(node, frame, ' / ');
  };

  _proto.compileMod = function compileMod(node, frame) {
    return this._binOpEmitter(node, frame, ' % ');
  };

  _proto.compileNot = function compileNot(node, frame) {
    this._emit('!');

    this.compile(node.target, frame);
  };

  _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
    this._emit('Math.floor(');

    this.compile(node.left, frame);

    this._emit(' / ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compilePow = function compilePow(node, frame) {
    this._emit('Math.pow(');

    this.compile(node.left, frame);

    this._emit(', ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileNeg = function compileNeg(node, frame) {
    this._emit('-');

    this.compile(node.target, frame);
  };

  _proto.compilePos = function compilePos(node, frame) {
    this._emit('+');

    this.compile(node.target, frame);
  };

  _proto.compileCompare = function compileCompare(node, frame) {
    var _this5 = this;

    this.compile(node.expr, frame);
    node.ops.forEach(function (op) {
      _this5._emit(" " + compareOps[op.type] + " ");

      _this5.compile(op.expr, frame);
    });
  };

  _proto.compileLookupVal = function compileLookupVal(node, frame) {
    this._emit('runtime.memberLookup((');

    this._compileExpression(node.target, frame);

    this._emit('),');

    this._compileExpression(node.val, frame);

    this._emit(')');
  };

  _proto._getNodeName = function _getNodeName(node) {
    switch (node.typename) {
      case 'Symbol':
        return node.value;

      case 'FunCall':
        return 'the return value of (' + this._getNodeName(node.name) + ')';

      case 'LookupVal':
        return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

      case 'Literal':
        return node.value.toString();

      default:
        return '--expression--';
    }
  };

  _proto.compileFunCall = function compileFunCall(node, frame) {
    // Keep track of line/col info at runtime by settings
    // variables within an expression. An expression in javascript
    // like (x, y, z) returns the last value, and x and y can be
    // anything
    this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

    this._emit('runtime.callWrap('); // Compile it as normal.


    this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
    // if the lookup fails.


    this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

    this._compileAggregate(node.args, frame, '[', '])');

    this._emit(')');
  };

  _proto.compileFilter = function compileFilter(node, frame) {
    var name = node.name;
    this.assertType(name, nodes.Symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emit(')');
  };

  _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
    var name = node.name;
    var symbol = node.symbol.value;
    this.assertType(name, nodes.Symbol);
    frame.set(symbol, symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emitLine(', ' + this._makeCallback(symbol));

    this._addScopeLevel();
  };

  _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
    this._emit('runtime.makeKeywordArgs(');

    this.compileDict(node, frame);

    this._emit(')');
  };

  _proto.compileSet = function compileSet(node, frame) {
    var _this6 = this;

    var ids = []; // Lookup the variable names for each identifier and create
    // new ones if necessary

    node.targets.forEach(function (target) {
      var name = target.value;
      var id = frame.lookup(name);

      if (id === null || id === undefined) {
        id = _this6._tmpid(); // Note: This relies on js allowing scope across
        // blocks, in case this is created inside an `if`

        _this6._emitLine('var ' + id + ';');
      }

      ids.push(id);
    });

    if (node.value) {
      this._emit(ids.join(' = ') + ' = ');

      this._compileExpression(node.value, frame);

      this._emitLine(';');
    } else {
      this._emit(ids.join(' = ') + ' = ');

      this.compile(node.body, frame);

      this._emitLine(';');
    }

    node.targets.forEach(function (target, i) {
      var id = ids[i];
      var name = target.value; // We are running this for every var, but it's very
      // uncommon to assign to multiple vars anyway

      _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

      _this6._emitLine('if(frame.topLevel) {');

      _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

      _this6._emitLine('}');

      if (name.charAt(0) !== '_') {
        _this6._emitLine('if(frame.topLevel) {');

        _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

        _this6._emitLine('}');
      }
    });
  };

  _proto.compileSwitch = function compileSwitch(node, frame) {
    var _this7 = this;

    this._emit('switch (');

    this.compile(node.expr, frame);

    this._emit(') {');

    node.cases.forEach(function (c, i) {
      _this7._emit('case ');

      _this7.compile(c.cond, frame);

      _this7._emit(': ');

      _this7.compile(c.body, frame); // preserve fall-throughs


      if (c.body.children.length) {
        _this7._emitLine('break;');
      }
    });

    if (node.default) {
      this._emit('default:');

      this.compile(node.default, frame);
    }

    this._emit('}');
  };

  _proto.compileIf = function compileIf(node, frame, async) {
    var _this8 = this;

    this._emit('if(');

    this._compileExpression(node.cond, frame);

    this._emitLine(') {');

    this._withScopedSyntax(function () {
      _this8.compile(node.body, frame);

      if (async) {
        _this8._emit('cb()');
      }
    });

    if (node.else_) {
      this._emitLine('}\nelse {');

      this._withScopedSyntax(function () {
        _this8.compile(node.else_, frame);

        if (async) {
          _this8._emit('cb()');
        }
      });
    } else if (async) {
      this._emitLine('}\nelse {');

      this._emit('cb()');
    }

    this._emitLine('}');
  };

  _proto.compileIfAsync = function compileIfAsync(node, frame) {
    this._emit('(function(cb) {');

    this.compileIf(node, frame, true);

    this._emit('})(' + this._makeCallback());

    this._addScopeLevel();
  };

  _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
    var _this9 = this;

    var bindings = [{
      name: 'index',
      val: i + " + 1"
    }, {
      name: 'index0',
      val: i
    }, {
      name: 'revindex',
      val: len + " - " + i
    }, {
      name: 'revindex0',
      val: len + " - " + i + " - 1"
    }, {
      name: 'first',
      val: i + " === 0"
    }, {
      name: 'last',
      val: i + " === " + len + " - 1"
    }, {
      name: 'length',
      val: len
    }];
    bindings.forEach(function (b) {
      _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
    });
  };

  _proto.compileFor = function compileFor(node, frame) {
    var _this10 = this;

    // Some of this code is ugly, but it keeps the generated code
    // as fast as possible. ForAsync also shares some of this, but
    // not much.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit("var " + arr + " = ");

    this._compileExpression(node.arr, frame);

    this._emitLine(';');

    this._emit("if(" + arr + ") {");

    this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
    // appropriately


    if (node.name instanceof nodes.Array) {
      this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
      // body of the loop is duplicated for each condition, but
      // we are optimizing for speed over size.


      this._emitLine("if(runtime.isArray(" + arr + ")) {");

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


      node.name.children.forEach(function (child, u) {
        var tid = _this10._tmpid();

        _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

        _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

        frame.set(node.name.children[u].value, tid);
      });

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('} else {'); // Iterate over the key/values of an object


      var _node$name$children = node.name.children,
          key = _node$name$children[0],
          val = _node$name$children[1];

      var k = this._tmpid();

      var v = this._tmpid();

      frame.set(key.value, k);
      frame.set(val.value, v);

      this._emitLine(i + " = -1;");

      this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

      this._emitLine("for(var " + k + " in " + arr + ") {");

      this._emitLine(i + "++;");

      this._emitLine("var " + v + " = " + arr + "[" + k + "];");

      this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

      this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('}');
    } else {
      // Generate a typical array iteration
      var _v = this._tmpid();

      frame.set(node.name.value, _v);

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

      this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

      this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');
    }

    this._emitLine('}');

    if (node.else_) {
      this._emitLine('if (!' + len + ') {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
    var _this11 = this;

    // This shares some code with the For tag, but not enough to
    // worry about. This iterates across an object asynchronously,
    // but not in parallel.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit('var ' + arr + ' = runtime.fromIterator(');

    this._compileExpression(node.arr, frame);

    this._emitLine(');');

    if (node.name instanceof nodes.Array) {
      var arrayLen = node.name.children.length;

      this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

      node.name.children.forEach(function (name) {
        _this11._emit(name.value + ",");
      });

      this._emit(i + ',' + len + ',next) {');

      node.name.children.forEach(function (name) {
        var id = name.value;
        frame.set(id, id);

        _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
      });
    } else {
      var id = node.name.value;

      this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

      this._emitLine('frame.set("' + id + '", ' + id + ');');

      frame.set(id, id);
    }

    this._emitLoopBindings(node, arr, i, len);

    this._withScopedSyntax(function () {
      var buf;

      if (parallel) {
        buf = _this11._pushBuffer();
      }

      _this11.compile(node.body, frame);

      _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

      if (parallel) {
        _this11._popBuffer();
      }
    });

    var output = this._tmpid();

    this._emitLine('}, ' + this._makeCallback(output));

    this._addScopeLevel();

    if (parallel) {
      this._emitLine(this.buffer + ' += ' + output + ';');
    }

    if (node.else_) {
      this._emitLine('if (!' + arr + '.length) {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
    this._compileAsyncLoop(node, frame);
  };

  _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
    this._compileAsyncLoop(node, frame, true);
  };

  _proto._compileMacro = function _compileMacro(node, frame) {
    var _this12 = this;

    var args = [];
    var kwargs = null;

    var funcId = 'macro_' + this._tmpid();

    var keepFrame = frame !== undefined; // Type check the definition of the args

    node.args.children.forEach(function (arg, i) {
      if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
        kwargs = arg;
      } else {
        _this12.assertType(arg, nodes.Symbol);

        args.push(arg);
      }
    });
    var realNames = [].concat(args.map(function (n) {
      return "l_" + n.value;
    }), ['kwargs']); // Quoted argument names

    var argNames = args.map(function (n) {
      return "\"" + n.value + "\"";
    });
    var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
      return "\"" + n.key.value + "\"";
    }); // We pass a function to makeMacro which destructures the
    // arguments so support setting positional args with keywords
    // args and passing keyword args as positional args
    // (essentially default values). See runtime.js.

    var currFrame;

    if (keepFrame) {
      currFrame = frame.push(true);
    } else {
      currFrame = new Frame();
    }

    this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
    // random names because the function
    // will create a new run-time scope for us


    args.forEach(function (arg) {
      _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

      currFrame.set(arg.value, "l_" + arg.value);
    }); // Expose the keyword arguments

    if (kwargs) {
      kwargs.children.forEach(function (pair) {
        var name = pair.key.value;

        _this12._emit("frame.set(\"" + name + "\", ");

        _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

        _this12._emit(" ? kwargs[\"" + name + "\"] : ");

        _this12._compileExpression(pair.value, currFrame);

        _this12._emit(');');
      });
    }

    var bufferId = this._pushBuffer();

    this._withScopedSyntax(function () {
      _this12.compile(node.body, currFrame);
    });

    this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

    this._emitLine("return new runtime.SafeString(" + bufferId + ");");

    this._emitLine('});');

    this._popBuffer();

    return funcId;
  };

  _proto.compileMacro = function compileMacro(node, frame) {
    var funcId = this._compileMacro(node); // Expose the macro to the templates


    var name = node.name.value;
    frame.set(name, funcId);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
    } else {
      if (node.name.value.charAt(0) !== '_') {
        this._emitLine("context.addExport(\"" + name + "\");");
      }

      this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
    }
  };

  _proto.compileCaller = function compileCaller(node, frame) {
    // basically an anonymous "macro expression"
    this._emit('(function (){');

    var funcId = this._compileMacro(node, frame);

    this._emit("return " + funcId + ";})()");
  };

  _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
    var parentTemplateId = this._tmpid();

    var parentName = this._templateName();

    var cb = this._makeCallback(parentTemplateId);

    var eagerCompileArg = eagerCompile ? 'true' : 'false';
    var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

    this._emit('env.getTemplate(');

    this._compileExpression(node.template, frame);

    this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

    return parentTemplateId;
  };

  _proto.compileImport = function compileImport(node, frame) {
    var target = node.target.value;

    var id = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

    this._addScopeLevel();

    frame.set(target, id);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + target + "\", " + id + ");");
    } else {
      this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
    }
  };

  _proto.compileFromImport = function compileFromImport(node, frame) {
    var _this13 = this;

    var importedId = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

    this._addScopeLevel();

    node.names.children.forEach(function (nameNode) {
      var name;
      var alias;

      var id = _this13._tmpid();

      if (nameNode instanceof nodes.Pair) {
        name = nameNode.key.value;
        alias = nameNode.value.value;
      } else {
        name = nameNode.value;
        alias = name;
      }

      _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

      _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

      _this13._emitLine('} else {');

      _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

      _this13._emitLine('}');

      frame.set(alias, id);

      if (frame.parent) {
        _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
      } else {
        _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
      }
    });
  };

  _proto.compileBlock = function compileBlock(node) {
    var id = this._tmpid(); // If we are executing outside a block (creating a top-level
    // block), we really don't want to execute its code because it
    // will execute twice: once when the child template runs and
    // again when the parent template runs. Note that blocks
    // within blocks will *always* execute immediately *and*
    // wherever else they are invoked (like used in a parent
    // template). This may have behavioral differences from jinja
    // because blocks can have side effects, but it seems like a
    // waste of performance to always execute huge top-level
    // blocks twice


    if (!this.inBlock) {
      this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
    }

    this._emit("context.getBlock(\"" + node.name.value + "\")");

    if (!this.inBlock) {
      this._emit(')');
    }

    this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

    this._emitLine(this.buffer + " += " + id + ";");

    this._addScopeLevel();
  };

  _proto.compileSuper = function compileSuper(node, frame) {
    var name = node.blockName.value;
    var id = node.symbol.value;

    var cb = this._makeCallback(id);

    this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

    this._emitLine(id + " = runtime.markSafe(" + id + ");");

    this._addScopeLevel();

    frame.set(id, id);
  };

  _proto.compileExtends = function compileExtends(node, frame) {
    var k = this._tmpid();

    var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
    // `if`, so if this happens we need to capture the parent
    // template in the top-level scope


    this._emitLine("parentTemplate = " + parentTemplateId);

    this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

    this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

    this._emitLine('}');

    this._addScopeLevel();
  };

  _proto.compileInclude = function compileInclude(node, frame) {
    this._emitLine('var tasks = [];');

    this._emitLine('tasks.push(');

    this._emitLine('function(callback) {');

    var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

    this._emitLine("callback(null," + id + ");});");

    this._emitLine('});');

    var id2 = this._tmpid();

    this._emitLine('tasks.push(');

    this._emitLine('function(template, callback){');

    this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

    this._emitLine('callback(null,' + id2 + ');});');

    this._emitLine('});');

    this._emitLine('tasks.push(');

    this._emitLine('function(result, callback){');

    this._emitLine(this.buffer + " += result;");

    this._emitLine('callback(null);');

    this._emitLine('});');

    this._emitLine('env.waterfall(tasks, function(){');

    this._addScopeLevel();
  };

  _proto.compileTemplateData = function compileTemplateData(node, frame) {
    this.compileLiteral(node, frame);
  };

  _proto.compileCapture = function compileCapture(node, frame) {
    var _this14 = this;

    // we need to temporarily override the current buffer id as 'output'
    // so the set block writes to the capture output instead of the buffer
    var buffer = this.buffer;
    this.buffer = 'output';

    this._emitLine('(function() {');

    this._emitLine('var output = "";');

    this._withScopedSyntax(function () {
      _this14.compile(node.body, frame);
    });

    this._emitLine('return output;');

    this._emitLine('})()'); // and of course, revert back to the old buffer id


    this.buffer = buffer;
  };

  _proto.compileOutput = function compileOutput(node, frame) {
    var _this15 = this;

    var children = node.children;
    children.forEach(function (child) {
      // TemplateData is a special case because it is never
      // autoescaped, so simply output it for optimization
      if (child instanceof nodes.TemplateData) {
        if (child.value) {
          _this15._emit(_this15.buffer + " += ");

          _this15.compileLiteral(child, frame);

          _this15._emitLine(';');
        }
      } else {
        _this15._emit(_this15.buffer + " += runtime.suppressValue(");

        if (_this15.throwOnUndefined) {
          _this15._emit('runtime.ensureDefined(');
        }

        _this15.compile(child, frame);

        if (_this15.throwOnUndefined) {
          _this15._emit("," + node.lineno + "," + node.colno + ")");
        }

        _this15._emit(', env.opts.autoescape);\n');
      }
    });
  };

  _proto.compileRoot = function compileRoot(node, frame) {
    var _this16 = this;

    if (frame) {
      this.fail('compileRoot: root node can\'t have frame');
    }

    frame = new Frame();

    this._emitFuncBegin(node, 'root');

    this._emitLine('var parentTemplate = null;');

    this._compileChildren(node, frame);

    this._emitLine('if(parentTemplate) {');

    this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

    this._emitLine('} else {');

    this._emitLine("cb(null, " + this.buffer + ");");

    this._emitLine('}');

    this._emitFuncEnd(true);

    this.inBlock = true;
    var blockNames = [];
    var blocks = node.findAll(nodes.Block);
    blocks.forEach(function (block, i) {
      var name = block.name.value;

      if (blockNames.indexOf(name) !== -1) {
        throw new Error("Block \"" + name + "\" defined more than once.");
      }

      blockNames.push(name);

      _this16._emitFuncBegin(block, "b_" + name);

      var tmpFrame = new Frame();

      _this16._emitLine('var frame = frame.push(true);');

      _this16.compile(block.body, tmpFrame);

      _this16._emitFuncEnd();
    });

    this._emitLine('return {');

    blocks.forEach(function (block, i) {
      var blockName = "b_" + block.name.value;

      _this16._emitLine(blockName + ": " + blockName + ",");
    });

    this._emitLine('root: root\n};');
  };

  _proto.compile = function compile(node, frame) {
    var _compile = this['compile' + node.typename];

    if (_compile) {
      _compile.call(this, node, frame);
    } else {
      this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.getCode = function getCode() {
    return this.codebuf.join('');
  };

  return Compiler;
}(Obj);

module.exports = {
  compile: function compile(src, asyncFilters, extensions, name, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

    var preprocessors = (extensions || []).map(function (ext) {
      return ext.preprocess;
    }).filter(function (f) {
      return !!f;
    });
    var processedSrc = preprocessors.reduce(function (s, processor) {
      return processor(s);
    }, src);
    c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
    return c.getCode();
  },
  Compiler: Compiler
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_71591__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var path = __nested_webpack_require_71591__(4);

var _require = __nested_webpack_require_71591__(1),
    EmitterObj = _require.EmitterObj;

module.exports = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Loader, _EmitterObj);

  function Loader() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Loader.prototype;

  _proto.resolve = function resolve(from, to) {
    return path.resolve(path.dirname(from), to);
  };

  _proto.isRelative = function isRelative(filename) {
    return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
  };

  return Loader;
}(EmitterObj);

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_72640__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var asap = __nested_webpack_require_72640__(12);

var _waterfall = __nested_webpack_require_72640__(15);

var lib = __nested_webpack_require_72640__(0);

var compiler = __nested_webpack_require_72640__(5);

var filters = __nested_webpack_require_72640__(18);

var _require = __nested_webpack_require_72640__(10),
    FileSystemLoader = _require.FileSystemLoader,
    WebLoader = _require.WebLoader,
    PrecompiledLoader = _require.PrecompiledLoader;

var tests = __nested_webpack_require_72640__(20);

var globals = __nested_webpack_require_72640__(21);

var _require2 = __nested_webpack_require_72640__(1),
    Obj = _require2.Obj,
    EmitterObj = _require2.EmitterObj;

var globalRuntime = __nested_webpack_require_72640__(2);

var handleError = globalRuntime.handleError,
    Frame = globalRuntime.Frame;

var expressApp = __nested_webpack_require_72640__(22); // If the user is using the async API, *always* call it
// asynchronously even if the template was synchronous.


function callbackAsap(cb, err, res) {
  asap(function () {
    cb(err, res);
  });
}
/**
 * A no-op template, for use with {% include ignore missing %}
 */


var noopTmplSrc = {
  type: 'code',
  obj: {
    root: function root(env, context, frame, runtime, cb) {
      try {
        cb(null, '');
      } catch (e) {
        cb(handleError(e, null, null));
      }
    }
  }
};

var Environment = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Environment, _EmitterObj);

  function Environment() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Environment.prototype;

  _proto.init = function init(loaders, opts) {
    var _this = this;

    // The dev flag determines the trace that'll be shown on errors.
    // If set to true, returns the full trace from the error point,
    // otherwise will return trace starting from Template.render
    // (the full trace from within nunjucks may confuse developers using
    //  the library)
    // defaults to false
    opts = this.opts = opts || {};
    this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
    // every string variable will be escaped by default.
    // If false, strings can be manually escaped using the `escape` filter.
    // defaults to true

    this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
    // to output a null or undefined value

    this.opts.throwOnUndefined = !!opts.throwOnUndefined;
    this.opts.trimBlocks = !!opts.trimBlocks;
    this.opts.lstripBlocks = !!opts.lstripBlocks;
    this.loaders = [];

    if (!loaders) {
      // The filesystem loader is only available server-side
      if (FileSystemLoader) {
        this.loaders = [new FileSystemLoader('views')];
      } else if (WebLoader) {
        this.loaders = [new WebLoader('/views')];
      }
    } else {
      this.loaders = lib.isArray(loaders) ? loaders : [loaders];
    } // It's easy to use precompiled templates: just include them
    // before you configure nunjucks and this will automatically
    // pick it up and use it


    if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
      this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
    }

    this._initLoaders();

    this.globals = globals();
    this.filters = {};
    this.tests = {};
    this.asyncFilters = [];
    this.extensions = {};
    this.extensionsList = [];

    lib._entries(filters).forEach(function (_ref) {
      var name = _ref[0],
          filter = _ref[1];
      return _this.addFilter(name, filter);
    });

    lib._entries(tests).forEach(function (_ref2) {
      var name = _ref2[0],
          test = _ref2[1];
      return _this.addTest(name, test);
    });
  };

  _proto._initLoaders = function _initLoaders() {
    var _this2 = this;

    this.loaders.forEach(function (loader) {
      // Caching and cache busting
      loader.cache = {};

      if (typeof loader.on === 'function') {
        loader.on('update', function (name, fullname) {
          loader.cache[name] = null;

          _this2.emit('update', name, fullname, loader);
        });
        loader.on('load', function (name, source) {
          _this2.emit('load', name, source, loader);
        });
      }
    });
  };

  _proto.invalidateCache = function invalidateCache() {
    this.loaders.forEach(function (loader) {
      loader.cache = {};
    });
  };

  _proto.addExtension = function addExtension(name, extension) {
    extension.__name = name;
    this.extensions[name] = extension;
    this.extensionsList.push(extension);
    return this;
  };

  _proto.removeExtension = function removeExtension(name) {
    var extension = this.getExtension(name);

    if (!extension) {
      return;
    }

    this.extensionsList = lib.without(this.extensionsList, extension);
    delete this.extensions[name];
  };

  _proto.getExtension = function getExtension(name) {
    return this.extensions[name];
  };

  _proto.hasExtension = function hasExtension(name) {
    return !!this.extensions[name];
  };

  _proto.addGlobal = function addGlobal(name, value) {
    this.globals[name] = value;
    return this;
  };

  _proto.getGlobal = function getGlobal(name) {
    if (typeof this.globals[name] === 'undefined') {
      throw new Error('global not found: ' + name);
    }

    return this.globals[name];
  };

  _proto.addFilter = function addFilter(name, func, async) {
    var wrapped = func;

    if (async) {
      this.asyncFilters.push(name);
    }

    this.filters[name] = wrapped;
    return this;
  };

  _proto.getFilter = function getFilter(name) {
    if (!this.filters[name]) {
      throw new Error('filter not found: ' + name);
    }

    return this.filters[name];
  };

  _proto.addTest = function addTest(name, func) {
    this.tests[name] = func;
    return this;
  };

  _proto.getTest = function getTest(name) {
    if (!this.tests[name]) {
      throw new Error('test not found: ' + name);
    }

    return this.tests[name];
  };

  _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
    var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
    return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
  };

  _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
    var _this3 = this;

    var that = this;
    var tmpl = null;

    if (name && name.raw) {
      // this fixes autoescape for templates referenced in symbols
      name = name.raw;
    }

    if (lib.isFunction(parentName)) {
      cb = parentName;
      parentName = null;
      eagerCompile = eagerCompile || false;
    }

    if (lib.isFunction(eagerCompile)) {
      cb = eagerCompile;
      eagerCompile = false;
    }

    if (name instanceof Template) {
      tmpl = name;
    } else if (typeof name !== 'string') {
      throw new Error('template names must be a string: ' + name);
    } else {
      for (var i = 0; i < this.loaders.length; i++) {
        var loader = this.loaders[i];
        tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

        if (tmpl) {
          break;
        }
      }
    }

    if (tmpl) {
      if (eagerCompile) {
        tmpl.compile();
      }

      if (cb) {
        cb(null, tmpl);
        return undefined;
      } else {
        return tmpl;
      }
    }

    var syncResult;

    var createTemplate = function createTemplate(err, info) {
      if (!info && !err && !ignoreMissing) {
        err = new Error('template not found: ' + name);
      }

      if (err) {
        if (cb) {
          cb(err);
          return;
        } else {
          throw err;
        }
      }

      var newTmpl;

      if (!info) {
        newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
      } else {
        newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

        if (!info.noCache) {
          info.loader.cache[name] = newTmpl;
        }
      }

      if (cb) {
        cb(null, newTmpl);
      } else {
        syncResult = newTmpl;
      }
    };

    lib.asyncIter(this.loaders, function (loader, i, next, done) {
      function handle(err, src) {
        if (err) {
          done(err);
        } else if (src) {
          src.loader = loader;
          done(null, src);
        } else {
          next();
        }
      } // Resolve name relative to parentName


      name = that.resolveTemplate(loader, parentName, name);

      if (loader.async) {
        loader.getSource(name, handle);
      } else {
        handle(null, loader.getSource(name));
      }
    }, createTemplate);
    return syncResult;
  };

  _proto.express = function express(app) {
    return expressApp(this, app);
  };

  _proto.render = function render(name, ctx, cb) {
    if (lib.isFunction(ctx)) {
      cb = ctx;
      ctx = null;
    } // We support a synchronous API to make it easier to migrate
    // existing code to async. This works because if you don't do
    // anything async work, the whole thing is actually run
    // synchronously.


    var syncResult = null;
    this.getTemplate(name, function (err, tmpl) {
      if (err && cb) {
        callbackAsap(cb, err);
      } else if (err) {
        throw err;
      } else {
        syncResult = tmpl.render(ctx, cb);
      }
    });
    return syncResult;
  };

  _proto.renderString = function renderString(src, ctx, opts, cb) {
    if (lib.isFunction(opts)) {
      cb = opts;
      opts = {};
    }

    opts = opts || {};
    var tmpl = new Template(src, this, opts.path);
    return tmpl.render(ctx, cb);
  };

  _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
    return _waterfall(tasks, callback, forceAsync);
  };

  return Environment;
}(EmitterObj);

var Context = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Context, _Obj);

  function Context() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto2 = Context.prototype;

  _proto2.init = function init(ctx, blocks, env) {
    var _this4 = this;

    // Has to be tied to an environment so we can tap into its globals.
    this.env = env || new Environment(); // Make a duplicate of ctx

    this.ctx = lib.extend({}, ctx);
    this.blocks = {};
    this.exported = [];
    lib.keys(blocks).forEach(function (name) {
      _this4.addBlock(name, blocks[name]);
    });
  };

  _proto2.lookup = function lookup(name) {
    // This is one of the most called functions, so optimize for
    // the typical case where the name isn't in the globals
    if (name in this.env.globals && !(name in this.ctx)) {
      return this.env.globals[name];
    } else {
      return this.ctx[name];
    }
  };

  _proto2.setVariable = function setVariable(name, val) {
    this.ctx[name] = val;
  };

  _proto2.getVariables = function getVariables() {
    return this.ctx;
  };

  _proto2.addBlock = function addBlock(name, block) {
    this.blocks[name] = this.blocks[name] || [];
    this.blocks[name].push(block);
    return this;
  };

  _proto2.getBlock = function getBlock(name) {
    if (!this.blocks[name]) {
      throw new Error('unknown block "' + name + '"');
    }

    return this.blocks[name][0];
  };

  _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
    var idx = lib.indexOf(this.blocks[name] || [], block);
    var blk = this.blocks[name][idx + 1];
    var context = this;

    if (idx === -1 || !blk) {
      throw new Error('no super block available for "' + name + '"');
    }

    blk(env, context, frame, runtime, cb);
  };

  _proto2.addExport = function addExport(name) {
    this.exported.push(name);
  };

  _proto2.getExported = function getExported() {
    var _this5 = this;

    var exported = {};
    this.exported.forEach(function (name) {
      exported[name] = _this5.ctx[name];
    });
    return exported;
  };

  return Context;
}(Obj);

var Template = /*#__PURE__*/function (_Obj2) {
  _inheritsLoose(Template, _Obj2);

  function Template() {
    return _Obj2.apply(this, arguments) || this;
  }

  var _proto3 = Template.prototype;

  _proto3.init = function init(src, env, path, eagerCompile) {
    this.env = env || new Environment();

    if (lib.isObject(src)) {
      switch (src.type) {
        case 'code':
          this.tmplProps = src.obj;
          break;

        case 'string':
          this.tmplStr = src.obj;
          break;

        default:
          throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
      }
    } else if (lib.isString(src)) {
      this.tmplStr = src;
    } else {
      throw new Error('src must be a string or an object describing the source');
    }

    this.path = path;

    if (eagerCompile) {
      try {
        this._compile();
      } catch (err) {
        throw lib._prettifyError(this.path, this.env.opts.dev, err);
      }
    } else {
      this.compiled = false;
    }
  };

  _proto3.render = function render(ctx, parentFrame, cb) {
    var _this6 = this;

    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    } else if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // If there is a parent frame, we are being called from internal
    // code of another template, and the internal system
    // depends on the sync/async nature of the parent template
    // to be inherited, so force an async callback


    var forceAsync = !parentFrame; // Catch compile errors for async rendering

    try {
      this.compile();
    } catch (e) {
      var err = lib._prettifyError(this.path, this.env.opts.dev, e);

      if (cb) {
        return callbackAsap(cb, err);
      } else {
        throw err;
      }
    }

    var context = new Context(ctx || {}, this.blocks, this.env);
    var frame = parentFrame ? parentFrame.push(true) : new Frame();
    frame.topLevel = true;
    var syncResult = null;
    var didError = false;
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
      // TODO: this is actually a bug in the compiled template (because waterfall
      // tasks are both not passing errors up the chain of callbacks AND are not
      // causing a return from the top-most render function). But fixing that
      // will require a more substantial change to the compiler.
      if (didError && cb && typeof res !== 'undefined') {
        // prevent multiple calls to cb
        return;
      }

      if (err) {
        err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
        didError = true;
      }

      if (cb) {
        if (forceAsync) {
          callbackAsap(cb, err, res);
        } else {
          cb(err, res);
        }
      } else {
        if (err) {
          throw err;
        }

        syncResult = res;
      }
    });
    return syncResult;
  };

  _proto3.getExported = function getExported(ctx, parentFrame, cb) {
    // eslint-disable-line consistent-return
    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    }

    if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // Catch compile errors for async rendering


    try {
      this.compile();
    } catch (e) {
      if (cb) {
        return cb(e);
      } else {
        throw e;
      }
    }

    var frame = parentFrame ? parentFrame.push() : new Frame();
    frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

    var context = new Context(ctx || {}, this.blocks, this.env);
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
      if (err) {
        cb(err, null);
      } else {
        cb(null, context.getExported());
      }
    });
  };

  _proto3.compile = function compile() {
    if (!this.compiled) {
      this._compile();
    }
  };

  _proto3._compile = function _compile() {
    var props;

    if (this.tmplProps) {
      props = this.tmplProps;
    } else {
      var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
      var func = new Function(source); // eslint-disable-line no-new-func

      props = func();
    }

    this.blocks = this._getBlocks(props);
    this.rootRenderFunc = props.root;
    this.compiled = true;
  };

  _proto3._getBlocks = function _getBlocks(props) {
    var blocks = {};
    lib.keys(props).forEach(function (k) {
      if (k.slice(0, 2) === 'b_') {
        blocks[k.slice(2)] = props[k];
      }
    });
    return blocks;
  };

  return Template;
}(Obj);

module.exports = {
  Environment: Environment,
  Template: Template
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_89670__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var lexer = __nested_webpack_require_89670__(9);

var nodes = __nested_webpack_require_89670__(3);

var Obj = __nested_webpack_require_89670__(1).Obj;

var lib = __nested_webpack_require_89670__(0);

var Parser = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Parser, _Obj);

  function Parser() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Parser.prototype;

  _proto.init = function init(tokens) {
    this.tokens = tokens;
    this.peeked = null;
    this.breakOnBlocks = null;
    this.dropLeadingWhitespace = false;
    this.extensions = [];
  };

  _proto.nextToken = function nextToken(withWhitespace) {
    var tok;

    if (this.peeked) {
      if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
        this.peeked = null;
      } else {
        tok = this.peeked;
        this.peeked = null;
        return tok;
      }
    }

    tok = this.tokens.nextToken();

    if (!withWhitespace) {
      while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
        tok = this.tokens.nextToken();
      }
    }

    return tok;
  };

  _proto.peekToken = function peekToken() {
    this.peeked = this.peeked || this.nextToken();
    return this.peeked;
  };

  _proto.pushToken = function pushToken(tok) {
    if (this.peeked) {
      throw new Error('pushToken: can only push one token on between reads');
    }

    this.peeked = tok;
  };

  _proto.error = function error(msg, lineno, colno) {
    if (lineno === undefined || colno === undefined) {
      var tok = this.peekToken() || {};
      lineno = tok.lineno;
      colno = tok.colno;
    }

    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    return new lib.TemplateError(msg, lineno, colno);
  };

  _proto.fail = function fail(msg, lineno, colno) {
    throw this.error(msg, lineno, colno);
  };

  _proto.skip = function skip(type) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.expect = function expect(type) {
    var tok = this.nextToken();

    if (tok.type !== type) {
      this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
    }

    return tok;
  };

  _proto.skipValue = function skipValue(type, val) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type || tok.value !== val) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.skipSymbol = function skipSymbol(val) {
    return this.skipValue(lexer.TOKEN_SYMBOL, val);
  };

  _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
    var tok;

    if (!name) {
      tok = this.peekToken();

      if (!tok) {
        this.fail('unexpected end of file');
      }

      if (tok.type !== lexer.TOKEN_SYMBOL) {
        this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
      }

      name = this.nextToken().value;
    }

    tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
      if (tok.value.charAt(0) === '-') {
        this.dropLeadingWhitespace = true;
      }
    } else {
      this.fail('expected block end in ' + name + ' statement');
    }

    return tok;
  };

  _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
    var tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
      this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
    } else {
      this.pushToken(tok);
      this.fail('expected variable end');
    }
  };

  _proto.parseFor = function parseFor() {
    var forTok = this.peekToken();
    var node;
    var endBlock;

    if (this.skipSymbol('for')) {
      node = new nodes.For(forTok.lineno, forTok.colno);
      endBlock = 'endfor';
    } else if (this.skipSymbol('asyncEach')) {
      node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
      endBlock = 'endeach';
    } else if (this.skipSymbol('asyncAll')) {
      node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
      endBlock = 'endall';
    } else {
      this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
    }

    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseFor: variable name expected for loop');
    }

    var type = this.peekToken().type;

    if (type === lexer.TOKEN_COMMA) {
      // key/value iteration
      var key = node.name;
      node.name = new nodes.Array(key.lineno, key.colno);
      node.name.addChild(key);

      while (this.skip(lexer.TOKEN_COMMA)) {
        var prim = this.parsePrimary();
        node.name.addChild(prim);
      }
    }

    if (!this.skipSymbol('in')) {
      this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
    }

    node.arr = this.parseExpression();
    this.advanceAfterBlockEnd(forTok.value);
    node.body = this.parseUntilBlocks(endBlock, 'else');

    if (this.skipSymbol('else')) {
      this.advanceAfterBlockEnd('else');
      node.else_ = this.parseUntilBlocks(endBlock);
    }

    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseMacro = function parseMacro() {
    var macroTok = this.peekToken();

    if (!this.skipSymbol('macro')) {
      this.fail('expected macro');
    }

    var name = this.parsePrimary(true);
    var args = this.parseSignature();
    var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
    this.advanceAfterBlockEnd(macroTok.value);
    node.body = this.parseUntilBlocks('endmacro');
    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseCall = function parseCall() {
    // a call block is parsed as a normal FunCall, but with an added
    // 'caller' kwarg which is a Caller node.
    var callTok = this.peekToken();

    if (!this.skipSymbol('call')) {
      this.fail('expected call');
    }

    var callerArgs = this.parseSignature(true) || new nodes.NodeList();
    var macroCall = this.parsePrimary();
    this.advanceAfterBlockEnd(callTok.value);
    var body = this.parseUntilBlocks('endcall');
    this.advanceAfterBlockEnd();
    var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
    var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

    var args = macroCall.args.children;

    if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
      args.push(new nodes.KeywordArgs());
    }

    var kwargs = args[args.length - 1];
    kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
    return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
  };

  _proto.parseWithContext = function parseWithContext() {
    var tok = this.peekToken();
    var withContext = null;

    if (this.skipSymbol('with')) {
      withContext = true;
    } else if (this.skipSymbol('without')) {
      withContext = false;
    }

    if (withContext !== null) {
      if (!this.skipSymbol('context')) {
        this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
      }
    }

    return withContext;
  };

  _proto.parseImport = function parseImport() {
    var importTok = this.peekToken();

    if (!this.skipSymbol('import')) {
      this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('as')) {
      this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
    }

    var target = this.parseExpression();
    var withContext = this.parseWithContext();
    var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
    this.advanceAfterBlockEnd(importTok.value);
    return node;
  };

  _proto.parseFrom = function parseFrom() {
    var fromTok = this.peekToken();

    if (!this.skipSymbol('from')) {
      this.fail('parseFrom: expected from');
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('import')) {
      this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
    }

    var names = new nodes.NodeList();
    var withContext;

    while (1) {
      // eslint-disable-line no-constant-condition
      var nextTok = this.peekToken();

      if (nextTok.type === lexer.TOKEN_BLOCK_END) {
        if (!names.children.length) {
          this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
        } // Since we are manually advancing past the block end,
        // need to keep track of whitespace control (normally
        // this is done in `advanceAfterBlockEnd`


        if (nextTok.value.charAt(0) === '-') {
          this.dropLeadingWhitespace = true;
        }

        this.nextToken();
        break;
      }

      if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
      }

      var name = this.parsePrimary();

      if (name.value.charAt(0) === '_') {
        this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
      }

      if (this.skipSymbol('as')) {
        var alias = this.parsePrimary();
        names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
      } else {
        names.addChild(name);
      }

      withContext = this.parseWithContext();
    }

    return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
  };

  _proto.parseBlock = function parseBlock() {
    var tag = this.peekToken();

    if (!this.skipSymbol('block')) {
      this.fail('parseBlock: expected block', tag.lineno, tag.colno);
    }

    var node = new nodes.Block(tag.lineno, tag.colno);
    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
    }

    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('endblock');
    this.skipSymbol('endblock');
    this.skipSymbol(node.name.value);
    var tok = this.peekToken();

    if (!tok) {
      this.fail('parseBlock: expected endblock, got end of file');
    }

    this.advanceAfterBlockEnd(tok.value);
    return node;
  };

  _proto.parseExtends = function parseExtends() {
    var tagName = 'extends';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseTemplateRef: expected ' + tagName);
    }

    var node = new nodes.Extends(tag.lineno, tag.colno);
    node.template = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseInclude = function parseInclude() {
    var tagName = 'include';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseInclude: expected ' + tagName);
    }

    var node = new nodes.Include(tag.lineno, tag.colno);
    node.template = this.parseExpression();

    if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
      node.ignoreMissing = true;
    }

    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseIf = function parseIf() {
    var tag = this.peekToken();
    var node;

    if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
      node = new nodes.If(tag.lineno, tag.colno);
    } else if (this.skipSymbol('ifAsync')) {
      node = new nodes.IfAsync(tag.lineno, tag.colno);
    } else {
      this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
    }

    node.cond = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
    var tok = this.peekToken();

    switch (tok && tok.value) {
      case 'elseif':
      case 'elif':
        node.else_ = this.parseIf();
        break;

      case 'else':
        this.advanceAfterBlockEnd();
        node.else_ = this.parseUntilBlocks('endif');
        this.advanceAfterBlockEnd();
        break;

      case 'endif':
        node.else_ = null;
        this.advanceAfterBlockEnd();
        break;

      default:
        this.fail('parseIf: expected elif, else, or endif, got end of file');
    }

    return node;
  };

  _proto.parseSet = function parseSet() {
    var tag = this.peekToken();

    if (!this.skipSymbol('set')) {
      this.fail('parseSet: expected set', tag.lineno, tag.colno);
    }

    var node = new nodes.Set(tag.lineno, tag.colno, []);
    var target;

    while (target = this.parsePrimary()) {
      node.targets.push(target);

      if (!this.skip(lexer.TOKEN_COMMA)) {
        break;
      }
    }

    if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
      if (!this.skip(lexer.TOKEN_BLOCK_END)) {
        this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
      } else {
        node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
        node.value = null;
        this.advanceAfterBlockEnd();
      }
    } else {
      node.value = this.parseExpression();
      this.advanceAfterBlockEnd(tag.value);
    }

    return node;
  };

  _proto.parseSwitch = function parseSwitch() {
    /*
     * Store the tag names in variables in case someone ever wants to
     * customize this.
     */
    var switchStart = 'switch';
    var switchEnd = 'endswitch';
    var caseStart = 'case';
    var caseDefault = 'default'; // Get the switch tag.

    var tag = this.peekToken(); // fail early if we get some unexpected tag.

    if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
      this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
    } // parse the switch expression


    var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

    this.advanceAfterBlockEnd(switchStart);
    this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

    var tok = this.peekToken(); // create new variables for our cases and default case.

    var cases = [];
    var defaultCase; // while we're dealing with new cases nodes...

    do {
      // skip the start symbol and get the case expression
      this.skipSymbol(caseStart);
      var cond = this.parseExpression();
      this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

      var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
      cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

      tok = this.peekToken();
    } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


    switch (tok.value) {
      case caseDefault:
        this.advanceAfterBlockEnd();
        defaultCase = this.parseUntilBlocks(switchEnd);
        this.advanceAfterBlockEnd();
        break;

      case switchEnd:
        this.advanceAfterBlockEnd();
        break;

      default:
        // otherwise bail because EOF
        this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
    } // and return the switch node.


    return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
  };

  _proto.parseStatement = function parseStatement() {
    var tok = this.peekToken();
    var node;

    if (tok.type !== lexer.TOKEN_SYMBOL) {
      this.fail('tag name expected', tok.lineno, tok.colno);
    }

    if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
      return null;
    }

    switch (tok.value) {
      case 'raw':
        return this.parseRaw();

      case 'verbatim':
        return this.parseRaw('verbatim');

      case 'if':
      case 'ifAsync':
        return this.parseIf();

      case 'for':
      case 'asyncEach':
      case 'asyncAll':
        return this.parseFor();

      case 'block':
        return this.parseBlock();

      case 'extends':
        return this.parseExtends();

      case 'include':
        return this.parseInclude();

      case 'set':
        return this.parseSet();

      case 'macro':
        return this.parseMacro();

      case 'call':
        return this.parseCall();

      case 'import':
        return this.parseImport();

      case 'from':
        return this.parseFrom();

      case 'filter':
        return this.parseFilterStatement();

      case 'switch':
        return this.parseSwitch();

      default:
        if (this.extensions.length) {
          for (var i = 0; i < this.extensions.length; i++) {
            var ext = this.extensions[i];

            if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
              return ext.parse(this, nodes, lexer);
            }
          }
        }

        this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
    }

    return node;
  };

  _proto.parseRaw = function parseRaw(tagName) {
    tagName = tagName || 'raw';
    var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

    var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
    var rawLevel = 1;
    var str = '';
    var matches = null; // Skip opening raw token
    // Keep this token to track line and column numbers

    var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
    // or when we've found the matching "endraw" block

    while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
      var all = matches[0];
      var pre = matches[1];
      var blockName = matches[2]; // Adjust rawlevel

      if (blockName === tagName) {
        rawLevel += 1;
      } else if (blockName === endTagName) {
        rawLevel -= 1;
      } // Add to str


      if (rawLevel === 0) {
        // We want to exclude the last "endraw"
        str += pre; // Move tokenizer to beginning of endraw block

        this.tokens.backN(all.length - pre.length);
      } else {
        str += all;
      }
    }

    return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
  };

  _proto.parsePostfix = function parsePostfix(node) {
    var lookup;
    var tok = this.peekToken();

    while (tok) {
      if (tok.type === lexer.TOKEN_LEFT_PAREN) {
        // Function call
        node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
      } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
        // Reference
        lookup = this.parseAggregate();

        if (lookup.children.length > 1) {
          this.fail('invalid index');
        }

        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
      } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
        // Reference
        this.nextToken();
        var val = this.nextToken();

        if (val.type !== lexer.TOKEN_SYMBOL) {
          this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
        } // Make a literal string because it's not a variable
        // reference


        lookup = new nodes.Literal(val.lineno, val.colno, val.value);
        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
      } else {
        break;
      }

      tok = this.peekToken();
    }

    return node;
  };

  _proto.parseExpression = function parseExpression() {
    var node = this.parseInlineIf();
    return node;
  };

  _proto.parseInlineIf = function parseInlineIf() {
    var node = this.parseOr();

    if (this.skipSymbol('if')) {
      var condNode = this.parseOr();
      var bodyNode = node;
      node = new nodes.InlineIf(node.lineno, node.colno);
      node.body = bodyNode;
      node.cond = condNode;

      if (this.skipSymbol('else')) {
        node.else_ = this.parseOr();
      } else {
        node.else_ = null;
      }
    }

    return node;
  };

  _proto.parseOr = function parseOr() {
    var node = this.parseAnd();

    while (this.skipSymbol('or')) {
      var node2 = this.parseAnd();
      node = new nodes.Or(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAnd = function parseAnd() {
    var node = this.parseNot();

    while (this.skipSymbol('and')) {
      var node2 = this.parseNot();
      node = new nodes.And(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseNot = function parseNot() {
    var tok = this.peekToken();

    if (this.skipSymbol('not')) {
      return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
    }

    return this.parseIn();
  };

  _proto.parseIn = function parseIn() {
    var node = this.parseIs();

    while (1) {
      // eslint-disable-line no-constant-condition
      // check if the next token is 'not'
      var tok = this.nextToken();

      if (!tok) {
        break;
      }

      var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

      if (!invert) {
        this.pushToken(tok);
      }

      if (this.skipSymbol('in')) {
        var node2 = this.parseIs();
        node = new nodes.In(node.lineno, node.colno, node, node2);

        if (invert) {
          node = new nodes.Not(node.lineno, node.colno, node);
        }
      } else {
        // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
        if (invert) {
          this.pushToken(tok);
        }

        break;
      }
    }

    return node;
  } // I put this right after "in" in the operator precedence stack. That can
  // obviously be changed to be closer to Jinja.
  ;

  _proto.parseIs = function parseIs() {
    var node = this.parseCompare(); // look for an is

    if (this.skipSymbol('is')) {
      // look for a not
      var not = this.skipSymbol('not'); // get the next node

      var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

      node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

      if (not) {
        node = new nodes.Not(node.lineno, node.colno, node);
      }
    } // return the node.


    return node;
  };

  _proto.parseCompare = function parseCompare() {
    var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
    var expr = this.parseConcat();
    var ops = [];

    while (1) {
      // eslint-disable-line no-constant-condition
      var tok = this.nextToken();

      if (!tok) {
        break;
      } else if (compareOps.indexOf(tok.value) !== -1) {
        ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
      } else {
        this.pushToken(tok);
        break;
      }
    }

    if (ops.length) {
      return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
    } else {
      return expr;
    }
  } // finds the '~' for string concatenation
  ;

  _proto.parseConcat = function parseConcat() {
    var node = this.parseAdd();

    while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
      var node2 = this.parseAdd();
      node = new nodes.Concat(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAdd = function parseAdd() {
    var node = this.parseSub();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      var node2 = this.parseSub();
      node = new nodes.Add(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseSub = function parseSub() {
    var node = this.parseMul();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      var node2 = this.parseMul();
      node = new nodes.Sub(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMul = function parseMul() {
    var node = this.parseDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
      var node2 = this.parseDiv();
      node = new nodes.Mul(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseDiv = function parseDiv() {
    var node = this.parseFloorDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
      var node2 = this.parseFloorDiv();
      node = new nodes.Div(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseFloorDiv = function parseFloorDiv() {
    var node = this.parseMod();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
      var node2 = this.parseMod();
      node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMod = function parseMod() {
    var node = this.parsePow();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
      var node2 = this.parsePow();
      node = new nodes.Mod(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parsePow = function parsePow() {
    var node = this.parseUnary();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
      var node2 = this.parseUnary();
      node = new nodes.Pow(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseUnary = function parseUnary(noFilters) {
    var tok = this.peekToken();
    var node;

    if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
    } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
    } else {
      node = this.parsePrimary();
    }

    if (!noFilters) {
      node = this.parseFilter(node);
    }

    return node;
  };

  _proto.parsePrimary = function parsePrimary(noPostfix) {
    var tok = this.nextToken();
    var val;
    var node = null;

    if (!tok) {
      this.fail('expected expression, got end of file');
    } else if (tok.type === lexer.TOKEN_STRING) {
      val = tok.value;
    } else if (tok.type === lexer.TOKEN_INT) {
      val = parseInt(tok.value, 10);
    } else if (tok.type === lexer.TOKEN_FLOAT) {
      val = parseFloat(tok.value);
    } else if (tok.type === lexer.TOKEN_BOOLEAN) {
      if (tok.value === 'true') {
        val = true;
      } else if (tok.value === 'false') {
        val = false;
      } else {
        this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
      }
    } else if (tok.type === lexer.TOKEN_NONE) {
      val = null;
    } else if (tok.type === lexer.TOKEN_REGEX) {
      val = new RegExp(tok.value.body, tok.value.flags);
    }

    if (val !== undefined) {
      node = new nodes.Literal(tok.lineno, tok.colno, val);
    } else if (tok.type === lexer.TOKEN_SYMBOL) {
      node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    } else {
      // See if it's an aggregate type, we need to push the
      // current delimiter token back on
      this.pushToken(tok);
      node = this.parseAggregate();
    }

    if (!noPostfix) {
      node = this.parsePostfix(node);
    }

    if (node) {
      return node;
    } else {
      throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
    }
  };

  _proto.parseFilterName = function parseFilterName() {
    var tok = this.expect(lexer.TOKEN_SYMBOL);
    var name = tok.value;

    while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
      name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
    }

    return new nodes.Symbol(tok.lineno, tok.colno, name);
  };

  _proto.parseFilterArgs = function parseFilterArgs(node) {
    if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
      // Get a FunCall node and add the parameters to the
      // filter
      var call = this.parsePostfix(node);
      return call.args.children;
    }

    return [];
  };

  _proto.parseFilter = function parseFilter(node) {
    while (this.skip(lexer.TOKEN_PIPE)) {
      var name = this.parseFilterName();
      node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
    }

    return node;
  };

  _proto.parseFilterStatement = function parseFilterStatement() {
    var filterTok = this.peekToken();

    if (!this.skipSymbol('filter')) {
      this.fail('parseFilterStatement: expected filter');
    }

    var name = this.parseFilterName();
    var args = this.parseFilterArgs(name);
    this.advanceAfterBlockEnd(filterTok.value);
    var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
    this.advanceAfterBlockEnd();
    var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
    return new nodes.Output(name.lineno, name.colno, [node]);
  };

  _proto.parseAggregate = function parseAggregate() {
    var tok = this.nextToken();
    var node;

    switch (tok.type) {
      case lexer.TOKEN_LEFT_PAREN:
        node = new nodes.Group(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_BRACKET:
        node = new nodes.Array(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_CURLY:
        node = new nodes.Dict(tok.lineno, tok.colno);
        break;

      default:
        return null;
    }

    while (1) {
      // eslint-disable-line no-constant-condition
      var type = this.peekToken().type;

      if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
        this.nextToken();
        break;
      }

      if (node.children.length > 0) {
        if (!this.skip(lexer.TOKEN_COMMA)) {
          this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
        }
      }

      if (node instanceof nodes.Dict) {
        // TODO: check for errors
        var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
        // colon

        if (!this.skip(lexer.TOKEN_COLON)) {
          this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
        } // TODO: check for errors


        var value = this.parseExpression();
        node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
      } else {
        // TODO: check for errors
        var expr = this.parseExpression();
        node.addChild(expr);
      }
    }

    return node;
  };

  _proto.parseSignature = function parseSignature(tolerant, noParens) {
    var tok = this.peekToken();

    if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
      if (tolerant) {
        return null;
      } else {
        this.fail('expected arguments', tok.lineno, tok.colno);
      }
    }

    if (tok.type === lexer.TOKEN_LEFT_PAREN) {
      tok = this.nextToken();
    }

    var args = new nodes.NodeList(tok.lineno, tok.colno);
    var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
    var checkComma = false;

    while (1) {
      // eslint-disable-line no-constant-condition
      tok = this.peekToken();

      if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
        this.nextToken();
        break;
      } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
        break;
      }

      if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
      } else {
        var arg = this.parseExpression();

        if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
          kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
        } else {
          args.addChild(arg);
        }
      }

      checkComma = true;
    }

    if (kwargs.children.length) {
      args.addChild(kwargs);
    }

    return args;
  };

  _proto.parseUntilBlocks = function parseUntilBlocks() {
    var prev = this.breakOnBlocks;

    for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
      blockNames[_key] = arguments[_key];
    }

    this.breakOnBlocks = blockNames;
    var ret = this.parse();
    this.breakOnBlocks = prev;
    return ret;
  };

  _proto.parseNodes = function parseNodes() {
    var tok;
    var buf = [];

    while (tok = this.nextToken()) {
      if (tok.type === lexer.TOKEN_DATA) {
        var data = tok.value;
        var nextToken = this.peekToken();
        var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
        // leading whitespace of the data. This is marked with
        // the `dropLeadingWhitespace` variable.

        if (this.dropLeadingWhitespace) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/^\s*/, '');
          this.dropLeadingWhitespace = false;
        } // Same for the succeeding block start token


        if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/\s*$/, '');
        }

        buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
      } else if (tok.type === lexer.TOKEN_BLOCK_START) {
        this.dropLeadingWhitespace = false;
        var n = this.parseStatement();

        if (!n) {
          break;
        }

        buf.push(n);
      } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
        var e = this.parseExpression();
        this.dropLeadingWhitespace = false;
        this.advanceAfterVariableEnd();
        buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
      } else if (tok.type === lexer.TOKEN_COMMENT) {
        this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
      } else {
        // Ignore comments, otherwise this should be an error
        this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
      }
    }

    return buf;
  };

  _proto.parse = function parse() {
    return new nodes.NodeList(0, 0, this.parseNodes());
  };

  _proto.parseAsRoot = function parseAsRoot() {
    return new nodes.Root(0, 0, this.parseNodes());
  };

  return Parser;
}(Obj); // var util = require('util');
// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
// var t;
// while((t = l.nextToken())) {
//     console.log(util.inspect(t));
// }
// var p = new Parser(lexer.lex('hello {% filter title %}' +
//                              'Hello madam how are you' +
//                              '{% endfilter %}'));
// var n = p.parseAsRoot();
// nodes.printNodes(n);


module.exports = {
  parse: function parse(src, extensions, opts) {
    var p = new Parser(lexer.lex(src, opts));

    if (extensions !== undefined) {
      p.extensions = extensions;
    }

    return p.parseAsRoot();
  },
  Parser: Parser
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_125313__) {

"use strict";


var lib = __nested_webpack_require_125313__(0);

var whitespaceChars = " \n\t\r\xA0";
var delimChars = '()[]{}%*-+~/#,:|.<>=!';
var intChars = '0123456789';
var BLOCK_START = '{%';
var BLOCK_END = '%}';
var VARIABLE_START = '{{';
var VARIABLE_END = '}}';
var COMMENT_START = '{#';
var COMMENT_END = '#}';
var TOKEN_STRING = 'string';
var TOKEN_WHITESPACE = 'whitespace';
var TOKEN_DATA = 'data';
var TOKEN_BLOCK_START = 'block-start';
var TOKEN_BLOCK_END = 'block-end';
var TOKEN_VARIABLE_START = 'variable-start';
var TOKEN_VARIABLE_END = 'variable-end';
var TOKEN_COMMENT = 'comment';
var TOKEN_LEFT_PAREN = 'left-paren';
var TOKEN_RIGHT_PAREN = 'right-paren';
var TOKEN_LEFT_BRACKET = 'left-bracket';
var TOKEN_RIGHT_BRACKET = 'right-bracket';
var TOKEN_LEFT_CURLY = 'left-curly';
var TOKEN_RIGHT_CURLY = 'right-curly';
var TOKEN_OPERATOR = 'operator';
var TOKEN_COMMA = 'comma';
var TOKEN_COLON = 'colon';
var TOKEN_TILDE = 'tilde';
var TOKEN_PIPE = 'pipe';
var TOKEN_INT = 'int';
var TOKEN_FLOAT = 'float';
var TOKEN_BOOLEAN = 'boolean';
var TOKEN_NONE = 'none';
var TOKEN_SYMBOL = 'symbol';
var TOKEN_SPECIAL = 'special';
var TOKEN_REGEX = 'regex';

function token(type, value, lineno, colno) {
  return {
    type: type,
    value: value,
    lineno: lineno,
    colno: colno
  };
}

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(str, opts) {
    this.str = str;
    this.index = 0;
    this.len = str.length;
    this.lineno = 0;
    this.colno = 0;
    this.in_code = false;
    opts = opts || {};
    var tags = opts.tags || {};
    this.tags = {
      BLOCK_START: tags.blockStart || BLOCK_START,
      BLOCK_END: tags.blockEnd || BLOCK_END,
      VARIABLE_START: tags.variableStart || VARIABLE_START,
      VARIABLE_END: tags.variableEnd || VARIABLE_END,
      COMMENT_START: tags.commentStart || COMMENT_START,
      COMMENT_END: tags.commentEnd || COMMENT_END
    };
    this.trimBlocks = !!opts.trimBlocks;
    this.lstripBlocks = !!opts.lstripBlocks;
  }

  var _proto = Tokenizer.prototype;

  _proto.nextToken = function nextToken() {
    var lineno = this.lineno;
    var colno = this.colno;
    var tok;

    if (this.in_code) {
      // Otherwise, if we are in a block parse it as code
      var cur = this.current();

      if (this.isFinished()) {
        // We have nothing else to parse
        return null;
      } else if (cur === '"' || cur === '\'') {
        // We've hit a string
        return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
      } else if (tok = this._extract(whitespaceChars)) {
        // We hit some whitespace
        return token(TOKEN_WHITESPACE, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
        // Special check for the block end tag
        //
        // It is a requirement that start and end tags are composed of
        // delimiter characters (%{}[] etc), and our code always
        // breaks on delimiters so we can assume the token parsing
        // doesn't consume these elsewhere
        this.in_code = false;

        if (this.trimBlocks) {
          cur = this.current();

          if (cur === '\n') {
            // Skip newline
            this.forward();
          } else if (cur === '\r') {
            // Skip CRLF newline
            this.forward();
            cur = this.current();

            if (cur === '\n') {
              this.forward();
            } else {
              // Was not a CRLF, so go back
              this.back();
            }
          }
        }

        return token(TOKEN_BLOCK_END, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
        // Special check for variable end tag (see above)
        this.in_code = false;
        return token(TOKEN_VARIABLE_END, tok, lineno, colno);
      } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
        // Skip past 'r/'.
        this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

        var regexBody = '';

        while (!this.isFinished()) {
          if (this.current() === '/' && this.previous() !== '\\') {
            this.forward();
            break;
          } else {
            regexBody += this.current();
            this.forward();
          }
        } // Check for flags.
        // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


        var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
        var regexFlags = '';

        while (!this.isFinished()) {
          var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

          if (isCurrentAFlag) {
            regexFlags += this.current();
            this.forward();
          } else {
            break;
          }
        }

        return token(TOKEN_REGEX, {
          body: regexBody,
          flags: regexFlags
        }, lineno, colno);
      } else if (delimChars.indexOf(cur) !== -1) {
        // We've hit a delimiter (a special char like a bracket)
        this.forward();
        var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
        var curComplex = cur + this.current();
        var type;

        if (lib.indexOf(complexOps, curComplex) !== -1) {
          this.forward();
          cur = curComplex; // See if this is a strict equality/inequality comparator

          if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
            cur = curComplex + this.current();
            this.forward();
          }
        }

        switch (cur) {
          case '(':
            type = TOKEN_LEFT_PAREN;
            break;

          case ')':
            type = TOKEN_RIGHT_PAREN;
            break;

          case '[':
            type = TOKEN_LEFT_BRACKET;
            break;

          case ']':
            type = TOKEN_RIGHT_BRACKET;
            break;

          case '{':
            type = TOKEN_LEFT_CURLY;
            break;

          case '}':
            type = TOKEN_RIGHT_CURLY;
            break;

          case ',':
            type = TOKEN_COMMA;
            break;

          case ':':
            type = TOKEN_COLON;
            break;

          case '~':
            type = TOKEN_TILDE;
            break;

          case '|':
            type = TOKEN_PIPE;
            break;

          default:
            type = TOKEN_OPERATOR;
        }

        return token(type, cur, lineno, colno);
      } else {
        // We are not at whitespace or a delimiter, so extract the
        // text and parse it
        tok = this._extractUntil(whitespaceChars + delimChars);

        if (tok.match(/^[-+]?[0-9]+$/)) {
          if (this.current() === '.') {
            this.forward();

            var dec = this._extract(intChars);

            return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
          } else {
            return token(TOKEN_INT, tok, lineno, colno);
          }
        } else if (tok.match(/^(true|false)$/)) {
          return token(TOKEN_BOOLEAN, tok, lineno, colno);
        } else if (tok === 'none') {
          return token(TOKEN_NONE, tok, lineno, colno);
          /*
           * Added to make the test `null is null` evaluate truthily.
           * Otherwise, Nunjucks will look up null in the context and
           * return `undefined`, which is not what we want. This *may* have
           * consequences is someone is using null in their templates as a
           * variable.
           */
        } else if (tok === 'null') {
          return token(TOKEN_NONE, tok, lineno, colno);
        } else if (tok) {
          return token(TOKEN_SYMBOL, tok, lineno, colno);
        } else {
          throw new Error('Unexpected value while parsing: ' + tok);
        }
      }
    } else {
      // Parse out the template text, breaking on tag
      // delimiters because we need to look for block/variable start
      // tags (don't use the full delimChars for optimization)
      var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

      if (this.isFinished()) {
        return null;
      } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
        this.in_code = true;
        return token(TOKEN_BLOCK_START, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
        this.in_code = true;
        return token(TOKEN_VARIABLE_START, tok, lineno, colno);
      } else {
        tok = '';
        var data;
        var inComment = false;

        if (this._matches(this.tags.COMMENT_START)) {
          inComment = true;
          tok = this._extractString(this.tags.COMMENT_START);
        } // Continually consume text, breaking on the tag delimiter
        // characters and checking to see if it's a start tag.
        //
        // We could hit the end of the template in the middle of
        // our looping, so check for the null return value from
        // _extractUntil


        while ((data = this._extractUntil(beginChars)) !== null) {
          tok += data;

          if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
            if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
              var lastLine = tok.slice(-this.colno);

              if (/^\s+$/.test(lastLine)) {
                // Remove block leading whitespace from beginning of the string
                tok = tok.slice(0, -this.colno);

                if (!tok.length) {
                  // All data removed, collapse to avoid unnecessary nodes
                  // by returning next token (block start)
                  return this.nextToken();
                }
              }
            } // If it is a start tag, stop looping


            break;
          } else if (this._matches(this.tags.COMMENT_END)) {
            if (!inComment) {
              throw new Error('unexpected end of comment');
            }

            tok += this._extractString(this.tags.COMMENT_END);
            break;
          } else {
            // It does not match any tag, so add the character and
            // carry on
            tok += this.current();
            this.forward();
          }
        }

        if (data === null && inComment) {
          throw new Error('expected end of comment, got end of file');
        }

        return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
      }
    }
  };

  _proto._parseString = function _parseString(delimiter) {
    this.forward();
    var str = '';

    while (!this.isFinished() && this.current() !== delimiter) {
      var cur = this.current();

      if (cur === '\\') {
        this.forward();

        switch (this.current()) {
          case 'n':
            str += '\n';
            break;

          case 't':
            str += '\t';
            break;

          case 'r':
            str += '\r';
            break;

          default:
            str += this.current();
        }

        this.forward();
      } else {
        str += cur;
        this.forward();
      }
    }

    this.forward();
    return str;
  };

  _proto._matches = function _matches(str) {
    if (this.index + str.length > this.len) {
      return null;
    }

    var m = this.str.slice(this.index, this.index + str.length);
    return m === str;
  };

  _proto._extractString = function _extractString(str) {
    if (this._matches(str)) {
      this.forwardN(str.length);
      return str;
    }

    return null;
  };

  _proto._extractUntil = function _extractUntil(charString) {
    // Extract all non-matching chars, with the default matching set
    // to everything
    return this._extractMatching(true, charString || '');
  };

  _proto._extract = function _extract(charString) {
    // Extract all matching chars (no default, so charString must be
    // explicit)
    return this._extractMatching(false, charString);
  };

  _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
    // Pull out characters until a breaking char is hit.
    // If breakOnMatch is false, a non-matching char stops it.
    // If breakOnMatch is true, a matching char stops it.
    if (this.isFinished()) {
      return null;
    }

    var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

    if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
      var t = this.current();
      this.forward(); // And pull out all the chars one at a time until we hit a
      // breaking char

      var idx = charString.indexOf(this.current());

      while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
        t += this.current();
        this.forward();
        idx = charString.indexOf(this.current());
      }

      return t;
    }

    return '';
  };

  _proto._extractRegex = function _extractRegex(regex) {
    var matches = this.currentStr().match(regex);

    if (!matches) {
      return null;
    } // Move forward whatever was matched


    this.forwardN(matches[0].length);
    return matches;
  };

  _proto.isFinished = function isFinished() {
    return this.index >= this.len;
  };

  _proto.forwardN = function forwardN(n) {
    for (var i = 0; i < n; i++) {
      this.forward();
    }
  };

  _proto.forward = function forward() {
    this.index++;

    if (this.previous() === '\n') {
      this.lineno++;
      this.colno = 0;
    } else {
      this.colno++;
    }
  };

  _proto.backN = function backN(n) {
    for (var i = 0; i < n; i++) {
      this.back();
    }
  };

  _proto.back = function back() {
    this.index--;

    if (this.current() === '\n') {
      this.lineno--;
      var idx = this.src.lastIndexOf('\n', this.index - 1);

      if (idx === -1) {
        this.colno = this.index;
      } else {
        this.colno = this.index - idx;
      }
    } else {
      this.colno--;
    }
  } // current returns current character
  ;

  _proto.current = function current() {
    if (!this.isFinished()) {
      return this.str.charAt(this.index);
    }

    return '';
  } // currentStr returns what's left of the unparsed string
  ;

  _proto.currentStr = function currentStr() {
    if (!this.isFinished()) {
      return this.str.substr(this.index);
    }

    return '';
  };

  _proto.previous = function previous() {
    return this.str.charAt(this.index - 1);
  };

  return Tokenizer;
}();

module.exports = {
  lex: function lex(src, opts) {
    return new Tokenizer(src, opts);
  },
  TOKEN_STRING: TOKEN_STRING,
  TOKEN_WHITESPACE: TOKEN_WHITESPACE,
  TOKEN_DATA: TOKEN_DATA,
  TOKEN_BLOCK_START: TOKEN_BLOCK_START,
  TOKEN_BLOCK_END: TOKEN_BLOCK_END,
  TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
  TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
  TOKEN_COMMENT: TOKEN_COMMENT,
  TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
  TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
  TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
  TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
  TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
  TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
  TOKEN_OPERATOR: TOKEN_OPERATOR,
  TOKEN_COMMA: TOKEN_COMMA,
  TOKEN_COLON: TOKEN_COLON,
  TOKEN_TILDE: TOKEN_TILDE,
  TOKEN_PIPE: TOKEN_PIPE,
  TOKEN_INT: TOKEN_INT,
  TOKEN_FLOAT: TOKEN_FLOAT,
  TOKEN_BOOLEAN: TOKEN_BOOLEAN,
  TOKEN_NONE: TOKEN_NONE,
  TOKEN_SYMBOL: TOKEN_SYMBOL,
  TOKEN_SPECIAL: TOKEN_SPECIAL,
  TOKEN_REGEX: TOKEN_REGEX
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_141230__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __nested_webpack_require_141230__(6);

var _require = __nested_webpack_require_141230__(19),
    PrecompiledLoader = _require.PrecompiledLoader;

var WebLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(WebLoader, _Loader);

  function WebLoader(baseURL, opts) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.baseURL = baseURL || '.';
    opts = opts || {}; // By default, the cache is turned off because there's no way
    // to "watch" templates over HTTP, so they are re-downloaded
    // and compiled each time. (Remember, PRECOMPILE YOUR
    // TEMPLATES in production!)

    _this.useCache = !!opts.useCache; // We default `async` to false so that the simple synchronous
    // API can be used when you aren't doing anything async in
    // your templates (which is most of the time). This performs a
    // sync ajax request, but that's ok because it should *only*
    // happen in development. PRECOMPILE YOUR TEMPLATES.

    _this.async = !!opts.async;
    return _this;
  }

  var _proto = WebLoader.prototype;

  _proto.resolve = function resolve(from, to) {
    throw new Error('relative templates not support in the browser yet');
  };

  _proto.getSource = function getSource(name, cb) {
    var _this2 = this;

    var useCache = this.useCache;
    var result;
    this.fetch(this.baseURL + '/' + name, function (err, src) {
      if (err) {
        if (cb) {
          cb(err.content);
        } else if (err.status === 404) {
          result = null;
        } else {
          throw err.content;
        }
      } else {
        result = {
          src: src,
          path: name,
          noCache: !useCache
        };

        _this2.emit('load', name, result);

        if (cb) {
          cb(null, result);
        }
      }
    }); // if this WebLoader isn't running asynchronously, the
    // fetch above would actually run sync and we'll have a
    // result here

    return result;
  };

  _proto.fetch = function fetch(url, cb) {
    // Only in the browser please
    if (typeof window === 'undefined') {
      throw new Error('WebLoader can only by used in a browser');
    }

    var ajax = new XMLHttpRequest();
    var loading = true;

    ajax.onreadystatechange = function () {
      if (ajax.readyState === 4 && loading) {
        loading = false;

        if (ajax.status === 0 || ajax.status === 200) {
          cb(null, ajax.responseText);
        } else {
          cb({
            status: ajax.status,
            content: ajax.responseText
          });
        }
      }
    };

    url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' + new Date().getTime();
    ajax.open('GET', url, this.async);
    ajax.send();
  };

  return WebLoader;
}(Loader);

module.exports = {
  WebLoader: WebLoader,
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_144485__) {

"use strict";


var lib = __nested_webpack_require_144485__(0);

var _require = __nested_webpack_require_144485__(7),
    Environment = _require.Environment,
    Template = _require.Template;

var Loader = __nested_webpack_require_144485__(6);

var loaders = __nested_webpack_require_144485__(10);

var precompile = __nested_webpack_require_144485__(23);

var compiler = __nested_webpack_require_144485__(5);

var parser = __nested_webpack_require_144485__(8);

var lexer = __nested_webpack_require_144485__(9);

var runtime = __nested_webpack_require_144485__(2);

var nodes = __nested_webpack_require_144485__(3);

var installJinjaCompat = __nested_webpack_require_144485__(25); // A single instance of an environment, since this is so commonly used


var e;

function configure(templatesPath, opts) {
  opts = opts || {};

  if (lib.isObject(templatesPath)) {
    opts = templatesPath;
    templatesPath = null;
  }

  var TemplateLoader;

  if (loaders.FileSystemLoader) {
    TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
      watch: opts.watch,
      noCache: opts.noCache
    });
  } else if (loaders.WebLoader) {
    TemplateLoader = new loaders.WebLoader(templatesPath, {
      useCache: opts.web && opts.web.useCache,
      async: opts.web && opts.web.async
    });
  }

  e = new Environment(TemplateLoader, opts);

  if (opts && opts.express) {
    e.express(opts.express);
  }

  return e;
}

module.exports = {
  Environment: Environment,
  Template: Template,
  Loader: Loader,
  FileSystemLoader: loaders.FileSystemLoader,
  NodeResolveLoader: loaders.NodeResolveLoader,
  PrecompiledLoader: loaders.PrecompiledLoader,
  WebLoader: loaders.WebLoader,
  compiler: compiler,
  parser: parser,
  lexer: lexer,
  runtime: runtime,
  lib: lib,
  nodes: nodes,
  installJinjaCompat: installJinjaCompat,
  configure: configure,
  reset: function reset() {
    e = undefined;
  },
  compile: function compile(src, env, path, eagerCompile) {
    if (!e) {
      configure();
    }

    return new Template(src, env, path, eagerCompile);
  },
  render: function render(name, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.render(name, ctx, cb);
  },
  renderString: function renderString(src, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.renderString(src, ctx, cb);
  },
  precompile: precompile ? precompile.precompile : undefined,
  precompileString: precompile ? precompile.precompileString : undefined
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_146877__) {

"use strict";


// rawAsap provides everything we need except exception management.
var rawAsap = __nested_webpack_require_146877__(13);
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_149147__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_149147__(14)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MIT license (by Elan Shanker).
(function(globals) {
  'use strict';

  var executeSync = function(){
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'function'){
      args[0].apply(null, args.splice(1));
    }
  };

  var executeAsync = function(fn){
    if (typeof setImmediate === 'function') {
      setImmediate(fn);
    } else if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };

  var makeIterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  
  var _isArray = Array.isArray || function(maybeArray){
    return Object.prototype.toString.call(maybeArray) === '[object Array]';
  };

  var waterfall = function (tasks, callback, forceAsync) {
    var nextTick = forceAsync ? executeAsync : executeSync;
    callback = callback || function () {};
    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {};
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(makeIterator(tasks))();
  };

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return waterfall;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
  } else {}
})(this);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_176372__) {

"use strict";


var nodes = __nested_webpack_require_176372__(3);

var lib = __nested_webpack_require_176372__(0);

var sym = 0;

function gensym() {
  return 'hole_' + sym++;
} // copy-on-write version of map


function mapCOW(arr, func) {
  var res = null;

  for (var i = 0; i < arr.length; i++) {
    var item = func(arr[i]);

    if (item !== arr[i]) {
      if (!res) {
        res = arr.slice();
      }

      res[i] = item;
    }
  }

  return res || arr;
}

function walk(ast, func, depthFirst) {
  if (!(ast instanceof nodes.Node)) {
    return ast;
  }

  if (!depthFirst) {
    var astT = func(ast);

    if (astT && astT !== ast) {
      return astT;
    }
  }

  if (ast instanceof nodes.NodeList) {
    var children = mapCOW(ast.children, function (node) {
      return walk(node, func, depthFirst);
    });

    if (children !== ast.children) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
    }
  } else if (ast instanceof nodes.CallExtension) {
    var args = walk(ast.args, func, depthFirst);
    var contentArgs = mapCOW(ast.contentArgs, function (node) {
      return walk(node, func, depthFirst);
    });

    if (args !== ast.args || contentArgs !== ast.contentArgs) {
      ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
    }
  } else {
    var props = ast.fields.map(function (field) {
      return ast[field];
    });
    var propsT = mapCOW(props, function (prop) {
      return walk(prop, func, depthFirst);
    });

    if (propsT !== props) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno);
      propsT.forEach(function (prop, i) {
        ast[ast.fields[i]] = prop;
      });
    }
  }

  return depthFirst ? func(ast) || ast : ast;
}

function depthWalk(ast, func) {
  return walk(ast, func, true);
}

function _liftFilters(node, asyncFilters, prop) {
  var children = [];
  var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
    var symbol;

    if (descNode instanceof nodes.Block) {
      return descNode;
    } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
      symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
      children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
    }

    return symbol;
  });

  if (prop) {
    node[prop] = walked;
  } else {
    node = walked;
  }

  if (children.length) {
    children.push(node);
    return new nodes.NodeList(node.lineno, node.colno, children);
  } else {
    return node;
  }
}

function liftFilters(ast, asyncFilters) {
  return depthWalk(ast, function (node) {
    if (node instanceof nodes.Output) {
      return _liftFilters(node, asyncFilters);
    } else if (node instanceof nodes.Set) {
      return _liftFilters(node, asyncFilters, 'value');
    } else if (node instanceof nodes.For) {
      return _liftFilters(node, asyncFilters, 'arr');
    } else if (node instanceof nodes.If) {
      return _liftFilters(node, asyncFilters, 'cond');
    } else if (node instanceof nodes.CallExtension) {
      return _liftFilters(node, asyncFilters, 'args');
    } else {
      return undefined;
    }
  });
}

function liftSuper(ast) {
  return walk(ast, function (blockNode) {
    if (!(blockNode instanceof nodes.Block)) {
      return;
    }

    var hasSuper = false;
    var symbol = gensym();
    blockNode.body = walk(blockNode.body, function (node) {
      // eslint-disable-line consistent-return
      if (node instanceof nodes.FunCall && node.name.value === 'super') {
        hasSuper = true;
        return new nodes.Symbol(node.lineno, node.colno, symbol);
      }
    });

    if (hasSuper) {
      blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
    }
  });
}

function convertStatements(ast) {
  return depthWalk(ast, function (node) {
    if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
      return undefined;
    }

    var async = false;
    walk(node, function (child) {
      if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
        async = true; // Stop iterating by returning the node

        return child;
      }

      return undefined;
    });

    if (async) {
      if (node instanceof nodes.If) {
        return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
      } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
        return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
      }
    }

    return undefined;
  });
}

function cps(ast, asyncFilters) {
  return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}

function transform(ast, asyncFilters) {
  return cps(ast, asyncFilters || []);
} // var parser = require('./parser');
// var src = 'hello {% foo %}{% endfoo %} end';
// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
// nodes.printNodes(ast);


module.exports = {
  transform: transform
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_181667__) {

"use strict";


var lib = __nested_webpack_require_181667__(0);

var r = __nested_webpack_require_181667__(2);

var exports = module.exports = {};

function normalize(value, defaultValue) {
  if (value === null || value === undefined || value === false) {
    return defaultValue;
  }

  return value;
}

exports.abs = Math.abs;

function isNaN(num) {
  return num !== num; // eslint-disable-line no-self-compare
}

function batch(arr, linecount, fillWith) {
  var i;
  var res = [];
  var tmp = [];

  for (i = 0; i < arr.length; i++) {
    if (i % linecount === 0 && tmp.length) {
      res.push(tmp);
      tmp = [];
    }

    tmp.push(arr[i]);
  }

  if (tmp.length) {
    if (fillWith) {
      for (i = tmp.length; i < linecount; i++) {
        tmp.push(fillWith);
      }
    }

    res.push(tmp);
  }

  return res;
}

exports.batch = batch;

function capitalize(str) {
  str = normalize(str, '');
  var ret = str.toLowerCase();
  return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}

exports.capitalize = capitalize;

function center(str, width) {
  str = normalize(str, '');
  width = width || 80;

  if (str.length >= width) {
    return str;
  }

  var spaces = width - str.length;
  var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
  var post = lib.repeat(' ', spaces / 2);
  return r.copySafeness(str, pre + str + post);
}

exports.center = center;

function default_(val, def, bool) {
  if (bool) {
    return val || def;
  } else {
    return val !== undefined ? val : def;
  }
} // TODO: it is confusing to export something called 'default'


exports['default'] = default_; // eslint-disable-line dot-notation

function dictsort(val, caseSensitive, by) {
  if (!lib.isObject(val)) {
    throw new lib.TemplateError('dictsort filter: val must be an object');
  }

  var array = []; // deliberately include properties from the object's prototype

  for (var k in val) {
    // eslint-disable-line guard-for-in, no-restricted-syntax
    array.push([k, val[k]]);
  }

  var si;

  if (by === undefined || by === 'key') {
    si = 0;
  } else if (by === 'value') {
    si = 1;
  } else {
    throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
  }

  array.sort(function (t1, t2) {
    var a = t1[si];
    var b = t2[si];

    if (!caseSensitive) {
      if (lib.isString(a)) {
        a = a.toUpperCase();
      }

      if (lib.isString(b)) {
        b = b.toUpperCase();
      }
    }

    return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
  });
  return array;
}

exports.dictsort = dictsort;

function dump(obj, spaces) {
  return JSON.stringify(obj, null, spaces);
}

exports.dump = dump;

function escape(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.escape = escape;

function safe(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(str.toString());
}

exports.safe = safe;

function first(arr) {
  return arr[0];
}

exports.first = first;

function forceescape(str) {
  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.forceescape = forceescape;

function groupby(arr, attr) {
  return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
}

exports.groupby = groupby;

function indent(str, width, indentfirst) {
  str = normalize(str, '');

  if (str === '') {
    return '';
  }

  width = width || 4; // let res = '';

  var lines = str.split('\n');
  var sp = lib.repeat(' ', width);
  var res = lines.map(function (l, i) {
    return i === 0 && !indentfirst ? l : "" + sp + l;
  }).join('\n');
  return r.copySafeness(str, res);
}

exports.indent = indent;

function join(arr, del, attr) {
  del = del || '';

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return arr.join(del);
}

exports.join = join;

function last(arr) {
  return arr[arr.length - 1];
}

exports.last = last;

function lengthFilter(val) {
  var value = normalize(val, '');

  if (value !== undefined) {
    if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
      // ECMAScript 2015 Maps and Sets
      return value.size;
    }

    if (lib.isObject(value) && !(value instanceof r.SafeString)) {
      // Objects (besides SafeStrings), non-primative Arrays
      return lib.keys(value).length;
    }

    return value.length;
  }

  return 0;
}

exports.length = lengthFilter;

function list(val) {
  if (lib.isString(val)) {
    return val.split('');
  } else if (lib.isObject(val)) {
    return lib._entries(val || {}).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        key: key,
        value: value
      };
    });
  } else if (lib.isArray(val)) {
    return val;
  } else {
    throw new lib.TemplateError('list filter: type not iterable');
  }
}

exports.list = list;

function lower(str) {
  str = normalize(str, '');
  return str.toLowerCase();
}

exports.lower = lower;

function nl2br(str) {
  if (str === null || str === undefined) {
    return '';
  }

  return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
}

exports.nl2br = nl2br;

function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

exports.random = random;
/**
 * Construct select or reject filter
 *
 * @param {boolean} expectedTestResult
 * @returns {function(array, string, *): array}
 */

function getSelectOrReject(expectedTestResult) {
  function filter(arr, testName, secondArg) {
    if (testName === void 0) {
      testName = 'truthy';
    }

    var context = this;
    var test = context.env.getTest(testName);
    return lib.toArray(arr).filter(function examineTestResult(item) {
      return test.call(context, item, secondArg) === expectedTestResult;
    });
  }

  return filter;
}

exports.reject = getSelectOrReject(false);

function rejectattr(arr, attr) {
  return arr.filter(function (item) {
    return !item[attr];
  });
}

exports.rejectattr = rejectattr;
exports.select = getSelectOrReject(true);

function selectattr(arr, attr) {
  return arr.filter(function (item) {
    return !!item[attr];
  });
}

exports.selectattr = selectattr;

function replace(str, old, new_, maxCount) {
  var originalStr = str;

  if (old instanceof RegExp) {
    return str.replace(old, new_);
  }

  if (typeof maxCount === 'undefined') {
    maxCount = -1;
  }

  var res = ''; // Output
  // Cast Numbers in the search term to string

  if (typeof old === 'number') {
    old = '' + old;
  } else if (typeof old !== 'string') {
    // If it is something other than number or string,
    // return the original string
    return str;
  } // Cast numbers in the replacement to string


  if (typeof str === 'number') {
    str = '' + str;
  } // If by now, we don't have a string, throw it back


  if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
    return str;
  } // ShortCircuits


  if (old === '') {
    // Mimic the python behaviour: empty string is replaced
    // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
    res = new_ + str.split('').join(new_) + new_;
    return r.copySafeness(str, res);
  }

  var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
  // not contain the old value, return the string

  if (maxCount === 0 || nextIndex === -1) {
    return str;
  }

  var pos = 0;
  var count = 0; // # of replacements made

  while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
    // Grab the next chunk of src string and add it with the
    // replacement, to the result
    res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

    pos = nextIndex + old.length;
    count++; // See if there are any more replacements to be made

    nextIndex = str.indexOf(old, pos);
  } // We've either reached the end, or done the max # of
  // replacements, tack on any remaining string


  if (pos < str.length) {
    res += str.substring(pos);
  }

  return r.copySafeness(originalStr, res);
}

exports.replace = replace;

function reverse(val) {
  var arr;

  if (lib.isString(val)) {
    arr = list(val);
  } else {
    // Copy it
    arr = lib.map(val, function (v) {
      return v;
    });
  }

  arr.reverse();

  if (lib.isString(val)) {
    return r.copySafeness(val, arr.join(''));
  }

  return arr;
}

exports.reverse = reverse;

function round(val, precision, method) {
  precision = precision || 0;
  var factor = Math.pow(10, precision);
  var rounder;

  if (method === 'ceil') {
    rounder = Math.ceil;
  } else if (method === 'floor') {
    rounder = Math.floor;
  } else {
    rounder = Math.round;
  }

  return rounder(val * factor) / factor;
}

exports.round = round;

function slice(arr, slices, fillWith) {
  var sliceLength = Math.floor(arr.length / slices);
  var extra = arr.length % slices;
  var res = [];
  var offset = 0;

  for (var i = 0; i < slices; i++) {
    var start = offset + i * sliceLength;

    if (i < extra) {
      offset++;
    }

    var end = offset + (i + 1) * sliceLength;
    var currSlice = arr.slice(start, end);

    if (fillWith && i >= extra) {
      currSlice.push(fillWith);
    }

    res.push(currSlice);
  }

  return res;
}

exports.slice = slice;

function sum(arr, attr, start) {
  if (start === void 0) {
    start = 0;
  }

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return start + arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

exports.sum = sum;
exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function sortFilter(arr, reversed, caseSens, attr) {
  var _this = this;

  // Copy it
  var array = lib.map(arr, function (v) {
    return v;
  });
  var getAttribute = lib.getAttrGetter(attr);
  array.sort(function (a, b) {
    var x = attr ? getAttribute(a) : a;
    var y = attr ? getAttribute(b) : b;

    if (_this.env.opts.throwOnUndefined && attr && (x === undefined || y === undefined)) {
      throw new TypeError("sort: attribute \"" + attr + "\" resolved to undefined");
    }

    if (!caseSens && lib.isString(x) && lib.isString(y)) {
      x = x.toLowerCase();
      y = y.toLowerCase();
    }

    if (x < y) {
      return reversed ? 1 : -1;
    } else if (x > y) {
      return reversed ? -1 : 1;
    } else {
      return 0;
    }
  });
  return array;
});

function string(obj) {
  return r.copySafeness(obj, obj);
}

exports.string = string;

function striptags(input, preserveLinebreaks) {
  input = normalize(input, '');
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
  var trimmedInput = trim(input.replace(tags, ''));
  var res = '';

  if (preserveLinebreaks) {
    res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
    .replace(/ +/g, ' ') // squash adjacent spaces
    .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
    .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
  } else {
    res = trimmedInput.replace(/\s+/gi, ' ');
  }

  return r.copySafeness(input, res);
}

exports.striptags = striptags;

function title(str) {
  str = normalize(str, '');
  var words = str.split(' ').map(function (word) {
    return capitalize(word);
  });
  return r.copySafeness(str, words.join(' '));
}

exports.title = title;

function trim(str) {
  return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
}

exports.trim = trim;

function truncate(input, length, killwords, end) {
  var orig = input;
  input = normalize(input, '');
  length = length || 255;

  if (input.length <= length) {
    return input;
  }

  if (killwords) {
    input = input.substring(0, length);
  } else {
    var idx = input.lastIndexOf(' ', length);

    if (idx === -1) {
      idx = length;
    }

    input = input.substring(0, idx);
  }

  input += end !== undefined && end !== null ? end : '...';
  return r.copySafeness(orig, input);
}

exports.truncate = truncate;

function upper(str) {
  str = normalize(str, '');
  return str.toUpperCase();
}

exports.upper = upper;

function urlencode(obj) {
  var enc = encodeURIComponent;

  if (lib.isString(obj)) {
    return enc(obj);
  } else {
    var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
    return keyvals.map(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      return enc(k) + "=" + enc(v);
    }).join('&');
  }
}

exports.urlencode = urlencode; // For the jinja regexp, see
// https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
var httpHttpsRe = /^https?:\/\/.*$/;
var wwwRe = /^www\./;
var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

function urlize(str, length, nofollow) {
  if (isNaN(length)) {
    length = Infinity;
  }

  var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
  var words = str.split(/(\s+)/).filter(function (word) {
    // If the word has no length, bail. This can happen for str with
    // trailing whitespace.
    return word && word.length;
  }).map(function (word) {
    var matches = word.match(puncRe);
    var possibleUrl = matches ? matches[1] : word;
    var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

    if (httpHttpsRe.test(possibleUrl)) {
      return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // url that starts with www.


    if (wwwRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // an email address of the form username@domain.tld


    if (emailRe.test(possibleUrl)) {
      return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
    } // url that ends in .com, .org or .net that is not an email address


    if (tldRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    }

    return word;
  });
  return words.join('');
}

exports.urlize = urlize;

function wordcount(str) {
  str = normalize(str, '');
  var words = str ? str.match(/\w+/g) : null;
  return words ? words.length : null;
}

exports.wordcount = wordcount;

function float(val, def) {
  var res = parseFloat(val);
  return isNaN(res) ? def : res;
}

exports.float = float;
var intFilter = r.makeMacro(['value', 'default', 'base'], [], function doInt(value, defaultValue, base) {
  if (base === void 0) {
    base = 10;
  }

  var res = parseInt(value, base);
  return isNaN(res) ? defaultValue : res;
});
exports.int = intFilter; // Aliases

exports.d = exports.default;
exports.e = exports.escape;

/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_196726__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __nested_webpack_require_196726__(6);

var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(PrecompiledLoader, _Loader);

  function PrecompiledLoader(compiledTemplates) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.precompiled = compiledTemplates || {};
    return _this;
  }

  var _proto = PrecompiledLoader.prototype;

  _proto.getSource = function getSource(name) {
    if (this.precompiled[name]) {
      return {
        src: {
          type: 'code',
          obj: this.precompiled[name]
        },
        path: name
      };
    }

    return null;
  };

  return PrecompiledLoader;
}(Loader);

module.exports = {
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_197892__) {

"use strict";


var SafeString = __nested_webpack_require_197892__(2).SafeString;
/**
 * Returns `true` if the object is a function, otherwise `false`.
 * @param { any } value
 * @returns { boolean }
 */


function callable(value) {
  return typeof value === 'function';
}

exports.callable = callable;
/**
 * Returns `true` if the object is strictly not `undefined`.
 * @param { any } value
 * @returns { boolean }
 */

function defined(value) {
  return value !== undefined;
}

exports.defined = defined;
/**
 * Returns `true` if the operand (one) is divisble by the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function divisibleby(one, two) {
  return one % two === 0;
}

exports.divisibleby = divisibleby;
/**
 * Returns true if the string has been escaped (i.e., is a SafeString).
 * @param { any } value
 * @returns { boolean }
 */

function escaped(value) {
  return value instanceof SafeString;
}

exports.escaped = escaped;
/**
 * Returns `true` if the arguments are strictly equal.
 * @param { any } one
 * @param { any } two
 */

function equalto(one, two) {
  return one === two;
}

exports.equalto = equalto; // Aliases

exports.eq = exports.equalto;
exports.sameas = exports.equalto;
/**
 * Returns `true` if the value is evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function even(value) {
  return value % 2 === 0;
}

exports.even = even;
/**
 * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
 * undefined, NaN or null. I don't know if we should stick to the default JS
 * behavior or attempt to replicate what Python believes should be falsy (i.e.,
 * empty arrays, empty dicts, not 0...).
 * @param { any } value
 * @returns { boolean }
 */

function falsy(value) {
  return !value;
}

exports.falsy = falsy;
/**
 * Returns `true` if the operand (one) is greater or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ge(one, two) {
  return one >= two;
}

exports.ge = ge;
/**
 * Returns `true` if the operand (one) is greater than the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function greaterthan(one, two) {
  return one > two;
}

exports.greaterthan = greaterthan; // alias

exports.gt = exports.greaterthan;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function le(one, two) {
  return one <= two;
}

exports.le = le;
/**
 * Returns `true` if the operand (one) is less than the test's passed argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function lessthan(one, two) {
  return one < two;
}

exports.lessthan = lessthan; // alias

exports.lt = exports.lessthan;
/**
 * Returns `true` if the string is lowercased.
 * @param { string } value
 * @returns { boolean }
 */

function lower(value) {
  return value.toLowerCase() === value;
}

exports.lower = lower;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ne(one, two) {
  return one !== two;
}

exports.ne = ne;
/**
 * Returns true if the value is strictly equal to `null`.
 * @param { any }
 * @returns { boolean }
 */

function nullTest(value) {
  return value === null;
}

exports.null = nullTest;
/**
 * Returns true if value is a number.
 * @param { any }
 * @returns { boolean }
 */

function number(value) {
  return typeof value === 'number';
}

exports.number = number;
/**
 * Returns `true` if the value is *not* evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function odd(value) {
  return value % 2 === 1;
}

exports.odd = odd;
/**
 * Returns `true` if the value is a string, `false` if not.
 * @param { any } value
 * @returns { boolean }
 */

function string(value) {
  return typeof value === 'string';
}

exports.string = string;
/**
 * Returns `true` if the value is not in the list of things considered falsy:
 * '', null, undefined, 0, NaN and false.
 * @param { any } value
 * @returns { boolean }
 */

function truthy(value) {
  return !!value;
}

exports.truthy = truthy;
/**
 * Returns `true` if the value is undefined.
 * @param { any } value
 * @returns { boolean }
 */

function undefinedTest(value) {
  return value === undefined;
}

exports.undefined = undefinedTest;
/**
 * Returns `true` if the string is uppercased.
 * @param { string } value
 * @returns { boolean }
 */

function upper(value) {
  return value.toUpperCase() === value;
}

exports.upper = upper;
/**
 * If ES6 features are available, returns `true` if the value implements the
 * `Symbol.iterator` method. If not, it's a string or Array.
 *
 * Could potentially cause issues if a browser exists that has Set and Map but
 * not Symbol.
 *
 * @param { any } value
 * @returns { boolean }
 */

function iterable(value) {
  if (typeof Symbol !== 'undefined') {
    return !!value[Symbol.iterator];
  } else {
    return Array.isArray(value) || typeof value === 'string';
  }
}

exports.iterable = iterable;
/**
 * If ES6 features are available, returns `true` if the value is an object hash
 * or an ES6 Map. Otherwise just return if it's an object hash.
 * @param { any } value
 * @returns { boolean }
 */

function mapping(value) {
  // only maps and object hashes
  var bool = value !== null && value !== undefined && typeof value === 'object' && !Array.isArray(value);

  if (Set) {
    return bool && !(value instanceof Set);
  } else {
    return bool;
  }
}

exports.mapping = mapping;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _cycler(items) {
  var index = -1;
  return {
    current: null,
    reset: function reset() {
      index = -1;
      this.current = null;
    },
    next: function next() {
      index++;

      if (index >= items.length) {
        index = 0;
      }

      this.current = items[index];
      return this.current;
    }
  };
}

function _joiner(sep) {
  sep = sep || ',';
  var first = true;
  return function () {
    var val = first ? '' : sep;
    first = false;
    return val;
  };
} // Making this a function instead so it returns a new object
// each time it's called. That way, if something like an environment
// uses it, they will each have their own copy.


function globals() {
  return {
    range: function range(start, stop, step) {
      if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
        step = 1;
      } else if (!step) {
        step = 1;
      }

      var arr = [];

      if (step > 0) {
        for (var i = start; i < stop; i += step) {
          arr.push(i);
        }
      } else {
        for (var _i = start; _i > stop; _i += step) {
          // eslint-disable-line for-direction
          arr.push(_i);
        }
      }

      return arr;
    },
    cycler: function cycler() {
      return _cycler(Array.prototype.slice.call(arguments));
    },
    joiner: function joiner(sep) {
      return _joiner(sep);
    }
  };
}

module.exports = globals;

/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_205249__) {

var path = __nested_webpack_require_205249__(4);

module.exports = function express(env, app) {
  function NunjucksView(name, opts) {
    this.name = name;
    this.path = name;
    this.defaultEngine = opts.defaultEngine;
    this.ext = path.extname(name);

    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }

    if (!this.ext) {
      this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
    }
  }

  NunjucksView.prototype.render = function render(opts, cb) {
    env.render(this.name, opts, cb);
  };

  app.set('view', NunjucksView);
  app.set('nunjucksEnv', env);
  return env;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_206024__) {

"use strict";


var fs = __nested_webpack_require_206024__(4);

var path = __nested_webpack_require_206024__(4);

var _require = __nested_webpack_require_206024__(0),
    _prettifyError = _require._prettifyError;

var compiler = __nested_webpack_require_206024__(5);

var _require2 = __nested_webpack_require_206024__(7),
    Environment = _require2.Environment;

var precompileGlobal = __nested_webpack_require_206024__(24);

function match(filename, patterns) {
  if (!Array.isArray(patterns)) {
    return false;
  }

  return patterns.some(function (pattern) {
    return filename.match(pattern);
  });
}

function precompileString(str, opts) {
  opts = opts || {};
  opts.isString = true;
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (!opts.name) {
    throw new Error('the "name" option is required when compiling a string');
  }

  return wrapper([_precompile(str, opts.name, env)], opts);
}

function precompile(input, opts) {
  // The following options are available:
  //
  // * name: name of the template (auto-generated when compiling a directory)
  // * isString: input is a string, not a file path
  // * asFunction: generate a callable function
  // * force: keep compiling on error
  // * env: the Environment to use (gets extensions and async filters from it)
  // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
  // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
  // * wrapper: function(templates, opts) {...}
  //       Customize the output format to store the compiled template.
  //       By default, templates are stored in a global variable used by the runtime.
  //       A custom loader will be necessary to load your custom wrapper.
  opts = opts || {};
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (opts.isString) {
    return precompileString(input, opts);
  }

  var pathStats = fs.existsSync(input) && fs.statSync(input);
  var precompiled = [];
  var templates = [];

  function addTemplates(dir) {
    fs.readdirSync(dir).forEach(function (file) {
      var filepath = path.join(dir, file);
      var subpath = filepath.substr(path.join(input, '/').length);
      var stat = fs.statSync(filepath);

      if (stat && stat.isDirectory()) {
        subpath += '/';

        if (!match(subpath, opts.exclude)) {
          addTemplates(filepath);
        }
      } else if (match(subpath, opts.include)) {
        templates.push(filepath);
      }
    });
  }

  if (pathStats.isFile()) {
    precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
  } else if (pathStats.isDirectory()) {
    addTemplates(input);

    for (var i = 0; i < templates.length; i++) {
      var name = templates[i].replace(path.join(input, '/'), '');

      try {
        precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
      } catch (e) {
        if (opts.force) {
          // Don't stop generating the output if we're
          // forcing compilation.
          console.error(e); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }
    }
  }

  return wrapper(precompiled, opts);
}

function _precompile(str, name, env) {
  env = env || new Environment([]);
  var asyncFilters = env.asyncFilters;
  var extensions = env.extensionsList;
  var template;
  name = name.replace(/\\/g, '/');

  try {
    template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
  } catch (err) {
    throw _prettifyError(name, false, err);
  }

  return {
    name: name,
    template: template
  };
}

module.exports = {
  precompile: precompile,
  precompileString: precompileString
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function precompileGlobal(templates, opts) {
  var out = '';
  opts = opts || {};

  for (var i = 0; i < templates.length; i++) {
    var name = JSON.stringify(templates[i].name);
    var template = templates[i].template;
    out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

    if (opts.asFunction) {
      out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
    }

    out += '})();\n';
  }

  return out;
}

module.exports = precompileGlobal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

function installCompat() {
  'use strict';
  /* eslint-disable camelcase */
  // This must be called like `nunjucks.installCompat` so that `this`
  // references the nunjucks instance

  var runtime = this.runtime;
  var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

  var Compiler = this.compiler.Compiler;
  var Parser = this.parser.Parser;
  var nodes = this.nodes;
  var lexer = this.lexer;
  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
  var orig_memberLookup = runtime.memberLookup;
  var orig_Compiler_assertType;
  var orig_Parser_parseAggregate;

  if (Compiler) {
    orig_Compiler_assertType = Compiler.prototype.assertType;
  }

  if (Parser) {
    orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
  }

  function uninstall() {
    runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
    runtime.memberLookup = orig_memberLookup;

    if (Compiler) {
      Compiler.prototype.assertType = orig_Compiler_assertType;
    }

    if (Parser) {
      Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
    }
  }

  runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
    var val = orig_contextOrFrameLookup.apply(this, arguments);

    if (val !== undefined) {
      return val;
    }

    switch (key) {
      case 'True':
        return true;

      case 'False':
        return false;

      case 'None':
        return null;

      default:
        return undefined;
    }
  };

  function getTokensState(tokens) {
    return {
      index: tokens.index,
      lineno: tokens.lineno,
      colno: tokens.colno
    };
  }

  if ( true && nodes && Compiler && Parser) {
    // i.e., not slim mode
    var Slice = nodes.Node.extend('Slice', {
      fields: ['start', 'stop', 'step'],
      init: function init(lineno, colno, start, stop, step) {
        start = start || new nodes.Literal(lineno, colno, null);
        stop = stop || new nodes.Literal(lineno, colno, null);
        step = step || new nodes.Literal(lineno, colno, 1);
        this.parent(lineno, colno, start, stop, step);
      }
    });

    Compiler.prototype.assertType = function assertType(node) {
      if (node instanceof Slice) {
        return;
      }

      orig_Compiler_assertType.apply(this, arguments);
    };

    Compiler.prototype.compileSlice = function compileSlice(node, frame) {
      this._emit('(');

      this._compileExpression(node.start, frame);

      this._emit('),(');

      this._compileExpression(node.stop, frame);

      this._emit('),(');

      this._compileExpression(node.step, frame);

      this._emit(')');
    };

    Parser.prototype.parseAggregate = function parseAggregate() {
      var _this = this;

      var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

      origState.colno--;
      origState.index--;

      try {
        return orig_Parser_parseAggregate.apply(this);
      } catch (e) {
        var errState = getTokensState(this.tokens);

        var rethrow = function rethrow() {
          lib._assign(_this.tokens, errState);

          return e;
        }; // Reset to state before original parseAggregate called


        lib._assign(this.tokens, origState);

        this.peeked = false;
        var tok = this.peekToken();

        if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
          throw rethrow();
        } else {
          this.nextToken();
        }

        var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
        // so re-raise the original exception.

        var isSlice = false;

        for (var i = 0; i <= node.fields.length; i++) {
          if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
            break;
          }

          if (i === node.fields.length) {
            if (isSlice) {
              this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
            } else {
              break;
            }
          }

          if (this.skip(lexer.TOKEN_COLON)) {
            isSlice = true;
          } else {
            var field = node.fields[i];
            node[field] = this.parseExpression();
            isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
          }
        }

        if (!isSlice) {
          throw rethrow();
        }

        return new nodes.Array(tok.lineno, tok.colno, [node]);
      }
    };
  }

  function sliceLookup(obj, start, stop, step) {
    obj = obj || [];

    if (start === null) {
      start = step < 0 ? obj.length - 1 : 0;
    }

    if (stop === null) {
      stop = step < 0 ? -1 : obj.length;
    } else if (stop < 0) {
      stop += obj.length;
    }

    if (start < 0) {
      start += obj.length;
    }

    var results = [];

    for (var i = start;; i += step) {
      if (i < 0 || i > obj.length) {
        break;
      }

      if (step > 0 && i >= stop) {
        break;
      }

      if (step < 0 && i <= stop) {
        break;
      }

      results.push(runtime.memberLookup(obj, i));
    }

    return results;
  }

  function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var ARRAY_MEMBERS = {
    pop: function pop(index) {
      if (index === undefined) {
        return this.pop();
      }

      if (index >= this.length || index < 0) {
        throw new Error('KeyError');
      }

      return this.splice(index, 1);
    },
    append: function append(element) {
      return this.push(element);
    },
    remove: function remove(element) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          return this.splice(i, 1);
        }
      }

      throw new Error('ValueError');
    },
    count: function count(element) {
      var count = 0;

      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          count++;
        }
      }

      return count;
    },
    index: function index(element) {
      var i;

      if ((i = this.indexOf(element)) === -1) {
        throw new Error('ValueError');
      }

      return i;
    },
    find: function find(element) {
      return this.indexOf(element);
    },
    insert: function insert(index, elem) {
      return this.splice(index, 0, elem);
    }
  };
  var OBJECT_MEMBERS = {
    items: function items() {
      return lib._entries(this);
    },
    values: function values() {
      return lib._values(this);
    },
    keys: function keys() {
      return lib.keys(this);
    },
    get: function get(key, def) {
      var output = this[key];

      if (output === undefined) {
        output = def;
      }

      return output;
    },
    has_key: function has_key(key) {
      return hasOwnProp(this, key);
    },
    pop: function pop(key, def) {
      var output = this[key];

      if (output === undefined && def !== undefined) {
        output = def;
      } else if (output === undefined) {
        throw new Error('KeyError');
      } else {
        delete this[key];
      }

      return output;
    },
    popitem: function popitem() {
      var keys = lib.keys(this);

      if (!keys.length) {
        throw new Error('KeyError');
      }

      var k = keys[0];
      var val = this[k];
      delete this[k];
      return [k, val];
    },
    setdefault: function setdefault(key, def) {
      if (def === void 0) {
        def = null;
      }

      if (!(key in this)) {
        this[key] = def;
      }

      return this[key];
    },
    update: function update(kwargs) {
      lib._assign(this, kwargs);

      return null; // Always returns None
    }
  };
  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

  runtime.memberLookup = function memberLookup(obj, val, autoescape) {
    if (arguments.length === 4) {
      return sliceLookup.apply(this, arguments);
    }

    obj = obj || {}; // If the object is an object, return any of the methods that Python would
    // otherwise provide.

    if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
      return ARRAY_MEMBERS[val].bind(obj);
    }

    if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
      return OBJECT_MEMBERS[val].bind(obj);
    }

    return orig_memberLookup.apply(this, arguments);
  };

  return uninstall;
}

module.exports = installCompat;

/***/ })
/******/ ]);
});
//# sourceMappingURL=nunjucks.js.map

/***/ }),

/***/ "./node_modules/resonance-audio/build/resonance-audio.js":
/*!***************************************************************!*\
  !*** ./node_modules/resonance-audio/build/resonance-audio.js ***!
  \***************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_536__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_536__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_536__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_536__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_536__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_536__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_536__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_536__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_536__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_536__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_536__(__nested_webpack_require_536__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library common utilities, mathematical constants,
 * and default values.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * @class Utils
 * @description A set of defaults, constants and utility functions.
 */
function Utils() {};


/**
 * Default input gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_GAIN = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field listener by.
 * @type {Number}
 */
Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field sources by.
 * @type {Number}
 */
Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Default distance from listener when setting angle.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_DISTANCE = 1;


/** @type {Float32Array} */
Utils.DEFAULT_POSITION = [0, 0, 0];


/** @type {Float32Array} */
Utils.DEFAULT_FORWARD = [0, 0, -1];


/** @type {Float32Array} */
Utils.DEFAULT_UP = [0, 1, 0];


/** @type {Float32Array} */
Utils.DEFAULT_RIGHT = [1, 0, 0];


/**
 * @type {Number}
 */
Utils.DEFAULT_SPEED_OF_SOUND = 343;


/** Rolloff models (e.g. 'logarithmic', 'linear', or 'none').
 * @type {Array}
 */
Utils.ATTENUATION_ROLLOFFS = ['logarithmic', 'linear', 'none'];


/** Default rolloff model ('logarithmic').
 * @type {string}
 */
Utils.DEFAULT_ATTENUATION_ROLLOFF = 'logarithmic';


/** @type {Number} */
Utils.DEFAULT_MIN_DISTANCE = 1;


/** @type {Number} */
Utils.DEFAULT_MAX_DISTANCE = 1000;


/**
 * The default alpha (i.e. microphone pattern).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_ALPHA = 0;


/**
 * The default pattern sharpness (i.e. pattern exponent).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_SHARPNESS = 1;


/**
 * Default azimuth (in degrees). Suitable range is 0 to 360.
 * @type {Number}
 */
Utils.DEFAULT_AZIMUTH = 0;


/**
 * Default elevation (in degres).
 * Suitable range is from -90 (below) to 90 (above).
 * @type {Number}
 */
Utils.DEFAULT_ELEVATION = 0;


/**
 * The default ambisonic order.
 * @type {Number}
 */
Utils.DEFAULT_AMBISONIC_ORDER = 1;


/**
 * The default source width.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_WIDTH = 0;


/**
 * The maximum delay (in seconds) of a single wall reflection.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MAX_DURATION = 0.5;


/**
 * The -12dB cutoff frequency (in Hertz) for the lowpass filter applied to
 * all reflections.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY = 6400; // Uses -12dB cutoff.


/**
 * The default reflection coefficients (where 0 = no reflection, 1 = perfect
 * reflection, -1 = mirrored reflection (180-degrees out of phase)).
 * @type {Object}
 */
Utils.DEFAULT_REFLECTION_COEFFICIENTS = {
  left: 0, right: 0, front: 0, back: 0, down: 0, up: 0,
};


/**
 * The minimum distance we consider the listener to be to any given wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MIN_DISTANCE = 1;


/**
 * Default room dimensions (in meters).
 * @type {Object}
 */
Utils.DEFAULT_ROOM_DIMENSIONS = {
  width: 0, height: 0, depth: 0,
};


/**
 * The multiplier to apply to distances from the listener to each wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MULTIPLIER = 1;


/** The default bandwidth (in octaves) of the center frequencies.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_BANDWIDTH = 1;


/** The default multiplier applied when computing tail lengths.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_DURATION_MULTIPLIER = 1;


/**
 * The late reflections pre-delay (in milliseconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_PREDELAY = 1.5;


/**
 * The length of the beginning of the impulse response to apply a
 * half-Hann window to.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_TAIL_ONSET = 3.8;


/**
 * The default gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_GAIN = 0.01;


/**
 * The maximum impulse response length (in seconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_MAX_DURATION = 3;


/**
 * Center frequencies of the multiband late reflections.
 * Nine bands are computed by: 31.25 * 2^(0:8).
 * @type {Array}
 */
Utils.DEFAULT_REVERB_FREQUENCY_BANDS = [
  31.25, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000,
];


/**
 * The number of frequency bands.
 */
Utils.NUMBER_REVERB_FREQUENCY_BANDS =
  Utils.DEFAULT_REVERB_FREQUENCY_BANDS.length;


/**
 * The default multiband RT60 durations (in seconds).
 * @type {Float32Array}
 */
Utils.DEFAULT_REVERB_DURATIONS =
  new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);


/**
 * Pre-defined frequency-dependent absorption coefficients for listed materials.
 * Currently supported materials are:
 * <ul>
 * <li>'transparent'</li>
 * <li>'acoustic-ceiling-tiles'</li>
 * <li>'brick-bare'</li>
 * <li>'brick-painted'</li>
 * <li>'concrete-block-coarse'</li>
 * <li>'concrete-block-painted'</li>
 * <li>'curtain-heavy'</li>
 * <li>'fiber-glass-insulation'</li>
 * <li>'glass-thin'</li>
 * <li>'glass-thick'</li>
 * <li>'grass'</li>
 * <li>'linoleum-on-concrete'</li>
 * <li>'marble'</li>
 * <li>'metal'</li>
 * <li>'parquet-on-concrete'</li>
 * <li>'plaster-smooth'</li>
 * <li>'plywood-panel'</li>
 * <li>'polished-concrete-or-tile'</li>
 * <li>'sheetrock'</li>
 * <li>'water-or-ice-surface'</li>
 * <li>'wood-ceiling'</li>
 * <li>'wood-panel'</li>
 * <li>'uniform'</li>
 * </ul>
 * @type {Object}
 */
Utils.ROOM_MATERIAL_COEFFICIENTS = {
  'transparent':
  [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000],
  'acoustic-ceiling-tiles':
  [0.672, 0.675, 0.700, 0.660, 0.720, 0.920, 0.880, 0.750, 1.000],
  'brick-bare':
  [0.030, 0.030, 0.030, 0.030, 0.030, 0.040, 0.050, 0.070, 0.140],
  'brick-painted':
  [0.006, 0.007, 0.010, 0.010, 0.020, 0.020, 0.020, 0.030, 0.060],
  'concrete-block-coarse':
  [0.360, 0.360, 0.360, 0.440, 0.310, 0.290, 0.390, 0.250, 0.500],
  'concrete-block-painted':
  [0.092, 0.090, 0.100, 0.050, 0.060, 0.070, 0.090, 0.080, 0.160],
  'curtain-heavy':
  [0.073, 0.106, 0.140, 0.350, 0.550, 0.720, 0.700, 0.650, 1.000],
  'fiber-glass-insulation':
  [0.193, 0.220, 0.220, 0.820, 0.990, 0.990, 0.990, 0.990, 1.000],
  'glass-thin':
  [0.180, 0.169, 0.180, 0.060, 0.040, 0.030, 0.020, 0.020, 0.040],
  'glass-thick':
  [0.350, 0.350, 0.350, 0.250, 0.180, 0.120, 0.070, 0.040, 0.080],
  'grass':
  [0.050, 0.050, 0.150, 0.250, 0.400, 0.550, 0.600, 0.600, 0.600],
  'linoleum-on-concrete':
  [0.020, 0.020, 0.020, 0.030, 0.030, 0.030, 0.030, 0.020, 0.040],
  'marble':
  [0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.020, 0.020, 0.040],
  'metal':
  [0.030, 0.035, 0.040, 0.040, 0.050, 0.050, 0.050, 0.070, 0.090],
  'parquet-on-concrete':
  [0.028, 0.030, 0.040, 0.040, 0.070, 0.060, 0.060, 0.070, 0.140],
  'plaster-rough':
  [0.017, 0.018, 0.020, 0.030, 0.040, 0.050, 0.040, 0.030, 0.060],
  'plaster-smooth':
  [0.011, 0.012, 0.013, 0.015, 0.020, 0.030, 0.040, 0.050, 0.100],
  'plywood-panel':
  [0.400, 0.340, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'polished-concrete-or-tile':
  [0.008, 0.008, 0.010, 0.010, 0.015, 0.020, 0.020, 0.020, 0.040],
  'sheet-rock':
  [0.290, 0.279, 0.290, 0.100, 0.050, 0.040, 0.070, 0.090, 0.180],
  'water-or-ice-surface':
  [0.006, 0.006, 0.008, 0.008, 0.013, 0.015, 0.020, 0.025, 0.050],
  'wood-ceiling':
  [0.150, 0.147, 0.150, 0.110, 0.100, 0.070, 0.060, 0.070, 0.140],
  'wood-panel':
  [0.280, 0.280, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'uniform':
  [0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500],
};


/**
 * Default materials that use strings from
 * {@linkcode Utils.MATERIAL_COEFFICIENTS MATERIAL_COEFFICIENTS}
 * @type {Object}
 */
Utils.DEFAULT_ROOM_MATERIALS = {
  left: 'transparent', right: 'transparent', front: 'transparent',
  back: 'transparent', down: 'transparent', up: 'transparent',
};


/**
 * The number of bands to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.NUMBER_REFLECTION_AVERAGING_BANDS = 3;


/**
 * The starting band to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.ROOM_STARTING_AVERAGING_BAND = 4;


/**
 * The minimum threshold for room volume.
 * Room model is disabled if volume is below this value.
 * @type {Number} */
Utils.ROOM_MIN_VOLUME = 1e-4;


/**
 * Air absorption coefficients per frequency band.
 * @type {Float32Array}
 */
Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS =
  [0.0006, 0.0006, 0.0007, 0.0008, 0.0010, 0.0015, 0.0026, 0.0060, 0.0207];


/**
 * A scalar correction value to ensure Sabine and Eyring produce the same RT60
 * value at the cross-over threshold.
 * @type {Number}
 */
Utils.ROOM_EYRING_CORRECTION_COEFFICIENT = 1.38;


/**
 * @type {Number}
 * @private
 */
Utils.TWO_PI = 6.28318530717959;


/**
 * @type {Number}
 * @private
 */
Utils.TWENTY_FOUR_LOG10 = 55.2620422318571;


/**
 * @type {Number}
 * @private
 */
Utils.LOG1000 = 6.90775527898214;


/**
 * @type {Number}
 * @private
 */
Utils.LOG2_DIV2 = 0.346573590279973;


/**
 * @type {Number}
 * @private
 */
Utils.DEGREES_TO_RADIANS = 0.017453292519943;


/**
 * @type {Number}
 * @private
 */
Utils.RADIANS_TO_DEGREES = 57.295779513082323;


/**
 * @type {Number}
 * @private
 */
Utils.EPSILON_FLOAT = 1e-8;


/**
 * ResonanceAudio library logging function.
 * @type {Function}
 * @param {any} Message to be printed out.
 * @private
 */
Utils.log = function() {
  window.console.log.apply(window.console, [
    '%c[ResonanceAudio]%c '
      + Array.prototype.slice.call(arguments).join(' ') + ' %c(@'
      + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 700',
    'font-weight: 400',
    'color: #AAA',
  ]);
};


/**
 * Normalize a 3-d vector.
 * @param {Float32Array} v 3-element vector.
 * @return {Float32Array} 3-element vector.
 * @private
 */
Utils.normalizeVector = function(v) {
  let n = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  if (n > exports.EPSILON_FLOAT) {
    n = 1 / n;
    v[0] *= n;
    v[1] *= n;
    v[2] *= n;
  }
  return v;
};


/**
 * Cross-product between two 3-d vectors.
 * @param {Float32Array} a 3-element vector.
 * @param {Float32Array} b 3-element vector.
 * @return {Float32Array}
 * @private
 */
Utils.crossProduct = function(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0],
  ];
};

module.exports = Utils;


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_13812__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Spatially encodes input using weighted spherical harmonics.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Tables = __nested_webpack_require_13812__(3);
const Utils = __nested_webpack_require_13812__(0);


/**
 * @class Encoder
 * @description Spatially encodes input using weighted spherical harmonics.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Number} options.azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} options.elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Encoder(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Encoder
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Encoder
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.azimuth == undefined) {
    options.azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (options.elevation == undefined) {
    options.elevation = Utils.DEFAULT_ELEVATION;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  this._context = context;

  // Create I/O nodes.
  this.input = context.createGain();
  this._channelGain = [];
  this._merger = undefined;
  this.output = context.createGain();

  // Set initial order, angle and source width.
  this.setAmbisonicOrder(options.ambisonicOrder);
  this._azimuth = options.azimuth;
  this._elevation = options.elevation;
  this.setSourceWidth(options.sourceWidth);
}

/**
 * Set the desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
Encoder.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);

  this.input.disconnect();
  for (let i = 0; i < this._channelGain.length; i++) {
    this._channelGain[i].disconnect();
  }
  if (this._merger != undefined) {
    this._merger.disconnect();
  }
  delete this._channelGain;
  delete this._merger;

  // Create audio graph.
  let numChannels = (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);
  this._merger = this._context.createChannelMerger(numChannels);
  this._channelGain = new Array(numChannels);
  for (let i = 0; i < numChannels; i++) {
    this._channelGain[i] = this._context.createGain();
    this.input.connect(this._channelGain[i]);
    this._channelGain[i].connect(this._merger, 0, i);
  }
  this._merger.connect(this.output);
};


/**
 * Set the direction of the encoded source signal.
 * @param {Number} azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 */
Encoder.prototype.setDirection = function(azimuth, elevation) {
  // Format input direction to nearest indices.
  if (azimuth == undefined || isNaN(azimuth)) {
    azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (elevation == undefined || isNaN(elevation)) {
    elevation = Utils.DEFAULT_ELEVATION;
  }

  // Store the formatted input (for updating source width).
  this._azimuth = azimuth;
  this._elevation = elevation;

  // Format direction for index lookups.
  azimuth = Math.round(azimuth % 360);
  if (azimuth < 0) {
    azimuth += 360;
  }
  elevation = Math.round(Math.min(90, Math.max(-90, elevation))) + 90;

  // Assign gains to each output.
  this._channelGain[0].gain.value = Tables.MAX_RE_WEIGHTS[this._spreadIndex][0];
  for (let i = 1; i <= this._ambisonicOrder; i++) {
    let degreeWeight = Tables.MAX_RE_WEIGHTS[this._spreadIndex][i];
    for (let j = -i; j <= i; j++) {
      let acnChannel = (i * i) + i + j;
      let elevationIndex = i * (i + 1) / 2 + Math.abs(j) - 1;
      let val = Tables.SPHERICAL_HARMONICS[1][elevation][elevationIndex];
      if (j != 0) {
        let azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j - 1;
        if (j < 0) {
          azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j;
        }
        val *= Tables.SPHERICAL_HARMONICS[0][azimuth][azimuthIndex];
      }
      this._channelGain[acnChannel].gain.value = val * degreeWeight;
    }
  }
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Encoder.prototype.setSourceWidth = function(sourceWidth) {
  // The MAX_RE_WEIGHTS is a 360 x (Tables.SPHERICAL_HARMONICS_MAX_ORDER+1)
  // size table.
  this._spreadIndex = Math.min(359, Math.max(0, Math.round(sourceWidth)));
  this.setDirection(this._azimuth, this._elevation);
};


/**
 * Validate the provided ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 * @return {Number} Validated/adjusted ambisonic order.
 * @private
 */
Encoder.validateAmbisonicOrder = function(ambisonicOrder) {
  if (isNaN(ambisonicOrder) || ambisonicOrder == undefined) {
    Utils.log('Error: Invalid ambisonic order',
    options.ambisonicOrder, '\nUsing ambisonicOrder=1 instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder < 1) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Min order is 1)',
    '\nUsing min order instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder > Tables.SPHERICAL_HARMONICS_MAX_ORDER) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Max order is',
    Tables.SPHERICAL_HARMONICS_MAX_ORDER, ')\nUsing max order instead.');
    options.ambisonicOrder = Tables.SPHERICAL_HARMONICS_MAX_ORDER;
  }
  return ambisonicOrder;
};


module.exports = Encoder;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_21131__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Listener model to spatialize sources in an environment.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Omnitone = __nested_webpack_require_21131__(12);
const Encoder = __nested_webpack_require_21131__(1);
const Utils = __nested_webpack_require_21131__(0);


/**
 * @class Listener
 * @description Listener model to spatialize sources in an environment.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.position
 * Initial position (in meters), where origin is the center of
 * the room. Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The listener's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The listener's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 */
function Listener(context, options) {
  // Public variables.
  /**
   * Position (in meters).
   * @member {Float32Array} position
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Listener
   * @instance
   */
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} ambisonicOutput
   * @memberof Listener
   * @instance
   */
  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }

  // Member variables.
  this.position = new Float32Array(3);
  this._tempMatrix3 = new Float32Array(9);

  // Select the appropriate HRIR filters using 2-channel chunks since
  // multichannel audio is not yet supported by a majority of browsers.
  this._ambisonicOrder =
    Encoder.validateAmbisonicOrder(options.ambisonicOrder);

    // Create audio nodes.
  this._context = context;
  if (this._ambisonicOrder == 1) {
    this._renderer = Omnitone.Omnitone.createFOARenderer(context, {});
  } else if (this._ambisonicOrder > 1) {
    this._renderer = Omnitone.Omnitone.createHOARenderer(context, {
      ambisonicOrder: this._ambisonicOrder,
    });
  }

  // These nodes are created in order to safely asynchronously load Omnitone
  // while the rest of the scene is being created.
  this.input = context.createGain();
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();

  // Initialize Omnitone (async) and connect to audio graph when complete.
  let that = this;
  this._renderer.initialize().then(function() {
    // Connect pre-rotated soundfield to renderer.
    that.input.connect(that._renderer.input);

    // Connect rotated soundfield to ambisonic output.
    if (that._ambisonicOrder > 1) {
      that._renderer._hoaRotator.output.connect(that.ambisonicOutput);
    } else {
      that._renderer._foaRotator.output.connect(that.ambisonicOutput);
    }

    // Connect binaurally-rendered soundfield to binaural output.
    that._renderer.output.connect(that.output);
  });

  // Set orientation and update rotation matrix accordingly.
  this.setOrientation(options.forward[0], options.forward[1],
    options.forward[2], options.up[0], options.up[1], options.up[2]);
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Listener.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
  upX, upY, upZ) {
  let right = Utils.crossProduct([forwardX, forwardY, forwardZ],
    [upX, upY, upZ]);
  this._tempMatrix3[0] = right[0];
  this._tempMatrix3[1] = right[1];
  this._tempMatrix3[2] = right[2];
  this._tempMatrix3[3] = upX;
  this._tempMatrix3[4] = upY;
  this._tempMatrix3[5] = upZ;
  this._tempMatrix3[6] = forwardX;
  this._tempMatrix3[7] = forwardY;
  this._tempMatrix3[8] = forwardZ;
  this._renderer.setRotationMatrix3(this._tempMatrix3);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix4
 * The Three.js Matrix4 object representing the listener's world transform.
 */
Listener.prototype.setFromMatrix = function(matrix4) {
  // Update ambisonic rotation matrix internally.
  this._renderer.setRotationMatrix4(matrix4.elements);

  // Extract position from matrix.
  this.position[0] = matrix4.elements[12];
  this.position[1] = matrix4.elements[13];
  this.position[2] = matrix4.elements[14];
};


module.exports = Listener;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Pre-computed lookup tables for encoding ambisonic sources.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * Pre-computed Spherical Harmonics Coefficients.
 *
 * This function generates an efficient lookup table of SH coefficients. It
 * exploits the way SHs are generated (i.e. Ylm = Nlm * Plm * Em). Since Nlm
 * & Plm coefficients only depend on theta, and Em only depends on phi, we
 * can separate the equation along these lines. Em does not depend on
 * degree, so we only need to compute (2 * l) per azimuth Em total and
 * Nlm * Plm is symmetrical across indexes, so only positive indexes are
 * computed ((l + 1) * (l + 2) / 2 - 1) per elevation.
 * @type {Float32Array}
 */
exports.SPHERICAL_HARMONICS =
[
  [
    [0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000],
    [0.052336, 0.034899, 0.017452, 0.999848, 0.999391, 0.998630],
    [0.104528, 0.069756, 0.034899, 0.999391, 0.997564, 0.994522],
    [0.156434, 0.104528, 0.052336, 0.998630, 0.994522, 0.987688],
    [0.207912, 0.139173, 0.069756, 0.997564, 0.990268, 0.978148],
    [0.258819, 0.173648, 0.087156, 0.996195, 0.984808, 0.965926],
    [0.309017, 0.207912, 0.104528, 0.994522, 0.978148, 0.951057],
    [0.358368, 0.241922, 0.121869, 0.992546, 0.970296, 0.933580],
    [0.406737, 0.275637, 0.139173, 0.990268, 0.961262, 0.913545],
    [0.453990, 0.309017, 0.156434, 0.987688, 0.951057, 0.891007],
    [0.500000, 0.342020, 0.173648, 0.984808, 0.939693, 0.866025],
    [0.544639, 0.374607, 0.190809, 0.981627, 0.927184, 0.838671],
    [0.587785, 0.406737, 0.207912, 0.978148, 0.913545, 0.809017],
    [0.629320, 0.438371, 0.224951, 0.974370, 0.898794, 0.777146],
    [0.669131, 0.469472, 0.241922, 0.970296, 0.882948, 0.743145],
    [0.707107, 0.500000, 0.258819, 0.965926, 0.866025, 0.707107],
    [0.743145, 0.529919, 0.275637, 0.961262, 0.848048, 0.669131],
    [0.777146, 0.559193, 0.292372, 0.956305, 0.829038, 0.629320],
    [0.809017, 0.587785, 0.309017, 0.951057, 0.809017, 0.587785],
    [0.838671, 0.615661, 0.325568, 0.945519, 0.788011, 0.544639],
    [0.866025, 0.642788, 0.342020, 0.939693, 0.766044, 0.500000],
    [0.891007, 0.669131, 0.358368, 0.933580, 0.743145, 0.453990],
    [0.913545, 0.694658, 0.374607, 0.927184, 0.719340, 0.406737],
    [0.933580, 0.719340, 0.390731, 0.920505, 0.694658, 0.358368],
    [0.951057, 0.743145, 0.406737, 0.913545, 0.669131, 0.309017],
    [0.965926, 0.766044, 0.422618, 0.906308, 0.642788, 0.258819],
    [0.978148, 0.788011, 0.438371, 0.898794, 0.615661, 0.207912],
    [0.987688, 0.809017, 0.453990, 0.891007, 0.587785, 0.156434],
    [0.994522, 0.829038, 0.469472, 0.882948, 0.559193, 0.104528],
    [0.998630, 0.848048, 0.484810, 0.874620, 0.529919, 0.052336],
    [1.000000, 0.866025, 0.500000, 0.866025, 0.500000, 0.000000],
    [0.998630, 0.882948, 0.515038, 0.857167, 0.469472, -0.052336],
    [0.994522, 0.898794, 0.529919, 0.848048, 0.438371, -0.104528],
    [0.987688, 0.913545, 0.544639, 0.838671, 0.406737, -0.156434],
    [0.978148, 0.927184, 0.559193, 0.829038, 0.374607, -0.207912],
    [0.965926, 0.939693, 0.573576, 0.819152, 0.342020, -0.258819],
    [0.951057, 0.951057, 0.587785, 0.809017, 0.309017, -0.309017],
    [0.933580, 0.961262, 0.601815, 0.798636, 0.275637, -0.358368],
    [0.913545, 0.970296, 0.615661, 0.788011, 0.241922, -0.406737],
    [0.891007, 0.978148, 0.629320, 0.777146, 0.207912, -0.453990],
    [0.866025, 0.984808, 0.642788, 0.766044, 0.173648, -0.500000],
    [0.838671, 0.990268, 0.656059, 0.754710, 0.139173, -0.544639],
    [0.809017, 0.994522, 0.669131, 0.743145, 0.104528, -0.587785],
    [0.777146, 0.997564, 0.681998, 0.731354, 0.069756, -0.629320],
    [0.743145, 0.999391, 0.694658, 0.719340, 0.034899, -0.669131],
    [0.707107, 1.000000, 0.707107, 0.707107, 0.000000, -0.707107],
    [0.669131, 0.999391, 0.719340, 0.694658, -0.034899, -0.743145],
    [0.629320, 0.997564, 0.731354, 0.681998, -0.069756, -0.777146],
    [0.587785, 0.994522, 0.743145, 0.669131, -0.104528, -0.809017],
    [0.544639, 0.990268, 0.754710, 0.656059, -0.139173, -0.838671],
    [0.500000, 0.984808, 0.766044, 0.642788, -0.173648, -0.866025],
    [0.453990, 0.978148, 0.777146, 0.629320, -0.207912, -0.891007],
    [0.406737, 0.970296, 0.788011, 0.615661, -0.241922, -0.913545],
    [0.358368, 0.961262, 0.798636, 0.601815, -0.275637, -0.933580],
    [0.309017, 0.951057, 0.809017, 0.587785, -0.309017, -0.951057],
    [0.258819, 0.939693, 0.819152, 0.573576, -0.342020, -0.965926],
    [0.207912, 0.927184, 0.829038, 0.559193, -0.374607, -0.978148],
    [0.156434, 0.913545, 0.838671, 0.544639, -0.406737, -0.987688],
    [0.104528, 0.898794, 0.848048, 0.529919, -0.438371, -0.994522],
    [0.052336, 0.882948, 0.857167, 0.515038, -0.469472, -0.998630],
    [0.000000, 0.866025, 0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, 0.848048, 0.874620, 0.484810, -0.529919, -0.998630],
    [-0.104528, 0.829038, 0.882948, 0.469472, -0.559193, -0.994522],
    [-0.156434, 0.809017, 0.891007, 0.453990, -0.587785, -0.987688],
    [-0.207912, 0.788011, 0.898794, 0.438371, -0.615661, -0.978148],
    [-0.258819, 0.766044, 0.906308, 0.422618, -0.642788, -0.965926],
    [-0.309017, 0.743145, 0.913545, 0.406737, -0.669131, -0.951057],
    [-0.358368, 0.719340, 0.920505, 0.390731, -0.694658, -0.933580],
    [-0.406737, 0.694658, 0.927184, 0.374607, -0.719340, -0.913545],
    [-0.453990, 0.669131, 0.933580, 0.358368, -0.743145, -0.891007],
    [-0.500000, 0.642788, 0.939693, 0.342020, -0.766044, -0.866025],
    [-0.544639, 0.615661, 0.945519, 0.325568, -0.788011, -0.838671],
    [-0.587785, 0.587785, 0.951057, 0.309017, -0.809017, -0.809017],
    [-0.629320, 0.559193, 0.956305, 0.292372, -0.829038, -0.777146],
    [-0.669131, 0.529919, 0.961262, 0.275637, -0.848048, -0.743145],
    [-0.707107, 0.500000, 0.965926, 0.258819, -0.866025, -0.707107],
    [-0.743145, 0.469472, 0.970296, 0.241922, -0.882948, -0.669131],
    [-0.777146, 0.438371, 0.974370, 0.224951, -0.898794, -0.629320],
    [-0.809017, 0.406737, 0.978148, 0.207912, -0.913545, -0.587785],
    [-0.838671, 0.374607, 0.981627, 0.190809, -0.927184, -0.544639],
    [-0.866025, 0.342020, 0.984808, 0.173648, -0.939693, -0.500000],
    [-0.891007, 0.309017, 0.987688, 0.156434, -0.951057, -0.453990],
    [-0.913545, 0.275637, 0.990268, 0.139173, -0.961262, -0.406737],
    [-0.933580, 0.241922, 0.992546, 0.121869, -0.970296, -0.358368],
    [-0.951057, 0.207912, 0.994522, 0.104528, -0.978148, -0.309017],
    [-0.965926, 0.173648, 0.996195, 0.087156, -0.984808, -0.258819],
    [-0.978148, 0.139173, 0.997564, 0.069756, -0.990268, -0.207912],
    [-0.987688, 0.104528, 0.998630, 0.052336, -0.994522, -0.156434],
    [-0.994522, 0.069756, 0.999391, 0.034899, -0.997564, -0.104528],
    [-0.998630, 0.034899, 0.999848, 0.017452, -0.999391, -0.052336],
    [-1.000000, 0.000000, 1.000000, 0.000000, -1.000000, -0.000000],
    [-0.998630, -0.034899, 0.999848, -0.017452, -0.999391, 0.052336],
    [-0.994522, -0.069756, 0.999391, -0.034899, -0.997564, 0.104528],
    [-0.987688, -0.104528, 0.998630, -0.052336, -0.994522, 0.156434],
    [-0.978148, -0.139173, 0.997564, -0.069756, -0.990268, 0.207912],
    [-0.965926, -0.173648, 0.996195, -0.087156, -0.984808, 0.258819],
    [-0.951057, -0.207912, 0.994522, -0.104528, -0.978148, 0.309017],
    [-0.933580, -0.241922, 0.992546, -0.121869, -0.970296, 0.358368],
    [-0.913545, -0.275637, 0.990268, -0.139173, -0.961262, 0.406737],
    [-0.891007, -0.309017, 0.987688, -0.156434, -0.951057, 0.453990],
    [-0.866025, -0.342020, 0.984808, -0.173648, -0.939693, 0.500000],
    [-0.838671, -0.374607, 0.981627, -0.190809, -0.927184, 0.544639],
    [-0.809017, -0.406737, 0.978148, -0.207912, -0.913545, 0.587785],
    [-0.777146, -0.438371, 0.974370, -0.224951, -0.898794, 0.629320],
    [-0.743145, -0.469472, 0.970296, -0.241922, -0.882948, 0.669131],
    [-0.707107, -0.500000, 0.965926, -0.258819, -0.866025, 0.707107],
    [-0.669131, -0.529919, 0.961262, -0.275637, -0.848048, 0.743145],
    [-0.629320, -0.559193, 0.956305, -0.292372, -0.829038, 0.777146],
    [-0.587785, -0.587785, 0.951057, -0.309017, -0.809017, 0.809017],
    [-0.544639, -0.615661, 0.945519, -0.325568, -0.788011, 0.838671],
    [-0.500000, -0.642788, 0.939693, -0.342020, -0.766044, 0.866025],
    [-0.453990, -0.669131, 0.933580, -0.358368, -0.743145, 0.891007],
    [-0.406737, -0.694658, 0.927184, -0.374607, -0.719340, 0.913545],
    [-0.358368, -0.719340, 0.920505, -0.390731, -0.694658, 0.933580],
    [-0.309017, -0.743145, 0.913545, -0.406737, -0.669131, 0.951057],
    [-0.258819, -0.766044, 0.906308, -0.422618, -0.642788, 0.965926],
    [-0.207912, -0.788011, 0.898794, -0.438371, -0.615661, 0.978148],
    [-0.156434, -0.809017, 0.891007, -0.453990, -0.587785, 0.987688],
    [-0.104528, -0.829038, 0.882948, -0.469472, -0.559193, 0.994522],
    [-0.052336, -0.848048, 0.874620, -0.484810, -0.529919, 0.998630],
    [-0.000000, -0.866025, 0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, -0.882948, 0.857167, -0.515038, -0.469472, 0.998630],
    [0.104528, -0.898794, 0.848048, -0.529919, -0.438371, 0.994522],
    [0.156434, -0.913545, 0.838671, -0.544639, -0.406737, 0.987688],
    [0.207912, -0.927184, 0.829038, -0.559193, -0.374607, 0.978148],
    [0.258819, -0.939693, 0.819152, -0.573576, -0.342020, 0.965926],
    [0.309017, -0.951057, 0.809017, -0.587785, -0.309017, 0.951057],
    [0.358368, -0.961262, 0.798636, -0.601815, -0.275637, 0.933580],
    [0.406737, -0.970296, 0.788011, -0.615661, -0.241922, 0.913545],
    [0.453990, -0.978148, 0.777146, -0.629320, -0.207912, 0.891007],
    [0.500000, -0.984808, 0.766044, -0.642788, -0.173648, 0.866025],
    [0.544639, -0.990268, 0.754710, -0.656059, -0.139173, 0.838671],
    [0.587785, -0.994522, 0.743145, -0.669131, -0.104528, 0.809017],
    [0.629320, -0.997564, 0.731354, -0.681998, -0.069756, 0.777146],
    [0.669131, -0.999391, 0.719340, -0.694658, -0.034899, 0.743145],
    [0.707107, -1.000000, 0.707107, -0.707107, -0.000000, 0.707107],
    [0.743145, -0.999391, 0.694658, -0.719340, 0.034899, 0.669131],
    [0.777146, -0.997564, 0.681998, -0.731354, 0.069756, 0.629320],
    [0.809017, -0.994522, 0.669131, -0.743145, 0.104528, 0.587785],
    [0.838671, -0.990268, 0.656059, -0.754710, 0.139173, 0.544639],
    [0.866025, -0.984808, 0.642788, -0.766044, 0.173648, 0.500000],
    [0.891007, -0.978148, 0.629320, -0.777146, 0.207912, 0.453990],
    [0.913545, -0.970296, 0.615661, -0.788011, 0.241922, 0.406737],
    [0.933580, -0.961262, 0.601815, -0.798636, 0.275637, 0.358368],
    [0.951057, -0.951057, 0.587785, -0.809017, 0.309017, 0.309017],
    [0.965926, -0.939693, 0.573576, -0.819152, 0.342020, 0.258819],
    [0.978148, -0.927184, 0.559193, -0.829038, 0.374607, 0.207912],
    [0.987688, -0.913545, 0.544639, -0.838671, 0.406737, 0.156434],
    [0.994522, -0.898794, 0.529919, -0.848048, 0.438371, 0.104528],
    [0.998630, -0.882948, 0.515038, -0.857167, 0.469472, 0.052336],
    [1.000000, -0.866025, 0.500000, -0.866025, 0.500000, 0.000000],
    [0.998630, -0.848048, 0.484810, -0.874620, 0.529919, -0.052336],
    [0.994522, -0.829038, 0.469472, -0.882948, 0.559193, -0.104528],
    [0.987688, -0.809017, 0.453990, -0.891007, 0.587785, -0.156434],
    [0.978148, -0.788011, 0.438371, -0.898794, 0.615661, -0.207912],
    [0.965926, -0.766044, 0.422618, -0.906308, 0.642788, -0.258819],
    [0.951057, -0.743145, 0.406737, -0.913545, 0.669131, -0.309017],
    [0.933580, -0.719340, 0.390731, -0.920505, 0.694658, -0.358368],
    [0.913545, -0.694658, 0.374607, -0.927184, 0.719340, -0.406737],
    [0.891007, -0.669131, 0.358368, -0.933580, 0.743145, -0.453990],
    [0.866025, -0.642788, 0.342020, -0.939693, 0.766044, -0.500000],
    [0.838671, -0.615661, 0.325568, -0.945519, 0.788011, -0.544639],
    [0.809017, -0.587785, 0.309017, -0.951057, 0.809017, -0.587785],
    [0.777146, -0.559193, 0.292372, -0.956305, 0.829038, -0.629320],
    [0.743145, -0.529919, 0.275637, -0.961262, 0.848048, -0.669131],
    [0.707107, -0.500000, 0.258819, -0.965926, 0.866025, -0.707107],
    [0.669131, -0.469472, 0.241922, -0.970296, 0.882948, -0.743145],
    [0.629320, -0.438371, 0.224951, -0.974370, 0.898794, -0.777146],
    [0.587785, -0.406737, 0.207912, -0.978148, 0.913545, -0.809017],
    [0.544639, -0.374607, 0.190809, -0.981627, 0.927184, -0.838671],
    [0.500000, -0.342020, 0.173648, -0.984808, 0.939693, -0.866025],
    [0.453990, -0.309017, 0.156434, -0.987688, 0.951057, -0.891007],
    [0.406737, -0.275637, 0.139173, -0.990268, 0.961262, -0.913545],
    [0.358368, -0.241922, 0.121869, -0.992546, 0.970296, -0.933580],
    [0.309017, -0.207912, 0.104528, -0.994522, 0.978148, -0.951057],
    [0.258819, -0.173648, 0.087156, -0.996195, 0.984808, -0.965926],
    [0.207912, -0.139173, 0.069756, -0.997564, 0.990268, -0.978148],
    [0.156434, -0.104528, 0.052336, -0.998630, 0.994522, -0.987688],
    [0.104528, -0.069756, 0.034899, -0.999391, 0.997564, -0.994522],
    [0.052336, -0.034899, 0.017452, -0.999848, 0.999391, -0.998630],
    [0.000000, -0.000000, 0.000000, -1.000000, 1.000000, -1.000000],
    [-0.052336, 0.034899, -0.017452, -0.999848, 0.999391, -0.998630],
    [-0.104528, 0.069756, -0.034899, -0.999391, 0.997564, -0.994522],
    [-0.156434, 0.104528, -0.052336, -0.998630, 0.994522, -0.987688],
    [-0.207912, 0.139173, -0.069756, -0.997564, 0.990268, -0.978148],
    [-0.258819, 0.173648, -0.087156, -0.996195, 0.984808, -0.965926],
    [-0.309017, 0.207912, -0.104528, -0.994522, 0.978148, -0.951057],
    [-0.358368, 0.241922, -0.121869, -0.992546, 0.970296, -0.933580],
    [-0.406737, 0.275637, -0.139173, -0.990268, 0.961262, -0.913545],
    [-0.453990, 0.309017, -0.156434, -0.987688, 0.951057, -0.891007],
    [-0.500000, 0.342020, -0.173648, -0.984808, 0.939693, -0.866025],
    [-0.544639, 0.374607, -0.190809, -0.981627, 0.927184, -0.838671],
    [-0.587785, 0.406737, -0.207912, -0.978148, 0.913545, -0.809017],
    [-0.629320, 0.438371, -0.224951, -0.974370, 0.898794, -0.777146],
    [-0.669131, 0.469472, -0.241922, -0.970296, 0.882948, -0.743145],
    [-0.707107, 0.500000, -0.258819, -0.965926, 0.866025, -0.707107],
    [-0.743145, 0.529919, -0.275637, -0.961262, 0.848048, -0.669131],
    [-0.777146, 0.559193, -0.292372, -0.956305, 0.829038, -0.629320],
    [-0.809017, 0.587785, -0.309017, -0.951057, 0.809017, -0.587785],
    [-0.838671, 0.615661, -0.325568, -0.945519, 0.788011, -0.544639],
    [-0.866025, 0.642788, -0.342020, -0.939693, 0.766044, -0.500000],
    [-0.891007, 0.669131, -0.358368, -0.933580, 0.743145, -0.453990],
    [-0.913545, 0.694658, -0.374607, -0.927184, 0.719340, -0.406737],
    [-0.933580, 0.719340, -0.390731, -0.920505, 0.694658, -0.358368],
    [-0.951057, 0.743145, -0.406737, -0.913545, 0.669131, -0.309017],
    [-0.965926, 0.766044, -0.422618, -0.906308, 0.642788, -0.258819],
    [-0.978148, 0.788011, -0.438371, -0.898794, 0.615661, -0.207912],
    [-0.987688, 0.809017, -0.453990, -0.891007, 0.587785, -0.156434],
    [-0.994522, 0.829038, -0.469472, -0.882948, 0.559193, -0.104528],
    [-0.998630, 0.848048, -0.484810, -0.874620, 0.529919, -0.052336],
    [-1.000000, 0.866025, -0.500000, -0.866025, 0.500000, 0.000000],
    [-0.998630, 0.882948, -0.515038, -0.857167, 0.469472, 0.052336],
    [-0.994522, 0.898794, -0.529919, -0.848048, 0.438371, 0.104528],
    [-0.987688, 0.913545, -0.544639, -0.838671, 0.406737, 0.156434],
    [-0.978148, 0.927184, -0.559193, -0.829038, 0.374607, 0.207912],
    [-0.965926, 0.939693, -0.573576, -0.819152, 0.342020, 0.258819],
    [-0.951057, 0.951057, -0.587785, -0.809017, 0.309017, 0.309017],
    [-0.933580, 0.961262, -0.601815, -0.798636, 0.275637, 0.358368],
    [-0.913545, 0.970296, -0.615661, -0.788011, 0.241922, 0.406737],
    [-0.891007, 0.978148, -0.629320, -0.777146, 0.207912, 0.453990],
    [-0.866025, 0.984808, -0.642788, -0.766044, 0.173648, 0.500000],
    [-0.838671, 0.990268, -0.656059, -0.754710, 0.139173, 0.544639],
    [-0.809017, 0.994522, -0.669131, -0.743145, 0.104528, 0.587785],
    [-0.777146, 0.997564, -0.681998, -0.731354, 0.069756, 0.629320],
    [-0.743145, 0.999391, -0.694658, -0.719340, 0.034899, 0.669131],
    [-0.707107, 1.000000, -0.707107, -0.707107, 0.000000, 0.707107],
    [-0.669131, 0.999391, -0.719340, -0.694658, -0.034899, 0.743145],
    [-0.629320, 0.997564, -0.731354, -0.681998, -0.069756, 0.777146],
    [-0.587785, 0.994522, -0.743145, -0.669131, -0.104528, 0.809017],
    [-0.544639, 0.990268, -0.754710, -0.656059, -0.139173, 0.838671],
    [-0.500000, 0.984808, -0.766044, -0.642788, -0.173648, 0.866025],
    [-0.453990, 0.978148, -0.777146, -0.629320, -0.207912, 0.891007],
    [-0.406737, 0.970296, -0.788011, -0.615661, -0.241922, 0.913545],
    [-0.358368, 0.961262, -0.798636, -0.601815, -0.275637, 0.933580],
    [-0.309017, 0.951057, -0.809017, -0.587785, -0.309017, 0.951057],
    [-0.258819, 0.939693, -0.819152, -0.573576, -0.342020, 0.965926],
    [-0.207912, 0.927184, -0.829038, -0.559193, -0.374607, 0.978148],
    [-0.156434, 0.913545, -0.838671, -0.544639, -0.406737, 0.987688],
    [-0.104528, 0.898794, -0.848048, -0.529919, -0.438371, 0.994522],
    [-0.052336, 0.882948, -0.857167, -0.515038, -0.469472, 0.998630],
    [-0.000000, 0.866025, -0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, 0.848048, -0.874620, -0.484810, -0.529919, 0.998630],
    [0.104528, 0.829038, -0.882948, -0.469472, -0.559193, 0.994522],
    [0.156434, 0.809017, -0.891007, -0.453990, -0.587785, 0.987688],
    [0.207912, 0.788011, -0.898794, -0.438371, -0.615661, 0.978148],
    [0.258819, 0.766044, -0.906308, -0.422618, -0.642788, 0.965926],
    [0.309017, 0.743145, -0.913545, -0.406737, -0.669131, 0.951057],
    [0.358368, 0.719340, -0.920505, -0.390731, -0.694658, 0.933580],
    [0.406737, 0.694658, -0.927184, -0.374607, -0.719340, 0.913545],
    [0.453990, 0.669131, -0.933580, -0.358368, -0.743145, 0.891007],
    [0.500000, 0.642788, -0.939693, -0.342020, -0.766044, 0.866025],
    [0.544639, 0.615661, -0.945519, -0.325568, -0.788011, 0.838671],
    [0.587785, 0.587785, -0.951057, -0.309017, -0.809017, 0.809017],
    [0.629320, 0.559193, -0.956305, -0.292372, -0.829038, 0.777146],
    [0.669131, 0.529919, -0.961262, -0.275637, -0.848048, 0.743145],
    [0.707107, 0.500000, -0.965926, -0.258819, -0.866025, 0.707107],
    [0.743145, 0.469472, -0.970296, -0.241922, -0.882948, 0.669131],
    [0.777146, 0.438371, -0.974370, -0.224951, -0.898794, 0.629320],
    [0.809017, 0.406737, -0.978148, -0.207912, -0.913545, 0.587785],
    [0.838671, 0.374607, -0.981627, -0.190809, -0.927184, 0.544639],
    [0.866025, 0.342020, -0.984808, -0.173648, -0.939693, 0.500000],
    [0.891007, 0.309017, -0.987688, -0.156434, -0.951057, 0.453990],
    [0.913545, 0.275637, -0.990268, -0.139173, -0.961262, 0.406737],
    [0.933580, 0.241922, -0.992546, -0.121869, -0.970296, 0.358368],
    [0.951057, 0.207912, -0.994522, -0.104528, -0.978148, 0.309017],
    [0.965926, 0.173648, -0.996195, -0.087156, -0.984808, 0.258819],
    [0.978148, 0.139173, -0.997564, -0.069756, -0.990268, 0.207912],
    [0.987688, 0.104528, -0.998630, -0.052336, -0.994522, 0.156434],
    [0.994522, 0.069756, -0.999391, -0.034899, -0.997564, 0.104528],
    [0.998630, 0.034899, -0.999848, -0.017452, -0.999391, 0.052336],
    [1.000000, 0.000000, -1.000000, -0.000000, -1.000000, 0.000000],
    [0.998630, -0.034899, -0.999848, 0.017452, -0.999391, -0.052336],
    [0.994522, -0.069756, -0.999391, 0.034899, -0.997564, -0.104528],
    [0.987688, -0.104528, -0.998630, 0.052336, -0.994522, -0.156434],
    [0.978148, -0.139173, -0.997564, 0.069756, -0.990268, -0.207912],
    [0.965926, -0.173648, -0.996195, 0.087156, -0.984808, -0.258819],
    [0.951057, -0.207912, -0.994522, 0.104528, -0.978148, -0.309017],
    [0.933580, -0.241922, -0.992546, 0.121869, -0.970296, -0.358368],
    [0.913545, -0.275637, -0.990268, 0.139173, -0.961262, -0.406737],
    [0.891007, -0.309017, -0.987688, 0.156434, -0.951057, -0.453990],
    [0.866025, -0.342020, -0.984808, 0.173648, -0.939693, -0.500000],
    [0.838671, -0.374607, -0.981627, 0.190809, -0.927184, -0.544639],
    [0.809017, -0.406737, -0.978148, 0.207912, -0.913545, -0.587785],
    [0.777146, -0.438371, -0.974370, 0.224951, -0.898794, -0.629320],
    [0.743145, -0.469472, -0.970296, 0.241922, -0.882948, -0.669131],
    [0.707107, -0.500000, -0.965926, 0.258819, -0.866025, -0.707107],
    [0.669131, -0.529919, -0.961262, 0.275637, -0.848048, -0.743145],
    [0.629320, -0.559193, -0.956305, 0.292372, -0.829038, -0.777146],
    [0.587785, -0.587785, -0.951057, 0.309017, -0.809017, -0.809017],
    [0.544639, -0.615661, -0.945519, 0.325568, -0.788011, -0.838671],
    [0.500000, -0.642788, -0.939693, 0.342020, -0.766044, -0.866025],
    [0.453990, -0.669131, -0.933580, 0.358368, -0.743145, -0.891007],
    [0.406737, -0.694658, -0.927184, 0.374607, -0.719340, -0.913545],
    [0.358368, -0.719340, -0.920505, 0.390731, -0.694658, -0.933580],
    [0.309017, -0.743145, -0.913545, 0.406737, -0.669131, -0.951057],
    [0.258819, -0.766044, -0.906308, 0.422618, -0.642788, -0.965926],
    [0.207912, -0.788011, -0.898794, 0.438371, -0.615661, -0.978148],
    [0.156434, -0.809017, -0.891007, 0.453990, -0.587785, -0.987688],
    [0.104528, -0.829038, -0.882948, 0.469472, -0.559193, -0.994522],
    [0.052336, -0.848048, -0.874620, 0.484810, -0.529919, -0.998630],
    [0.000000, -0.866025, -0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, -0.882948, -0.857167, 0.515038, -0.469472, -0.998630],
    [-0.104528, -0.898794, -0.848048, 0.529919, -0.438371, -0.994522],
    [-0.156434, -0.913545, -0.838671, 0.544639, -0.406737, -0.987688],
    [-0.207912, -0.927184, -0.829038, 0.559193, -0.374607, -0.978148],
    [-0.258819, -0.939693, -0.819152, 0.573576, -0.342020, -0.965926],
    [-0.309017, -0.951057, -0.809017, 0.587785, -0.309017, -0.951057],
    [-0.358368, -0.961262, -0.798636, 0.601815, -0.275637, -0.933580],
    [-0.406737, -0.970296, -0.788011, 0.615661, -0.241922, -0.913545],
    [-0.453990, -0.978148, -0.777146, 0.629320, -0.207912, -0.891007],
    [-0.500000, -0.984808, -0.766044, 0.642788, -0.173648, -0.866025],
    [-0.544639, -0.990268, -0.754710, 0.656059, -0.139173, -0.838671],
    [-0.587785, -0.994522, -0.743145, 0.669131, -0.104528, -0.809017],
    [-0.629320, -0.997564, -0.731354, 0.681998, -0.069756, -0.777146],
    [-0.669131, -0.999391, -0.719340, 0.694658, -0.034899, -0.743145],
    [-0.707107, -1.000000, -0.707107, 0.707107, -0.000000, -0.707107],
    [-0.743145, -0.999391, -0.694658, 0.719340, 0.034899, -0.669131],
    [-0.777146, -0.997564, -0.681998, 0.731354, 0.069756, -0.629320],
    [-0.809017, -0.994522, -0.669131, 0.743145, 0.104528, -0.587785],
    [-0.838671, -0.990268, -0.656059, 0.754710, 0.139173, -0.544639],
    [-0.866025, -0.984808, -0.642788, 0.766044, 0.173648, -0.500000],
    [-0.891007, -0.978148, -0.629320, 0.777146, 0.207912, -0.453990],
    [-0.913545, -0.970296, -0.615661, 0.788011, 0.241922, -0.406737],
    [-0.933580, -0.961262, -0.601815, 0.798636, 0.275637, -0.358368],
    [-0.951057, -0.951057, -0.587785, 0.809017, 0.309017, -0.309017],
    [-0.965926, -0.939693, -0.573576, 0.819152, 0.342020, -0.258819],
    [-0.978148, -0.927184, -0.559193, 0.829038, 0.374607, -0.207912],
    [-0.987688, -0.913545, -0.544639, 0.838671, 0.406737, -0.156434],
    [-0.994522, -0.898794, -0.529919, 0.848048, 0.438371, -0.104528],
    [-0.998630, -0.882948, -0.515038, 0.857167, 0.469472, -0.052336],
    [-1.000000, -0.866025, -0.500000, 0.866025, 0.500000, -0.000000],
    [-0.998630, -0.848048, -0.484810, 0.874620, 0.529919, 0.052336],
    [-0.994522, -0.829038, -0.469472, 0.882948, 0.559193, 0.104528],
    [-0.987688, -0.809017, -0.453990, 0.891007, 0.587785, 0.156434],
    [-0.978148, -0.788011, -0.438371, 0.898794, 0.615661, 0.207912],
    [-0.965926, -0.766044, -0.422618, 0.906308, 0.642788, 0.258819],
    [-0.951057, -0.743145, -0.406737, 0.913545, 0.669131, 0.309017],
    [-0.933580, -0.719340, -0.390731, 0.920505, 0.694658, 0.358368],
    [-0.913545, -0.694658, -0.374607, 0.927184, 0.719340, 0.406737],
    [-0.891007, -0.669131, -0.358368, 0.933580, 0.743145, 0.453990],
    [-0.866025, -0.642788, -0.342020, 0.939693, 0.766044, 0.500000],
    [-0.838671, -0.615661, -0.325568, 0.945519, 0.788011, 0.544639],
    [-0.809017, -0.587785, -0.309017, 0.951057, 0.809017, 0.587785],
    [-0.777146, -0.559193, -0.292372, 0.956305, 0.829038, 0.629320],
    [-0.743145, -0.529919, -0.275637, 0.961262, 0.848048, 0.669131],
    [-0.707107, -0.500000, -0.258819, 0.965926, 0.866025, 0.707107],
    [-0.669131, -0.469472, -0.241922, 0.970296, 0.882948, 0.743145],
    [-0.629320, -0.438371, -0.224951, 0.974370, 0.898794, 0.777146],
    [-0.587785, -0.406737, -0.207912, 0.978148, 0.913545, 0.809017],
    [-0.544639, -0.374607, -0.190809, 0.981627, 0.927184, 0.838671],
    [-0.500000, -0.342020, -0.173648, 0.984808, 0.939693, 0.866025],
    [-0.453990, -0.309017, -0.156434, 0.987688, 0.951057, 0.891007],
    [-0.406737, -0.275637, -0.139173, 0.990268, 0.961262, 0.913545],
    [-0.358368, -0.241922, -0.121869, 0.992546, 0.970296, 0.933580],
    [-0.309017, -0.207912, -0.104528, 0.994522, 0.978148, 0.951057],
    [-0.258819, -0.173648, -0.087156, 0.996195, 0.984808, 0.965926],
    [-0.207912, -0.139173, -0.069756, 0.997564, 0.990268, 0.978148],
    [-0.156434, -0.104528, -0.052336, 0.998630, 0.994522, 0.987688],
    [-0.104528, -0.069756, -0.034899, 0.999391, 0.997564, 0.994522],
    [-0.052336, -0.034899, -0.017452, 0.999848, 0.999391, 0.998630],
  ],
  [
    [-1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     -1.000000, -0.000000, 0.000000, -0.000000],
    [-0.999848, 0.017452, 0.999543, -0.030224, 0.000264,
     -0.999086, 0.042733, -0.000590, 0.000004],
    [-0.999391, 0.034899, 0.998173, -0.060411, 0.001055,
     -0.996348, 0.085356, -0.002357, 0.000034],
    [-0.998630, 0.052336, 0.995891, -0.090524, 0.002372,
     -0.991791, 0.127757, -0.005297, 0.000113],
    [-0.997564, 0.069756, 0.992701, -0.120527, 0.004214,
     -0.985429, 0.169828, -0.009400, 0.000268],
    [-0.996195, 0.087156, 0.988606, -0.150384, 0.006578,
     -0.977277, 0.211460, -0.014654, 0.000523],
    [-0.994522, 0.104528, 0.983611, -0.180057, 0.009462,
     -0.967356, 0.252544, -0.021043, 0.000903],
    [-0.992546, 0.121869, 0.977722, -0.209511, 0.012862,
     -0.955693, 0.292976, -0.028547, 0.001431],
    [-0.990268, 0.139173, 0.970946, -0.238709, 0.016774,
     -0.942316, 0.332649, -0.037143, 0.002131],
    [-0.987688, 0.156434, 0.963292, -0.267617, 0.021193,
     -0.927262, 0.371463, -0.046806, 0.003026],
    [-0.984808, 0.173648, 0.954769, -0.296198, 0.026114,
     -0.910569, 0.409317, -0.057505, 0.004140],
    [-0.981627, 0.190809, 0.945388, -0.324419, 0.031530,
     -0.892279, 0.446114, -0.069209, 0.005492],
    [-0.978148, 0.207912, 0.935159, -0.352244, 0.037436,
     -0.872441, 0.481759, -0.081880, 0.007105],
    [-0.974370, 0.224951, 0.924096, -0.379641, 0.043823,
     -0.851105, 0.516162, -0.095481, 0.008999],
    [-0.970296, 0.241922, 0.912211, -0.406574, 0.050685,
     -0.828326, 0.549233, -0.109969, 0.011193],
    [-0.965926, 0.258819, 0.899519, -0.433013, 0.058013,
     -0.804164, 0.580889, -0.125300, 0.013707],
    [-0.961262, 0.275637, 0.886036, -0.458924, 0.065797,
     -0.778680, 0.611050, -0.141427, 0.016556],
    [-0.956305, 0.292372, 0.871778, -0.484275, 0.074029,
     -0.751940, 0.639639, -0.158301, 0.019758],
    [-0.951057, 0.309017, 0.856763, -0.509037, 0.082698,
     -0.724012, 0.666583, -0.175868, 0.023329],
    [-0.945519, 0.325568, 0.841008, -0.533178, 0.091794,
     -0.694969, 0.691816, -0.194075, 0.027281],
    [-0.939693, 0.342020, 0.824533, -0.556670, 0.101306,
     -0.664885, 0.715274, -0.212865, 0.031630],
    [-0.933580, 0.358368, 0.807359, -0.579484, 0.111222,
     -0.633837, 0.736898, -0.232180, 0.036385],
    [-0.927184, 0.374607, 0.789505, -0.601592, 0.121529,
     -0.601904, 0.756637, -0.251960, 0.041559],
    [-0.920505, 0.390731, 0.770994, -0.622967, 0.132217,
     -0.569169, 0.774442, -0.272143, 0.047160],
    [-0.913545, 0.406737, 0.751848, -0.643582, 0.143271,
     -0.535715, 0.790270, -0.292666, 0.053196],
    [-0.906308, 0.422618, 0.732091, -0.663414, 0.154678,
     -0.501627, 0.804083, -0.313464, 0.059674],
    [-0.898794, 0.438371, 0.711746, -0.682437, 0.166423,
     -0.466993, 0.815850, -0.334472, 0.066599],
    [-0.891007, 0.453990, 0.690839, -0.700629, 0.178494,
     -0.431899, 0.825544, -0.355623, 0.073974],
    [-0.882948, 0.469472, 0.669395, -0.717968, 0.190875,
     -0.396436, 0.833145, -0.376851, 0.081803],
    [-0.874620, 0.484810, 0.647439, -0.734431, 0.203551,
     -0.360692, 0.838638, -0.398086, 0.090085],
    [-0.866025, 0.500000, 0.625000, -0.750000, 0.216506,
     -0.324760, 0.842012, -0.419263, 0.098821],
    [-0.857167, 0.515038, 0.602104, -0.764655, 0.229726,
     -0.288728, 0.843265, -0.440311, 0.108009],
    [-0.848048, 0.529919, 0.578778, -0.778378, 0.243192,
     -0.252688, 0.842399, -0.461164, 0.117644],
    [-0.838671, 0.544639, 0.555052, -0.791154, 0.256891,
     -0.216730, 0.839422, -0.481753, 0.127722],
    [-0.829038, 0.559193, 0.530955, -0.802965, 0.270803,
     -0.180944, 0.834347, -0.502011, 0.138237],
    [-0.819152, 0.573576, 0.506515, -0.813798, 0.284914,
     -0.145420, 0.827194, -0.521871, 0.149181],
    [-0.809017, 0.587785, 0.481763, -0.823639, 0.299204,
     -0.110246, 0.817987, -0.541266, 0.160545],
    [-0.798636, 0.601815, 0.456728, -0.832477, 0.313658,
     -0.075508, 0.806757, -0.560132, 0.172317],
    [-0.788011, 0.615661, 0.431441, -0.840301, 0.328257,
     -0.041294, 0.793541, -0.578405, 0.184487],
    [-0.777146, 0.629320, 0.405934, -0.847101, 0.342984,
     -0.007686, 0.778379, -0.596021, 0.197040],
    [-0.766044, 0.642788, 0.380236, -0.852869, 0.357821,
     0.025233, 0.761319, -0.612921, 0.209963],
    [-0.754710, 0.656059, 0.354380, -0.857597, 0.372749,
     0.057383, 0.742412, -0.629044, 0.223238],
    [-0.743145, 0.669131, 0.328396, -0.861281, 0.387751,
     0.088686, 0.721714, -0.644334, 0.236850],
    [-0.731354, 0.681998, 0.302317, -0.863916, 0.402807,
     0.119068, 0.699288, -0.658734, 0.250778],
    [-0.719340, 0.694658, 0.276175, -0.865498, 0.417901,
     0.148454, 0.675199, -0.672190, 0.265005],
    [-0.707107, 0.707107, 0.250000, -0.866025, 0.433013,
     0.176777, 0.649519, -0.684653, 0.279508],
    [-0.694658, 0.719340, 0.223825, -0.865498, 0.448125,
     0.203969, 0.622322, -0.696073, 0.294267],
    [-0.681998, 0.731354, 0.197683, -0.863916, 0.463218,
     0.229967, 0.593688, -0.706405, 0.309259],
    [-0.669131, 0.743145, 0.171604, -0.861281, 0.478275,
     0.254712, 0.563700, -0.715605, 0.324459],
    [-0.656059, 0.754710, 0.145620, -0.857597, 0.493276,
     0.278147, 0.532443, -0.723633, 0.339844],
    [-0.642788, 0.766044, 0.119764, -0.852869, 0.508205,
     0.300221, 0.500009, -0.730451, 0.355387],
    [-0.629320, 0.777146, 0.094066, -0.847101, 0.523041,
     0.320884, 0.466490, -0.736025, 0.371063],
    [-0.615661, 0.788011, 0.068559, -0.840301, 0.537768,
     0.340093, 0.431982, -0.740324, 0.386845],
    [-0.601815, 0.798636, 0.043272, -0.832477, 0.552367,
     0.357807, 0.396584, -0.743320, 0.402704],
    [-0.587785, 0.809017, 0.018237, -0.823639, 0.566821,
     0.373991, 0.360397, -0.744989, 0.418613],
    [-0.573576, 0.819152, -0.006515, -0.813798, 0.581112,
     0.388612, 0.323524, -0.745308, 0.434544],
    [-0.559193, 0.829038, -0.030955, -0.802965, 0.595222,
     0.401645, 0.286069, -0.744262, 0.450467],
    [-0.544639, 0.838671, -0.055052, -0.791154, 0.609135,
     0.413066, 0.248140, -0.741835, 0.466352],
    [-0.529919, 0.848048, -0.078778, -0.778378, 0.622833,
     0.422856, 0.209843, -0.738017, 0.482171],
    [-0.515038, 0.857167, -0.102104, -0.764655, 0.636300,
     0.431004, 0.171288, -0.732801, 0.497894],
    [-0.500000, 0.866025, -0.125000, -0.750000, 0.649519,
     0.437500, 0.132583, -0.726184, 0.513490],
    [-0.484810, 0.874620, -0.147439, -0.734431, 0.662474,
     0.442340, 0.093837, -0.718167, 0.528929],
    [-0.469472, 0.882948, -0.169395, -0.717968, 0.675150,
     0.445524, 0.055160, -0.708753, 0.544183],
    [-0.453990, 0.891007, -0.190839, -0.700629, 0.687531,
     0.447059, 0.016662, -0.697950, 0.559220],
    [-0.438371, 0.898794, -0.211746, -0.682437, 0.699602,
     0.446953, -0.021550, -0.685769, 0.574011],
    [-0.422618, 0.906308, -0.232091, -0.663414, 0.711348,
     0.445222, -0.059368, -0.672226, 0.588528],
    [-0.406737, 0.913545, -0.251848, -0.643582, 0.722755,
     0.441884, -0.096684, -0.657339, 0.602741],
    [-0.390731, 0.920505, -0.270994, -0.622967, 0.733809,
     0.436964, -0.133395, -0.641130, 0.616621],
    [-0.374607, 0.927184, -0.289505, -0.601592, 0.744496,
     0.430488, -0.169397, -0.623624, 0.630141],
    [-0.358368, 0.933580, -0.307359, -0.579484, 0.754804,
     0.422491, -0.204589, -0.604851, 0.643273],
    [-0.342020, 0.939693, -0.324533, -0.556670, 0.764720,
     0.413008, -0.238872, -0.584843, 0.655990],
    [-0.325568, 0.945519, -0.341008, -0.533178, 0.774231,
     0.402081, -0.272150, -0.563635, 0.668267],
    [-0.309017, 0.951057, -0.356763, -0.509037, 0.783327,
     0.389754, -0.304329, -0.541266, 0.680078],
    [-0.292372, 0.956305, -0.371778, -0.484275, 0.791997,
     0.376077, -0.335319, -0.517778, 0.691399],
    [-0.275637, 0.961262, -0.386036, -0.458924, 0.800228,
     0.361102, -0.365034, -0.493216, 0.702207],
    [-0.258819, 0.965926, -0.399519, -0.433013, 0.808013,
     0.344885, -0.393389, -0.467627, 0.712478],
    [-0.241922, 0.970296, -0.412211, -0.406574, 0.815340,
     0.327486, -0.420306, -0.441061, 0.722191],
    [-0.224951, 0.974370, -0.424096, -0.379641, 0.822202,
     0.308969, -0.445709, -0.413572, 0.731327],
    [-0.207912, 0.978148, -0.435159, -0.352244, 0.828589,
     0.289399, -0.469527, -0.385215, 0.739866],
    [-0.190809, 0.981627, -0.445388, -0.324419, 0.834495,
     0.268846, -0.491693, -0.356047, 0.747790],
    [-0.173648, 0.984808, -0.454769, -0.296198, 0.839912,
     0.247382, -0.512145, -0.326129, 0.755082],
    [-0.156434, 0.987688, -0.463292, -0.267617, 0.844832,
     0.225081, -0.530827, -0.295521, 0.761728],
    [-0.139173, 0.990268, -0.470946, -0.238709, 0.849251,
     0.202020, -0.547684, -0.264287, 0.767712],
    [-0.121869, 0.992546, -0.477722, -0.209511, 0.853163,
     0.178279, -0.562672, -0.232494, 0.773023],
    [-0.104528, 0.994522, -0.483611, -0.180057, 0.856563,
     0.153937, -0.575747, -0.200207, 0.777648],
    [-0.087156, 0.996195, -0.488606, -0.150384, 0.859447,
     0.129078, -0.586872, -0.167494, 0.781579],
    [-0.069756, 0.997564, -0.492701, -0.120527, 0.861811,
     0.103786, -0.596018, -0.134426, 0.784806],
    [-0.052336, 0.998630, -0.495891, -0.090524, 0.863653,
     0.078146, -0.603158, -0.101071, 0.787324],
    [-0.034899, 0.999391, -0.498173, -0.060411, 0.864971,
     0.052243, -0.608272, -0.067500, 0.789126],
    [-0.017452, 0.999848, -0.499543, -0.030224, 0.865762,
     0.026165, -0.611347, -0.033786, 0.790208],
    [0.000000, 1.000000, -0.500000, 0.000000, 0.866025,
     -0.000000, -0.612372, 0.000000, 0.790569],
    [0.017452, 0.999848, -0.499543, 0.030224, 0.865762,
     -0.026165, -0.611347, 0.033786, 0.790208],
    [0.034899, 0.999391, -0.498173, 0.060411, 0.864971,
     -0.052243, -0.608272, 0.067500, 0.789126],
    [0.052336, 0.998630, -0.495891, 0.090524, 0.863653,
     -0.078146, -0.603158, 0.101071, 0.787324],
    [0.069756, 0.997564, -0.492701, 0.120527, 0.861811,
     -0.103786, -0.596018, 0.134426, 0.784806],
    [0.087156, 0.996195, -0.488606, 0.150384, 0.859447,
     -0.129078, -0.586872, 0.167494, 0.781579],
    [0.104528, 0.994522, -0.483611, 0.180057, 0.856563,
     -0.153937, -0.575747, 0.200207, 0.777648],
    [0.121869, 0.992546, -0.477722, 0.209511, 0.853163,
     -0.178279, -0.562672, 0.232494, 0.773023],
    [0.139173, 0.990268, -0.470946, 0.238709, 0.849251,
     -0.202020, -0.547684, 0.264287, 0.767712],
    [0.156434, 0.987688, -0.463292, 0.267617, 0.844832,
     -0.225081, -0.530827, 0.295521, 0.761728],
    [0.173648, 0.984808, -0.454769, 0.296198, 0.839912,
     -0.247382, -0.512145, 0.326129, 0.755082],
    [0.190809, 0.981627, -0.445388, 0.324419, 0.834495,
     -0.268846, -0.491693, 0.356047, 0.747790],
    [0.207912, 0.978148, -0.435159, 0.352244, 0.828589,
     -0.289399, -0.469527, 0.385215, 0.739866],
    [0.224951, 0.974370, -0.424096, 0.379641, 0.822202,
     -0.308969, -0.445709, 0.413572, 0.731327],
    [0.241922, 0.970296, -0.412211, 0.406574, 0.815340,
     -0.327486, -0.420306, 0.441061, 0.722191],
    [0.258819, 0.965926, -0.399519, 0.433013, 0.808013,
     -0.344885, -0.393389, 0.467627, 0.712478],
    [0.275637, 0.961262, -0.386036, 0.458924, 0.800228,
     -0.361102, -0.365034, 0.493216, 0.702207],
    [0.292372, 0.956305, -0.371778, 0.484275, 0.791997,
     -0.376077, -0.335319, 0.517778, 0.691399],
    [0.309017, 0.951057, -0.356763, 0.509037, 0.783327,
     -0.389754, -0.304329, 0.541266, 0.680078],
    [0.325568, 0.945519, -0.341008, 0.533178, 0.774231,
     -0.402081, -0.272150, 0.563635, 0.668267],
    [0.342020, 0.939693, -0.324533, 0.556670, 0.764720,
     -0.413008, -0.238872, 0.584843, 0.655990],
    [0.358368, 0.933580, -0.307359, 0.579484, 0.754804,
     -0.422491, -0.204589, 0.604851, 0.643273],
    [0.374607, 0.927184, -0.289505, 0.601592, 0.744496,
     -0.430488, -0.169397, 0.623624, 0.630141],
    [0.390731, 0.920505, -0.270994, 0.622967, 0.733809,
     -0.436964, -0.133395, 0.641130, 0.616621],
    [0.406737, 0.913545, -0.251848, 0.643582, 0.722755,
     -0.441884, -0.096684, 0.657339, 0.602741],
    [0.422618, 0.906308, -0.232091, 0.663414, 0.711348,
     -0.445222, -0.059368, 0.672226, 0.588528],
    [0.438371, 0.898794, -0.211746, 0.682437, 0.699602,
     -0.446953, -0.021550, 0.685769, 0.574011],
    [0.453990, 0.891007, -0.190839, 0.700629, 0.687531,
     -0.447059, 0.016662, 0.697950, 0.559220],
    [0.469472, 0.882948, -0.169395, 0.717968, 0.675150,
     -0.445524, 0.055160, 0.708753, 0.544183],
    [0.484810, 0.874620, -0.147439, 0.734431, 0.662474,
     -0.442340, 0.093837, 0.718167, 0.528929],
    [0.500000, 0.866025, -0.125000, 0.750000, 0.649519,
     -0.437500, 0.132583, 0.726184, 0.513490],
    [0.515038, 0.857167, -0.102104, 0.764655, 0.636300,
     -0.431004, 0.171288, 0.732801, 0.497894],
    [0.529919, 0.848048, -0.078778, 0.778378, 0.622833,
     -0.422856, 0.209843, 0.738017, 0.482171],
    [0.544639, 0.838671, -0.055052, 0.791154, 0.609135,
     -0.413066, 0.248140, 0.741835, 0.466352],
    [0.559193, 0.829038, -0.030955, 0.802965, 0.595222,
     -0.401645, 0.286069, 0.744262, 0.450467],
    [0.573576, 0.819152, -0.006515, 0.813798, 0.581112,
     -0.388612, 0.323524, 0.745308, 0.434544],
    [0.587785, 0.809017, 0.018237, 0.823639, 0.566821,
     -0.373991, 0.360397, 0.744989, 0.418613],
    [0.601815, 0.798636, 0.043272, 0.832477, 0.552367,
     -0.357807, 0.396584, 0.743320, 0.402704],
    [0.615661, 0.788011, 0.068559, 0.840301, 0.537768,
     -0.340093, 0.431982, 0.740324, 0.386845],
    [0.629320, 0.777146, 0.094066, 0.847101, 0.523041,
     -0.320884, 0.466490, 0.736025, 0.371063],
    [0.642788, 0.766044, 0.119764, 0.852869, 0.508205,
     -0.300221, 0.500009, 0.730451, 0.355387],
    [0.656059, 0.754710, 0.145620, 0.857597, 0.493276,
     -0.278147, 0.532443, 0.723633, 0.339844],
    [0.669131, 0.743145, 0.171604, 0.861281, 0.478275,
     -0.254712, 0.563700, 0.715605, 0.324459],
    [0.681998, 0.731354, 0.197683, 0.863916, 0.463218,
     -0.229967, 0.593688, 0.706405, 0.309259],
    [0.694658, 0.719340, 0.223825, 0.865498, 0.448125,
     -0.203969, 0.622322, 0.696073, 0.294267],
    [0.707107, 0.707107, 0.250000, 0.866025, 0.433013,
     -0.176777, 0.649519, 0.684653, 0.279508],
    [0.719340, 0.694658, 0.276175, 0.865498, 0.417901,
     -0.148454, 0.675199, 0.672190, 0.265005],
    [0.731354, 0.681998, 0.302317, 0.863916, 0.402807,
     -0.119068, 0.699288, 0.658734, 0.250778],
    [0.743145, 0.669131, 0.328396, 0.861281, 0.387751,
     -0.088686, 0.721714, 0.644334, 0.236850],
    [0.754710, 0.656059, 0.354380, 0.857597, 0.372749,
     -0.057383, 0.742412, 0.629044, 0.223238],
    [0.766044, 0.642788, 0.380236, 0.852869, 0.357821,
     -0.025233, 0.761319, 0.612921, 0.209963],
    [0.777146, 0.629320, 0.405934, 0.847101, 0.342984,
     0.007686, 0.778379, 0.596021, 0.197040],
    [0.788011, 0.615661, 0.431441, 0.840301, 0.328257,
     0.041294, 0.793541, 0.578405, 0.184487],
    [0.798636, 0.601815, 0.456728, 0.832477, 0.313658,
     0.075508, 0.806757, 0.560132, 0.172317],
    [0.809017, 0.587785, 0.481763, 0.823639, 0.299204,
     0.110246, 0.817987, 0.541266, 0.160545],
    [0.819152, 0.573576, 0.506515, 0.813798, 0.284914,
     0.145420, 0.827194, 0.521871, 0.149181],
    [0.829038, 0.559193, 0.530955, 0.802965, 0.270803,
     0.180944, 0.834347, 0.502011, 0.138237],
    [0.838671, 0.544639, 0.555052, 0.791154, 0.256891,
     0.216730, 0.839422, 0.481753, 0.127722],
    [0.848048, 0.529919, 0.578778, 0.778378, 0.243192,
     0.252688, 0.842399, 0.461164, 0.117644],
    [0.857167, 0.515038, 0.602104, 0.764655, 0.229726,
     0.288728, 0.843265, 0.440311, 0.108009],
    [0.866025, 0.500000, 0.625000, 0.750000, 0.216506,
     0.324760, 0.842012, 0.419263, 0.098821],
    [0.874620, 0.484810, 0.647439, 0.734431, 0.203551,
     0.360692, 0.838638, 0.398086, 0.090085],
    [0.882948, 0.469472, 0.669395, 0.717968, 0.190875,
     0.396436, 0.833145, 0.376851, 0.081803],
    [0.891007, 0.453990, 0.690839, 0.700629, 0.178494,
     0.431899, 0.825544, 0.355623, 0.073974],
    [0.898794, 0.438371, 0.711746, 0.682437, 0.166423,
     0.466993, 0.815850, 0.334472, 0.066599],
    [0.906308, 0.422618, 0.732091, 0.663414, 0.154678,
     0.501627, 0.804083, 0.313464, 0.059674],
    [0.913545, 0.406737, 0.751848, 0.643582, 0.143271,
     0.535715, 0.790270, 0.292666, 0.053196],
    [0.920505, 0.390731, 0.770994, 0.622967, 0.132217,
     0.569169, 0.774442, 0.272143, 0.047160],
    [0.927184, 0.374607, 0.789505, 0.601592, 0.121529,
     0.601904, 0.756637, 0.251960, 0.041559],
    [0.933580, 0.358368, 0.807359, 0.579484, 0.111222,
     0.633837, 0.736898, 0.232180, 0.036385],
    [0.939693, 0.342020, 0.824533, 0.556670, 0.101306,
     0.664885, 0.715274, 0.212865, 0.031630],
    [0.945519, 0.325568, 0.841008, 0.533178, 0.091794,
     0.694969, 0.691816, 0.194075, 0.027281],
    [0.951057, 0.309017, 0.856763, 0.509037, 0.082698,
     0.724012, 0.666583, 0.175868, 0.023329],
    [0.956305, 0.292372, 0.871778, 0.484275, 0.074029,
     0.751940, 0.639639, 0.158301, 0.019758],
    [0.961262, 0.275637, 0.886036, 0.458924, 0.065797,
     0.778680, 0.611050, 0.141427, 0.016556],
    [0.965926, 0.258819, 0.899519, 0.433013, 0.058013,
     0.804164, 0.580889, 0.125300, 0.013707],
    [0.970296, 0.241922, 0.912211, 0.406574, 0.050685,
     0.828326, 0.549233, 0.109969, 0.011193],
    [0.974370, 0.224951, 0.924096, 0.379641, 0.043823,
     0.851105, 0.516162, 0.095481, 0.008999],
    [0.978148, 0.207912, 0.935159, 0.352244, 0.037436,
     0.872441, 0.481759, 0.081880, 0.007105],
    [0.981627, 0.190809, 0.945388, 0.324419, 0.031530,
     0.892279, 0.446114, 0.069209, 0.005492],
    [0.984808, 0.173648, 0.954769, 0.296198, 0.026114,
     0.910569, 0.409317, 0.057505, 0.004140],
    [0.987688, 0.156434, 0.963292, 0.267617, 0.021193,
     0.927262, 0.371463, 0.046806, 0.003026],
    [0.990268, 0.139173, 0.970946, 0.238709, 0.016774,
     0.942316, 0.332649, 0.037143, 0.002131],
    [0.992546, 0.121869, 0.977722, 0.209511, 0.012862,
     0.955693, 0.292976, 0.028547, 0.001431],
    [0.994522, 0.104528, 0.983611, 0.180057, 0.009462,
     0.967356, 0.252544, 0.021043, 0.000903],
    [0.996195, 0.087156, 0.988606, 0.150384, 0.006578,
     0.977277, 0.211460, 0.014654, 0.000523],
    [0.997564, 0.069756, 0.992701, 0.120527, 0.004214,
     0.985429, 0.169828, 0.009400, 0.000268],
    [0.998630, 0.052336, 0.995891, 0.090524, 0.002372,
     0.991791, 0.127757, 0.005297, 0.000113],
    [0.999391, 0.034899, 0.998173, 0.060411, 0.001055,
     0.996348, 0.085356, 0.002357, 0.000034],
    [0.999848, 0.017452, 0.999543, 0.030224, 0.000264,
     0.999086, 0.042733, 0.000590, 0.000004],
    [1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     1.000000, -0.000000, 0.000000, -0.000000],
  ],
];


/** @type {Number} */
exports.SPHERICAL_HARMONICS_AZIMUTH_RESOLUTION =
  exports.SPHERICAL_HARMONICS[0].length;


/** @type {Number} */
exports.SPHERICAL_HARMONICS_ELEVATION_RESOLUTION =
  exports.SPHERICAL_HARMONICS[1].length;


/**
 * The maximum allowed ambisonic order.
 * @type {Number}
 */
exports.SPHERICAL_HARMONICS_MAX_ORDER =
  exports.SPHERICAL_HARMONICS[0][0].length / 2;


/**
 * Pre-computed per-band weighting coefficients for producing energy-preserving
 * Max-Re sources.
 */
exports.MAX_RE_WEIGHTS =
[
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.003236, 1.002156, 0.999152, 0.990038],
  [1.032370, 1.021194, 0.990433, 0.898572],
  [1.062694, 1.040231, 0.979161, 0.799806],
  [1.093999, 1.058954, 0.964976, 0.693603],
  [1.126003, 1.077006, 0.947526, 0.579890],
  [1.158345, 1.093982, 0.926474, 0.458690],
  [1.190590, 1.109437, 0.901512, 0.330158],
  [1.222228, 1.122890, 0.872370, 0.194621],
  [1.252684, 1.133837, 0.838839, 0.052614],
  [1.281987, 1.142358, 0.801199, 0.000000],
  [1.312073, 1.150207, 0.760839, 0.000000],
  [1.343011, 1.157424, 0.717799, 0.000000],
  [1.374649, 1.163859, 0.671999, 0.000000],
  [1.406809, 1.169354, 0.623371, 0.000000],
  [1.439286, 1.173739, 0.571868, 0.000000],
  [1.471846, 1.176837, 0.517465, 0.000000],
  [1.504226, 1.178465, 0.460174, 0.000000],
  [1.536133, 1.178438, 0.400043, 0.000000],
  [1.567253, 1.176573, 0.337165, 0.000000],
  [1.597247, 1.172695, 0.271688, 0.000000],
  [1.625766, 1.166645, 0.203815, 0.000000],
  [1.652455, 1.158285, 0.133806, 0.000000],
  [1.676966, 1.147506, 0.061983, 0.000000],
  [1.699006, 1.134261, 0.000000, 0.000000],
  [1.720224, 1.119789, 0.000000, 0.000000],
  [1.741631, 1.104810, 0.000000, 0.000000],
  [1.763183, 1.089330, 0.000000, 0.000000],
  [1.784837, 1.073356, 0.000000, 0.000000],
  [1.806548, 1.056898, 0.000000, 0.000000],
  [1.828269, 1.039968, 0.000000, 0.000000],
  [1.849952, 1.022580, 0.000000, 0.000000],
  [1.871552, 1.004752, 0.000000, 0.000000],
  [1.893018, 0.986504, 0.000000, 0.000000],
  [1.914305, 0.967857, 0.000000, 0.000000],
  [1.935366, 0.948837, 0.000000, 0.000000],
  [1.956154, 0.929471, 0.000000, 0.000000],
  [1.976625, 0.909790, 0.000000, 0.000000],
  [1.996736, 0.889823, 0.000000, 0.000000],
  [2.016448, 0.869607, 0.000000, 0.000000],
  [2.035721, 0.849175, 0.000000, 0.000000],
  [2.054522, 0.828565, 0.000000, 0.000000],
  [2.072818, 0.807816, 0.000000, 0.000000],
  [2.090581, 0.786964, 0.000000, 0.000000],
  [2.107785, 0.766051, 0.000000, 0.000000],
  [2.124411, 0.745115, 0.000000, 0.000000],
  [2.140439, 0.724196, 0.000000, 0.000000],
  [2.155856, 0.703332, 0.000000, 0.000000],
  [2.170653, 0.682561, 0.000000, 0.000000],
  [2.184823, 0.661921, 0.000000, 0.000000],
  [2.198364, 0.641445, 0.000000, 0.000000],
  [2.211275, 0.621169, 0.000000, 0.000000],
  [2.223562, 0.601125, 0.000000, 0.000000],
  [2.235230, 0.581341, 0.000000, 0.000000],
  [2.246289, 0.561847, 0.000000, 0.000000],
  [2.256751, 0.542667, 0.000000, 0.000000],
  [2.266631, 0.523826, 0.000000, 0.000000],
  [2.275943, 0.505344, 0.000000, 0.000000],
  [2.284707, 0.487239, 0.000000, 0.000000],
  [2.292939, 0.469528, 0.000000, 0.000000],
  [2.300661, 0.452225, 0.000000, 0.000000],
  [2.307892, 0.435342, 0.000000, 0.000000],
  [2.314654, 0.418888, 0.000000, 0.000000],
  [2.320969, 0.402870, 0.000000, 0.000000],
  [2.326858, 0.387294, 0.000000, 0.000000],
  [2.332343, 0.372164, 0.000000, 0.000000],
  [2.337445, 0.357481, 0.000000, 0.000000],
  [2.342186, 0.343246, 0.000000, 0.000000],
  [2.346585, 0.329458, 0.000000, 0.000000],
  [2.350664, 0.316113, 0.000000, 0.000000],
  [2.354442, 0.303208, 0.000000, 0.000000],
  [2.357937, 0.290738, 0.000000, 0.000000],
  [2.361168, 0.278698, 0.000000, 0.000000],
  [2.364152, 0.267080, 0.000000, 0.000000],
  [2.366906, 0.255878, 0.000000, 0.000000],
  [2.369446, 0.245082, 0.000000, 0.000000],
  [2.371786, 0.234685, 0.000000, 0.000000],
  [2.373940, 0.224677, 0.000000, 0.000000],
  [2.375923, 0.215048, 0.000000, 0.000000],
  [2.377745, 0.205790, 0.000000, 0.000000],
  [2.379421, 0.196891, 0.000000, 0.000000],
  [2.380959, 0.188342, 0.000000, 0.000000],
  [2.382372, 0.180132, 0.000000, 0.000000],
  [2.383667, 0.172251, 0.000000, 0.000000],
  [2.384856, 0.164689, 0.000000, 0.000000],
  [2.385945, 0.157435, 0.000000, 0.000000],
  [2.386943, 0.150479, 0.000000, 0.000000],
  [2.387857, 0.143811, 0.000000, 0.000000],
  [2.388694, 0.137421, 0.000000, 0.000000],
  [2.389460, 0.131299, 0.000000, 0.000000],
  [2.390160, 0.125435, 0.000000, 0.000000],
  [2.390801, 0.119820, 0.000000, 0.000000],
  [2.391386, 0.114445, 0.000000, 0.000000],
  [2.391921, 0.109300, 0.000000, 0.000000],
  [2.392410, 0.104376, 0.000000, 0.000000],
  [2.392857, 0.099666, 0.000000, 0.000000],
  [2.393265, 0.095160, 0.000000, 0.000000],
  [2.393637, 0.090851, 0.000000, 0.000000],
  [2.393977, 0.086731, 0.000000, 0.000000],
  [2.394288, 0.082791, 0.000000, 0.000000],
  [2.394571, 0.079025, 0.000000, 0.000000],
  [2.394829, 0.075426, 0.000000, 0.000000],
  [2.395064, 0.071986, 0.000000, 0.000000],
  [2.395279, 0.068699, 0.000000, 0.000000],
  [2.395475, 0.065558, 0.000000, 0.000000],
  [2.395653, 0.062558, 0.000000, 0.000000],
  [2.395816, 0.059693, 0.000000, 0.000000],
  [2.395964, 0.056955, 0.000000, 0.000000],
  [2.396099, 0.054341, 0.000000, 0.000000],
  [2.396222, 0.051845, 0.000000, 0.000000],
  [2.396334, 0.049462, 0.000000, 0.000000],
  [2.396436, 0.047186, 0.000000, 0.000000],
  [2.396529, 0.045013, 0.000000, 0.000000],
  [2.396613, 0.042939, 0.000000, 0.000000],
  [2.396691, 0.040959, 0.000000, 0.000000],
  [2.396761, 0.039069, 0.000000, 0.000000],
  [2.396825, 0.037266, 0.000000, 0.000000],
  [2.396883, 0.035544, 0.000000, 0.000000],
  [2.396936, 0.033901, 0.000000, 0.000000],
  [2.396984, 0.032334, 0.000000, 0.000000],
  [2.397028, 0.030838, 0.000000, 0.000000],
  [2.397068, 0.029410, 0.000000, 0.000000],
  [2.397104, 0.028048, 0.000000, 0.000000],
  [2.397137, 0.026749, 0.000000, 0.000000],
  [2.397167, 0.025509, 0.000000, 0.000000],
  [2.397194, 0.024326, 0.000000, 0.000000],
  [2.397219, 0.023198, 0.000000, 0.000000],
  [2.397242, 0.022122, 0.000000, 0.000000],
  [2.397262, 0.021095, 0.000000, 0.000000],
  [2.397281, 0.020116, 0.000000, 0.000000],
  [2.397298, 0.019181, 0.000000, 0.000000],
  [2.397314, 0.018290, 0.000000, 0.000000],
  [2.397328, 0.017441, 0.000000, 0.000000],
  [2.397341, 0.016630, 0.000000, 0.000000],
  [2.397352, 0.015857, 0.000000, 0.000000],
  [2.397363, 0.015119, 0.000000, 0.000000],
  [2.397372, 0.014416, 0.000000, 0.000000],
  [2.397381, 0.013745, 0.000000, 0.000000],
  [2.397389, 0.013106, 0.000000, 0.000000],
  [2.397396, 0.012496, 0.000000, 0.000000],
  [2.397403, 0.011914, 0.000000, 0.000000],
  [2.397409, 0.011360, 0.000000, 0.000000],
  [2.397414, 0.010831, 0.000000, 0.000000],
  [2.397419, 0.010326, 0.000000, 0.000000],
  [2.397424, 0.009845, 0.000000, 0.000000],
  [2.397428, 0.009387, 0.000000, 0.000000],
  [2.397432, 0.008949, 0.000000, 0.000000],
  [2.397435, 0.008532, 0.000000, 0.000000],
  [2.397438, 0.008135, 0.000000, 0.000000],
  [2.397441, 0.007755, 0.000000, 0.000000],
  [2.397443, 0.007394, 0.000000, 0.000000],
  [2.397446, 0.007049, 0.000000, 0.000000],
  [2.397448, 0.006721, 0.000000, 0.000000],
  [2.397450, 0.006407, 0.000000, 0.000000],
  [2.397451, 0.006108, 0.000000, 0.000000],
  [2.397453, 0.005824, 0.000000, 0.000000],
  [2.397454, 0.005552, 0.000000, 0.000000],
  [2.397456, 0.005293, 0.000000, 0.000000],
  [2.397457, 0.005046, 0.000000, 0.000000],
  [2.397458, 0.004811, 0.000000, 0.000000],
  [2.397459, 0.004586, 0.000000, 0.000000],
  [2.397460, 0.004372, 0.000000, 0.000000],
  [2.397461, 0.004168, 0.000000, 0.000000],
  [2.397461, 0.003974, 0.000000, 0.000000],
  [2.397462, 0.003788, 0.000000, 0.000000],
  [2.397463, 0.003611, 0.000000, 0.000000],
  [2.397463, 0.003443, 0.000000, 0.000000],
  [2.397464, 0.003282, 0.000000, 0.000000],
  [2.397464, 0.003129, 0.000000, 0.000000],
  [2.397465, 0.002983, 0.000000, 0.000000],
  [2.397465, 0.002844, 0.000000, 0.000000],
  [2.397465, 0.002711, 0.000000, 0.000000],
  [2.397466, 0.002584, 0.000000, 0.000000],
  [2.397466, 0.002464, 0.000000, 0.000000],
  [2.397466, 0.002349, 0.000000, 0.000000],
  [2.397466, 0.002239, 0.000000, 0.000000],
  [2.397467, 0.002135, 0.000000, 0.000000],
  [2.397467, 0.002035, 0.000000, 0.000000],
  [2.397467, 0.001940, 0.000000, 0.000000],
  [2.397467, 0.001849, 0.000000, 0.000000],
  [2.397467, 0.001763, 0.000000, 0.000000],
  [2.397467, 0.001681, 0.000000, 0.000000],
  [2.397468, 0.001602, 0.000000, 0.000000],
  [2.397468, 0.001527, 0.000000, 0.000000],
  [2.397468, 0.001456, 0.000000, 0.000000],
  [2.397468, 0.001388, 0.000000, 0.000000],
  [2.397468, 0.001323, 0.000000, 0.000000],
  [2.397468, 0.001261, 0.000000, 0.000000],
  [2.397468, 0.001202, 0.000000, 0.000000],
  [2.397468, 0.001146, 0.000000, 0.000000],
  [2.397468, 0.001093, 0.000000, 0.000000],
  [2.397468, 0.001042, 0.000000, 0.000000],
  [2.397468, 0.000993, 0.000000, 0.000000],
  [2.397468, 0.000947, 0.000000, 0.000000],
  [2.397468, 0.000902, 0.000000, 0.000000],
  [2.397468, 0.000860, 0.000000, 0.000000],
  [2.397468, 0.000820, 0.000000, 0.000000],
  [2.397469, 0.000782, 0.000000, 0.000000],
  [2.397469, 0.000745, 0.000000, 0.000000],
  [2.397469, 0.000710, 0.000000, 0.000000],
  [2.397469, 0.000677, 0.000000, 0.000000],
  [2.397469, 0.000646, 0.000000, 0.000000],
  [2.397469, 0.000616, 0.000000, 0.000000],
  [2.397469, 0.000587, 0.000000, 0.000000],
  [2.397469, 0.000559, 0.000000, 0.000000],
  [2.397469, 0.000533, 0.000000, 0.000000],
  [2.397469, 0.000508, 0.000000, 0.000000],
  [2.397469, 0.000485, 0.000000, 0.000000],
  [2.397469, 0.000462, 0.000000, 0.000000],
  [2.397469, 0.000440, 0.000000, 0.000000],
  [2.397469, 0.000420, 0.000000, 0.000000],
  [2.397469, 0.000400, 0.000000, 0.000000],
  [2.397469, 0.000381, 0.000000, 0.000000],
  [2.397469, 0.000364, 0.000000, 0.000000],
  [2.397469, 0.000347, 0.000000, 0.000000],
  [2.397469, 0.000330, 0.000000, 0.000000],
  [2.397469, 0.000315, 0.000000, 0.000000],
  [2.397469, 0.000300, 0.000000, 0.000000],
  [2.397469, 0.000286, 0.000000, 0.000000],
  [2.397469, 0.000273, 0.000000, 0.000000],
  [2.397469, 0.000260, 0.000000, 0.000000],
  [2.397469, 0.000248, 0.000000, 0.000000],
  [2.397469, 0.000236, 0.000000, 0.000000],
  [2.397469, 0.000225, 0.000000, 0.000000],
  [2.397469, 0.000215, 0.000000, 0.000000],
  [2.397469, 0.000205, 0.000000, 0.000000],
  [2.397469, 0.000195, 0.000000, 0.000000],
  [2.397469, 0.000186, 0.000000, 0.000000],
  [2.397469, 0.000177, 0.000000, 0.000000],
  [2.397469, 0.000169, 0.000000, 0.000000],
  [2.397469, 0.000161, 0.000000, 0.000000],
  [2.397469, 0.000154, 0.000000, 0.000000],
  [2.397469, 0.000147, 0.000000, 0.000000],
  [2.397469, 0.000140, 0.000000, 0.000000],
  [2.397469, 0.000133, 0.000000, 0.000000],
  [2.397469, 0.000127, 0.000000, 0.000000],
  [2.397469, 0.000121, 0.000000, 0.000000],
  [2.397469, 0.000115, 0.000000, 0.000000],
  [2.397469, 0.000110, 0.000000, 0.000000],
  [2.397469, 0.000105, 0.000000, 0.000000],
  [2.397469, 0.000100, 0.000000, 0.000000],
  [2.397469, 0.000095, 0.000000, 0.000000],
  [2.397469, 0.000091, 0.000000, 0.000000],
  [2.397469, 0.000087, 0.000000, 0.000000],
  [2.397469, 0.000083, 0.000000, 0.000000],
  [2.397469, 0.000079, 0.000000, 0.000000],
  [2.397469, 0.000075, 0.000000, 0.000000],
  [2.397469, 0.000071, 0.000000, 0.000000],
  [2.397469, 0.000068, 0.000000, 0.000000],
  [2.397469, 0.000065, 0.000000, 0.000000],
  [2.397469, 0.000062, 0.000000, 0.000000],
  [2.397469, 0.000059, 0.000000, 0.000000],
  [2.397469, 0.000056, 0.000000, 0.000000],
  [2.397469, 0.000054, 0.000000, 0.000000],
  [2.397469, 0.000051, 0.000000, 0.000000],
  [2.397469, 0.000049, 0.000000, 0.000000],
  [2.397469, 0.000046, 0.000000, 0.000000],
  [2.397469, 0.000044, 0.000000, 0.000000],
  [2.397469, 0.000042, 0.000000, 0.000000],
  [2.397469, 0.000040, 0.000000, 0.000000],
  [2.397469, 0.000038, 0.000000, 0.000000],
  [2.397469, 0.000037, 0.000000, 0.000000],
  [2.397469, 0.000035, 0.000000, 0.000000],
  [2.397469, 0.000033, 0.000000, 0.000000],
  [2.397469, 0.000032, 0.000000, 0.000000],
  [2.397469, 0.000030, 0.000000, 0.000000],
  [2.397469, 0.000029, 0.000000, 0.000000],
  [2.397469, 0.000027, 0.000000, 0.000000],
  [2.397469, 0.000026, 0.000000, 0.000000],
  [2.397469, 0.000025, 0.000000, 0.000000],
  [2.397469, 0.000024, 0.000000, 0.000000],
  [2.397469, 0.000023, 0.000000, 0.000000],
  [2.397469, 0.000022, 0.000000, 0.000000],
  [2.397469, 0.000021, 0.000000, 0.000000],
  [2.397469, 0.000020, 0.000000, 0.000000],
  [2.397469, 0.000019, 0.000000, 0.000000],
  [2.397469, 0.000018, 0.000000, 0.000000],
  [2.397469, 0.000017, 0.000000, 0.000000],
  [2.397469, 0.000016, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000014, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
];


/** @type {Number} */
exports.MAX_RE_WEIGHTS_RESOLUTION = exports.MAX_RE_WEIGHTS.length;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_88844__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Source model to spatialize an audio buffer.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Directivity = __nested_webpack_require_88844__(5);
const Attenuation = __nested_webpack_require_88844__(6);
const Encoder = __nested_webpack_require_88844__(1);
const Utils = __nested_webpack_require_88844__(0);


/**
 * @class Source
 * @description Source model to spatialize an audio buffer.
 * @param {ResonanceAudio} scene Associated {@link ResonanceAudio
 * ResonanceAudio} instance.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Source(scene, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Source
   * @instance
   */
  /**
   *
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ROLLOFF;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_SOURCE_GAIN;
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  // Member variables.
  this._scene = scene;
  this._position = options.position;
  this._forward = options.forward;
  this._up = options.up;
  this._dx = new Float32Array(3);
  this._right = Utils.crossProduct(this._forward, this._up);

  // Create audio nodes.
  let context = scene._context;
  this.input = context.createGain();
  this._directivity = new Directivity(context, {
    alpha: options.alpha,
    sharpness: options.sharpness,
  });
  this._toEarly = context.createGain();
  this._toLate = context.createGain();
  this._attenuation = new Attenuation(context, {
    minDistance: options.minDistance,
    maxDistance: options.maxDistance,
    rolloff: options.rolloff,
  });
  this._encoder = new Encoder(context, {
    ambisonicOrder: scene._ambisonicOrder,
    sourceWidth: options.sourceWidth,
  });

  // Connect nodes.
  this.input.connect(this._toLate);
  this._toLate.connect(scene._room.late.input);

  this.input.connect(this._attenuation.input);
  this._attenuation.output.connect(this._toEarly);
  this._toEarly.connect(scene._room.early.input);

  this._attenuation.output.connect(this._directivity.input);
  this._directivity.output.connect(this._encoder.input);

  this._encoder.output.connect(scene._listener.input);

  // Assign initial conditions.
  this.setPosition(
    options.position[0], options.position[1], options.position[2]);
  this.input.gain.value = options.gain;
};


/**
 * Set source's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Source.prototype.setPosition = function(x, y, z) {
  // Assign new position.
  this._position[0] = x;
  this._position[1] = y;
  this._position[2] = z;

  // Handle far-field effect.
  let distance = this._scene._room.getDistanceOutsideRoom(
    this._position[0], this._position[1], this._position[2]);
    let gain = _computeDistanceOutsideRoom(distance);
  this._toLate.gain.value = gain;
  this._toEarly.gain.value = gain;

  this._update();
};


// Update the source when changing the listener's position.
Source.prototype._update = function() {
  // Compute distance to listener.
  for (let i = 0; i < 3; i++) {
    this._dx[i] = this._position[i] - this._scene._listener.position[i];
  }
  let distance = Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[1] * this._dx[1] + this._dx[2] * this._dx[2]);
  if (distance > 0) {
    // Normalize direction vector.
    this._dx[0] /= distance;
    this._dx[1] /= distance;
    this._dx[2] /= distance;
  }

  // Compuete angle of direction vector.
  let azimuth = Math.atan2(-this._dx[0], this._dx[2]) *
    Utils.RADIANS_TO_DEGREES;
  let elevation = Math.atan2(this._dx[1], Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[2] * this._dx[2])) * Utils.RADIANS_TO_DEGREES;

  // Set distance/directivity/direction values.
  this._attenuation.setDistance(distance);
  this._directivity.computeAngle(this._forward, this._dx);
  this._encoder.setDirection(azimuth, elevation);
};


/**
 * Set source's rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Source.prototype.setRolloff = function(rolloff) {
  this._attenuation.setRolloff(rolloff);
};


/**
 * Set source's minimum distance (in meters).
 * @param {Number} minDistance
 */
Source.prototype.setMinDistance = function(minDistance) {
  this._attenuation.minDistance = minDistance;
};


/**
 * Set source's maximum distance (in meters).
 * @param {Number} maxDistance
 */
Source.prototype.setMaxDistance = function(maxDistance) {
  this._attenuation.maxDistance = maxDistance;
};


/**
 * Set source's gain (linear).
 * @param {Number} gain
 */
Source.prototype.setGain = function(gain) {
  this.input.gain.value = gain;
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Source.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
    upX, upY, upZ) {
  this._forward[0] = forwardX;
  this._forward[1] = forwardY;
  this._forward[2] = forwardZ;
  this._up[0] = upX;
  this._up[1] = upY;
  this._up[2] = upZ;
  this._right = Utils.crossProduct(this._forward, this._up);
};


// TODO(bitllama): Make sure this works with Three.js as intended.
/**
 * Set source's position and orientation using a
 * Three.js modelViewMatrix object.
 * @param {Float32Array} matrix4
 * The Matrix4 representing the object position and rotation in world space.
 */
Source.prototype.setFromMatrix = function(matrix4) {
  this._right[0] = matrix4.elements[0];
  this._right[1] = matrix4.elements[1];
  this._right[2] = matrix4.elements[2];
  this._up[0] = matrix4.elements[4];
  this._up[1] = matrix4.elements[5];
  this._up[2] = matrix4.elements[6];
  this._forward[0] = matrix4.elements[8];
  this._forward[1] = matrix4.elements[9];
  this._forward[2] = matrix4.elements[10];

  // Normalize to remove scaling.
  this._right = Utils.normalizeVector(this._right);
  this._up = Utils.normalizeVector(this._up);
  this._forward = Utils.normalizeVector(this._forward);

  // Update position.
  this.setPosition(
    matrix4.elements[12], matrix4.elements[13], matrix4.elements[14]);
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Source.prototype.setSourceWidth = function(sourceWidth) {
  this._encoder.setSourceWidth(sourceWidth);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 */
Source.prototype.setDirectivityPattern = function(alpha, sharpness) {
  this._directivity.setPattern(alpha, sharpness);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Determine the distance a source is outside of a room. Attenuate gain going
 * to the reflections and reverb when the source is outside of the room.
 * @param {Number} distance Distance in meters.
 * @return {Number} Gain (linear) of source.
 * @private
 */
function _computeDistanceOutsideRoom(distance) {
  // We apply a linear ramp from 1 to 0 as the source is up to 1m outside.
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  return gain;
}


module.exports = Source;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_99936__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Directivity/occlusion filter.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_99936__(0);


/**
 * @class Directivity
 * @description Directivity/occlusion filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.alpha
 * Determines directivity pattern (0 to 1). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
function Directivity(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Directivity
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Directivity
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }

  // Create audio node.
  this._context = context;
  this._lowpass = context.createBiquadFilter();

  // Initialize filter coefficients.
  this._lowpass.type = 'lowpass';
  this._lowpass.Q.value = 0;
  this._lowpass.frequency.value = context.sampleRate * 0.5;

  this._cosTheta = 0;
  this.setPattern(options.alpha, options.sharpness);

  // Input/Output proxy.
  this.input = this._lowpass;
  this.output = this._lowpass;
}


/**
 * Compute the filter using the source's forward orientation and the listener's
 * position.
 * @param {Float32Array} forward The source's forward vector.
 * @param {Float32Array} direction The direction from the source to the
 * listener.
 */
Directivity.prototype.computeAngle = function(forward, direction) {
  let forwardNorm = Utils.normalizeVector(forward);
  let directionNorm = Utils.normalizeVector(direction);
  let coeff = 1;
  if (this._alpha > Utils.EPSILON_FLOAT) {
    let cosTheta = forwardNorm[0] * directionNorm[0] +
      forwardNorm[1] * directionNorm[1] + forwardNorm[2] * directionNorm[2];
    coeff = (1 - this._alpha) + this._alpha * cosTheta;
    coeff = Math.pow(Math.abs(coeff), this._sharpness);
  }
  this._lowpass.frequency.value = this._context.sampleRate * 0.5 * coeff;
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponenentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
Directivity.prototype.setPattern = function(alpha, sharpness) {
  // Clamp and set values.
  this._alpha = Math.min(1, Math.max(0, alpha));
  this._sharpness = Math.max(1, sharpness);

  // Update angle calculation using new values.
  this.computeAngle([this._cosTheta * this._cosTheta, 0, 0], [1, 0, 0]);
};


module.exports = Directivity;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_104304__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Distance-based attenuation filter.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Utils = __nested_webpack_require_104304__(0);


/**
 * @class Attenuation
 * @description Distance-based attenuation filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 */
function Attenuation(context, options) {
  // Public variables.
  /**
   * Min. distance (in meters).
   * @member {Number} minDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Max. distance (in meters).
   * @member {Number} maxDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Attenuation
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  }

  // Assign values.
  this.minDistance = options.minDistance;
  this.maxDistance = options.maxDistance;
  this.setRolloff(options.rolloff);

  // Create node.
  this._gainNode = context.createGain();

  // Initialize distance to max distance.
  this.setDistance(options.maxDistance);

  // Input/Output proxy.
  this.input = this._gainNode;
  this.output = this._gainNode;
}


/**
 * Set distance from the listener.
 * @param {Number} distance Distance (in meters).
 */
Attenuation.prototype.setDistance = function(distance) {
  let gain = 1;
  if (this._rolloff == 'logarithmic') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        // Compute the distance attenuation value by the logarithmic curve
        // "1 / (d + 1)" with an offset of |minDistance|.
        let relativeDistance = distance - this.minDistance;
        let attenuation = 1 / (relativeDistance + 1);
        let attenuationMax = 1 / (range + 1);
        gain = (attenuation - attenuationMax) / (1 - attenuationMax);
      }
    }
  } else if (this._rolloff == 'linear') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        gain = (this.maxDistance - distance) / range;
      }
    }
  }
  this._gainNode.gain.value = gain;
};


/**
 * Set rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Attenuation.prototype.setRolloff = function(rolloff) {
  let isValidModel = ~Utils.ATTENUATION_ROLLOFFS.indexOf(rolloff);
  if (rolloff == undefined || !isValidModel) {
    if (!isValidModel) {
      Utils.log('Invalid rolloff model (\"' + rolloff +
        '\"). Using default: \"' + Utils.DEFAULT_ATTENUATION_ROLLOFF + '\".');
    }
    rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  } else {
    rolloff = rolloff.toString().toLowerCase();
  }
  this._rolloff = rolloff;
};


module.exports = Attenuation;


/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_109231__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Complete room model with early and late reflections.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const LateReflections = __nested_webpack_require_109231__(8);
const EarlyReflections = __nested_webpack_require_109231__(9);
const Utils = __nested_webpack_require_109231__(0);


/**
 * Generate absorption coefficients from material names.
 * @param {Object} materials
 * @return {Object}
 */
function _getCoefficientsFromMaterials(materials) {
  // Initialize coefficients to use defaults.
  let coefficients = {};
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property)) {
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }

  // Sanitize materials.
  if (materials == undefined) {
    materials = {};
    Object.assign(materials, Utils.DEFAULT_ROOM_MATERIALS);
  }

  // Assign coefficients using provided materials.
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property) &&
        materials.hasOwnProperty(property)) {
      if (materials[property] in Utils.ROOM_MATERIAL_COEFFICIENTS) {
        coefficients[property] =
          Utils.ROOM_MATERIAL_COEFFICIENTS[materials[property]];
      } else {
        Utils.log('Material \"' + materials[property] + '\" on wall \"' +
          property + '\" not found. Using \"' +
          Utils.DEFAULT_ROOM_MATERIALS[property] + '\".');
      }
    } else {
      Utils.log('Wall \"' + property + '\" is not defined. Default used.');
    }
  }
  return coefficients;
}

/**
 * Sanitize coefficients.
 * @param {Object} coefficients
 * @return {Object}
 */
function _sanitizeCoefficients(coefficients) {
  if (coefficients == undefined) {
    coefficients = {};
  }
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (!(coefficients.hasOwnProperty(property))) {
      // If element is not present, use default coefficients.
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }
  return coefficients;
}

/**
 * Sanitize dimensions.
 * @param {Object} dimensions
 * @return {Object}
 */
function _sanitizeDimensions(dimensions) {
  if (dimensions == undefined) {
    dimensions = {};
  }
  for (let property in Utils.DEFAULT_ROOM_DIMENSIONS) {
    if (!(dimensions.hasOwnProperty(property))) {
      dimensions[property] = Utils.DEFAULT_ROOM_DIMENSIONS[property];
    }
  }
  return dimensions;
}

/**
 * Compute frequency-dependent reverb durations.
 * @param {Object} dimensions
 * @param {Object} coefficients
 * @param {Number} speedOfSound
 * @return {Array}
 */
function _getDurationsFromProperties(dimensions, coefficients, speedOfSound) {
  let durations = new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);

  // Sanitize inputs.
  dimensions = _sanitizeDimensions(dimensions);
  coefficients = _sanitizeCoefficients(coefficients);
  if (speedOfSound == undefined) {
    speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Acoustic constant.
  let k = Utils.TWENTY_FOUR_LOG10 / speedOfSound;

  // Compute volume, skip if room is not present.
  let volume = dimensions.width * dimensions.height * dimensions.depth;
  if (volume < Utils.ROOM_MIN_VOLUME) {
    return durations;
  }

  // Room surface area.
  let leftRightArea = dimensions.width * dimensions.height;
  let floorCeilingArea = dimensions.width * dimensions.depth;
  let frontBackArea = dimensions.depth * dimensions.height;
  let totalArea = 2 * (leftRightArea + floorCeilingArea + frontBackArea);
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Effective absorptive area.
    let absorbtionArea =
      (coefficients.left[i] + coefficients.right[i]) * leftRightArea +
      (coefficients.down[i] + coefficients.up[i]) * floorCeilingArea +
      (coefficients.front[i] + coefficients.back[i]) * frontBackArea;
    let meanAbsorbtionArea = absorbtionArea / totalArea;

    // Compute reverberation using Eyring equation [1].
    // [1] Beranek, Leo L. "Analysis of Sabine and Eyring equations and their
    //     application to concert hall audience and chair absorption." The
    //     Journal of the Acoustical Society of America, Vol. 120, No. 3.
    //     (2006), pp. 1399-1399.
    durations[i] = Utils.ROOM_EYRING_CORRECTION_COEFFICIENT * k * volume /
      (-totalArea * Math.log(1 - meanAbsorbtionArea) + 4 *
      Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS[i] * volume);
  }
  return durations;
}


/**
 * Compute reflection coefficients from absorption coefficients.
 * @param {Object} absorptionCoefficients
 * @return {Object}
 */
function _computeReflectionCoefficients(absorptionCoefficients) {
  let reflectionCoefficients = [];
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute average absorption coefficient (per wall).
      reflectionCoefficients[property] = 0;
      for (let j = 0; j < Utils.NUMBER_REFLECTION_AVERAGING_BANDS; j++) {
        let bandIndex = j + Utils.ROOM_STARTING_AVERAGING_BAND;
        reflectionCoefficients[property] +=
          absorptionCoefficients[property][bandIndex];
      }
      reflectionCoefficients[property] /=
        Utils.NUMBER_REFLECTION_AVERAGING_BANDS;

      // Convert absorption coefficient to reflection coefficient.
      reflectionCoefficients[property] =
        Math.sqrt(1 - reflectionCoefficients[property]);
    }
  }
  return reflectionCoefficients;
}


/**
 * @class Room
 * @description Model that manages early and late reflections using acoustic
 * properties and listener position relative to a rectangular room.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function Room(context, options) {
  // Public variables.
  /**
   * EarlyReflections {@link EarlyReflections EarlyReflections} submodule.
   * @member {AudioNode} early
   * @memberof Room
   * @instance
   */
  /**
   * LateReflections {@link LateReflections LateReflections} submodule.
   * @member {AudioNode} late
   * @memberof Room
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Room
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Sanitize room-properties-related arguments.
  options.dimensions = _sanitizeDimensions(options.dimensions);
  let absorptionCoefficients = _getCoefficientsFromMaterials(options.materials);
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  let durations = _getDurationsFromProperties(options.dimensions,
    absorptionCoefficients, options.speedOfSound);

  // Construct submodules for early and late reflections.
  this.early = new EarlyReflections(context, {
    dimensions: options.dimensions,
    coefficients: reflectionCoefficients,
    speedOfSound: options.speedOfSound,
    listenerPosition: options.listenerPosition,
  });
  this.late = new LateReflections(context, {
    durations: durations,
  });

  this.speedOfSound = options.speedOfSound;

  // Construct auxillary audio nodes.
  this.output = context.createGain();
  this.early.output.connect(this.output);
  this._merger = context.createChannelMerger(4);

  this.late.output.connect(this._merger, 0, 0);
  this._merger.connect(this.output);
}


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} materials Named acoustic materials per wall. Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 */
Room.prototype.setProperties = function(dimensions, materials) {
  // Compute late response.
  let absorptionCoefficients = _getCoefficientsFromMaterials(materials);
  let durations = _getDurationsFromProperties(dimensions,
    absorptionCoefficients, this.speedOfSound);
  this.late.setDurations(durations);

  // Compute early response.
  this.early.speedOfSound = this.speedOfSound;
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  this.early.setRoomProperties(dimensions, reflectionCoefficients);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Room.prototype.setListenerPosition = function(x, y, z) {
  this.early.speedOfSound = this.speedOfSound;
  this.early.setListenerPosition(x, y, z);

  // Disable room effects if the listener is outside the room boundaries.
  let distance = this.getDistanceOutsideRoom(x, y, z);
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  this.output.gain.value = gain;
};


/**
 * Compute distance outside room of provided position (in meters).
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return {Number}
 * Distance outside room (in meters). Returns 0 if inside room.
 */
Room.prototype.getDistanceOutsideRoom = function(x, y, z) {
  let dx = Math.max(0, -this.early._halfDimensions.width - x,
    x - this.early._halfDimensions.width);
    let dy = Math.max(0, -this.early._halfDimensions.height - y,
    y - this.early._halfDimensions.height);
    let dz = Math.max(0, -this.early._halfDimensions.depth - z,
    z - this.early._halfDimensions.depth);
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};


module.exports = Room;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_120970__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Late reverberation filter for Ambisonic content.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_120970__(0);


/**
 * @class LateReflections
 * @description Late-reflections reverberation filter for Ambisonic content.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Array} options.durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * FREQUDEFAULT_REVERB_FREQUENCY_BANDSENCY_BANDS}. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_DURATIONS DEFAULT_REVERB_DURATIONS}.
 * @param {Number} options.predelay Pre-delay (in milliseconds). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_PREDELAY DEFAULT_REVERB_PREDELAY}.
 * @param {Number} options.gain Output gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_GAIN DEFAULT_REVERB_GAIN}.
 * @param {Number} options.bandwidth Bandwidth (in octaves) for each frequency
 * band. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_BANDWIDTH DEFAULT_REVERB_BANDWIDTH}.
 * @param {Number} options.tailonset Length (in milliseconds) of impulse
 * response to apply a half-Hann window. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_TAIL_ONSET DEFAULT_REVERB_TAIL_ONSET}.
 */
function LateReflections(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof LateReflections
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof LateReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.durations == undefined) {
    options.durations = Utils.DEFAULT_REVERB_DURATIONS.slice();
  }
  if (options.predelay == undefined) {
    options.predelay = Utils.DEFAULT_REVERB_PREDELAY;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_REVERB_GAIN;
  }
  if (options.bandwidth == undefined) {
    options.bandwidth = Utils.DEFAULT_REVERB_BANDWIDTH;
  }
  if (options.tailonset == undefined) {
    options.tailonset = Utils.DEFAULT_REVERB_TAIL_ONSET;
  }

  // Assign pre-computed variables.
  let delaySecs = options.predelay / 1000;
  this._bandwidthCoeff = options.bandwidth * Utils.LOG2_DIV2;
  this._tailonsetSamples = options.tailonset / 1000;

  // Create nodes.
  this._context = context;
  this.input = context.createGain();
  this._predelay = context.createDelay(delaySecs);
  this._convolver = context.createConvolver();
  this.output = context.createGain();

  // Set reverb attenuation.
  this.output.gain.value = options.gain;

  // Disable normalization.
  this._convolver.normalize = false;

  // Connect nodes.
  this.input.connect(this._predelay);
  this._predelay.connect(this._convolver);
  this._convolver.connect(this.output);

  // Compute IR using RT60 values.
  this.setDurations(options.durations);
}


/**
 * Re-compute a new impulse response by providing Multiband RT60 durations.
 * @param {Array} durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * DEFAULT_REVERB_FREQUENCY_BANDS}.
 */
LateReflections.prototype.setDurations = function(durations) {
  if (durations.length !== Utils.NUMBER_REVERB_FREQUENCY_BANDS) {
    Utils.log('Warning: invalid number of RT60 values provided to reverb.');
    return;
  }

  // Compute impulse response.
  let durationsSamples =
    new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);
    let sampleRate = this._context.sampleRate;

  for (let i = 0; i < durations.length; i++) {
    // Clamp within suitable range.
    durations[i] =
      Math.max(0, Math.min(Utils.DEFAULT_REVERB_MAX_DURATION, durations[i]));

    // Convert seconds to samples.
    durationsSamples[i] = Math.round(durations[i] * sampleRate *
      Utils.DEFAULT_REVERB_DURATION_MULTIPLIER);
  };

  // Determine max RT60 length in samples.
  let durationsSamplesMax = 0;
  for (let i = 0; i < durationsSamples.length; i++) {
    if (durationsSamples[i] > durationsSamplesMax) {
      durationsSamplesMax = durationsSamples[i];
    }
  }

  // Skip this step if there is no reverberation to compute.
  if (durationsSamplesMax < 1) {
    durationsSamplesMax = 1;
  }

  // Create impulse response buffer.
  let buffer = this._context.createBuffer(1, durationsSamplesMax, sampleRate);
  let bufferData = buffer.getChannelData(0);

  // Create noise signal (computed once, referenced in each band's routine).
  let noiseSignal = new Float32Array(durationsSamplesMax);
  for (let i = 0; i < durationsSamplesMax; i++) {
    noiseSignal[i] = Math.random() * 2 - 1;
  }

  // Compute the decay rate per-band and filter the decaying noise signal.
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Compute decay rate.
    let decayRate = -Utils.LOG1000 / durationsSamples[i];

    // Construct a standard one-zero, two-pole bandpass filter:
    // H(z) = (b0 * z^0 + b1 * z^-1 + b2 * z^-2) / (1 + a1 * z^-1 + a2 * z^-2)
    let omega = Utils.TWO_PI *
      Utils.DEFAULT_REVERB_FREQUENCY_BANDS[i] / sampleRate;
    let sinOmega = Math.sin(omega);
    let alpha = sinOmega * Math.sinh(this._bandwidthCoeff * omega / sinOmega);
    let a0CoeffReciprocal = 1 / (1 + alpha);
    let b0Coeff = alpha * a0CoeffReciprocal;
    let a1Coeff = -2 * Math.cos(omega) * a0CoeffReciprocal;
    let a2Coeff = (1 - alpha) * a0CoeffReciprocal;

    // We optimize since b2 = -b0, b1 = 0.
    // Update equation for two-pole bandpass filter:
    //   u[n] = x[n] - a1 * x[n-1] - a2 * x[n-2]
    //   y[n] = b0 * (u[n] - u[n-2])
    let um1 = 0;
    let um2 = 0;
    for (let j = 0; j < durationsSamples[i]; j++) {
      // Exponentially-decaying white noise.
      let x = noiseSignal[j] * Math.exp(decayRate * j);

      // Filter signal with bandpass filter and add to output.
      let u = x - a1Coeff * um1 - a2Coeff * um2;
      bufferData[j] += b0Coeff * (u - um2);

      // Update coefficients.
      um2 = um1;
      um1 = u;
    }
  }

  // Create and apply half of a Hann window to the beginning of the
  // impulse response.
  let halfHannLength =
    Math.round(this._tailonsetSamples);
  for (let i = 0; i < Math.min(bufferData.length, halfHannLength); i++) {
    let halfHann =
      0.5 * (1 - Math.cos(Utils.TWO_PI * i / (2 * halfHannLength - 1)));
      bufferData[i] *= halfHann;
  }
  this._convolver.buffer = buffer;
};


module.exports = LateReflections;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_128486__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Ray-tracing-based early reflections model.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_128486__(0);


/**
 * @class EarlyReflections
 * @description Ray-tracing-based early reflections model.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Object} options.dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 * @param {Number} options.speedOfSound
 * (in meters / second). Defaults to {@linkcode Utils.DEFAULT_SPEED_OF_SOUND
 * DEFAULT_SPEED_OF_SOUND}.
 * @param {Float32Array} options.listenerPosition
 * (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 */
function EarlyReflections(context, options) {
  // Public variables.
  /**
   * The room's speed of sound (in meters/second).
   * @member {Number} speedOfSound
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * First-order ambisonic (4-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof EarlyReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.coefficients == undefined) {
    options.coefficients = {};
    Object.assign(options.coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }

  // Assign room's speed of sound.
  this.speedOfSound = options.speedOfSound;

  // Create nodes.
  this.input = context.createGain();
  this.output = context.createGain();
  this._lowpass = context.createBiquadFilter();
  this._delays = {};
  this._gains = {}; // gainPerWall = (ReflectionCoeff / Attenuation)
  this._inverters = {}; // 3 of these are needed for right/back/down walls.
  this._merger = context.createChannelMerger(4); // First-order encoding only.

  // Connect audio graph for each wall reflection.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property] =
        context.createDelay(Utils.MAX_DURATION);
      this._gains[property] = context.createGain();
    }
  }
  this._inverters.right = context.createGain();
  this._inverters.down = context.createGain();
  this._inverters.back = context.createGain();

  // Initialize lowpass filter.
  this._lowpass.type = 'lowpass';
  this._lowpass.frequency.value = Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY;
  this._lowpass.Q.value = 0;

  // Initialize encoder directions, set delay times and gains to 0.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property].delayTime.value = 0;
      this._gains[property].gain.value = 0;
    }
  }

  // Initialize inverters for opposite walls ('right', 'down', 'back' only).
  this._inverters.right.gain.value = -1;
  this._inverters.down.gain.value = -1;
  this._inverters.back.gain.value = -1;

  // Connect nodes.
  this.input.connect(this._lowpass);
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._lowpass.connect(this._delays[property]);
      this._delays[property].connect(this._gains[property]);
      this._gains[property].connect(this._merger, 0, 0);
    }
  }

  // Connect gains to ambisonic channel output.
  // Left: [1 1 0 0]
  // Right: [1 -1 0 0]
  // Up: [1 0 1 0]
  // Down: [1 0 -1 0]
  // Front: [1 0 0 1]
  // Back: [1 0 0 -1]
  this._gains.left.connect(this._merger, 0, 1);

  this._gains.right.connect(this._inverters.right);
  this._inverters.right.connect(this._merger, 0, 1);

  this._gains.up.connect(this._merger, 0, 2);

  this._gains.down.connect(this._inverters.down);
  this._inverters.down.connect(this._merger, 0, 2);

  this._gains.front.connect(this._merger, 0, 3);

  this._gains.back.connect(this._inverters.back);
  this._inverters.back.connect(this._merger, 0, 3);
  this._merger.connect(this.output);

  // Initialize.
  this._listenerPosition = options.listenerPosition;
  this.setRoomProperties(options.dimensions, options.coefficients);
}


/**
 * Set the listener's position (in meters),
 * where [0,0,0] is the center of the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
EarlyReflections.prototype.setListenerPosition = function(x, y, z) {
  // Assign listener position.
  this._listenerPosition = [x, y, z];

  // Determine distances to each wall.
  let distances = {
    left: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width + x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    right: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width - x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    front: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth + z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    back: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth - z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    down: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height + y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    up: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height - y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
  };

  // Assign delay & attenuation values using distances.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute and assign delay (in seconds).
      let delayInSecs = distances[property] / this.speedOfSound;
      this._delays[property].delayTime.value = delayInSecs;

      // Compute and assign gain, uses logarithmic rolloff: "g = R / (d + 1)"
      let attenuation = this._coefficients[property] / distances[property];
      this._gains[property].gain.value = attenuation;
    }
  }
};


/**
 * Set the room's properties which determines the characteristics of
 * reflections.
 * @param {Object} dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 */
EarlyReflections.prototype.setRoomProperties = function(dimensions,
                                                        coefficients) {
  if (dimensions == undefined) {
    dimensions = {};
    Object.assign(dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (coefficients == undefined) {
    coefficients = {};
    Object.assign(coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }
  this._coefficients = coefficients;

  // Sanitize dimensions and store half-dimensions.
  this._halfDimensions = {};
  this._halfDimensions.width = dimensions.width * 0.5;
  this._halfDimensions.height = dimensions.height * 0.5;
  this._halfDimensions.depth = dimensions.depth * 0.5;

  // Update listener position with new room properties.
  this.setListenerPosition(this._listenerPosition[0],
    this._listenerPosition[1], this._listenerPosition[2]);
};


module.exports = EarlyReflections;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_137320__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Primary namespace for ResonanceAudio library.
 * @author Andrew Allen <bitllama@google.com>
 */

 


// Main module.
exports.ResonanceAudio = __nested_webpack_require_137320__(11);


// Testable Submodules.
exports.ResonanceAudio.Attenuation = __nested_webpack_require_137320__(6);
exports.ResonanceAudio.Directivity = __nested_webpack_require_137320__(5);
exports.ResonanceAudio.EarlyReflections = __nested_webpack_require_137320__(9);
exports.ResonanceAudio.Encoder = __nested_webpack_require_137320__(1);
exports.ResonanceAudio.LateReflections = __nested_webpack_require_137320__(8);
exports.ResonanceAudio.Listener = __nested_webpack_require_137320__(2);
exports.ResonanceAudio.Room = __nested_webpack_require_137320__(7);
exports.ResonanceAudio.Source = __nested_webpack_require_137320__(4);
exports.ResonanceAudio.Tables = __nested_webpack_require_137320__(3);
exports.ResonanceAudio.Utils = __nested_webpack_require_137320__(0);
exports.ResonanceAudio.Version = __nested_webpack_require_137320__(13);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_138892__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library name space and common utilities.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Listener = __nested_webpack_require_138892__(2);
const Source = __nested_webpack_require_138892__(4);
const Room = __nested_webpack_require_138892__(7);
const Encoder = __nested_webpack_require_138892__(1);
const Utils = __nested_webpack_require_138892__(0);


/**
 * @class ResonanceAudio
 * @description Main class for managing sources, room and listener models.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic Order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.listenerForward
 * The listener's initial forward vector.
 * Defaults to {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.listenerUp
 * The listener's initial up vector.
 * Defaults to {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function ResonanceAudio(context, options) {
  // Public variables.
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For rendering input soundfields).
   * @member {AudioNode} ambisonicInput
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For allowing external rendering / post-processing).
   * @member {AudioNode} ambisonicOutput
   * @memberof ResonanceAudio
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.listenerForward == undefined) {
    options.listenerForward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.listenerUp == undefined) {
    options.listenerUp = Utils.DEFAULT_UP.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Create member submodules.
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(options.ambisonicOrder);
  this._sources = [];
  this._room = new Room(context, {
    listenerPosition: options.listenerPosition,
    dimensions: options.dimensions,
    materials: options.materials,
    speedOfSound: options.speedOfSound,
  });
  this._listener = new Listener(context, {
    ambisonicOrder: options.ambisonicOrder,
    position: options.listenerPosition,
    forward: options.listenerForward,
    up: options.listenerUp,
  });

  // Create auxillary audio nodes.
  this._context = context;
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();
  this.ambisonicInput = this._listener.input;

  // Connect audio graph.
  this._room.output.connect(this._listener.input);
  this._listener.output.connect(this.output);
  this._listener.ambisonicOutput.connect(this.ambisonicOutput);
}


/**
 * Create a new source for the scene.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 * @return {Source}
 */
ResonanceAudio.prototype.createSource = function(options) {
  // Create a source and push it to the internal sources array, returning
  // the object's reference to the user.
  let source = new Source(this, options);
  this._sources[this._sources.length] = source;
  return source;
};


/**
 * Set the scene's desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
ResonanceAudio.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);
};


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters).
 * @param {Object} materials Named acoustic materials per wall.
 */
ResonanceAudio.prototype.setRoomProperties = function(dimensions, materials) {
  this._room.setProperties(dimensions, materials);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
ResonanceAudio.prototype.setListenerPosition = function(x, y, z) {
  // Update listener position.
  this._listener.position[0] = x;
  this._listener.position[1] = y;
  this._listener.position[2] = z;
  this._room.setListenerPosition(x, y, z);

  // Update sources with new listener position.
  this._sources.forEach(function(element) {
     element._update();
  });
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
ResonanceAudio.prototype.setListenerOrientation = function(forwardX, forwardY,
  forwardZ, upX, upY, upZ) {
  this._listener.setOrientation(forwardX, forwardY, forwardZ, upX, upY, upZ);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix
 * The Three.js Matrix4 object representing the listener's world transform.
 */
ResonanceAudio.prototype.setListenerFromMatrix = function(matrix) {
  this._listener.setFromMatrix(matrix);

  // Update the rest of the scene using new listener position.
  this.setListenerPosition(this._listener.position[0],
    this._listener.position[1], this._listener.position[2]);
};


/**
 * Set the speed of sound.
 * @param {Number} speedOfSound
 */
ResonanceAudio.prototype.setSpeedOfSound = function(speedOfSound) {
  this._room.speedOfSound = speedOfSound;
};


module.exports = ResonanceAudio;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_148723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_148723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_148723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_148723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_148723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_148723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_148723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_148723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_148723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_148723__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_148723__(__nested_webpack_require_148723__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library common utilities.
 */


/**
 * Omnitone library logging function.
 * @param {any} Message to be printed out.
 */
exports.log = function() {
  window.console.log.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 500', 'font-weight: 300',
    'color: #AAA',
  ]);
};


/**
 * Omnitone library error-throwing function.
 * @param {any} Message to be printed out.
 */
exports.throw = function() {
  window.console.error.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #C62828; color: #FFEBEE; font-weight: 800', 'font-weight: 400',
    'color: #AAA',
  ]);

  throw new Error(false);
};


// Static temp storage for matrix inversion.
let a00;
let a01;
let a02;
let a03;
let a10;
let a11;
let a12;
let a13;
let a20;
let a21;
let a22;
let a23;
let a30;
let a31;
let a32;
let a33;
let b00;
let b01;
let b02;
let b03;
let b04;
let b05;
let b06;
let b07;
let b08;
let b09;
let b10;
let b11;
let det;


/**
 * A 4x4 matrix inversion utility. This does not handle the case when the
 * arguments are not proper 4x4 matrices.
 * @param {Float32Array} out   The inverted result.
 * @param {Float32Array} a     The source matrix.
 * @return {Float32Array} out
 */
exports.invertMatrix4 = function(out, a) {
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  a30 = a[12];
  a31 = a[13];
  a32 = a[14];
  a33 = a[15];
  b00 = a00 * a11 - a01 * a10;
  b01 = a00 * a12 - a02 * a10;
  b02 = a00 * a13 - a03 * a10;
  b03 = a01 * a12 - a02 * a11;
  b04 = a01 * a13 - a03 * a11;
  b05 = a02 * a13 - a03 * a12;
  b06 = a20 * a31 - a21 * a30;
  b07 = a20 * a32 - a22 * a30;
  b08 = a20 * a33 - a23 * a30;
  b09 = a21 * a32 - a22 * a31;
  b10 = a21 * a33 - a23 * a31;
  b11 = a22 * a33 - a23 * a32;
  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
};


/**
 * Check if a value is defined in the ENUM dictionary.
 * @param {Object} enumDictionary - ENUM dictionary.
 * @param {Number|String} entryValue - a value to probe.
 * @return {Boolean}
 */
exports.isDefinedENUMEntry = function(enumDictionary, entryValue) {
  for (let enumKey in enumDictionary) {
    if (entryValue === enumDictionary[enumKey]) {
      return true;
    }
  }
  return false;
};


/**
 * Check if the given object is an instance of BaseAudioContext.
 * @param {AudioContext} context - A context object to be checked.
 * @return {Boolean}
 */
exports.isAudioContext = function(context) {
  // TODO(hoch): Update this when BaseAudioContext is available for all
  // browsers.
  return context instanceof AudioContext ||
    context instanceof OfflineAudioContext;
};


/**
 * Check if the given object is a valid AudioBuffer.
 * @param {Object} audioBuffer An AudioBuffer object to be checked.
 * @return {Boolean}
 */
exports.isAudioBuffer = function(audioBuffer) {
  return audioBuffer instanceof AudioBuffer;
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
exports.mergeBufferListByChannel = function(context, bufferList) {
  const bufferLength = bufferList[0].length;
  const bufferSampleRate = bufferList[0].sampleRate;
  let bufferNumberOfChannel = 0;

  for (let i = 0; i < bufferList.length; ++i) {
    if (bufferNumberOfChannel > 32) {
      exports.throw('Utils.mergeBuffer: Number of channels cannot exceed 32.' +
          '(got ' + bufferNumberOfChannel + ')');
    }
    if (bufferLength !== bufferList[i].length) {
      exports.throw('Utils.mergeBuffer: AudioBuffer lengths are ' +
          'inconsistent. (expected ' + bufferLength + ' but got ' +
          bufferList[i].length + ')');
    }
    if (bufferSampleRate !== bufferList[i].sampleRate) {
      exports.throw('Utils.mergeBuffer: AudioBuffer sample rates are ' +
          'inconsistent. (expected ' + bufferSampleRate + ' but got ' +
          bufferList[i].sampleRate + ')');
    }
    bufferNumberOfChannel += bufferList[i].numberOfChannels;
  }

  const buffer = context.createBuffer(bufferNumberOfChannel,
                                      bufferLength,
                                      bufferSampleRate);
  let destinationChannelIndex = 0;
  for (let i = 0; i < bufferList.length; ++i) {
    for (let j = 0; j < bufferList[i].numberOfChannels; ++j) {
      buffer.getChannelData(destinationChannelIndex++).set(
          bufferList[i].getChannelData(j));
    }
  }

  return buffer;
};


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
exports.splitBufferbyChannel = function(context, audioBuffer, splitBy) {
  if (audioBuffer.numberOfChannels <= splitBy) {
    exports.throw('Utils.splitBuffer: Insufficient number of channels. (' +
        audioBuffer.numberOfChannels + ' splitted by ' + splitBy + ')');
  }

  let bufflerList = [];
  let sourceChannelIndex = 0;
  const numberOfSplittedBuffer =
      Math.ceil(audioBuffer.numberOfChannels / splitBy);
  for (let i = 0; i < numberOfSplittedBuffer; ++i) {
    let buffer = context.createBuffer(splitBy,
                                      audioBuffer.length,
                                      audioBuffer.sampleRate);
    for (let j = 0; j < splitBy; ++j) {
      if (sourceChannelIndex < audioBuffer.numberOfChannels) {
        buffer.getChannelData(j).set(
          audioBuffer.getChannelData(sourceChannelIndex++));
      }
    }
    bufflerList.push(buffer);
  }

  return bufferList;
};


/**
 * Converts Base64-encoded string to ArrayBuffer.
 * @param {string} base64String - Base64-encdoed string.
 * @return {ArrayByuffer} Converted ArrayBuffer object.
 */
exports.getArrayBufferFromBase64String = function(base64String) {
  let binaryString = window.atob(base64String);
  let byteArray = new Uint8Array(binaryString.length);
  byteArray.forEach(
    (value, index) => byteArray[index] = binaryString.charCodeAt(index));
  return byteArray.buffer;
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_159425__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Streamlined AudioBuffer loader.
 */




const Utils = __nested_webpack_require_159425__(0);

/**
 * @typedef {string} BufferDataType
 */

/**
 * Buffer data type for ENUM.
 * @enum {BufferDataType}
 */
const BufferDataType = {
  /** @type {string} The data contains Base64-encoded string.. */
  BASE64: 'base64',
  /** @type {string} The data is a URL for audio file. */
  URL: 'url',
};


/**
 * BufferList object mananges the async loading/decoding of multiple
 * AudioBuffers from multiple URLs.
 * @constructor
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} options - Options
 * @param {string} [options.dataType='base64'] - BufferDataType specifier.
 * @param {Boolean} [options.verbose=false] - Log verbosity. |true| prints the
 * individual message from each URL and AudioBuffer.
 */
function BufferList(context, bufferData, options) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('BufferList: Invalid BaseAudioContext.');

  this._options = {
    dataType: BufferDataType.BASE64,
    verbose: false,
  };

  if (options) {
    if (options.dataType &&
        Utils.isDefinedENUMEntry(BufferDataType, options.dataType)) {
      this._options.dataType = options.dataType;
    }
    if (options.verbose) {
      this._options.verbose = Boolean(options.verbose);
    }
  }

  this._bufferList = [];
  this._bufferData = this._options.dataType === BufferDataType.BASE64
      ? bufferData
      : bufferData.slice(0);
  this._numberOfTasks = this._bufferData.length;

  this._resolveHandler = null;
  this._rejectHandler = new Function();
}


/**
 * Starts AudioBuffer loading tasks.
 * @return {Promise<AudioBuffer[]>} The promise resolves with an array of
 * AudioBuffer.
 */
BufferList.prototype.load = function() {
  return new Promise(this._promiseGenerator.bind(this));
};


/**
 * Promise argument generator. Internally starts multiple async loading tasks.
 * @private
 * @param {function} resolve Promise resolver.
 * @param {function} reject Promise reject.
 */
BufferList.prototype._promiseGenerator = function(resolve, reject) {
  if (typeof resolve !== 'function') {
    Utils.throw('BufferList: Invalid Promise resolver.');
  } else {
    this._resolveHandler = resolve;
  }

  if (typeof reject === 'function') {
    this._rejectHandler = reject;
  }

  for (let i = 0; i < this._bufferData.length; ++i) {
    this._options.dataType === BufferDataType.BASE64
        ? this._launchAsyncLoadTask(i)
        : this._launchAsyncLoadTaskXHR(i);
  }
};


/**
 * Run async loading task for Base64-encoded string.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTask = function(taskId) {
  const that = this;
  this._context.decodeAudioData(
      Utils.getArrayBufferFromBase64String(this._bufferData[taskId]),
      function(audioBuffer) {
        that._updateProgress(taskId, audioBuffer);
      },
      function(errorMessage) {
        that._updateProgress(taskId, null);
        const message = 'BufferList: decoding ArrayByffer("' + taskId +
            '" from Base64-encoded data failed. (' + errorMessage + ')';
        Utils.throw(message);
        that._rejectHandler(message);
      });
};


/**
 * Run async loading task via XHR for audio file URLs.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTaskXHR = function(taskId) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', this._bufferData[taskId]);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(
          xhr.response,
          function(audioBuffer) {
            that._updateProgress(taskId, audioBuffer);
          },
          function(errorMessage) {
            that._updateProgress(taskId, null);
            const message = 'BufferList: decoding "' +
                that._bufferData[taskId] + '" failed. (' + errorMessage + ')';
            Utils.throw(message);
            that._rejectHandler(message);
          });
    } else {
      const message = 'BufferList: XHR error while loading "' +
          that._bufferData[taskId] + '(' + xhr.statusText + ')';
      Utils.throw(message);
      that._rejectHandler(message);
    }
  };

  xhr.onerror = function(event) {
    Utils.throw(
        'BufferList: XHR network failed on loading "' +
        that._bufferData[taskId] + '".');
    that._updateProgress(taskId, null);
    that._rejectHandler();
  };

  xhr.send();
};


/**
 * Updates the overall progress on loading tasks.
 * @param {Number} taskId Task ID number.
 * @param {AudioBuffer} audioBuffer Decoded AudioBuffer object.
 */
BufferList.prototype._updateProgress = function(taskId, audioBuffer) {
  this._bufferList[taskId] = audioBuffer;

  if (this._options.verbose) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? 'ArrayBuffer(' + taskId + ') from Base64-encoded HRIR'
        : '"' + this._bufferData[taskId] + '"';
    Utils.log('BufferList: ' + messageString + ' successfully loaded.');
  }

  if (--this._numberOfTasks === 0) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? this._bufferData.length + ' AudioBuffers from Base64-encoded HRIRs'
        : this._bufferData.length + ' files via XHR';
    Utils.log('BufferList: ' + messageString + ' loaded successfully.');
    this._resolveHandler(this._bufferList);
  }
};


module.exports = BufferList;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file An audio channel router to resolve different channel layouts between
 * browsers.
 */




/**
 * @typedef {Number[]} ChannelMap
 */

/**
 * Channel map dictionary ENUM.
 * @enum {ChannelMap}
 */
const ChannelMap = {
  /** @type {Number[]} - ACN channel map for Chrome and FireFox. (FFMPEG) */
  DEFAULT: [0, 1, 2, 3],
  /** @type {Number[]} - Safari's 4-channel map for AAC codec. */
  SAFARI: [2, 0, 1, 3],
  /** @type {Number[]} - ACN > FuMa conversion map. */
  FUMA: [0, 3, 1, 2],
};


/**
 * Channel router for FOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 */
function FOARouter(context, channelMap) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._merger = this._context.createChannelMerger(4);

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;

  this.setChannelMap(channelMap || ChannelMap.DEFAULT);
}


/**
 * Sets channel map.
 * @param {Number[]} channelMap - A new channel map for FOA stream.
 */
FOARouter.prototype.setChannelMap = function(channelMap) {
  if (!Array.isArray(channelMap)) {
    return;
  }

  this._channelMap = channelMap;
  this._splitter.disconnect();
  this._splitter.connect(this._merger, 0, this._channelMap[0]);
  this._splitter.connect(this._merger, 1, this._channelMap[1]);
  this._splitter.connect(this._merger, 2, this._channelMap[2]);
  this._splitter.connect(this._merger, 3, this._channelMap[3]);
};


/**
 * Static channel map ENUM.
 * @static
 * @type {ChannelMap}
 */
FOARouter.ChannelMap = ChannelMap;


module.exports = FOARouter;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for first-order-ambisonics decoding.
 */




/**
 * First-order-ambisonic decoder based on gain node network.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOARotator(context) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._inY = this._context.createGain();
  this._inZ = this._context.createGain();
  this._inX = this._context.createGain();
  this._m0 = this._context.createGain();
  this._m1 = this._context.createGain();
  this._m2 = this._context.createGain();
  this._m3 = this._context.createGain();
  this._m4 = this._context.createGain();
  this._m5 = this._context.createGain();
  this._m6 = this._context.createGain();
  this._m7 = this._context.createGain();
  this._m8 = this._context.createGain();
  this._outY = this._context.createGain();
  this._outZ = this._context.createGain();
  this._outX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  // ACN channel ordering: [1, 2, 3] => [-Y, Z, -X]
  // Y (from channel 1)
  this._splitter.connect(this._inY, 1);
  // Z (from channel 2)
  this._splitter.connect(this._inZ, 2);
  // X (from channel 3)
  this._splitter.connect(this._inX, 3);
  this._inY.gain.value = -1;
  this._inX.gain.value = -1;

  // Apply the rotation in the world space.
  // |Y|   | m0  m3  m6 |   | Y * m0 + Z * m3 + X * m6 |   | Yr |
  // |Z| * | m1  m4  m7 | = | Y * m1 + Z * m4 + X * m7 | = | Zr |
  // |X|   | m2  m5  m8 |   | Y * m2 + Z * m5 + X * m8 |   | Xr |
  this._inY.connect(this._m0);
  this._inY.connect(this._m1);
  this._inY.connect(this._m2);
  this._inZ.connect(this._m3);
  this._inZ.connect(this._m4);
  this._inZ.connect(this._m5);
  this._inX.connect(this._m6);
  this._inX.connect(this._m7);
  this._inX.connect(this._m8);
  this._m0.connect(this._outY);
  this._m1.connect(this._outZ);
  this._m2.connect(this._outX);
  this._m3.connect(this._outY);
  this._m4.connect(this._outZ);
  this._m5.connect(this._outX);
  this._m6.connect(this._outY);
  this._m7.connect(this._outZ);
  this._m8.connect(this._outX);

  // Transform 3: world space to audio space.
  // W -> W (to channel 0)
  this._splitter.connect(this._merger, 0, 0);
  // Y (to channel 1)
  this._outY.connect(this._merger, 0, 1);
  // Z (to channel 2)
  this._outZ.connect(this._merger, 0, 2);
  // X (to channel 3)
  this._outX.connect(this._merger, 0, 3);
  this._outY.gain.value = -1;
  this._outX.gain.value = -1;

  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  this._m0.gain.value = rotationMatrix3[0];
  this._m1.gain.value = rotationMatrix3[1];
  this._m2.gain.value = rotationMatrix3[2];
  this._m3.gain.value = rotationMatrix3[3];
  this._m4.gain.value = rotationMatrix3[4];
  this._m5.gain.value = rotationMatrix3[5];
  this._m6.gain.value = rotationMatrix3[6];
  this._m7.gain.value = rotationMatrix3[7];
  this._m8.gain.value = rotationMatrix3[8];
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._m0.gain.value = rotationMatrix4[0];
  this._m1.gain.value = rotationMatrix4[1];
  this._m2.gain.value = rotationMatrix4[2];
  this._m3.gain.value = rotationMatrix4[4];
  this._m4.gain.value = rotationMatrix4[5];
  this._m5.gain.value = rotationMatrix4[6];
  this._m6.gain.value = rotationMatrix4[8];
  this._m7.gain.value = rotationMatrix4[9];
  this._m8.gain.value = rotationMatrix4[10];
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix3 = function() {
  return [
    this._m0.gain.value, this._m1.gain.value, this._m2.gain.value,
    this._m3.gain.value, this._m4.gain.value, this._m5.gain.value,
    this._m6.gain.value, this._m7.gain.value, this._m8.gain.value,
  ];
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._m0.gain.value;
  rotationMatrix4[1] = this._m1.gain.value;
  rotationMatrix4[2] = this._m2.gain.value;
  rotationMatrix4[4] = this._m3.gain.value;
  rotationMatrix4[5] = this._m4.gain.value;
  rotationMatrix4[6] = this._m5.gain.value;
  rotationMatrix4[8] = this._m6.gain.value;
  rotationMatrix4[9] = this._m7.gain.value;
  rotationMatrix4[10] = this._m8.gain.value;
  return rotationMatrix4;
};


module.exports = FOARotator;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized FOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * FOAConvolver. A collection of 2 stereo convolvers for 4-channel FOA stream.
 * @constructor
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (i.e. 2 stereo AudioBuffers for FOA)
 */
function FOAConvolver(context, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  this._buildAudioGraph();

  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 *
 * @private
 */
FOAConvolver.prototype._buildAudioGraph = function() {
  this._splitterWYZX = this._context.createChannelSplitter(4);
  this._mergerWY = this._context.createChannelMerger(2);
  this._mergerZX = this._context.createChannelMerger(2);
  this._convolverWY = this._context.createConvolver();
  this._convolverZX = this._context.createConvolver();
  this._splitterWY = this._context.createChannelSplitter(2);
  this._splitterZX = this._context.createChannelSplitter(2);
  this._inverter = this._context.createGain();
  this._mergerBinaural = this._context.createChannelMerger(2);
  this._summingBus = this._context.createGain();

  // Group W and Y, then Z and X.
  this._splitterWYZX.connect(this._mergerWY, 0, 0);
  this._splitterWYZX.connect(this._mergerWY, 1, 1);
  this._splitterWYZX.connect(this._mergerZX, 2, 0);
  this._splitterWYZX.connect(this._mergerZX, 3, 1);

  // Create a network of convolvers using splitter/merger.
  this._mergerWY.connect(this._convolverWY);
  this._mergerZX.connect(this._convolverZX);
  this._convolverWY.connect(this._splitterWY);
  this._convolverZX.connect(this._splitterZX);
  this._splitterWY.connect(this._mergerBinaural, 0, 0);
  this._splitterWY.connect(this._mergerBinaural, 0, 1);
  this._splitterWY.connect(this._mergerBinaural, 1, 0);
  this._splitterWY.connect(this._inverter, 1, 0);
  this._inverter.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 0, 0);
  this._splitterZX.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 1, 0);
  this._splitterZX.connect(this._mergerBinaural, 1, 1);

  // By default, WebAudio's convolver does the normalization based on IR's
  // energy. For the precise convolution, it must be disabled before the buffer
  // assignment.
  this._convolverWY.normalize = false;
  this._convolverZX.normalize = false;

  // For asymmetric degree.
  this._inverter.gain.value = -1;

  // Input/output proxy.
  this.input = this._splitterWYZX;
  this.output = this._summingBus;
};


/**
 * Assigns 2 HRIR AudioBuffers to 2 convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
FOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  this._convolverWY.buffer = hrirBufferList[0];
  this._convolverZX.buffer = hrirBufferList[1];
  this._isBufferLoaded = true;
};


/**
 * Enable FOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
FOAConvolver.prototype.enable = function() {
  this._mergerBinaural.connect(this._summingBus);
  this._active = true;
};


/**
 * Disable FOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
FOAConvolver.prototype.disable = function() {
  this._mergerBinaural.disconnect();
  this._active = false;
};


module.exports = FOAConvolver;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_178724__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileOverview DEPRECATED at V1. Audio buffer loading utility.
 */



const Utils = __nested_webpack_require_178724__(0);

/**
 * Streamlined audio file loader supports Promise.
 * @param {Object} context          AudioContext
 * @param {Object} audioFileData    Audio file info as [{name, url}]
 * @param {Function} resolve        Resolution handler for promise.
 * @param {Function} reject         Rejection handler for promise.
 * @param {Function} progress       Progress event handler.
 */
function AudioBufferManager(context, audioFileData, resolve, reject, progress) {
  this._context = context;

  this._buffers = new Map();
  this._loadingTasks = {};

  this._resolve = resolve;
  this._reject = reject;
  this._progress = progress;

  // Iterating file loading.
  for (let i = 0; i < audioFileData.length; i++) {
    const fileInfo = audioFileData[i];

    // Check for duplicates filename and quit if it happens.
    if (this._loadingTasks.hasOwnProperty(fileInfo.name)) {
      Utils.log('Duplicated filename when loading: ' + fileInfo.name);
      return;
    }

    // Mark it as pending (0)
    this._loadingTasks[fileInfo.name] = 0;
    this._loadAudioFile(fileInfo);
  }
}

AudioBufferManager.prototype._loadAudioFile = function(fileInfo) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', fileInfo.url);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(xhr.response,
        function(buffer) {
          // Utils.log('File loaded: ' + fileInfo.url);
          that._done(fileInfo.name, buffer);
        },
        function(message) {
          Utils.log('Decoding failure: '
            + fileInfo.url + ' (' + message + ')');
          that._done(fileInfo.name, null);
        });
    } else {
      Utils.log('XHR Error: ' + fileInfo.url + ' (' + xhr.statusText
        + ')');
      that._done(fileInfo.name, null);
    }
  };

  // TODO: fetch local resources if XHR fails.
  xhr.onerror = function(event) {
    Utils.log('XHR Network failure: ' + fileInfo.url);
    that._done(fileInfo.name, null);
  };

  xhr.send();
};

AudioBufferManager.prototype._done = function(filename, buffer) {
  // Label the loading task.
  this._loadingTasks[filename] = buffer !== null ? 'loaded' : 'failed';

  // A failed task will be a null buffer.
  this._buffers.set(filename, buffer);

  this._updateProgress(filename);
};

AudioBufferManager.prototype._updateProgress = function(filename) {
  let numberOfFinishedTasks = 0;
  let numberOfFailedTask = 0;
  let numberOfTasks = 0;

  for (const task in this._loadingTasks) {
    if (Object.prototype.hasOwnProperty.call(this._loadingTasks, task)) {
      numberOfTasks++;
      if (this._loadingTasks[task] === 'loaded') {
        numberOfFinishedTasks++;
      } else if (this._loadingTasks[task] === 'failed') {
        numberOfFailedTask++;
      }
    }
  }

  if (typeof this._progress === 'function') {
    this._progress(filename, numberOfFinishedTasks, numberOfTasks);
    return;
  }

  if (numberOfFinishedTasks === numberOfTasks) {
    this._resolve(this._buffers);
    return;
  }

  if (numberOfFinishedTasks + numberOfFailedTask === numberOfTasks) {
    this._reject(this._buffers);
    return;
  }
};

module.exports = AudioBufferManager;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_182743__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Phase matched filter for first-order-ambisonics decoding.
 */



const Utils = __nested_webpack_require_182743__(0);


// Static parameters.
const CROSSOVER_FREQUENCY = 690;
const GAIN_COEFFICIENTS = [1.4142, 0.8166, 0.8166, 0.8166];


/**
 * Generate the coefficients for dual band filter.
 * @param {Number} crossoverFrequency
 * @param {Number} sampleRate
 * @return {Object} Filter coefficients.
 */
function generateDualBandCoefficients(crossoverFrequency, sampleRate) {
  const k = Math.tan(Math.PI * crossoverFrequency / sampleRate);
  const k2 = k * k;
  const denominator = k2 + 2 * k + 1;

  return {
    lowpassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    lowpassB: [k2 / denominator, 2 * k2 / denominator, k2 / denominator],
    hipassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    hipassB: [1 / denominator, -2 * 1 / denominator, 1 / denominator],
  };
}


/**
 * FOAPhaseMatchedFilter: A set of filters (LP/HP) with a crossover frequency to
 * compensate the gain of high frequency contents without a phase difference.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOAPhaseMatchedFilter(context) {
  this._context = context;

  this._input = this._context.createGain();

  if (!this._context.createIIRFilter) {
    Utils.log('IIR filter is missing. Using Biquad filter instead.');
    this._lpf = this._context.createBiquadFilter();
    this._hpf = this._context.createBiquadFilter();
    this._lpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.type = 'highpass';
  } else {
    const coef = generateDualBandCoefficients(CROSSOVER_FREQUENCY,
                                              this._context.sampleRate);
    this._lpf = this._context.createIIRFilter(coef.lowpassB, coef.lowpassA);
    this._hpf = this._context.createIIRFilter(coef.hipassB, coef.hipassA);
  }

  this._splitterLow = this._context.createChannelSplitter(4);
  this._splitterHigh = this._context.createChannelSplitter(4);
  this._gainHighW = this._context.createGain();
  this._gainHighY = this._context.createGain();
  this._gainHighZ = this._context.createGain();
  this._gainHighX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  this._input.connect(this._hpf);
  this._hpf.connect(this._splitterHigh);
  this._splitterHigh.connect(this._gainHighW, 0);
  this._splitterHigh.connect(this._gainHighY, 1);
  this._splitterHigh.connect(this._gainHighZ, 2);
  this._splitterHigh.connect(this._gainHighX, 3);
  this._gainHighW.connect(this._merger, 0, 0);
  this._gainHighY.connect(this._merger, 0, 1);
  this._gainHighZ.connect(this._merger, 0, 2);
  this._gainHighX.connect(this._merger, 0, 3);

  this._input.connect(this._lpf);
  this._lpf.connect(this._splitterLow);
  this._splitterLow.connect(this._merger, 0, 0);
  this._splitterLow.connect(this._merger, 1, 1);
  this._splitterLow.connect(this._merger, 2, 2);
  this._splitterLow.connect(this._merger, 3, 3);

  // Apply gain correction to hi-passed pressure and velocity components:
  // Inverting sign is necessary as the low-passed and high-passed portion are
  // out-of-phase after the filtering.
  const now = this._context.currentTime;
  this._gainHighW.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[0], now);
  this._gainHighY.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[1], now);
  this._gainHighZ.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[2], now);
  this._gainHighX.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[3], now);

  // Input/output Proxy.
  this.input = this._input;
  this.output = this._merger;
}


module.exports = FOAPhaseMatchedFilter;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Virtual speaker abstraction for first-order-ambisonics decoding.
 */




/**
 * DEPRECATED at V1: A virtual speaker with ambisonic decoding gain coefficients
 * and HRTF convolution for first-order-ambisonics stream. Note that the
 * subgraph directly connects to context's destination.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options for speaker.
 * @param {Number[]} options.coefficients - Decoding coefficients for (W,Y,Z,X).
 * @param {AudioBuffer} options.IR - Stereo IR buffer for HRTF convolution.
 * @param {Number} options.gain - Post-gain for the speaker.
 */
function FOAVirtualSpeaker(context, options) {
  if (options.IR.numberOfChannels !== 2) {
    throw new Error('IR does not have 2 channels. cannot proceed.');
  }

  this._active = false;
  this._context = context;

  this._input = this._context.createChannelSplitter(4);
  this._cW = this._context.createGain();
  this._cY = this._context.createGain();
  this._cZ = this._context.createGain();
  this._cX = this._context.createGain();
  this._convolver = this._context.createConvolver();
  this._gain = this._context.createGain();

  this._input.connect(this._cW, 0);
  this._input.connect(this._cY, 1);
  this._input.connect(this._cZ, 2);
  this._input.connect(this._cX, 3);
  this._cW.connect(this._convolver);
  this._cY.connect(this._convolver);
  this._cZ.connect(this._convolver);
  this._cX.connect(this._convolver);
  this._convolver.connect(this._gain);
  this._gain.connect(this._context.destination);

  this.enable();

  this._convolver.normalize = false;
  this._convolver.buffer = options.IR;
  this._gain.gain.value = options.gain;

  // Set gain coefficients for FOA ambisonic streams.
  this._cW.gain.value = options.coefficients[0];
  this._cY.gain.value = options.coefficients[1];
  this._cZ.gain.value = options.coefficients[2];
  this._cX.gain.value = options.coefficients[3];

  // Input proxy. Output directly connects to the destination.
  this.input = this._input;
}


FOAVirtualSpeaker.prototype.enable = function() {
  this._gain.connect(this._context.destination);
  this._active = true;
};


FOAVirtualSpeaker.prototype.disable = function() {
  this._gain.disconnect();
  this._active = false;
};


module.exports = FOAVirtualSpeaker;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized HOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * A convolver network for N-channel HOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 */
function HOAConvolver(context, ambisonicOrder, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  // The number of channels K based on the ambisonic order N where K = (N+1)^2.
  this._ambisonicOrder = ambisonicOrder;
  this._numberOfChannels =
      (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);

  this._buildAudioGraph();
  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 * For TOA convolution:
 *   input -> splitter(16) -[0,1]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[2,3]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[4,5]-> ... (6 more, 8 branches total)
 * @private
 */
HOAConvolver.prototype._buildAudioGraph = function() {
  const numberOfStereoChannels = Math.ceil(this._numberOfChannels / 2);

  this._inputSplitter =
      this._context.createChannelSplitter(this._numberOfChannels);
  this._stereoMergers = [];
  this._convolvers = [];
  this._stereoSplitters = [];
  this._positiveIndexSphericalHarmonics = this._context.createGain();
  this._negativeIndexSphericalHarmonics = this._context.createGain();
  this._inverter = this._context.createGain();
  this._binauralMerger = this._context.createChannelMerger(2);
  this._outputGain = this._context.createGain();

  for (let i = 0; i < numberOfStereoChannels; ++i) {
    this._stereoMergers[i] = this._context.createChannelMerger(2);
    this._convolvers[i] = this._context.createConvolver();
    this._stereoSplitters[i] = this._context.createChannelSplitter(2);
    this._convolvers[i].normalize = false;
  }

  for (let l = 0; l <= this._ambisonicOrder; ++l) {
    for (let m = -l; m <= l; m++) {
      // We compute the ACN index (k) of ambisonics channel using the degree (l)
      // and index (m): k = l^2 + l + m
      const acnIndex = l * l + l + m;
      const stereoIndex = Math.floor(acnIndex / 2);

      // Split channels from input into array of stereo convolvers.
      // Then create a network of mergers that produces the stereo output.
      this._inputSplitter.connect(
          this._stereoMergers[stereoIndex], acnIndex, acnIndex % 2);
      this._stereoMergers[stereoIndex].connect(this._convolvers[stereoIndex]);
      this._convolvers[stereoIndex].connect(this._stereoSplitters[stereoIndex]);

      // Positive index (m >= 0) spherical harmonics are symmetrical around the
      // front axis, while negative index (m < 0) spherical harmonics are
      // anti-symmetrical around the front axis. We will exploit this symmetry
      // to reduce the number of convolutions required when rendering to a
      // symmetrical binaural renderer.
      if (m >= 0) {
        this._stereoSplitters[stereoIndex].connect(
            this._positiveIndexSphericalHarmonics, acnIndex % 2);
      } else {
        this._stereoSplitters[stereoIndex].connect(
            this._negativeIndexSphericalHarmonics, acnIndex % 2);
      }
    }
  }

  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 1);
  this._negativeIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._negativeIndexSphericalHarmonics.connect(this._inverter);
  this._inverter.connect(this._binauralMerger, 0, 1);

  // For asymmetric index.
  this._inverter.gain.value = -1;

  // Input/Output proxy.
  this.input = this._inputSplitter;
  this.output = this._outputGain;
};


/**
 * Assigns N HRIR AudioBuffers to N convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
HOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  for (let i = 0; i < hrirBufferList.length; ++i) {
    this._convolvers[i].buffer = hrirBufferList[i];
  }

  this._isBufferLoaded = true;
};


/**
 * Enable HOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
HOAConvolver.prototype.enable = function() {
  this._binauralMerger.connect(this._outputGain);
  this._active = true;
};


/**
 * Disable HOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
HOAConvolver.prototype.disable = function() {
  this._binauralMerger.disconnect();
  this._active = false;
};


module.exports = HOAConvolver;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for higher-order-ambisonics decoding.
 */




/**
 * Kronecker Delta function.
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getKroneckerDelta(i, j) {
  return i === j ? 1 : 0;
}


/**
 * A helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1)x(2l+1) matrix. [2] uses an odd convention of
 * referring to the rows and columns using centered indices, so the middle row
 * and column are (0, 0) and the upper left would have negative coordinates.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @param {Number} gainValue
 */
function setCenteredElement(matrix, l, i, j, gainValue) {
  const index = (j + l) * (2 * l + 1) + (i + l);
  // Row-wise indexing.
  matrix[l - 1][index].gain.value = gainValue;
}


/**
 * This is a helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1) x (2l+1) matrix.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getCenteredElement(matrix, l, i, j) {
  // Row-wise indexing.
  const index = (j + l) * (2 * l + 1) + (i + l);
  return matrix[l - 1][index].gain.value;
}


/**
 * Helper function defined in [2] that is used by the functions U, V, W.
 * This should not be called on its own, as U, V, and W (and their coefficients)
 * select the appropriate matrix elements to access arguments |a| and |b|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} i
 * @param {Number} a
 * @param {Number} b
 * @param {Number} l
 * @return {Number}
 */
function getP(matrix, i, a, b, l) {
  if (b === l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, l - 1) -
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, -l + 1);
  } else if (b === -l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, -l + 1) +
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, l - 1);
  } else {
    return getCenteredElement(matrix, 1, i, 0) *
        getCenteredElement(matrix, l - 1, a, b);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getU(matrix, m, n, l) {
  // Although [1, 2] split U into three cases for m == 0, m < 0, m > 0
  // the actual values are the same for all three cases.
  return getP(matrix, 0, m, n, l);
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getV(matrix, m, n, l) {
  if (m === 0) {
    return getP(matrix, 1, 1, n, l) + getP(matrix, -1, -1, n, l);
  } else if (m > 0) {
    const d = getKroneckerDelta(m, 1);
    return getP(matrix, 1, m - 1, n, l) * Math.sqrt(1 + d) -
        getP(matrix, -1, -m + 1, n, l) * (1 - d);
  } else {
    // Note there is apparent errata in [1,2,2b] dealing with this particular
    // case. [2b] writes it should be P*(1-d)+P*(1-d)^0.5
    // [1] writes it as P*(1+d)+P*(1-d)^0.5, but going through the math by hand,
    // you must have it as P*(1-d)+P*(1+d)^0.5 to form a 2^.5 term, which
    // parallels the case where m > 0.
    const d = getKroneckerDelta(m, -1);
    return getP(matrix, 1, m + 1, n, l) * (1 - d) +
        getP(matrix, -1, -m - 1, n, l) * Math.sqrt(1 + d);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getW(matrix, m, n, l) {
  // Whenever this happens, w is also 0 so W can be anything.
  if (m === 0) {
    return 0;
  }

  return m > 0 ? getP(matrix, 1, m + 1, n, l) + getP(matrix, -1, -m - 1, n, l) :
                 getP(matrix, 1, m - 1, n, l) - getP(matrix, -1, -m + 1, n, l);
}


/**
 * Calculates the coefficients applied to the U, V, and W functions. Because
 * their equations share many common terms they are computed simultaneously.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Array} 3 coefficients for U, V and W functions.
 */
function computeUVWCoeff(m, n, l) {
  const d = getKroneckerDelta(m, 0);
  const reciprocalDenominator =
      Math.abs(n) === l ? 1 / (2 * l * (2 * l - 1)) : 1 / ((l + n) * (l - n));

  return [
    Math.sqrt((l + m) * (l - m) * reciprocalDenominator),
    0.5 * (1 - 2 * d) * Math.sqrt((1 + d) *
                                  (l + Math.abs(m) - 1) *
                                  (l + Math.abs(m)) *
                                  reciprocalDenominator),
    -0.5 * (1 - d) * Math.sqrt((l - Math.abs(m) - 1) * (l - Math.abs(m))) *
        reciprocalDenominator,
  ];
}


/**
 * Calculates the (2l+1) x (2l+1) rotation matrix for the band l.
 * This uses the matrices computed for band 1 and band l-1 to compute the
 * matrix for band l. |rotations| must contain the previously computed l-1
 * rotation matrices.
 * This implementation comes from p. 5 (6346), Table 1 and 2 in [2] taking
 * into account the corrections from [2b].
 * @param {Number[]} matrix - N matrices of gainNodes, each with where
 * n=1,2,...,N.
 * @param {Number} l
 */
function computeBandRotation(matrix, l) {
  // The lth band rotation matrix has rows and columns equal to the number of
  // coefficients within that band (-l <= m <= l implies 2l + 1 coefficients).
  for (let m = -l; m <= l; m++) {
    for (let n = -l; n <= l; n++) {
      const uvwCoefficients = computeUVWCoeff(m, n, l);

      // The functions U, V, W are only safe to call if the coefficients
      // u, v, w are not zero.
      if (Math.abs(uvwCoefficients[0]) > 0) {
        uvwCoefficients[0] *= getU(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[1]) > 0) {
        uvwCoefficients[1] *= getV(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[2]) > 0) {
        uvwCoefficients[2] *= getW(matrix, m, n, l);
      }

      setCenteredElement(
          matrix, l, m, n,
          uvwCoefficients[0] + uvwCoefficients[1] + uvwCoefficients[2]);
    }
  }
}


/**
 * Compute the HOA rotation matrix after setting the transform matrix.
 * @param {Array} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 */
function computeHOAMatrices(matrix) {
  // We start by computing the 2nd-order matrix from the 1st-order matrix.
  for (let i = 2; i <= matrix.length; i++) {
    computeBandRotation(matrix, i);
  }
}


/**
 * Higher-order-ambisonic decoder based on gain node network. We expect
 * the order of the channels to conform to ACN ordering. Below are the helper
 * methods to compute SH rotation using recursion. The code uses maths described
 * in the following papers:
 *  [1] R. Green, "Spherical Harmonic Lighting: The Gritty Details", GDC 2003,
 *      http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf
 *  [2] J. Ivanic and K. Ruedenberg, "Rotation Matrices for Real
 *      Spherical Harmonics. Direct Determination by Recursion", J. Phys.
 *      Chem., vol. 100, no. 15, pp. 6342-6347, 1996.
 *      http://pubs.acs.org/doi/pdf/10.1021/jp953350u
 *  [2b] Corrections to initial publication:
 *       http://pubs.acs.org/doi/pdf/10.1021/jp9833350
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 */
function HOARotator(context, ambisonicOrder) {
  this._context = context;
  this._ambisonicOrder = ambisonicOrder;

  // We need to determine the number of channels K based on the ambisonic order
  // N where K = (N + 1)^2.
  const numberOfChannels = (ambisonicOrder + 1) * (ambisonicOrder + 1);

  this._splitter = this._context.createChannelSplitter(numberOfChannels);
  this._merger = this._context.createChannelMerger(numberOfChannels);

  // Create a set of per-order rotation matrices using gain nodes.
  this._gainNodeMatrix = [];
  let orderOffset;
  let rows;
  let inputIndex;
  let outputIndex;
  let matrixIndex;
  for (let i = 1; i <= ambisonicOrder; i++) {
    // Each ambisonic order requires a separate (2l + 1) x (2l + 1) rotation
    // matrix. We compute the offset value as the first channel index of the
    // current order where
    //   k_last = l^2 + l + m,
    // and m = -l
    //   k_last = l^2
    orderOffset = i * i;

    // Uses row-major indexing.
    rows = (2 * i + 1);

    this._gainNodeMatrix[i - 1] = [];
    for (let j = 0; j < rows; j++) {
      inputIndex = orderOffset + j;
      for (let k = 0; k < rows; k++) {
        outputIndex = orderOffset + k;
        matrixIndex = j * rows + k;
        this._gainNodeMatrix[i - 1][matrixIndex] = this._context.createGain();
        this._splitter.connect(
            this._gainNodeMatrix[i - 1][matrixIndex], inputIndex);
        this._gainNodeMatrix[i - 1][matrixIndex].connect(
            this._merger, 0, outputIndex);
      }
    }
  }

  // W-channel is not involved in rotation, skip straight to ouput.
  this._splitter.connect(this._merger, 0, 0);

  // Default Identity matrix.
  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // Input/Output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  for (let i = 0; i < 9; ++i) {
    this._gainNodeMatrix[0][i].gain.value = rotationMatrix3[i];
  }
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._gainNodeMatrix[0][0].gain.value = rotationMatrix4[0];
  this._gainNodeMatrix[0][1].gain.value = rotationMatrix4[1];
  this._gainNodeMatrix[0][2].gain.value = rotationMatrix4[2];
  this._gainNodeMatrix[0][3].gain.value = rotationMatrix4[4];
  this._gainNodeMatrix[0][4].gain.value = rotationMatrix4[5];
  this._gainNodeMatrix[0][5].gain.value = rotationMatrix4[6];
  this._gainNodeMatrix[0][6].gain.value = rotationMatrix4[8];
  this._gainNodeMatrix[0][7].gain.value = rotationMatrix4[9];
  this._gainNodeMatrix[0][8].gain.value = rotationMatrix4[10];
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix3 = function() {
  let rotationMatrix3 = new Float32Array(9);
  for (let i = 0; i < 9; ++i) {
    rotationMatrix3[i] = this._gainNodeMatrix[0][i].gain.value;
  }
  return rotationMatrix3;
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._gainNodeMatrix[0][0].gain.value;
  rotationMatrix4[1] = this._gainNodeMatrix[0][1].gain.value;
  rotationMatrix4[2] = this._gainNodeMatrix[0][2].gain.value;
  rotationMatrix4[4] = this._gainNodeMatrix[0][3].gain.value;
  rotationMatrix4[5] = this._gainNodeMatrix[0][4].gain.value;
  rotationMatrix4[6] = this._gainNodeMatrix[0][5].gain.value;
  rotationMatrix4[8] = this._gainNodeMatrix[0][6].gain.value;
  rotationMatrix4[9] = this._gainNodeMatrix[0][7].gain.value;
  rotationMatrix4[10] = this._gainNodeMatrix[0][8].gain.value;
  return rotationMatrix4;
};


/**
 * Get the current ambisonic order.
 * @return {Number}
 */
HOARotator.prototype.getAmbisonicOrder = function() {
  return this._ambisonicOrder;
};


module.exports = HOARotator;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_210444__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Namespace for Omnitone library.
 */




exports.Omnitone = __nested_webpack_require_210444__(11);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_211260__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library name space and user-facing APIs.
 */




const BufferList = __nested_webpack_require_211260__(1);
const FOAConvolver = __nested_webpack_require_211260__(4);
const FOADecoder = __nested_webpack_require_211260__(12);
const FOAPhaseMatchedFilter = __nested_webpack_require_211260__(6);
const FOARenderer = __nested_webpack_require_211260__(14);
const FOARotator = __nested_webpack_require_211260__(3);
const FOARouter = __nested_webpack_require_211260__(2);
const FOAVirtualSpeaker = __nested_webpack_require_211260__(7);
const HOAConvolver = __nested_webpack_require_211260__(8);
const HOARenderer = __nested_webpack_require_211260__(16);
const HOARotator = __nested_webpack_require_211260__(9);
const Polyfill = __nested_webpack_require_211260__(19);
const Utils = __nested_webpack_require_211260__(0);
const Version = __nested_webpack_require_211260__(20);

// DEPRECATED in V1, in favor of BufferList.
const AudioBufferManager = __nested_webpack_require_211260__(5);


/**
 * Omnitone namespace.
 * @namespace
 */
let Omnitone = {};


/**
 * @typedef {Object} BrowserInfo
 * @property {string} name - Browser name.
 * @property {string} version - Browser version.
 */

/**
 * An object contains the detected browser name and version.
 * @memberOf Omnitone
 * @static {BrowserInfo}
 */
Omnitone.browserInfo = Polyfill.getBrowserInfo();


// DEPRECATED in V1. DO. NOT. USE.
Omnitone.loadAudioBuffers = function(context, speakerData) {
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(context, speakerData, function(buffers) {
      resolve(buffers);
    }, reject);
  });
};


/**
 * Performs the async loading/decoding of multiple AudioBuffers from multiple
 * URLs.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} [options] - BufferList options.
 * @param {String} [options.dataType='url'] - BufferList data type.
 * @return {Promise<AudioBuffer[]>} - The promise resolves with an array of
 * AudioBuffer.
 */
Omnitone.createBufferList = function(context, bufferData, options) {
  const bufferList =
      new BufferList(context, bufferData, options || {dataType: 'url'});
  return bufferList.load();
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
Omnitone.mergeBufferListByChannel = Utils.mergeBufferListByChannel;


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
Omnitone.splitBufferbyChannel = Utils.splitBufferbyChannel;


/**
 * Creates an instance of FOA Convolver.
 * @see FOAConvolver
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * @return {FOAConvolver}
 */
Omnitone.createFOAConvolver = function(context, hrirBufferList) {
  return new FOAConvolver(context, hrirBufferList);
};


/**
 * Create an instance of FOA Router.
 * @see FOARouter
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 * @return {FOARouter}
 */
Omnitone.createFOARouter = function(context, channelMap) {
  return new FOARouter(context, channelMap);
};


/**
 * Create an instance of FOA Rotator.
 * @see FOARotator
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOARotator}
 */
Omnitone.createFOARotator = function(context) {
  return new FOARotator(context);
};


/**
 * Create an instance of FOAPhaseMatchedFilter.
 * @ignore
 * @see FOAPhaseMatchedFilter
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOAPhaseMatchedFilter}
 */
Omnitone.createFOAPhaseMatchedFilter = function(context) {
  return new FOAPhaseMatchedFilter(context);
};


/**
 * Create an instance of FOAVirtualSpeaker. For parameters, refer the
 * definition of VirtualSpeaker class.
 * @ignore
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options.
 * @return {FOAVirtualSpeaker}
 */
Omnitone.createFOAVirtualSpeaker = function(context, options) {
  return new FOAVirtualSpeaker(context, options);
};


/**
 * DEPRECATED. Use FOARenderer instance.
 * @see FOARenderer
 * @param {AudioContext} context - Associated AudioContext.
 * @param {DOMElement} videoElement - Video or Audio DOM element to be streamed.
 * @param {Object} options - Options for FOA decoder.
 * @param {String} options.baseResourceUrl - Base URL for resources.
 * (base path for HRIR files)
 * @param {Number} [options.postGain=26.0] - Post-decoding gain compensation.
 * @param {Array} [options.routingDestination]  Custom channel layout.
 * @return {FOADecoder}
 */
Omnitone.createFOADecoder = function(context, videoElement, options) {
  Utils.log('WARNING: FOADecoder is deprecated in favor of FOARenderer.');
  return new FOADecoder(context, videoElement, options);
};


/**
 * Create a FOARenderer, the first-order ambisonic decoder and the optimized
 * binaural renderer.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {FOARenderer}
 */
Omnitone.createFOARenderer = function(context, config) {
  return new FOARenderer(context, config);
};


/**
 * Creates HOARotator for higher-order ambisonics rotation.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 * @return {HOARotator}
 */
Omnitone.createHOARotator = function(context, ambisonicOrder) {
  return new HOARotator(context, ambisonicOrder);
};


/**
 * Creates HOAConvolver performs the multi-channel convolution for the optmized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 * @return {HOAConvovler}
 */
Omnitone.createHOAConvolver = function(
    context, ambisonicOrder, hrirBufferList) {
  return new HOAConvolver(context, ambisonicOrder, hrirBufferList);
};


/**
 * Creates HOARenderer for higher-order ambisonic decoding and the optimized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {HOARenderer}
 */
Omnitone.createHOARenderer = function(context, config) {
  return new HOARenderer(context, config);
};


// Handler Preload Tasks.
// - Detects the browser information.
// - Prints out the version number.
(function() {
  Utils.log('Version ' + Version + ' (running ' +
      Omnitone.browserInfo.name + ' ' + Omnitone.browserInfo.version +
      ' on ' + Omnitone.browserInfo.platform +')');
  if (Omnitone.browserInfo.name.toLowerCase() === 'safari') {
    Polyfill.patchSafari();
    Utils.log(Omnitone.browserInfo.name + ' detected. Appliying polyfill...');
  }
})();


module.exports = Omnitone;


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_219960__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOA decoder, DEPRECATED in favor of FOARenderer.
 */



const AudioBufferManager = __nested_webpack_require_219960__(5);
const FOARouter = __nested_webpack_require_219960__(2);
const FOARotator = __nested_webpack_require_219960__(3);
const FOAPhaseMatchedFilter = __nested_webpack_require_219960__(6);
const FOAVirtualSpeaker = __nested_webpack_require_219960__(7);
const FOASpeakerData = __nested_webpack_require_219960__(13);
const Utils = __nested_webpack_require_219960__(0);

// By default, Omnitone fetches IR from the spatial media repository.
const HRTFSET_URL = 'https://raw.githubusercontent.com/GoogleChrome/omnitone/master/build/resources/';

// Post gain compensation value.
let POST_GAIN_DB = 0;


/**
 * Omnitone FOA decoder.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {VideoElement} videoElement - Target video (or audio) element for
 * streaming.
 * @param {Object} options
 * @param {String} options.HRTFSetUrl - Base URL for the cube HRTF sets.
 * @param {Number} options.postGainDB - Post-decoding gain compensation in dB.
 * @param {Number[]} options.channelMap - Custom channel map.
 */
function FOADecoder(context, videoElement, options) {
  this._isDecoderReady = false;
  this._context = context;
  this._videoElement = videoElement;
  this._decodingMode = 'ambisonic';

  this._postGainDB = POST_GAIN_DB;
  this._HRTFSetUrl = HRTFSET_URL;
  this._channelMap = FOARouter.ChannelMap.DEFAULT; // ACN

  if (options) {
    if (options.postGainDB) {
      this._postGainDB = options.postGainDB;
    }
    if (options.HRTFSetUrl) {
      this._HRTFSetUrl = options.HRTFSetUrl;
    }
    if (options.channelMap) {
      this._channelMap = options.channelMap;
    }
  }

  // Rearrange speaker data based on |options.HRTFSetUrl|.
  this._speakerData = [];
  for (let i = 0; i < FOASpeakerData.length; ++i) {
    this._speakerData.push({
      name: FOASpeakerData[i].name,
      url: this._HRTFSetUrl + '/' + FOASpeakerData[i].url,
      coef: FOASpeakerData[i].coef,
    });
  }

  this._tempMatrix4 = new Float32Array(16);
}


/**
 * Initialize and load the resources for the decode.
 * @return {Promise}
 */
FOADecoder.prototype.initialize = function() {
  Utils.log('Initializing... (mode: ' + this._decodingMode + ')');

  // Rerouting channels if necessary.
  let channelMapString = this._channelMap.toString();
  let defaultChannelMapString = FOARouter.ChannelMap.DEFAULT.toString();
  if (channelMapString !== defaultChannelMapString) {
    Utils.log('Remapping channels ([' + defaultChannelMapString + '] -> ['
      + channelMapString + '])');
  }

  this._audioElementSource =
      this._context.createMediaElementSource(this._videoElement);
  this._foaRouter = new FOARouter(this._context, this._channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaPhaseMatchedFilter = new FOAPhaseMatchedFilter(this._context);

  this._audioElementSource.connect(this._foaRouter.input);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaPhaseMatchedFilter.input);

  this._foaVirtualSpeakers = [];

  // Bypass signal path.
  this._bypass = this._context.createGain();
  this._audioElementSource.connect(this._bypass);

  // Get the linear amplitude from the post gain option, which is in decibel.
  const postGainLinear = Math.pow(10, this._postGainDB/20);
  Utils.log('Gain compensation: ' + postGainLinear + ' (' + this._postGainDB
    + 'dB)');

  // This returns a promise so developers can use the decoder when it is ready.
  const that = this;
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(that._context, that._speakerData,
      function(buffers) {
        for (let i = 0; i < that._speakerData.length; ++i) {
          that._foaVirtualSpeakers[i] = new FOAVirtualSpeaker(that._context, {
            coefficients: that._speakerData[i].coef,
            IR: buffers.get(that._speakerData[i].name),
            gain: postGainLinear,
          });

          that._foaPhaseMatchedFilter.output.connect(
            that._foaVirtualSpeakers[i].input);
        }

        // Set the decoding mode.
        that.setMode(that._decodingMode);
        that._isDecoderReady = true;
        Utils.log('HRTF IRs are loaded successfully. The decoder is ready.');
        resolve();
      }, reject);
  });
};

/**
 * Set the rotation matrix for the sound field rotation.
 * @param {Array} rotationMatrix      3x3 rotation matrix (row-major
 *                                    representation)
 */
FOADecoder.prototype.setRotationMatrix = function(rotationMatrix) {
  this._foaRotator.setRotationMatrix(rotationMatrix);
};


/**
 * Update the rotation matrix from a Three.js camera object.
 * @param  {Object} cameraMatrix      The Matrix4 obejct of Three.js the camera.
 */
FOADecoder.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};

/**
 * Set the decoding mode.
 * @param {String} mode               Decoding mode. When the mode is 'bypass'
 *                                    the decoder is disabled and bypass the
 *                                    input stream to the output. Setting the
 *                                    mode to 'ambisonic' activates the decoder.
 *                                    When the mode is 'off', all the
 *                                    processing is completely turned off saving
 *                                    the CPU power.
 */
FOADecoder.prototype.setMode = function(mode) {
  if (mode === this._decodingMode) {
    return;
  }

  switch (mode) {
    case 'bypass':
      this._decodingMode = 'bypass';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.connect(this._context.destination);
      break;

    case 'ambisonic':
      this._decodingMode = 'ambisonic';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].enable();
      }
      this._bypass.disconnect();
      break;

    case 'off':
      this._decodingMode = 'off';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.disconnect();
      break;

    default:
      break;
  }

  Utils.log('Decoding mode changed. (' + mode + ')');
};

module.exports = FOADecoder;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data for FOAVirtualSpeaker. Each entry contains the URL for IR files and
 * the gain coefficients for the associated IR files. Note that the order of
 * coefficients follows the ACN channel ordering. (W,Y,Z,X)
 * @type {Object[]}
 */
const FOASpeakerData = [{
  name: 'E35_A135',
  url: 'E35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, -0.216495],
}, {
  name: 'E35_A-135',
  url: 'E35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, -0.216495],
}, {
  name: 'E-35_A135',
  url: 'E-35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, -0.216495],
}, {
  name: 'E-35_A-135',
  url: 'E-35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, -0.216495],
}, {
  name: 'E35_A45',
  url: 'E35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, 0.216495],
}, {
  name: 'E35_A-45',
  url: 'E35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, 0.216495],
}, {
  name: 'E-35_A45',
  url: 'E-35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, 0.216495],
}, {
  name: 'E-35_A-45',
  url: 'E-35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, 0.216495],
}];


module.exports = FOASpeakerData;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_229122__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOARenderer. This is user-facing API for the first-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_229122__(1);
const FOAConvolver = __nested_webpack_require_229122__(4);
const FOAHrirBase64 = __nested_webpack_require_229122__(15);
const FOARotator = __nested_webpack_require_229122__(3);
const FOARouter = __nested_webpack_require_229122__(2);
const Utils = __nested_webpack_require_229122__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


/**
 * Omnitone FOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function FOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('FOARenderer: Invalid BaseAudioContext.');

  this._config = {
    channelMap: FOARouter.ChannelMap.DEFAULT,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config) {
    if (config.channelMap) {
      if (Array.isArray(config.channelMap) && config.channelMap.length === 4) {
        this._config.channelMap = config.channelMap;
      } else {
        Utils.throw(
            'FOARenderer: Invalid channel map. (got ' + config.channelMap
            + ')');
      }
    }

    if (config.hrirPathList) {
      if (Array.isArray(config.hrirPathList) &&
          config.hrirPathList.length === 2) {
        this._config.pathList = config.hrirPathList;
      } else {
        Utils.throw(
            'FOARenderer: Invalid HRIR URLs. It must be an array with ' +
            '2 URLs to HRIR files. (got ' + config.hrirPathList + ')');
      }
    }

    if (config.renderingMode) {
      if (Object.values(RenderingMode).includes(config.renderingMode)) {
        this._config.renderingMode = config.renderingMode;
      } else {
        Utils.log(
            'FOARenderer: Invalid rendering mode order. (got' +
            config.renderingMode + ') Fallbacks to the mode "ambisonic".');
      }
    }
  }

  this._buildAudioGraph();

  this._tempMatrix4 = new Float32Array(16);
  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
FOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._foaRouter = new FOARouter(this._context, this._config.channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaConvolver = new FOAConvolver(this._context);
  this.input.connect(this._foaRouter.input);
  this.input.connect(this._bypass);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaConvolver.input);
  this._foaConvolver.output.connect(this.output);

  this.input.channelCount = 4;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
FOARenderer.prototype._initializeCallback = function(resolve, reject) {
  const bufferList = this._config.pathList
      ? new BufferList(this._context, this._config.pathList, {dataType: 'url'})
      : new BufferList(this._context, FOAHrirBase64);
  bufferList.load().then(
      function(hrirBufferList) {
        this._foaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('FOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'FOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
FOARenderer.prototype.initialize = function() {
  Utils.log(
      'FOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('FOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Set the channel map.
 * @param {Number[]} channelMap - Custom channel routing for FOA stream.
 */
FOARenderer.prototype.setChannelMap = function(channelMap) {
  if (!this._isRendererReady) {
    return;
  }

  if (channelMap.toString() !== this._config.channelMap.toString()) {
    Utils.log(
        'Remapping channels ([' + this._config.channelMap.toString() +
        '] -> [' + channelMap.toString() + ']).');
    this._config.channelMap = channelMap.slice();
    this._foaRouter.setChannelMap(this._config.channelMap);
  }
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the rotation matrix from a Three.js camera object. Depreated in V1, and
 * this exists only for the backward compatiblity. Instead, use
 * |setRotatationMatrix4()| with Three.js |camera.worldMatrix.elements|.
 * @deprecated
 * @param {Object} cameraMatrix - Matrix4 from Three.js |camera.matrix|.
 */
FOARenderer.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  if (!this._isRendererReady) {
    return;
  }

  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};


/**
 * Set the rendering mode.
 * @param {RenderingMode} mode - Rendering mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
FOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._foaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._foaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._foaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'FOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('FOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = FOARenderer;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

const OmnitoneFOAHrirBase64 = [
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD+/wIA9v8QAPv/CwD+/wcA/v8MAP//AQD7/wEACAAEAPj/+v8YABAA7v/n//v/9P/M/8D//f34/R38EvzxAfEBtA2lDTcBJQFJ9T71FP0D/cD1tfVo/Wv9uPTO9PPmOufc/U/+agL3Aisc/RxuGKEZBv3j/iYMzQ2gAzsEQQUABiQFrASzA5cB2QmyCy0AtgR4AeYGtfgAA2j5OQHP+scArPsMBJgEggIEBtz6+QVq/pj/aPg8BPP3gQEi+jEAof0fA1v9+/7S+8IBjvwd/xD4IADL/Pf9zvs+/l3+wgB7/+L+7fzFADH9kf6A+n3+DP6+/TP9xP68/pn+w/26/i39YgA0/u790Pt9/kD+7v1s/Wb+8f4C/1P+pf/x/cT+6/3p/Xz9ff5F/0f9G/4r/6v/4P5L/sL+ff7c/pj+Ov7X/UT+9P5G/oz+6v6A/2D+9/6P/8r/bP7m/ij+C//e/tj/Gf4e/9v+FwDP/lz/sP7F/2H+rv/G/s7/Hf7y/4P+NAD9/k0AK/6w/zP/hACh/sX/gf44AOP+dgCm/iUAk/5qAOD+PwC+/jEAWP4CAAr/bQBw/vv/zf5iACD/OgCS/uD/Cv9oAAb/CgDK/kwA//5tACH/TgCg/h4AHP9aABP/JADP/hEAYv9gAAj/3f8m/ysAYv8gACX/8/8k/ysAXv8bABH//v8j/ygAa/8qAAD/9f9g/1YAWf8JACH/AgB2/z4AXP/w/z3/FgB2/ykAX//9/z//EwCV/zUAS//n/1T/GACK/x4ATv/0/4P/QQB4//v/WP/2/3X/HAB8//P/V//3/2f/AQBh/9v/Tf/x/5P/IwCI/wMAf/8hAKP/JACZ/xUAiv8nAK//HgCr/yMAm/8uAMz/OACi/yQAqf87AMT/MwCY/yUAtP9FAMH/KgCu/ycAyP85AMv/IwCz/xoA1f8qAMn/FgC8/xQA4/8nAMX/CwDJ/xQA4f8ZAMH/BgDO/xQA4f8WAMP/BwDU/xQA4P8QAMH/AQDb/xQA3P8JAMP/AgDh/xIA2v8EAMj/AgDk/w0A1f/+/8v/AwDm/wwA0v/+/9H/BgDl/wkAzv/8/9T/BwDk/wcAzv/8/9r/CQDi/wQAzf/8/9//CADf////0P/9/+L/BwDd//7/0////+T/BgDb//z/1f8AAOf/BQDZ//v/2v8CAOb/AwDY//v/3v8EAOb/AgDY//3/4f8FAOX/AQDZ//7/5P8GAOP/AADb/wAA5/8GAOH////d/wIA5/8FAOD////f/wMA6P8FAOD////h/wQA6P8EAN7////h/wUA4v8DANv/AQDd/wQA3P8CANn/AgDb/wMA2/8CANv/AgDd/wIA3v8CAOH/AQDj/wEA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAAAA/f8CAP//AQD//wEA//8BAP3/AAACAP7/+f8AAAIA/P8FAAQA8/8AABoA+f/V/wQAHQDO/xoAQQBO/ocA0Px1/ucHW/4UCm8HLO6kAjv8/fCRDdAAYfPiBIgFXveUCM0GBvh6/nz7rf0J/QcQSRVdBgoBSgFR62r9NP8m+LoEAvriBVAAiAPmABEGMf2l+SwBjva6/G4A//8P/CYDMgXm/R0CKAE6/fcBBwAtAND+kQA0A5UDhwFs/8IB8fydAEP/A/8v/e7/mP8j/2YBIwE3Av0AYv+uAOD8lgAg/wwAIf/L/n0Ae//OAJMB3P/XAF//XwCM/08AB/8NAEf/rf4jAT3/lgAJAP4AHgDpAO8AUf9L/07/Qf8KAOD/x/+D/3sATQCDAMoA0f79/+L/EQDt/7EAqv+S/7IAuv/o/wgAc//X//H/SwCm/+3/Yf/B/yoAAADI/7X/AwBg/5EATgCX/xYA/P+q/00AVACY/6v/BADD/zwALQCN/8z/KQDu/ygAEgCZ/6f/VQDC//T/KQCs/7P/UgAfAO7/NgC8/57/awAZAPP/+P/V/8z/bQBBAL//DgD0/+T/TABBAMz/CwAxAPz/SQBqALn/BgALAPz/EAA7AIz/3/8iAAUA//8kALf/y/9VABQA+v81AOj/0P9cAB4A+f8WAOr/vv83ABgAw/8JAOj/4f8nACIAsf/y/w4A3v8gACQAxP/n/ycA7P8WAC0Ayf/U/ycA9v/7/yUA0P/P/zUABADc/xUA5P/J/zcACwDS/xUA9P/m/zAACQDX/+3/9v/2/yQACgDZ/+P/AwAKABYA///b/9j/EQALABkADgD6/+7/GwD4/w4A8P/w//j/EgAEAAUA9f/1/wQAGgD4/wAA5////wAAGQD1////7f8FAAUAFQDv/wAA6v8LAAcAFQDs/wEA9P8SAAYACwDr//7/AQASAAYABQDv/wIAAwAWAAIAAgDv/wAABgATAAEA/f/u/wQABgAQAPr/+P/z/wUACQALAPj/9//4/wgABwAKAPT/+f/5/w4ABwAIAPT/+//9/w4AAwADAPH//f///w8A//8BAPP///8BAA0A/f/+//X/AgACAA0A+//8//b/BAADAAoA+f/7//n/BgADAAcA+P/7//v/BwABAAQA+P/8//3/CQABAAIA9//9////CQD/////+P///wAACAD9//7/+f8AAAAABwD8//3/+v8CAAAABgD7//z//P8EAAAABAD6//3//P8FAP//AgD6//7//v8FAP7/AQD7//////8GAP7/AAD7/wEA//8EAP3/AAD9/wEA/v8DAP3/AAD9/wIA/v8CAP3/AQD9/wIA/v8CAP7/AQD+/wEA",
];

module.exports = OmnitoneFOAHrirBase64;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_240610__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone HOARenderer. This is user-facing API for the higher-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_240610__(1);
const HOAConvolver = __nested_webpack_require_240610__(8);
const HOARotator = __nested_webpack_require_240610__(9);
const TOAHrirBase64 = __nested_webpack_require_240610__(17);
const SOAHrirBase64 = __nested_webpack_require_240610__(18);
const Utils = __nested_webpack_require_240610__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


// Currently SOA and TOA are only supported.
const SupportedAmbisonicOrder = [2, 3];


/**
 * Omnitone HOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function HOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('HOARenderer: Invalid BaseAudioContext.');

  this._config = {
    ambisonicOrder: 3,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config && config.ambisonicOrder) {
    if (SupportedAmbisonicOrder.includes(config.ambisonicOrder)) {
      this._config.ambisonicOrder = config.ambisonicOrder;
    } else {
      Utils.log(
          'HOARenderer: Invalid ambisonic order. (got ' +
          config.ambisonicOrder + ') Fallbacks to 3rd-order ambisonic.');
    }
  }

  this._config.numberOfChannels =
      (this._config.ambisonicOrder + 1) * (this._config.ambisonicOrder + 1);
  this._config.numberOfStereoChannels =
      Math.ceil(this._config.numberOfChannels / 2);

  if (config && config.hrirPathList) {
    if (Array.isArray(config.hrirPathList) &&
        config.hrirPathList.length === this._config.numberOfStereoChannels) {
      this._config.pathList = config.hrirPathList;
    } else {
      Utils.throw(
          'HOARenderer: Invalid HRIR URLs. It must be an array with ' +
          this._config.numberOfStereoChannels + ' URLs to HRIR files.' +
          ' (got ' + config.hrirPathList + ')');
    }
  }

  if (config && config.renderingMode) {
    if (Object.values(RenderingMode).includes(config.renderingMode)) {
      this._config.renderingMode = config.renderingMode;
    } else {
      Utils.log(
          'HOARenderer: Invalid rendering mode. (got ' +
          config.renderingMode + ') Fallbacks to "ambisonic".');
    }
  }

  this._buildAudioGraph();

  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
HOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._hoaRotator = new HOARotator(this._context, this._config.ambisonicOrder);
  this._hoaConvolver =
      new HOAConvolver(this._context, this._config.ambisonicOrder);
  this.input.connect(this._hoaRotator.input);
  this.input.connect(this._bypass);
  this._hoaRotator.output.connect(this._hoaConvolver.input);
  this._hoaConvolver.output.connect(this.output);

  this.input.channelCount = this._config.numberOfChannels;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
HOARenderer.prototype._initializeCallback = function(resolve, reject) {
  let bufferList;
  if (this._config.pathList) {
    bufferList =
        new BufferList(this._context, this._config.pathList, {dataType: 'url'});
  } else {
    bufferList = this._config.ambisonicOrder === 2
        ? new BufferList(this._context, SOAHrirBase64)
        : new BufferList(this._context, TOAHrirBase64);
  }

  bufferList.load().then(
      function(hrirBufferList) {
        this._hoaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('HOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'HOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
HOARenderer.prototype.initialize = function() {
  Utils.log(
      'HOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ', ambisonic order: ' + this._config.ambisonicOrder + ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('HOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the decoding mode.
 * @param {RenderingMode} mode - Decoding mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
HOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._hoaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._hoaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._hoaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'HOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('HOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = HOARenderer;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

const OmnitoneTOAHrirBase64 = [
"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AAD7/wEAAgD7//7/AQD8/wAAAwD8//3/AwD9/wAAAgD9//z/AwD/////AgD+//z/AwAAAP7/AQD///3/AgABAP3/AAAAAP3/AgACAPz///8BAP3/AQACAP3//v8BAP7/AAABAP3//v8CAP7///8BAP7//f8CAP////8AAAAA/v8CAAAAAAAAAAAA/v8BAAAAAAD//wAA//8AAP//AAD//wAA//8AAP//",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA/////wAAAQD+////AAAGAP3/OAABAIIAAwBv//f/E/0QAK0ADQCzA/7/8P4u/0cBDQCJA6ABbQDg/w7/z/9o+Vn/SPnL/1//Ef+2+jr9RfZgA5QFZwILDFj+PAb2/nEFKgKk/R0Dlv6b/FUDsP6YAoj9SgAT/iL/tAPwAv8A0P6zAr7/dwAnAf39uP22/skA2v///2YCoP4UAUsAZgF2AJH+4P70/rz9+f+U/Xv/8v7CAcb+TACS/kwAv/+x/tX9oP71/oL/1f8nAEUAZwGtAAgAIgC/AD4BaP8GAGH/dQDF/64Arf8nAakAhAH9/+kAQQD3AFb/q/8p/yIAR/8FAPD/ZAA/AIYA3v8tADQADQBp/3f/CwABAP3/Wf8OANj/WwDH/xoAe/8DAKz/zv96/z8A3f/J/5X/IAD5//j/q//c/+//RADq//D/vv8pADUAFQDI/y8ACAAbANb/OwD3/+3/9f/e/wcAIAAeAMH/8/8xAC0AEADW/+3/HAADAPv/8P8DAOL/OwD3/xcACQAHAM//5f8XAAcAz//T/9D/HgD9////yf/e//v/AgD//9H/6/////H/+/8hAAIA9//7/w0AFgAQAPL/2v/8/xsAGQABANz/9P8YAAQA/v/y/wMA5v8YAAkAAAAAAAMA7/8KABgADwDs//j/BwATABsA8P/1//z/BAAMAAAA9P/s/xAA/v8GAAkA/v/p/wMACwALAP7/9P/p/wcADQAFAPb/7//4/w0ACAD8//b//v/1/wMACwD1//T/8P/8/wAACQDz/+f/5P8GAAkABQD5//D/+v8FAA0AAwD///T/AgACABAA/v8CAPD/+/8FAAoA9f/3//f//v8GAP7/9v/t//z/+f8AAPj/+v/3/wEA+v8HAPr//P/5/wQA//8DAPr/+P/3/wYA///+//X/+//5/wQA/f/7//X/+//4/wMA/f/8//j//v/9/wYA///8//f/AgAAAAUA/f/6//n/AwACAAIA/f/7//z/AwACAAAA/f/6//3/AgADAP7//f/7/wAAAwAFAPz////8/wMAAgAEAPv//v/+/wMAAgADAPv//v///wMAAQABAPv//f8AAAIAAAD///v//f8BAAIA///+//z//v8CAAIA/v/9//3///8CAAEA/v/9//7/AAACAAAA/v/9////AAABAAAA/f/9/wAAAQABAP///f/+/wEAAQAAAP///v/+/wEAAQD///7//v///wEAAQD///7//v///wEAAAD+//7///8AAAAAAAD+//7///8AAAAA///+//7///8AAAAA////////AAAAAP////////////8AAP//////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAAAAAAABAAAAAAD//////////////v////3/////////+//8////AQD9//z/9f8BAAIA+f8dACgAWQBxAJX/qv+Y/uz9aP9k/7UDUQQBAiQA4Pgi/AkB0gKaBsD/+fxp/vz9CQSp/I/+ywDO+vMD0fzK/PABcgBeBfoBv/+uAuH9Sf5gAy39awMmBWUBuP9fA9/9fgDj/2/+EACaACcCSv9Z/2j/rv7hAA0AWf55/7L84P7E/SIAT/67AMv/tf+FAA7/1v+7/gv/IP+E/sQA+P5aAXz/tP9XAFX/tP8o/4r/j//e/yQAMv9mAJT/rgCr/9X/EwCb//H/9f7F/6D/EAAoAK3//v+e/zsAh/+B/7r/if/C/2r/4P/z/6//HwCy/0IA7/9ZALT/y/80ACgA9v/J/9//DgA5ADUALQARADIACwAfAOf/NgArACMACQBBAEcAGAAjAC4AWQBUAHcAAAAfACEAIAAcAPj/CADk/yQA7v89AEEAFwD5/xYA6f8aAOX/AADF/zQADwAUAOT/BQDr/yUA6P8XAOf/HADR/0AA8P8nAAgACQDt/ycAKAAHAPH/IQDz/xsACADn//n/DgADAA4A8P///8z/GgDN/yMA/f8QANj/MwACAC0ACwAOAO3/JgAZAAUACgAAAA4AIgAaAAkADwACAAAAHQATAAUABQACAAgACwAjAO////8AAA8ABQAPAPL//f8GAAsABgAGAPD/8v8GAPz/CAD6//H/6v8PAAgABgD4//3/9v8aAAgABwD1//7//v8QAAoACAD//wUA9v8QAAoABAAFAAgAAgAJAAoAAwD//w0AAgD//wcA/v8DAAoABQAFABUABAAKAAYABwAHAA8ACgAGAAwADwAMAAkAEAAJAAgADwAMAAgADgAJAAUACQAPAAUACwAHAAEABgAIAAEABAAGAP//AgAJAAAAAgAEAP7///8IAAIA//8GAAEAAQAJAAIA/v8EAAMA//8JAAEA/v8DAAMA/v8HAAMA/f8BAAUA/v8FAAMA/v8BAAcA//8DAAMA/v8BAAYA//8CAAMA/////wcAAAAAAAMAAAD//wYAAQD+/wMAAQD//wUAAQD+/wIAAgD//wQAAgD+/wEAAwD//wMAAwD+/wEAAwD//wIAAwD//wEABAAAAAEABAD//wAABAABAAAAAwAAAAAABAABAP//AwABAAAAAwACAP//AgACAAAAAwACAP//AgACAAAAAgACAAAAAQADAAAAAQACAAAAAQADAAAAAQACAAAAAAACAAEAAAACAAEAAAACAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAAAAAAAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA//8AAP//AAACAAAA+f8BAAYA///4/wIA//8AAA8A/v/V/wEAEwA9AAEBRwA2AF7/kfog/3gBwv99CDYBU/qtAUX/AP7OAfkAX/o9B38FSfwaAuT14/60BAr8CQAI/tfyIQTzAXP+egdUBBwBof7TBMT8bAWi/5EEWwBRAAAKyfxE/8b88vp6ACP+PAF4/qD8MQNM/ygCJ/2XAPD9kP5gAVT/iP9I/lEB4P8qAD0BFAGa/+7/DgB2AOP98gFm/u/+Vv5/AG8ASP9gAM//qv9w//oAcv+2/jIBHgA7/6D/oAAGAKH/lADT/wAAggC8AAYAkP9yAEcAkf8BAOD/RAAr/zUANwDt/xQAJQAkAMT/zwA/AOH/xv9zAGsANQBTAIcALAAvACIATACy/xMADADg/xcAWABvAJL/7f9VAPb/EgDt/wcA4f8kAPP/5P+h/wgACQDy//r/LgAQAMn/8/9CAOX/5v/S/9//3P8pABYAuP/s/w8AFgDt/+3/7v/w/9j/5/8GAOf/2P/2//P//v8kABMAuf/m/xoADADZ/+r/3P8KAAUAKwDe/wsA3P8VAAAADgAfAB0ACAAMAF4AGgAhAPL/MwDz/0kABAAKAPX/LwAbAAkA9v/s/+3/8/8CABAAAADm//n/BQALAAUAAQDj//n/JQAVAPX/9v/+/wIAEQABAPP/8P/1/wAABgD6/+3/7//o//j/DAD8/+b/8P8IAAkABgD4//D/8P8UAAoAAwD4/wAA+f8OAAcAAAAFAPX/9v8TAAkA8v8EAPb/9/8dAA0A7/8CAPn/+f8SAAQA8/8CAOf/+v8DAAgA9P////H//P8IAAUA8//0/wIAAQAGAAgA9//7/wAA+/8EAP//+P/+////AgACAAsA8v/+/wIABQD7/wgA9v/7/wMABAD5/wAA/P/3/wEAAQD7//7//P/1/wQA///3//r////3/wMAAwD1//r/AwD6////AgD4//n/AwD8//7/AgD4//n/AwD+//3/AQD4//n/BQD///n/AAD6//j/BAABAPj/AAD9//v/AwADAPj//v/+//z/AwAEAPj//v8BAP7/AQADAPj//f8CAP////8EAPr//P8DAAAA/v8CAPv//P8DAAEA/f8BAP3//f8DAAIA/P8AAP7//f8DAAIA/P///wAA/f8BAAIA+//+/wEA//8AAAEA+//+/wEA/////wEA/P/+/wEA///+/wAA/f/9/wEAAAD9/wAA/f/+/wEAAQD8/////v/+/wAAAQD8////////////AQD9////AAD/////AAD+////AAAAAP//AAD///////8AAP//AAD//wAA//8AAP//",
];

module.exports = OmnitoneTOAHrirBase64;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

const OmnitoneSOAHrirBase64 = [
"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/P////v//P8CAAQA+//+//3//f8CAAUA+v/9//////8AAAQA+v/8////AAD//wIA+//8/wAAAQD+/wEA+//8/wAAAgD9/////P/9/wEAAgD8//7//f/9/wAAAgD8//3//v/+////AQD8//z/////////AAD8//3///8AAP7/AAD9//7///8AAP7////+//////8AAP7////+////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD//////v8AAP///////wAAAAAAAP7/AQABAAAABwD///X/BQAjAPL/CQDb/9D/GAAb/7sAYwCW/z0BcP/X/7T/2QDW+wH8yANCCCUJ5QT++UXmhPwhA78FuAxH+p78ifudBlAG9vmu/lAK2fdlB///cfjoCa0E7Akn9Yb/zvba+AkAHPywBGEBFwUNAL8AXAAGA20DFvmR/kz+F/06Ag/+GwHl/5EEKgJd/q0AP/ym/9n6EfxY/2H+/QFtAC4C6QBDAaMCo/20/+3/3f/p/fL9rv9V/6cBhQHuAX4AcwJYAaH/IP/P/gsApP0LAe7/sQBuAI0AAgGDAE4BzACe/5X//v+v/+f+Zf+gAOv/5QBhAOIApAANASYAuP+h/8b/HQBr/9//bACWAGEAFAB5AD0AWQDU/+D/Yf/p//D/s/+R/4QAMQBvABEAkQBfABQAJgDW/wwA8/8XALz/vf8zAFAAKwD1/zEAPwDJ/x0A7/8LAOX/FwDR//H/EQAdAO//6P8QAFEA2f8WABEAMgDy/xIA+f/s/xAALgDv////HQAvAPT/+f8iAAYAEgAFABoAGgD//w0A+f/0/xsAHgDx/9f/GAACAPH/8f8JAPf/GwALABEA7/8cAPT/CgD2//j/BQD8/+3/OgAgAAYA9f8PAN7/DgD9/9r/1//3/+3/9//1//b/8//5//f/AgAJAOf/+v8OAAMACwD9/+7/5f8eAAEA9//q//7/8P8WAP7/+//4/wIA+f8TAAIA9f/5/wcA+P8iAAgA9v/n/xoA//8gAAUABwDj/wAA9v8BAAUAFQDn/wMA7v8QABAAEQDm/wwA8f8aAAAABwDu/wcACgASAAEA7//w//f/BgARAAkA6P/3/wcADgAKAAYA4f/4/wYADgAAAPr/8P/9/xQACgAHAPn/7//9/xEAAgD+//L/8v/8/xUAAwDw//H/9f8CAAsA/v/q//L/+f8FAAYA/P/r//j///8GAAkA+//o//j/AQAIAP//+v/o//v/CAAIAPv/+P/w/wEACQAHAPj/+f/0/wIACwAFAPb/+f/4/wQACwACAPP/+f/+/wYACAD///L/+/8BAAYABQD9//P//P8FAAUAAgD7//T//f8HAAQA///7//f///8IAAMA/P/6//r/AQAIAAEA+v/6//3/AgAHAAAA+f/7/wAAAwAFAP7/+P/8/wIAAgACAP3/+f/9/wMAAwAAAPz/+v/+/wQAAgD+//z/+/8AAAQAAQD8//z//f8BAAQAAAD7//3///8BAAMA///7//3/AAACAAEA/v/7//7/AQABAAAA/v/9////AQAAAP///v/+////AAD/////////////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD////////+//////8AAAAA/v/+/wAAAQD8//3/CQAJAP3/+v8PAAcApABlABkBkwCO/i//lfqa/HQAcf/3BdkCzwJcBCMC0wMN/9/9wgI7AaECYfxV/Tf83vhn/xrt8Owx/8n7cgHABYb43QcZDh4WugNrA7P74gHu/9z/zv0t/acCiQHY/iv4qQOl/ysCE/0//XT9Sf4O//j9xfupAn394gHO+rsCXAFIAxQC9wIXBgcD2AQuAnb/9gJh/6wAVfxEAI4Bvf7oAFv/bALsAMQBe/88/joAT/4dAH39/v9LAXn/gwDI//QBdABcAA0A7f4lAMn///+9/tv/iABp/13/pP/dALv/w/8MAHv//f+y/6////7U/5AAZP+Z/8r/nQDR/5r/DwDr/xAA4v+s/3z/+P9uAOv/t/82AGcAHgCb/yQAFQBGAM7/CgD3/xoAegAaAOz/CgBHAA8Adv8/AAAABQC2/xIAAAA7ABQAKgCj/z4AAQAXAJz/JAADAAcA8f/1/2AAAQAlAPD/NgDx/1wA7v/4/wMAZADv//3/HQAkAFoA8P9FAPv/FgBIAPf/WQAHAEUACQD0/xIAQwDu/wMAwP9VALn/XwCw/yEA5f8sAPj/FgDD/1YAyv8rAOX/HQDo//j/IQAQACAAHwD9/yQAHQBAABgABQAiAAUAKAD3/wkACwAKAAMABwAJAPb/+f8GAOr/JQAHABMA6P8TAA4AGgD//woA8/8ZAP//GADu/w0A9v8SAAMABwD4/wQA5P8XAAQACgDq/wUA+/8VAAcACADs/xIAAAATAPH/+v/1//T/7f///+z/+v/y/+//9/8KAAcACgAJAPT/BAAKAAAABgAIAPL/9v8KAAMABAACAPr/9v8OAAIA+P/x//v/+f8MAPb/+P/w/wQA9f8MAPn////7/woA/v8PAAEAAgD1/xAAAQAPAP//AwD//xQABwALAAAABgADABAAAgAHAAAACAABAA8ABQAFAAMABwAEAA4ABwADAAEACQAFAAoAAwD//wAACQADAAUAAQD/////CAABAAMAAAD/////BwACAAEAAAD/////BwACAP7///8BAAAABgABAP7///8CAAAABAAAAP7///8DAAAAAwAAAP3///8DAAAAAQAAAP3//v8EAAAAAAD+//////8EAP/////+/wAA/v8EAP/////+/wEA/v8EAP///v/+/wIA//8DAP///v/+/wIA//8BAP///v/+/wMA//8BAP/////+/wMA//8AAP//AAD+/wQA//8AAP7/AQD//wIA////////AQD//wIA////////AQAAAAEAAAAAAP//AQD//wEAAAAAAP//AQAAAAEAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD+/wAA+v8AAPz/AAD//wAA/f8AAAEAAAD+/wAACQAAAAQAAAAZAAAAtgAAAFsBAABW/gAAH/oAAGcBAABoBwAAlAAAAO3/AAARAQAA+wIAAEoEAACe/gAAiv4AALD0AADJ8wAAkQQAAF34AABi8QAAPQAAAAH2AAD19AAADAMAAJwGAACTEAAA0AwAAJkHAACOBwAAuQEAANcDAAC6AgAAHwUAAHEFAAB0AwAAbgEAADz+AADYAQAAGAAAAJwCAADgAAAA//0AAMn+AAAT/AAAwP8AAOn9AAAJAAAAewEAAOn+AACN/wAAOv0AAO3+AADN/gAAcP8AACj/AACq/gAA+f4AAML9AACa/wAA/f4AAN7/AABo/wAA6/4AAE//AAAC/wAAEQAAAHX/AAB0AAAA5f8AAEwAAAB3AAAA5/8AAMIAAABCAAAAzgAAAE8AAAB3AAAAKAAAADMAAACqAAAALwAAAK4AAAASAAAAVgAAACgAAAAtAAAATAAAAP3/AAA7AAAA2/8AACQAAADw/wAALQAAADEAAAAlAAAAbAAAADMAAABUAAAAEAAAACgAAAD1/wAA9v8AAPr/AADu/wAALgAAABIAAABUAAAARAAAAGUAAABGAAAAOAAAAGAAAAAuAAAARQAAACEAAAAfAAAAAAAAAAkAAAAQAAAAAwAAABIAAADs/wAAEAAAAAYAAAASAAAAIgAAABEAAAADAAAABAAAAA8AAAD4/wAAHQAAAAsAAAAIAAAADgAAAP//AAAcAAAADwAAAAYAAAASAAAAFwAAAAMAAAAYAAAAEgAAAPr/AAAQAAAADQAAAAoAAAD3/wAABgAAAPb/AADf/wAA/v8AAPL/AAD6/wAAFAAAAAQAAAAEAAAAGwAAAAEAAAAMAAAAIAAAAAIAAAAdAAAAGAAAAAIAAAAcAAAAEgAAAAcAAAAeAAAADwAAAAQAAAAeAAAABAAAAAYAAAAZAAAAAQAAAA4AAAATAAAA/v8AAAoAAAAOAAAA+/8AAAsAAAAJAAAA+f8AAAsAAAABAAAA+f8AAAoAAAD9/wAA+v8AAAcAAAD5/wAA+v8AAAUAAAD3/wAA/f8AAAQAAAD2/wAAAAAAAAEAAAD3/wAAAgAAAAAAAAD4/wAAAwAAAP7/AAD6/wAABAAAAP3/AAD8/wAABAAAAPv/AAD+/wAAAwAAAPv/AAD//wAAAQAAAPv/AAAAAAAAAAAAAPv/AAACAAAA//8AAPz/AAACAAAA/v8AAP3/AAACAAAA/f8AAP7/AAABAAAA/f8AAP//AAABAAAA/f8AAAAAAAAAAAAA/v8AAAEAAAAAAAAA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
];

module.exports = OmnitoneSOAHrirBase64;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Cross-browser support polyfill for Omnitone library.
 */




/**
 * Detects browser type and version.
 * @return {string[]} - An array contains the detected browser name and version.
 */
exports.getBrowserInfo = function() {
  const ua = navigator.userAgent;
  let M = ua.match(
      /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) ||
      [];
  let tem;

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return {name: 'IE', version: (tem[1] || '')};
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\bOPR|Edge\/(\d+)/);
    if (tem != null) {
      return {name: 'Opera', version: tem[1]};
    }
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/([\d.]+)/i)) != null) {
    M.splice(1, 1, tem[1]);
  }

  let platform = ua.match(/android|ipad|iphone/i);
  if (!platform) {
    platform = ua.match(/cros|linux|mac os x|windows/i);
  }

  return {
    name: M[0],
    version: M[1],
    platform: platform ? platform[0] : 'unknown',
  };
};


/**
 * Patches AudioContext if the prefixed API is found.
 */
exports.patchSafari = function() {
  if (window.webkitAudioContext && window.webkitOfflineAudioContext) {
    window.AudioContext = window.webkitAudioContext;
    window.OfflineAudioContext = window.webkitOfflineAudioContext;
  }
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone version.
 */




/**
 * Omnitone library version
 * @type {String}
 */
module.exports = '1.0.6';


/***/ })
/******/ ]);
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio version.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * ResonanceAudio library version
 * @type {String}
 */
module.exports = '0.0.4';


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/three/src/math/Euler.js":
/*!**********************************************!*\
  !*** ./node_modules/three/src/math/Euler.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Euler": function() { return /* binding */ Euler; }
/* harmony export */ });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");





const _matrix = /*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_3__.Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];




/***/ }),

/***/ "./node_modules/three/src/math/MathUtils.js":
/*!**************************************************!*\
  !*** ./node_modules/three/src/math/MathUtils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEG2RAD": function() { return /* binding */ DEG2RAD; },
/* harmony export */   "RAD2DEG": function() { return /* binding */ RAD2DEG; },
/* harmony export */   "generateUUID": function() { return /* binding */ generateUUID; },
/* harmony export */   "clamp": function() { return /* binding */ clamp; },
/* harmony export */   "euclideanModulo": function() { return /* binding */ euclideanModulo; },
/* harmony export */   "mapLinear": function() { return /* binding */ mapLinear; },
/* harmony export */   "inverseLerp": function() { return /* binding */ inverseLerp; },
/* harmony export */   "lerp": function() { return /* binding */ lerp; },
/* harmony export */   "damp": function() { return /* binding */ damp; },
/* harmony export */   "pingpong": function() { return /* binding */ pingpong; },
/* harmony export */   "smoothstep": function() { return /* binding */ smoothstep; },
/* harmony export */   "smootherstep": function() { return /* binding */ smootherstep; },
/* harmony export */   "randInt": function() { return /* binding */ randInt; },
/* harmony export */   "randFloat": function() { return /* binding */ randFloat; },
/* harmony export */   "randFloatSpread": function() { return /* binding */ randFloatSpread; },
/* harmony export */   "seededRandom": function() { return /* binding */ seededRandom; },
/* harmony export */   "degToRad": function() { return /* binding */ degToRad; },
/* harmony export */   "radToDeg": function() { return /* binding */ radToDeg; },
/* harmony export */   "isPowerOfTwo": function() { return /* binding */ isPowerOfTwo; },
/* harmony export */   "ceilPowerOfTwo": function() { return /* binding */ ceilPowerOfTwo; },
/* harmony export */   "floorPowerOfTwo": function() { return /* binding */ floorPowerOfTwo; },
/* harmony export */   "setQuaternionFromProperEuler": function() { return /* binding */ setQuaternionFromProperEuler; }
/* harmony export */ });
const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toUpperCase() here flattens concatenated strings to save heap memory space.
	return uuid.toUpperCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

		 } else {

		return 0;

		 }

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s % 2147483647;

	// Park-Miller algorithm

	_seed = _seed * 16807 % 2147483647;

	return ( _seed - 1 ) / 2147483646;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}







/***/ }),

/***/ "./node_modules/three/src/math/Matrix4.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix4.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix4": function() { return /* binding */ Matrix4; }
/* harmony export */ });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _y = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _z = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();




/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quaternion": function() { return /* binding */ Quaternion; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");


class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;




/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector3": function() { return /* binding */ Vector3; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();




/***/ }),

/***/ "./src/global.ts":
/*!***********************!*\
  !*** ./src/global.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! detect-browser */ "./node_modules/detect-browser/es/index.js");
/* harmony import */ var _isIos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isIos */ "./src/isIos.ts");


window.addEventListener("load", function () {
    var browser = (0,detect_browser__WEBPACK_IMPORTED_MODULE_1__.detect)();
    console.log(browser);
    console.log(navigator.userAgent);
    //iOS we will redirect to non ar version anyway
    if (_isIos__WEBPACK_IMPORTED_MODULE_0__.isIos)
        return;
    if (browser.os !== "Android OS" && browser.os !== "android")
        return;
    if (browser.name !== "chrome" && browser.name !== "chromium-webview") {
        document.querySelector("#error-overlay").innerHTML = "\n    <div>This site only supports the <a href='https://play.google.com/store/apps/details?id=com.android.chrome'>Chrome web browser on Android.</a></div>;\n    ";
        document.querySelector("#error-overlay").style.display = "flex";
    }
});
window.addEventListener("error", function (event) {
    document.querySelector("#error-overlay").innerHTML = "<div>Oops! An error<br><br>Please refresh the page and try again.<br><br><span style=\"font-size: 0.5em\">" + event.message + "</span></div>";
    document.querySelector("#error-overlay").style.display = "flex";
});


/***/ }),

/***/ "./src/isIos.ts":
/*!**********************!*\
  !*** ./src/isIos.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIos": function() { return /* binding */ isIos; }
/* harmony export */ });
var isIos = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document);


/***/ }),

/***/ "./src/loadMedia.ts":
/*!**************************!*\
  !*** ./src/loadMedia.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadMedia": function() { return /* binding */ loadMedia; }
/* harmony export */ });
function loadMedia(state, params) {
    var _this = this;
    state.loaded = false;
    state.numLoaded = 0;
    state.numItems = params.el.children.length;
    state.bufferSources = [];
    console.log(params.audioContext.sampleRate);
    state.requests = [];
    console.log("Loading " + state.numItems + " audio elements");
    var sampleRate = params.audioContext.sampleRate;
    state.progress = Array(params.el.children.length).fill(0);
    Array.from(params.el.children).forEach(function (anchorEl, index) {
        if (anchorEl.tagName !== "A") {
            console.error("The loader should only have <a> children");
        }
        var originalUrl = anchorEl.getAttribute("href");
        var url = sampleRate === 48000
            ? originalUrl.slice(0, -3) + "48." + originalUrl.slice(-3)
            : sampleRate === 44100
                ? originalUrl.slice(0, -3) + "44." + originalUrl.slice(-3)
                : null;
        if (!url)
            throw Error("Unsupported sample rate " + sampleRate);
        state.bufferSources.push(params.audioContext.createBufferSource());
        var request = new XMLHttpRequest();
        state.requests.push(request);
        request.addEventListener("progress", childProgress.bind(_this, state, params, index));
        request.addEventListener("load", childLoadSuccess.bind(_this, state, params, index));
        request.addEventListener("error", childError.bind(_this, index));
        request.addEventListener("abort", childAbort.bind(_this, index));
        request.open("GET", url);
        request.responseType = "arraybuffer";
        request.send();
    });
}
function childProgress(state, params, index, event) {
    var percent = event.total ? event.loaded / event.total : 0;
    state.progress[index] = percent;
    var totalPercent = state.progress.reduce(function (prev, cur) { return prev + cur; }) / state.progress.length;
    params.onProgress(totalPercent);
}
function childLoadSuccess(state, params, index) {
    console.log("Loaded " + index);
    var data = state.requests[index].response;
    //safari doesn't support promise based decode
    params.audioContext.decodeAudioData(data, function (buffer) {
        state.bufferSources[index].buffer = buffer;
        state.numLoaded += 1;
        if (state.numLoaded >= state.numItems) {
            console.log("Loaded all items");
            state.loaded = true;
            params.onSuccess(params.barcodeData, state.bufferSources);
        }
    }, function () {
        childError(index);
    });
}
function childError(index, event) {
    throw Error("Couldn't load piece " + index + ".");
}
function childAbort(index) {
    console.log("Aborting load item " + index);
}


/***/ }),

/***/ "./src/loadResonance.ts":
/*!******************************!*\
  !*** ./src/loadResonance.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadResonance": function() { return /* binding */ loadResonance; }
/* harmony export */ });
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resonance-audio */ "./node_modules/resonance-audio/build/resonance-audio.js");
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(resonance_audio__WEBPACK_IMPORTED_MODULE_0__);

function loadResonance(audioContext) {
    console.log("Loading resonance");
    var ambisonicOrder = 1;
    var resonanceAudioScene = new resonance_audio__WEBPACK_IMPORTED_MODULE_0__.ResonanceAudio(audioContext, { ambisonicOrder: ambisonicOrder });
    resonanceAudioScene.setRoomProperties({ width: 6, height: 5, depth: 6 }, {
        back: "wood-panel",
        left: "brick-bare",
        right: "brick-bare",
        front: "wood-panel",
        down: "plywood-panel",
        up: "acoustic-ceiling-tiles",
    });
    resonanceAudioScene.output.connect(audioContext.destination);
    return resonanceAudioScene;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!******************!*\
  !*** ./src/p.ts ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/src/math/Euler */ "./node_modules/three/src/math/Euler.js");
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nunjucks */ "./node_modules/nunjucks/browser/nunjucks.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nunjucks__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./src/global.ts");
/* harmony import */ var _loadResonance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadResonance */ "./src/loadResonance.ts");
/* harmony import */ var _loadMedia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadMedia */ "./src/loadMedia.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var index = Number.parseInt(window.location.pathname.match(/\/?(\d+)\.html/)[1]);
nunjucks__WEBPACK_IMPORTED_MODULE_0__.configure("templates", { autoescape: true });
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("loader-" + index + ".njk"));
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("scene-" + index + ".njk"));
var loadMediaState = {};
var resonanceAudioScene;
var audioContext;
var orientationPermission = undefined;
var degtorad = Math.PI / 180;
var xAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0);
var yAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var zAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var upAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, -1, 0);
var forwardAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var initialDirection = undefined;
var q0 = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var quaternion = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var alphaOffset = 0;
var forward = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -1);
var up = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var eulerOrigin = new three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__.Euler(Math.PI / 2, 0, 0, "YZX");
var freezeCheckboxEl = document.getElementById("freeze-checkbox");
var animationTimeline = [];
var timelineLoop = null;
var animationTimelineIndex = -1;
var animationStartTime = 0;
var entities = [];
window.addEventListener("load", function () {
    document.body.querySelector("#play-overlay").classList.remove("fade-out");
    audioContext = new window.AudioContext();
    resonanceAudioScene = (0,_loadResonance__WEBPACK_IMPORTED_MODULE_2__.loadResonance)(audioContext);
    var loaderEl = document.querySelector("[loader]");
    (0,_loadMedia__WEBPACK_IMPORTED_MODULE_3__.loadMedia)(loadMediaState, {
        el: loaderEl,
        audioContext: audioContext,
        onSuccess: mediaLoaded,
        onProgress: function (percent) {
            var loadingButton = document.querySelector("#play-button");
            if (loadingButton)
                loadingButton.innerText = "Loading " + Math.round(percent * 98) + "%...";
        },
        barcodeData: index.toString(),
        loadingBarcodeContainer: { loadingBarcode: index },
    });
    loadEntities();
});
function loadEntities() {
    document.body.querySelectorAll("[resonance-source]").forEach(function (e) {
        var _a;
        var index = Number.parseInt(e.getAttribute("resonance-source"));
        var position = e
            .getAttribute("position")
            .split(" ")
            .map(function (i) { return Number.parseFloat(i); });
        var bufferSource = (_a = loadMediaState.bufferSources) === null || _a === void 0 ? void 0 : _a[index];
        var resonanceSource = resonanceAudioScene.createSource();
        bufferSource.connect(resonanceSource.input);
        resonanceSource.setPosition(position[0], position[1], position[2]);
        var animations = extractAnimations(e);
        var mixinAnimations = e.hasAttribute("mixin")
            ? extractAnimations(document.getElementById(e.getAttribute("mixin")))
            : {};
        var entity = {
            el: e,
            position: position,
            index: index,
            bufferSource: bufferSource,
            resonanceSource: resonanceSource,
            animations: __assign(__assign({}, mixinAnimations), animations),
        };
        entities.push(entity);
    });
    document.querySelectorAll("a-entity").forEach(function (e) {
        var attr = Array.from(e.attributes).find(function (attr) { return attr.name.startsWith("animation-timeline"); });
        if (attr) {
            if (timelineLoop !== null)
                throw Error("Found more than one entity with animation-timeline attribute");
            if (attr.value.match(/loop:\s?true/))
                timelineLoop = true;
            else
                timelineLoop = false;
        }
    });
    console.log("loop: " + timelineLoop);
    var t = document.querySelector("a-timeline");
    if (!t)
        throw Error("No animation timeline found");
    var time = 0;
    Array.from(t.children).forEach(function (child) {
        var _a, _b, _c;
        if (child.tagName === "A-TIMELINE-ANIMATION") {
            var name_1 = child.getAttribute("name");
            var offset = (_a = child.getAttribute("offset")) !== null && _a !== void 0 ? _a : 0;
            var target_1 = child.getAttribute("select");
            var entity = entities.find(function (e) { return e.el === document.querySelector(target_1); });
            if (!entity)
                throw Error("Couldn't find entity " + target_1);
            var animation = entity.animations[name_1];
            var startTime = time + ((_b = animation.delay) !== null && _b !== void 0 ? _b : 0) + offset;
            var finishTime = startTime + animation.dur;
            animationTimeline.push({
                animation: animation,
                entity: entity,
                startTime: startTime,
                finishTime: finishTime,
            });
            time = finishTime;
        }
        else if (child.tagName === "A-TIMELINE-GROUP") {
            var group_1 = { items: [], finishTime: 0 };
            var groupOffset_1 = (_c = child.getAttribute("offset")) !== null && _c !== void 0 ? _c : 0;
            Array.from(child.children).forEach(function (grandchild) {
                var _a, _b;
                if (grandchild.tagName === "A-TIMELINE-ANIMATION") {
                    var name_2 = "animation__" + grandchild.getAttribute("name");
                    var offset = (_a = grandchild.getAttribute("offset")) !== null && _a !== void 0 ? _a : 0;
                    var target_2 = grandchild.getAttribute("select");
                    var entity = entities.find(function (e) { return e.el === document.querySelector(target_2); });
                    if (!entity)
                        throw Error("Couldn't find entity " + target_2);
                    var animation = entity.animations[name_2];
                    var startTime = time + ((_b = animation.delay) !== null && _b !== void 0 ? _b : 0) + groupOffset_1 + offset;
                    var finishTime = startTime + animation.dur;
                    group_1.items.push({
                        animation: animation,
                        entity: entity,
                        startTime: startTime,
                        finishTime: finishTime,
                    });
                    group_1.finishTime = Math.max(group_1.finishTime, finishTime);
                }
                else
                    throw Error("Unsupported timeline tag " + grandchild.tagName);
            });
            animationTimeline.push(group_1);
            time = group_1.finishTime;
        }
        else
            throw Error("Unsupported timeline tag " + child.tagName);
    });
    console.log(animationTimeline);
}
function mediaLoaded() {
    var _this = this;
    var button = document.body.querySelector("#play-button");
    button.disabled = false;
    button.innerText = "Play";
    button.addEventListener("click", function () { return __awaiter(_this, void 0, void 0, function () {
        var startTime, message;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    audioContext.resume();
                    startTime = audioContext.currentTime + 1;
                    animationStartTime = Date.now() + 1000;
                    entities.forEach(function (entity) { return entity.bufferSource.start(startTime); });
                    window.setInterval(mainLoop, 50);
                    document.getElementById("title").innerText = "You are listening to the spatial experience.";
                    button.remove();
                    if (!window.DeviceOrientationEvent) return [3 /*break*/, 3];
                    if (!(DeviceOrientationEvent.requestPermission &&
                        orientationPermission !== "denied" &&
                        orientationPermission !== "granted")) return [3 /*break*/, 2];
                    return [4 /*yield*/, DeviceOrientationEvent.requestPermission()];
                case 1:
                    orientationPermission = _a.sent();
                    if (orientationPermission === "denied") {
                        message = document.createElement("p");
                        message.innerText = "You did not give permission to use device motion. Your viewpoint will remain static.";
                        document.body.appendChild(message);
                    }
                    _a.label = 2;
                case 2:
                    window.addEventListener("deviceorientation", throttle(updateListener, 50));
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); });
}
function mainLoop() {
    updateEntities();
}
function updateEntities() {
    var _a, _b;
    var now = Date.now();
    //increment the timeline if necessary
    while (now > ((_b = (_a = animationTimeline === null || animationTimeline === void 0 ? void 0 : animationTimeline[animationTimelineIndex]) === null || _a === void 0 ? void 0 : _a.finishTime) !== null && _b !== void 0 ? _b : 0) + animationStartTime) {
        animationTimelineIndex++;
        if (animationTimelineIndex >= animationTimeline.length) {
            if (!timelineLoop)
                return;
            animationStartTime = animationStartTime + animationTimeline[animationTimelineIndex - 1].finishTime;
            animationTimelineIndex = 0;
        }
    }
    //index is less than zero at the start because the audio plays after 1 sec
    if (animationTimelineIndex < 0)
        return;
    //place items
    var a = animationTimeline[animationTimelineIndex];
    //is array
    if ("items" in a) {
        a.items.forEach(function (item) {
            interpolate(item.entity.resonanceSource, Math.max(0, (now - animationStartTime - item.startTime) / (item.finishTime - item.startTime)), item.animation.from, item.animation.to);
        });
    }
    else {
        //single item, not array
        interpolate(a.entity.resonanceSource, Math.max(0, (now - animationStartTime - a.startTime) / (a.finishTime - a.startTime)), a.animation.from, a.animation.to);
    }
}
function updateListener(e) {
    if (freezeCheckboxEl.checked)
        return;
    var alpha = e.alpha ? e.alpha * degtorad + alphaOffset : 0; // Z
    var beta = e.beta ? e.beta * degtorad : 0; // X'
    var gamma = e.gamma ? e.gamma * degtorad : 0; // Y''
    quaternion.setFromEuler(eulerOrigin);
    q0.setFromAxisAngle(zAxis, alpha);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(xAxis, beta);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(yAxis, gamma);
    quaternion.multiply(q0);
    up.copy(upAxis).applyQuaternion(quaternion);
    forward.copy(forwardAxis).applyQuaternion(quaternion);
    if (!initialDirection) {
        initialDirection = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3().projectOnPlane(upAxis).normalize();
        var angle = initialDirection.angleTo(forwardAxis);
        eulerOrigin.y = angle;
    }
    /*document.querySelector("#debug").innerHTML = `${forward.x.toFixed(2)} ${forward.y.toFixed(2)} ${forward.z.toFixed(
      2,
    )}<br>${up.x.toFixed(2)} ${up.y.toFixed(2)} ${up.z.toFixed(2)}<br>
    ${alpha.toFixed(2)} ${beta.toFixed(2)} ${gamma.toFixed(2)}<br>
    ${eulerOrigin.x.toFixed(2)} ${eulerOrigin.y.toFixed(2)} ${eulerOrigin.z.toFixed(2)}`;*/
    //@ts-expect-error - bad typing
    resonanceAudioScene.setListenerOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
}
function throttle(callback, delay) {
    var prev = 0;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var now = new Date().getTime();
        if (now - prev < delay)
            return;
        prev = now;
        return callback.apply(void 0, args);
    };
}
function extractAnimations(element) {
    var result = {};
    for (var i = 0; i < element.attributes.length; i++) {
        var attr = element.attributes[i];
        if (attr.name.startsWith("animation__") || attr.name === "animation") {
            result[attr.name] = parseAnimation(attr.value);
        }
    }
    return result;
}
function parseAnimation(a) {
    var result = {};
    var data = a.split(";").map(function (e) {
        return e
            .trim()
            .split(":")
            .map(function (e2) { return e2.trim(); });
    });
    for (var i = 0; i < data.length; i++) {
        if (data[i].length < 2)
            continue;
        if (data[i][0] === "from" || data[i][0] === "to") {
            result[data[i][0]] = data[i][1].split(" ").map(function (n) { return Number.parseFloat(n); });
        }
        else if (data[i][0] === "dur" || data[i][0] === "delay") {
            result[data[i][0]] = Number.parseInt(data[i][1]);
        }
        else if (data[i][1] === "true") {
            result[data[i][0]] = true;
        }
        else if (data[i][1] === "false") {
            result[data[i][0]] = false;
        }
        else {
            result[data[i][0]] = data[i][1];
        }
    }
    return result;
}
function interpolate(resonanceSource, t, from, to, easing) {
    if (easing === void 0) { easing = "linear"; }
    switch (easing) {
        case "linear":
            resonanceSource.setPosition(from[0] + t * (to[0] - from[0]), from[1] + t * (to[1] - from[1]), from[2] + t * (to[2] - from[2]));
            break;
        default:
            throw Error("Unhandled easing " + easing);
    }
}

}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9ub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL251bmp1Y2tzL2Jyb3dzZXIvbnVuanVja3MuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3Jlc29uYW5jZS1hdWRpby9idWlsZC9yZXNvbmFuY2UtYXVkaW8uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0V1bGVyLmpzIiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDQuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1F1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1ZlY3RvcjMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2dsb2JhbC50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvaXNJb3MudHMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2xvYWRNZWRpYS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvbG9hZFJlc29uYW5jZS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL3AudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzQkFBc0IsU0FBSSxJQUFJLFNBQUk7QUFDbEMsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LDRCQUE0QixxQkFBcUI7QUFDakQsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsZ0JBQWdCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLCtDQUErQywwREFBMEQsMkNBQTJDLHVDQUF1Qzs7QUFFM0wsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZUFBZSxnQ0FBbUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxNQUFNOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsT0FBTzs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOzs7QUFHcEMsOENBQThDO0FBQzlDOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMOztBQUVBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBLHNFQUFzRTs7QUFFdEUsNENBQTRDOztBQUU1QywwRUFBMEU7O0FBRTFFLHlCQUF5Qjs7QUFFekI7QUFDQSw4Q0FBOEM7O0FBRTlDLDBFQUEwRTs7QUFFMUUsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBLG9DQUFvQzs7O0FBR3BDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLHVCQUF1QixRQUFROztBQUUvQjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMEVBQTBFO0FBQzFFLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlDQUF5Qzs7QUFFekM7O0FBRUE7O0FBRUEscUJBQXFCOztBQUVyQixpQ0FBaUM7O0FBRWpDLCtEQUErRCxHQUFHO0FBQ2xFOzs7QUFHQTtBQUNBLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7OztBQUdBLHdEQUF3RDs7QUFFeEQsMkRBQTJEOztBQUUzRCxzQ0FBc0MsZ0NBQWdDLGVBQWUsR0FBRzs7O0FBR3hGO0FBQ0E7O0FBRUEsK0VBQStFOztBQUUvRSwyRkFBMkY7O0FBRTNGO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx1QkFBdUI7O0FBRXZCLHVCQUF1QixPQUFPLEdBQUc7OztBQUdqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDLHlFQUF5RTs7QUFFekUseURBQXlEOztBQUV6RCw2QkFBNkI7O0FBRTdCLDZEQUE2RDs7QUFFN0Qsa0VBQWtFOztBQUVsRSxrRUFBa0U7O0FBRWxFOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHVCQUF1Qjs7QUFFdkIsdUJBQXVCO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLDJEQUEyRDs7QUFFM0QsMENBQTBDLGdDQUFnQyxlQUFlOztBQUV6Riw4REFBOEQ7O0FBRTlELHlFQUF5RTs7QUFFekU7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVAsdUJBQXVCO0FBQ3ZCOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQSx5Q0FBeUM7O0FBRXpDOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7O0FBRUE7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBLHFIQUFxSDs7QUFFckgsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUEsd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssZUFBZTs7QUFFcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxpTEFBaUwsNEJBQTRCLCtDQUErQyx5QkFBeUIsMkJBQTJCLGlFQUFpRSx1Q0FBdUMsRUFBRSxHQUFHO0FBQzdaO0FBQ0E7OztBQUdBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCwwREFBMEQsaUJBQWlCOztBQUUzRSxvRUFBb0U7O0FBRXBFLHFCQUFxQixFQUFFOztBQUV2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOzs7QUFHMUM7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRSxLQUFLO0FBQ0w7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUEsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxnRUFBZ0U7QUFDaEUsS0FBSztBQUNMLDBFQUEwRTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEseUdBQXlHOztBQUV6RywwRUFBMEU7O0FBRTFFLDBCQUEwQixPQUFPOztBQUVqQyx5RUFBeUUsUUFBUTs7QUFFakYsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBLG9FQUFvRTtBQUNwRSxPQUFPO0FBQ1AsOEVBQThFO0FBQzlFO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSw4REFBOEQsUUFBUSxFQUFFO0FBQ3hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHlEQUF5RDs7QUFFekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhFQUE4RTtBQUM5RTtBQUNBOzs7QUFHQTs7QUFFQSxpRUFBaUU7O0FBRWpFLGtGQUFrRjs7QUFFbEYscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQzs7QUFFQSx3Q0FBd0M7O0FBRXhDOztBQUVBLCtDQUErQyxFQUFFOztBQUVqRCxxQkFBcUIsRUFBRTs7QUFFdkI7O0FBRUE7O0FBRUEsaURBQWlEOztBQUVqRDs7QUFFQSxnREFBZ0QsRUFBRTs7QUFFbEQscUJBQXFCLEVBQUU7O0FBRXZCOztBQUVBLCtDQUErQzs7QUFFL0MsNkNBQTZDOztBQUU3QyxtQ0FBbUM7O0FBRW5DLHFCQUFxQixFQUFFOztBQUV2QixvREFBb0Q7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQyxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGtDQUFrQzs7QUFFbEMscUJBQXFCLE1BQU07OztBQUczQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUEsd0NBQXdDOztBQUV4QyxvRkFBb0Y7O0FBRXBGLHFCQUFxQixPQUFPOztBQUU1QixrREFBa0Q7O0FBRWxELHFCQUFxQjs7QUFFckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSwrQ0FBK0MsMERBQTBELDJDQUEyQyx1Q0FBdUM7O0FBRTNMLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLFdBQVcsZ0NBQW1COztBQUU5QixlQUFlLGdDQUFtQjtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0EsK0NBQStDLDBEQUEwRCwyQ0FBMkMsdUNBQXVDOztBQUUzTCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxXQUFXLGdDQUFtQjs7QUFFOUIsaUJBQWlCLGdDQUFtQjs7QUFFcEMsVUFBVSxnQ0FBbUI7O0FBRTdCLGVBQWUsZ0NBQW1COztBQUVsQyxjQUFjLGdDQUFtQjs7QUFFakMsZUFBZSxnQ0FBbUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBLFlBQVksZ0NBQW1COztBQUUvQixjQUFjLGdDQUFtQjs7QUFFakMsZ0JBQWdCLGdDQUFtQjtBQUNuQztBQUNBOztBQUVBLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7O0FBRUEsaUJBQWlCLGdDQUFtQixLQUFLO0FBQ3pDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLCtDQUErQywwREFBMEQsMkNBQTJDLHVDQUF1Qzs7QUFFM0wsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssWUFBWSxnQ0FBbUI7O0FBRS9CLFlBQVksZ0NBQW1COztBQUUvQixVQUFVLGdDQUFtQjs7QUFFN0IsVUFBVSxnQ0FBbUI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsTUFBTTtBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRzs7QUFFbkc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QyxzQ0FBc0M7O0FBRXRDLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsTUFBTTtBQUNQLHVCQUF1QixXQUFXLFVBQVUsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBLFVBQVUsaUNBQW1COztBQUU3QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsK0NBQStDLDBEQUEwRCwyQ0FBMkMsdUNBQXVDOztBQUUzTCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxhQUFhLGlDQUFtQjs7QUFFaEMsZUFBZSxpQ0FBbUI7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBLFVBQVUsaUNBQW1COztBQUU3QixlQUFlLGlDQUFtQjtBQUNsQztBQUNBOztBQUVBLGFBQWEsaUNBQW1COztBQUVoQyxjQUFjLGlDQUFtQjs7QUFFakMsaUJBQWlCLGlDQUFtQjs7QUFFcEMsZUFBZSxpQ0FBbUI7O0FBRWxDLGFBQWEsaUNBQW1COztBQUVoQyxZQUFZLGlDQUFtQjs7QUFFL0IsY0FBYyxpQ0FBbUI7O0FBRWpDLFlBQVksaUNBQW1COztBQUUvQix5QkFBeUIsaUNBQW1CLEtBQUs7OztBQUdqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQSxjQUFjLGlDQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixlQUFlLGlDQUFtQjs7QUFFOUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTCxxR0FBcUc7QUFDckcsR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FB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Qjs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlEQUFpRDs7O0FBR2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtB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OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25VakI7O0FBRUEsZ0JBQWdCLFNBQVM7O0FBRXpCOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUE0QkU7Ozs7Ozs7Ozs7Ozs7Ozs7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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLGdEQUFlOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFc0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pwQnNCO0FBQ0M7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FB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LENBQUMsQ0FBQyxLQUFLLE9BQU8sRUFBRTtZQUNqQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO1NBQzVCO2FBQU07WUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pDO0tBQ0Y7SUFDRCxPQUFPLE1BQXlCLENBQUM7QUFDbkMsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUNsQixlQUF1QixFQUN2QixDQUFTLEVBQ1QsSUFBOEIsRUFDOUIsRUFBNEIsRUFDNUIsTUFBNEM7SUFBNUMsMENBQTRDO0lBRTVDLFFBQVEsTUFBTSxFQUFFO1FBQ2QsS0FBSyxRQUFRO1lBQ1gsZUFBZSxDQUFDLFdBQVcsQ0FDekIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDL0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDL0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDaEMsQ0FBQztZQUNGLE1BQU07UUFDUjtZQUNFLE1BQU0sS0FBSyxDQUFDLHNCQUFvQixNQUFRLENBQUMsQ0FBQztLQUM3QztBQUNILENBQUMiLCJmaWxlIjoicC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xudmFyIEJyb3dzZXJJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJJbmZvKG5hbWUsIHZlcnNpb24sIG9zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMub3MgPSBvcztcbiAgICAgICAgdGhpcy50eXBlID0gJ2Jyb3dzZXInO1xuICAgIH1cbiAgICByZXR1cm4gQnJvd3NlckluZm87XG59KCkpO1xuZXhwb3J0IHsgQnJvd3NlckluZm8gfTtcbnZhciBOb2RlSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlSW5mbyh2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm9zID0gcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgICB9XG4gICAgcmV0dXJuIE5vZGVJbmZvO1xufSgpKTtcbmV4cG9ydCB7IE5vZGVJbmZvIH07XG52YXIgU2VhcmNoQm90RGV2aWNlSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWFyY2hCb3REZXZpY2VJbmZvKG5hbWUsIHZlcnNpb24sIG9zLCBib3QpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgICAgICB0aGlzLmJvdCA9IGJvdDtcbiAgICAgICAgdGhpcy50eXBlID0gJ2JvdC1kZXZpY2UnO1xuICAgIH1cbiAgICByZXR1cm4gU2VhcmNoQm90RGV2aWNlSW5mbztcbn0oKSk7XG5leHBvcnQgeyBTZWFyY2hCb3REZXZpY2VJbmZvIH07XG52YXIgQm90SW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCb3RJbmZvKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm90JztcbiAgICAgICAgdGhpcy5ib3QgPSB0cnVlOyAvLyBOT1RFOiBkZXByZWNhdGVkIHRlc3QgbmFtZSBpbnN0ZWFkXG4gICAgICAgIHRoaXMubmFtZSA9ICdib3QnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJvdEluZm87XG59KCkpO1xuZXhwb3J0IHsgQm90SW5mbyB9O1xudmFyIFJlYWN0TmF0aXZlSW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWFjdE5hdGl2ZUluZm8oKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdyZWFjdC1uYXRpdmUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAncmVhY3QtbmF0aXZlJztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdE5hdGl2ZUluZm87XG59KCkpO1xuZXhwb3J0IHsgUmVhY3ROYXRpdmVJbmZvIH07XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG52YXIgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xudmFyIFNFQVJDSEJPVF9PU19SRUdFWCA9IC8obnVoa3xHb29nbGVib3R8WWFtbXlib3R8T3BlbmJvdHxTbHVycHxNU05Cb3R8QXNrXFwgSmVldmVzXFwvVGVvbWF8aWFfYXJjaGl2ZXIpLztcbnZhciBSRVFVSVJFRF9WRVJTSU9OX1BBUlRTID0gMztcbnZhciB1c2VyQWdlbnRSdWxlcyA9IFtcbiAgICBbJ2FvbCcsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ2VkZ2UnLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZS1pb3MnLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sXG4gICAgWyd5YW5kZXhicm93c2VyJywgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsna2FrYW90YWxrJywgL0tBS0FPVEFMS1xccyhbMC05XFwuXSspL10sXG4gICAgWydzYW1zdW5nJywgL1NhbXN1bmdCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ3NpbGsnLCAvXFxiU2lsa1xcLyhbMC05Ll8tXSspXFxiL10sXG4gICAgWydtaXVpJywgL01pdWlCcm93c2VyXFwvKFswLTlcXC5dKykkL10sXG4gICAgWydiZWFrZXInLCAvQmVha2VyQnJvd3NlclxcLyhbMC05XFwuXSspL10sXG4gICAgWydlZGdlLWNocm9taXVtJywgL0VkZ0E/XFwvKFswLTlcXC5dKykvXSxcbiAgICBbXG4gICAgICAgICdjaHJvbWl1bS13ZWJ2aWV3JyxcbiAgICAgICAgLyg/IUNocm9tLipPUFIpd3ZcXCkuKkNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvLFxuICAgIF0sXG4gICAgWydjaHJvbWUnLCAvKD8hQ2hyb20uKk9QUilDaHJvbSg/OmV8aXVtKVxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sXG4gICAgWydwaGFudG9tanMnLCAvUGhhbnRvbUpTXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2NyaW9zJywgL0NyaU9TXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2ZpcmVmb3gnLCAvRmlyZWZveFxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydmeGlvcycsIC9GeGlPU1xcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYS1taW5pJywgL09wZXJhIE1pbmkuKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnb3BlcmEnLCAvT3BlcmFcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLFxuICAgIFsnb3BlcmEnLCAvT1BSXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ2llJywgL1RyaWRlbnRcXC83XFwuMC4qcnZcXDooWzAtOVxcLl0rKS4qXFwpLipHZWNrbyQvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoWzAtOVxcLl0rKTsuKlRyaWRlbnRcXC9bNC03XS4wL10sXG4gICAgWydpZScsIC9NU0lFXFxzKDdcXC4wKS9dLFxuICAgIFsnYmIxMCcsIC9CQjEwO1xcc1RvdWNoLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2FuZHJvaWQnLCAvQW5kcm9pZFxccyhbMC05XFwuXSspL10sXG4gICAgWydpb3MnLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qTW9iaWxlLipTYWZhcmkuKi9dLFxuICAgIFsnc2FmYXJpJywgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKlNhZmFyaS9dLFxuICAgIFsnZmFjZWJvb2snLCAvRkJBVlxcLyhbMC05XFwuXSspL10sXG4gICAgWydpbnN0YWdyYW0nLCAvSW5zdGFncmFtXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcy13ZWJ2aWV3JywgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKk1vYmlsZS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qR2Vja29cXCkkL10sXG4gICAgWydzZWFyY2hib3QnLCBTRUFSQ0hCT1hfVUFfUkVHRVhdLFxuXTtcbnZhciBvcGVyYXRpbmdTeXN0ZW1SdWxlcyA9IFtcbiAgICBbJ2lPUycsIC9pUChob25lfG9kfGFkKS9dLFxuICAgIFsnQW5kcm9pZCBPUycsIC9BbmRyb2lkL10sXG4gICAgWydCbGFja0JlcnJ5IE9TJywgL0JsYWNrQmVycnl8QkIxMC9dLFxuICAgIFsnV2luZG93cyBNb2JpbGUnLCAvSUVNb2JpbGUvXSxcbiAgICBbJ0FtYXpvbiBPUycsIC9LaW5kbGUvXSxcbiAgICBbJ1dpbmRvd3MgMy4xMScsIC9XaW4xNi9dLFxuICAgIFsnV2luZG93cyA5NScsIC8oV2luZG93cyA5NSl8KFdpbjk1KXwoV2luZG93c185NSkvXSxcbiAgICBbJ1dpbmRvd3MgOTgnLCAvKFdpbmRvd3MgOTgpfChXaW45OCkvXSxcbiAgICBbJ1dpbmRvd3MgMjAwMCcsIC8oV2luZG93cyBOVCA1LjApfChXaW5kb3dzIDIwMDApL10sXG4gICAgWydXaW5kb3dzIFhQJywgLyhXaW5kb3dzIE5UIDUuMSl8KFdpbmRvd3MgWFApL10sXG4gICAgWydXaW5kb3dzIFNlcnZlciAyMDAzJywgLyhXaW5kb3dzIE5UIDUuMikvXSxcbiAgICBbJ1dpbmRvd3MgVmlzdGEnLCAvKFdpbmRvd3MgTlQgNi4wKS9dLFxuICAgIFsnV2luZG93cyA3JywgLyhXaW5kb3dzIE5UIDYuMSkvXSxcbiAgICBbJ1dpbmRvd3MgOCcsIC8oV2luZG93cyBOVCA2LjIpL10sXG4gICAgWydXaW5kb3dzIDguMScsIC8oV2luZG93cyBOVCA2LjMpL10sXG4gICAgWydXaW5kb3dzIDEwJywgLyhXaW5kb3dzIE5UIDEwLjApL10sXG4gICAgWydXaW5kb3dzIE1FJywgL1dpbmRvd3MgTUUvXSxcbiAgICBbJ09wZW4gQlNEJywgL09wZW5CU0QvXSxcbiAgICBbJ1N1biBPUycsIC9TdW5PUy9dLFxuICAgIFsnQ2hyb21lIE9TJywgL0NyT1MvXSxcbiAgICBbJ0xpbnV4JywgLyhMaW51eCl8KFgxMSkvXSxcbiAgICBbJ01hYyBPUycsIC8oTWFjX1Bvd2VyUEMpfChNYWNpbnRvc2gpL10sXG4gICAgWydRTlgnLCAvUU5YL10sXG4gICAgWydCZU9TJywgL0JlT1MvXSxcbiAgICBbJ09TLzInLCAvT1NcXC8yL10sXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdCh1c2VyQWdlbnQpIHtcbiAgICBpZiAoISF1c2VyQWdlbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVXNlckFnZW50KHVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhY3ROYXRpdmVJbmZvKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICAgIHJldHVybiBnZXROb2RlVmVyc2lvbigpO1xufVxuZnVuY3Rpb24gbWF0Y2hVc2VyQWdlbnQodWEpIHtcbiAgICAvLyBvcHRlZCBmb3IgdXNpbmcgcmVkdWNlIGhlcmUgcmF0aGVyIHRoYW4gQXJyYXkjZmlyc3Qgd2l0aCBhIHJlZ2V4LnRlc3QgY2FsbFxuICAgIC8vIHRoaXMgaXMgcHJpbWFyaWx5IGJlY2F1c2UgdXNpbmcgdGhlIHJlZHVjZSB3ZSBvbmx5IHBlcmZvcm0gdGhlIHJlZ2V4XG4gICAgLy8gZXhlY3V0aW9uIG9uY2UgcmF0aGVyIHRoYW4gb25jZSBmb3IgdGhlIHRlc3QgYW5kIGZvciB0aGUgZXhlYyBhZ2FpbiBiZWxvd1xuICAgIC8vIHByb2JhYmx5IHNvbWV0aGluZyB0aGF0IG5lZWRzIHRvIGJlIGJlbmNobWFya2VkIHRob3VnaFxuICAgIHJldHVybiAodWEgIT09ICcnICYmXG4gICAgICAgIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgX2EpIHtcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVhTWF0Y2ggPSByZWdleC5leGVjKHVhKTtcbiAgICAgICAgICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICAgICAgICB9LCBmYWxzZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJyb3dzZXJOYW1lKHVhKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaFVzZXJBZ2VudCh1YSk7XG4gICAgcmV0dXJuIGRhdGEgPyBkYXRhWzBdIDogbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVzZXJBZ2VudCh1YSkge1xuICAgIHZhciBtYXRjaGVkUnVsZSA9IG1hdGNoVXNlckFnZW50KHVhKTtcbiAgICBpZiAoIW1hdGNoZWRSdWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IG1hdGNoZWRSdWxlWzBdLCBtYXRjaCA9IG1hdGNoZWRSdWxlWzFdO1xuICAgIGlmIChuYW1lID09PSAnc2VhcmNoYm90Jykge1xuICAgICAgICByZXR1cm4gbmV3IEJvdEluZm8oKTtcbiAgICB9XG4gICAgdmFyIHZlcnNpb25QYXJ0cyA9IG1hdGNoWzFdICYmIG1hdGNoWzFdLnNwbGl0KC9bLl9dLykuc2xpY2UoMCwgMyk7XG4gICAgaWYgKHZlcnNpb25QYXJ0cykge1xuICAgICAgICBpZiAodmVyc2lvblBhcnRzLmxlbmd0aCA8IFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMpIHtcbiAgICAgICAgICAgIHZlcnNpb25QYXJ0cyA9IF9fc3ByZWFkQXJyYXlzKHZlcnNpb25QYXJ0cywgY3JlYXRlVmVyc2lvblBhcnRzKFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMgLSB2ZXJzaW9uUGFydHMubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZlcnNpb25QYXJ0cyA9IFtdO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvbiA9IHZlcnNpb25QYXJ0cy5qb2luKCcuJyk7XG4gICAgdmFyIG9zID0gZGV0ZWN0T1ModWEpO1xuICAgIHZhciBzZWFyY2hCb3RNYXRjaCA9IFNFQVJDSEJPVF9PU19SRUdFWC5leGVjKHVhKTtcbiAgICBpZiAoc2VhcmNoQm90TWF0Y2ggJiYgc2VhcmNoQm90TWF0Y2hbMV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hCb3REZXZpY2VJbmZvKG5hbWUsIHZlcnNpb24sIG9zLCBzZWFyY2hCb3RNYXRjaFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdE9TKHVhKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBjb3VudCA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzLmxlbmd0aDsgaWkgPCBjb3VudDsgaWkrKykge1xuICAgICAgICB2YXIgX2EgPSBvcGVyYXRpbmdTeXN0ZW1SdWxlc1tpaV0sIG9zID0gX2FbMF0sIHJlZ2V4ID0gX2FbMV07XG4gICAgICAgIHZhciBtYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBvcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlVmVyc2lvbigpIHtcbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbjtcbiAgICByZXR1cm4gaXNOb2RlID8gbmV3IE5vZGVJbmZvKHByb2Nlc3MudmVyc2lvbi5zbGljZSgxKSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlVmVyc2lvblBhcnRzKGNvdW50KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBjb3VudDsgaWkrKykge1xuICAgICAgICBvdXRwdXQucHVzaCgnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyohIEJyb3dzZXIgYnVuZGxlIG9mIG51bmp1Y2tzIDMuMi4zICAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibnVuanVja3NcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibnVuanVja3NcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDExKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGVzY2FwZU1hcCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgJ1xcJyc6ICcmIzM5OycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7J1xufTtcbnZhciBlc2NhcGVSZWdleCA9IC9bJlwiJzw+XS9nO1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgaykge1xuICByZXR1cm4gT2JqUHJvdG8uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspO1xufVxuXG5leHBvcnRzLmhhc093blByb3AgPSBoYXNPd25Qcm9wO1xuXG5mdW5jdGlvbiBsb29rdXBFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIGVzY2FwZU1hcFtjaF07XG59XG5cbmZ1bmN0aW9uIF9wcmV0dGlmeUVycm9yKHBhdGgsIHdpdGhJbnRlcm5hbHMsIGVycikge1xuICBpZiAoIWVyci5VcGRhdGUpIHtcbiAgICAvLyBub3Qgb25lIG9mIG91cnMsIGNhc3QgaXRcbiAgICBlcnIgPSBuZXcgZXhwb3J0cy5UZW1wbGF0ZUVycm9yKGVycik7XG4gIH1cblxuICBlcnIuVXBkYXRlKHBhdGgpOyAvLyBVbmxlc3MgdGhleSBtYXJrZWQgdGhlIGRldiBmbGFnLCBzaG93IHRoZW0gYSB0cmFjZSBmcm9tIGhlcmVcblxuICBpZiAoIXdpdGhJbnRlcm5hbHMpIHtcbiAgICB2YXIgb2xkID0gZXJyO1xuICAgIGVyciA9IG5ldyBFcnJvcihvbGQubWVzc2FnZSk7XG4gICAgZXJyLm5hbWUgPSBvbGQubmFtZTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbmV4cG9ydHMuX3ByZXR0aWZ5RXJyb3IgPSBfcHJldHRpZnlFcnJvcjtcblxuZnVuY3Rpb24gVGVtcGxhdGVFcnJvcihtZXNzYWdlLCBsaW5lbm8sIGNvbG5vKSB7XG4gIHZhciBlcnI7XG4gIHZhciBjYXVzZTtcblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY2F1c2UgPSBtZXNzYWdlO1xuICAgIG1lc3NhZ2UgPSBjYXVzZS5uYW1lICsgXCI6IFwiICsgY2F1c2UubWVzc2FnZTtcbiAgfVxuXG4gIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVyciwgVGVtcGxhdGVFcnJvci5wcm90b3R5cGUpO1xuICB9IGVsc2Uge1xuICAgIGVyciA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ21lc3NhZ2UnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICduYW1lJywge1xuICAgIHZhbHVlOiAnVGVtcGxhdGUgcmVuZGVyIGVycm9yJ1xuICB9KTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG5cbiAgdmFyIGdldFN0YWNrO1xuXG4gIGlmIChjYXVzZSkge1xuICAgIHZhciBzdGFja0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNhdXNlLCAnc3RhY2snKTtcblxuICAgIGdldFN0YWNrID0gc3RhY2tEZXNjcmlwdG9yICYmIChzdGFja0Rlc2NyaXB0b3IuZ2V0IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdGFja0Rlc2NyaXB0b3IudmFsdWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWdldFN0YWNrKSB7XG4gICAgICBnZXRTdGFjayA9IGZ1bmN0aW9uIGdldFN0YWNrKCkge1xuICAgICAgICByZXR1cm4gY2F1c2Uuc3RhY2s7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG5cbiAgICBnZXRTdGFjayA9IGZ1bmN0aW9uIGdldFN0YWNrKCkge1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnc3RhY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0U3RhY2suY2FsbChlcnIpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdjYXVzZScsIHtcbiAgICB2YWx1ZTogY2F1c2VcbiAgfSk7XG4gIGVyci5saW5lbm8gPSBsaW5lbm87XG4gIGVyci5jb2xubyA9IGNvbG5vO1xuICBlcnIuZmlyc3RVcGRhdGUgPSB0cnVlO1xuXG4gIGVyci5VcGRhdGUgPSBmdW5jdGlvbiBVcGRhdGUocGF0aCkge1xuICAgIHZhciBtc2cgPSAnKCcgKyAocGF0aCB8fCAndW5rbm93biBwYXRoJykgKyAnKSc7IC8vIG9ubHkgc2hvdyBsaW5lbm8gKyBjb2xubyBuZXh0IHRvIHBhdGggb2YgdGVtcGxhdGVcbiAgICAvLyB3aGVyZSBlcnJvciBvY2N1cnJlZFxuXG4gICAgaWYgKHRoaXMuZmlyc3RVcGRhdGUpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVubyAmJiB0aGlzLmNvbG5vKSB7XG4gICAgICAgIG1zZyArPSBcIiBbTGluZSBcIiArIHRoaXMubGluZW5vICsgXCIsIENvbHVtbiBcIiArIHRoaXMuY29sbm8gKyBcIl1cIjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5saW5lbm8pIHtcbiAgICAgICAgbXNnICs9IFwiIFtMaW5lIFwiICsgdGhpcy5saW5lbm8gKyBcIl1cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtc2cgKz0gJ1xcbiAnO1xuXG4gICAgaWYgKHRoaXMuZmlyc3RVcGRhdGUpIHtcbiAgICAgIG1zZyArPSAnICc7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlID0gbXNnICsgKHRoaXMubWVzc2FnZSB8fCAnJyk7XG4gICAgdGhpcy5maXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBlcnI7XG59XG5cbmlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKFRlbXBsYXRlRXJyb3IucHJvdG90eXBlLCBFcnJvci5wcm90b3R5cGUpO1xufSBlbHNlIHtcbiAgVGVtcGxhdGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogVGVtcGxhdGVFcnJvclxuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydHMuVGVtcGxhdGVFcnJvciA9IFRlbXBsYXRlRXJyb3I7XG5cbmZ1bmN0aW9uIGVzY2FwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbC5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBsb29rdXBFc2NhcGUpO1xufVxuXG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9ialByb3RvLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIE9ialByb3RvLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gIHJldHVybiBPYmpQcm90by50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuXG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGF0dHJcbiAqIEByZXR1cm5zIHsoc3RyaW5nfG51bWJlcilbXX1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3ByZXBhcmVBdHRyaWJ1dGVQYXJ0cyhhdHRyKSB7XG4gIGlmICghYXR0cikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXR0ciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXR0ci5zcGxpdCgnLicpO1xuICB9XG5cbiAgcmV0dXJuIFthdHRyXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgYXR0cmlidXRlICAgICAgQXR0cmlidXRlIHZhbHVlLiBEb3RzIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oT2JqZWN0KTogKn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEF0dHJHZXR0ZXIoYXR0cmlidXRlKSB7XG4gIHZhciBwYXJ0cyA9IF9wcmVwYXJlQXR0cmlidXRlUGFydHMoYXR0cmlidXRlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gYXR0ckdldHRlcihpdGVtKSB7XG4gICAgdmFyIF9pdGVtID0gaXRlbTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07IC8vIElmIGl0ZW0gaXMgbm90IGFuIG9iamVjdCwgYW5kIHdlIHN0aWxsIGdvdCBwYXJ0cyB0byBoYW5kbGUsIGl0IG1lYW5zXG4gICAgICAvLyB0aGF0IHNvbWV0aGluZyBnb2VzIHdyb25nLiBKdXN0IHJvbGwgb3V0IHRvIHVuZGVmaW5lZCBpbiB0aGF0IGNhc2UuXG5cbiAgICAgIGlmIChoYXNPd25Qcm9wKF9pdGVtLCBwYXJ0KSkge1xuICAgICAgICBfaXRlbSA9IF9pdGVtW3BhcnRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2l0ZW07XG4gIH07XG59XG5cbmV4cG9ydHMuZ2V0QXR0ckdldHRlciA9IGdldEF0dHJHZXR0ZXI7XG5cbmZ1bmN0aW9uIGdyb3VwQnkob2JqLCB2YWwsIHRocm93T25VbmRlZmluZWQpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaXRlcmF0b3IgPSBpc0Z1bmN0aW9uKHZhbCkgPyB2YWwgOiBnZXRBdHRyR2V0dGVyKHZhbCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbaV07XG4gICAgdmFyIGtleSA9IGl0ZXJhdG9yKHZhbHVlLCBpKTtcblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCAmJiB0aHJvd09uVW5kZWZpbmVkID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZ3JvdXBieTogYXR0cmlidXRlIFxcXCJcIiArIHZhbCArIFwiXFxcIiByZXNvbHZlZCB0byB1bmRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgKHJlc3VsdFtrZXldIHx8IChyZXN1bHRba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLmdyb3VwQnkgPSBncm91cEJ5O1xuXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbn1cblxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFhcnJheSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgY29udGFpbnMgPSB0b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7XG4gIHZhciBpbmRleCA9IC0xO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGluZGV4T2YoY29udGFpbnMsIGFycmF5W2luZGV4XSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMud2l0aG91dCA9IHdpdGhvdXQ7XG5cbmZ1bmN0aW9uIHJlcGVhdChjaGFyXywgbikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBzdHIgKz0gY2hhcl87XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnRzLnJlcGVhdCA9IHJlcGVhdDtcblxuZnVuY3Rpb24gZWFjaChvYmosIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5UHJvdG8uZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gQXJyYXlQcm90by5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goZnVuYywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZ1bmMuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZWFjaCA9IGVhY2g7XG5cbmZ1bmN0aW9uIG1hcChvYmosIGZ1bmMpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGlmIChBcnJheVByb3RvLm1hcCAmJiBvYmoubWFwID09PSBBcnJheVByb3RvLm1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmMpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGZ1bmMob2JqW2ldLCBpKTtcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIHJlc3VsdHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnRzLm1hcCA9IG1hcDtcblxuZnVuY3Rpb24gYXN5bmNJdGVyKGFyciwgaXRlciwgY2IpIHtcbiAgdmFyIGkgPSAtMTtcblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGkrKztcblxuICAgIGlmIChpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgaXRlcihhcnJbaV0sIGksIG5leHQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmV4cG9ydHMuYXN5bmNJdGVyID0gYXN5bmNJdGVyO1xuXG5mdW5jdGlvbiBhc3luY0ZvcihvYmosIGl0ZXIsIGNiKSB7XG4gIHZhciBrZXlzID0ga2V5c18ob2JqIHx8IHt9KTtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaSsrO1xuICAgIHZhciBrID0ga2V5c1tpXTtcblxuICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICBpdGVyKGssIG9ialtrXSwgaSwgbGVuLCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmV4cG9ydHMuYXN5bmNGb3IgPSBhc3luY0ZvcjtcblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnIgfHwgW10sIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG59XG5cbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5cbmZ1bmN0aW9uIGtleXNfKG9iaikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICB2YXIgYXJyID0gW107XG5cbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICBhcnIucHVzaChrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnRzLmtleXMgPSBrZXlzXztcblxuZnVuY3Rpb24gX2VudHJpZXMob2JqKSB7XG4gIHJldHVybiBrZXlzXyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBbaywgb2JqW2tdXTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuX2VudHJpZXMgPSBfZW50cmllcztcblxuZnVuY3Rpb24gX3ZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIGtleXNfKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIG9ialtrXTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuX3ZhbHVlcyA9IF92YWx1ZXM7XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmoxLCBvYmoyKSB7XG4gIG9iajEgPSBvYmoxIHx8IHt9O1xuICBrZXlzXyhvYmoyKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgb2JqMVtrXSA9IG9iajJba107XG4gIH0pO1xuICByZXR1cm4gb2JqMTtcbn1cblxuZXhwb3J0cy5fYXNzaWduID0gZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5cbmZ1bmN0aW9uIGluT3BlcmF0b3Ioa2V5LCB2YWwpIHtcbiAgaWYgKGlzQXJyYXkodmFsKSB8fCBpc1N0cmluZyh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5pbmRleE9mKGtleSkgIT09IC0xO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4ga2V5IGluIHZhbDtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBcImluXCIgb3BlcmF0b3IgdG8gc2VhcmNoIGZvciBcIicgKyBrZXkgKyAnXCIgaW4gdW5leHBlY3RlZCB0eXBlcy4nKTtcbn1cblxuZXhwb3J0cy5pbk9wZXJhdG9yID0gaW5PcGVyYXRvcjtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuIC8vIEEgc2ltcGxlIGNsYXNzIHN5c3RlbSwgbW9yZSBkb2N1bWVudGF0aW9uIHRvIGNvbWVcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIEV2ZW50RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gcGFyZW50V3JhcChwYXJlbnQsIHByb3ApIHtcbiAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgcGFyZW50IG1ldGhvZFxuICAgIHZhciB0bXAgPSB0aGlzLnBhcmVudDsgLy8gU2V0IHBhcmVudCB0byB0aGUgcHJldmlvdXMgbWV0aG9kLCBjYWxsLCBhbmQgcmVzdG9yZVxuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdmFyIHJlcyA9IHByb3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhcmVudCA9IHRtcDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbmRDbGFzcyhjbHMsIG5hbWUsIHByb3BzKSB7XG4gIHByb3BzID0gcHJvcHMgfHwge307XG4gIGxpYi5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgcHJvcHNba10gPSBwYXJlbnRXcmFwKGNscy5wcm90b3R5cGVba10sIHByb3BzW2tdKTtcbiAgfSk7XG5cbiAgdmFyIHN1YmNsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfY2xzKSB7XG4gICAgX2luaGVyaXRzTG9vc2Uoc3ViY2xhc3MsIF9jbHMpO1xuXG4gICAgZnVuY3Rpb24gc3ViY2xhc3MoKSB7XG4gICAgICByZXR1cm4gX2Nscy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKHN1YmNsYXNzLCBbe1xuICAgICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIHN1YmNsYXNzO1xuICB9KGNscyk7XG5cbiAgbGliLl9hc3NpZ24oc3ViY2xhc3MucHJvdG90eXBlLCBwcm9wcyk7XG5cbiAgcmV0dXJuIHN1YmNsYXNzO1xufVxuXG52YXIgT2JqID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JqKCkge1xuICAgIC8vIFVuZm9ydHVuYXRlbHkgbmVjZXNzYXJ5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9iai5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge307XG5cbiAgT2JqLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChuYW1lLCBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHByb3BzID0gbmFtZTtcbiAgICAgIG5hbWUgPSAnYW5vbnltb3VzJztcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kQ2xhc3ModGhpcywgbmFtZSwgcHJvcHMpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhPYmosIFt7XG4gICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPYmo7XG59KCk7XG5cbnZhciBFbWl0dGVyT2JqID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKEVtaXR0ZXJPYmosIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXJPYmooKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpIHx8IHRoaXM7IC8vIFVuZm9ydHVuYXRlbHkgbmVjZXNzYXJ5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgKF90aGlzMiA9IF90aGlzKS5pbml0LmFwcGx5KF90aGlzMiwgYXJndW1lbnRzKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gRW1pdHRlck9iai5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHt9O1xuXG4gIEVtaXR0ZXJPYmouZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvcHMgPSBuYW1lO1xuICAgICAgbmFtZSA9ICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBuYW1lLCBwcm9wcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXJPYmosIFt7XG4gICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbWl0dGVyT2JqO1xufShFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgT2JqOiBPYmosXG4gIEVtaXR0ZXJPYmo6IEVtaXR0ZXJPYmpcbn07XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGFycmF5RnJvbSA9IEFycmF5LmZyb207XG52YXIgc3VwcG9ydHNJdGVyYXRvcnMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvciAmJiB0eXBlb2YgYXJyYXlGcm9tID09PSAnZnVuY3Rpb24nOyAvLyBGcmFtZXMga2VlcCB0cmFjayBvZiBzY29waW5nIGJvdGggYXQgY29tcGlsZS10aW1lIGFuZCBydW4tdGltZSBzb1xuLy8gd2Uga25vdyBob3cgdG8gYWNjZXNzIHZhcmlhYmxlcy4gQmxvY2sgdGFncyBjYW4gaW50cm9kdWNlIHNwZWNpYWxcbi8vIHZhcmlhYmxlcywgZm9yIGV4YW1wbGUuXG5cbnZhciBGcmFtZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZyYW1lKHBhcmVudCwgaXNvbGF0ZVdyaXRlcykge1xuICAgIHRoaXMudmFyaWFibGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnRvcExldmVsID0gZmFsc2U7IC8vIGlmIHRoaXMgaXMgdHJ1ZSwgd3JpdGVzIChzZXQpIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXB3YXJkcyBwYXN0XG4gICAgLy8gdGhpcyBmcmFtZSB0byBpdHMgcGFyZW50ICh0aG91Z2ggcmVhZHMgbWF5KS5cblxuICAgIHRoaXMuaXNvbGF0ZVdyaXRlcyA9IGlzb2xhdGVXcml0ZXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsLCByZXNvbHZlVXApIHtcbiAgICAvLyBBbGxvdyB2YXJpYWJsZXMgd2l0aCBkb3RzIGJ5IGF1dG9tYXRpY2FsbHkgY3JlYXRpbmcgdGhlXG4gICAgLy8gbmVzdGVkIHN0cnVjdHVyZVxuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gdGhpcy52YXJpYWJsZXM7XG4gICAgdmFyIGZyYW1lID0gdGhpcztcblxuICAgIGlmIChyZXNvbHZlVXApIHtcbiAgICAgIGlmIChmcmFtZSA9IHRoaXMucmVzb2x2ZShwYXJ0c1swXSwgdHJ1ZSkpIHtcbiAgICAgICAgZnJhbWUuc2V0KG5hbWUsIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIGlkID0gcGFydHNbaV07XG5cbiAgICAgIGlmICghb2JqW2lkXSkge1xuICAgICAgICBvYmpbaWRdID0ge307XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialtpZF07XG4gICAgfVxuXG4gICAgb2JqW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChuYW1lKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAgJiYgcC5sb29rdXAobmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKG5hbWUsIGZvcldyaXRlKSB7XG4gICAgdmFyIHAgPSBmb3JXcml0ZSAmJiB0aGlzLmlzb2xhdGVXcml0ZXMgPyB1bmRlZmluZWQgOiB0aGlzLnBhcmVudDtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBwICYmIHAucmVzb2x2ZShuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goaXNvbGF0ZVdyaXRlcykge1xuICAgIHJldHVybiBuZXcgRnJhbWUodGhpcywgaXNvbGF0ZVdyaXRlcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBvcCA9IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH07XG5cbiAgcmV0dXJuIEZyYW1lO1xufSgpO1xuXG5mdW5jdGlvbiBtYWtlTWFjcm8oYXJnTmFtZXMsIGt3YXJnTmFtZXMsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1hY3JvKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtYWNyb0FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBtYWNyb0FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0NvdW50ID0gbnVtQXJncyhtYWNyb0FyZ3MpO1xuICAgIHZhciBhcmdzO1xuICAgIHZhciBrd2FyZ3MgPSBnZXRLZXl3b3JkQXJncyhtYWNyb0FyZ3MpO1xuXG4gICAgaWYgKGFyZ0NvdW50ID4gYXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICBhcmdzID0gbWFjcm9BcmdzLnNsaWNlKDAsIGFyZ05hbWVzLmxlbmd0aCk7IC8vIFBvc2l0aW9uYWwgYXJndW1lbnRzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBpbiBhc1xuICAgICAgLy8ga2V5d29yZCBhcmd1bWVudHMgKGVzc2VudGlhbGx5IGRlZmF1bHQgdmFsdWVzKVxuXG4gICAgICBtYWNyb0FyZ3Muc2xpY2UoYXJncy5sZW5ndGgsIGFyZ0NvdW50KS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGkpIHtcbiAgICAgICAgaWYgKGkgPCBrd2FyZ05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIGt3YXJnc1trd2FyZ05hbWVzW2ldXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhcmdzLnB1c2goa3dhcmdzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ0NvdW50IDwgYXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICBhcmdzID0gbWFjcm9BcmdzLnNsaWNlKDAsIGFyZ0NvdW50KTtcblxuICAgICAgZm9yICh2YXIgaSA9IGFyZ0NvdW50OyBpIDwgYXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ05hbWVzW2ldOyAvLyBLZXl3b3JkIGFyZ3VtZW50cyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgYXNcbiAgICAgICAgLy8gcG9zaXRpb25hbCBhcmd1bWVudHMsIGkuZS4gdGhlIGNhbGxlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHVzZWQgdGhlIG5hbWUgb2YgYSBwb3NpdGlvbmFsIGFyZ1xuXG4gICAgICAgIGFyZ3MucHVzaChrd2FyZ3NbYXJnXSk7XG4gICAgICAgIGRlbGV0ZSBrd2FyZ3NbYXJnXTtcbiAgICAgIH1cblxuICAgICAgYXJncy5wdXNoKGt3YXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBtYWNyb0FyZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VLZXl3b3JkQXJncyhvYmopIHtcbiAgb2JqLl9fa2V5d29yZHMgPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBpc0tleXdvcmRBcmdzKG9iaikge1xuICByZXR1cm4gb2JqICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdfX2tleXdvcmRzJyk7XG59XG5cbmZ1bmN0aW9uIGdldEtleXdvcmRBcmdzKGFyZ3MpIHtcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gIGlmIChsZW4pIHtcbiAgICB2YXIgbGFzdEFyZyA9IGFyZ3NbbGVuIC0gMV07XG5cbiAgICBpZiAoaXNLZXl3b3JkQXJncyhsYXN0QXJnKSkge1xuICAgICAgcmV0dXJuIGxhc3RBcmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBudW1BcmdzKGFyZ3MpIHtcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBsYXN0QXJnID0gYXJnc1tsZW4gLSAxXTtcblxuICBpZiAoaXNLZXl3b3JkQXJncyhsYXN0QXJnKSkge1xuICAgIHJldHVybiBsZW4gLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsZW47XG4gIH1cbn0gLy8gQSBTYWZlU3RyaW5nIG9iamVjdCBpbmRpY2F0ZXMgdGhhdCB0aGUgc3RyaW5nIHNob3VsZCBub3QgYmVcbi8vIGF1dG9lc2NhcGVkLiBUaGlzIGhhcHBlbnMgbWFnaWNhbGx5IGJlY2F1c2UgYXV0b2VzY2FwaW5nIG9ubHlcbi8vIG9jY3VycyBvbiBwcmltaXRpdmUgc3RyaW5nIG9iamVjdHMuXG5cblxuZnVuY3Rpb24gU2FmZVN0cmluZyh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHRoaXMudmFsID0gdmFsO1xuICB0aGlzLmxlbmd0aCA9IHZhbC5sZW5ndGg7XG59XG5cblNhZmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJpbmcucHJvdG90eXBlLCB7XG4gIGxlbmd0aDoge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogMFxuICB9XG59KTtcblxuU2FmZVN0cmluZy5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gIHJldHVybiB0aGlzLnZhbDtcbn07XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnZhbDtcbn07XG5cbmZ1bmN0aW9uIGNvcHlTYWZlbmVzcyhkZXN0LCB0YXJnZXQpIHtcbiAgaWYgKGRlc3QgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKHRhcmdldCk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0LnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtTYWZlKHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBTYWZlKGFyZ3MpIHtcbiAgICAgIHZhciByZXQgPSB2YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVN0cmluZyhyZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VwcHJlc3NWYWx1ZSh2YWwsIGF1dG9lc2NhcGUpIHtcbiAgdmFsID0gdmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsID8gdmFsIDogJyc7XG5cbiAgaWYgKGF1dG9lc2NhcGUgJiYgISh2YWwgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSkge1xuICAgIHZhbCA9IGxpYi5lc2NhcGUodmFsLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRGVmaW5lZCh2YWwsIGxpbmVubywgY29sbm8pIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBsaWIuVGVtcGxhdGVFcnJvcignYXR0ZW1wdGVkIHRvIG91dHB1dCBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZScsIGxpbmVubyArIDEsIGNvbG5vICsgMSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBtZW1iZXJMb29rdXAob2JqLCB2YWwpIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9ialt2YWxdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpbdmFsXS5hcHBseShvYmosIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gb2JqW3ZhbF07XG59XG5cbmZ1bmN0aW9uIGNhbGxXcmFwKG9iaiwgbmFtZSwgY29udGV4dCwgYXJncykge1xuICBpZiAoIW9iaikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNhbGwgYCcgKyBuYW1lICsgJ2AsIHdoaWNoIGlzIHVuZGVmaW5lZCBvciBmYWxzZXknKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY2FsbCBgJyArIG5hbWUgKyAnYCwgd2hpY2ggaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHJldHVybiBvYmouYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRPckZyYW1lTG9va3VwKGNvbnRleHQsIGZyYW1lLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBmcmFtZS5sb29rdXAobmFtZSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGNvbnRleHQubG9va3VwKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbGluZW5vLCBjb2xubykge1xuICBpZiAoZXJyb3IubGluZW5vKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgbGliLlRlbXBsYXRlRXJyb3IoZXJyb3IsIGxpbmVubywgY29sbm8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzeW5jRWFjaChhcnIsIGRpbWVuLCBpdGVyLCBjYikge1xuICBpZiAobGliLmlzQXJyYXkoYXJyKSkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGxpYi5hc3luY0l0ZXIoYXJyLCBmdW5jdGlvbiBpdGVyQ2FsbGJhY2soaXRlbSwgaSwgbmV4dCkge1xuICAgICAgc3dpdGNoIChkaW1lbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaXRlcihpdGVtLCBpLCBsZW4sIG5leHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpdGVyKGl0ZW1bMF0sIGl0ZW1bMV0sIGksIGxlbiwgbmV4dCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGl0ZXIoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGl0ZW0ucHVzaChpLCBsZW4sIG5leHQpO1xuICAgICAgICAgIGl0ZXIuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICB9XG4gICAgfSwgY2IpO1xuICB9IGVsc2Uge1xuICAgIGxpYi5hc3luY0ZvcihhcnIsIGZ1bmN0aW9uIGl0ZXJDYWxsYmFjayhrZXksIHZhbCwgaSwgbGVuLCBuZXh0KSB7XG4gICAgICBpdGVyKGtleSwgdmFsLCBpLCBsZW4sIG5leHQpO1xuICAgIH0sIGNiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3luY0FsbChhcnIsIGRpbWVuLCBmdW5jLCBjYikge1xuICB2YXIgZmluaXNoZWQgPSAwO1xuICB2YXIgbGVuO1xuICB2YXIgb3V0cHV0QXJyO1xuXG4gIGZ1bmN0aW9uIGRvbmUoaSwgb3V0cHV0KSB7XG4gICAgZmluaXNoZWQrKztcbiAgICBvdXRwdXRBcnJbaV0gPSBvdXRwdXQ7XG5cbiAgICBpZiAoZmluaXNoZWQgPT09IGxlbikge1xuICAgICAgY2IobnVsbCwgb3V0cHV0QXJyLmpvaW4oJycpKTtcbiAgICB9XG4gIH1cblxuICBpZiAobGliLmlzQXJyYXkoYXJyKSkge1xuICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgb3V0cHV0QXJyID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjYihudWxsLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYXJyW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoZGltZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBmdW5jKGl0ZW0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGZ1bmMoaXRlbVswXSwgaXRlbVsxXSwgaSwgbGVuLCBkb25lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZnVuYyhpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdLCBpLCBsZW4sIGRvbmUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaXRlbS5wdXNoKGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBrZXlzID0gbGliLmtleXMoYXJyIHx8IHt9KTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBvdXRwdXRBcnIgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIGNiKG51bGwsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tfaV07XG4gICAgICAgIGZ1bmMoaywgYXJyW2tdLCBfaSwgbGVuLCBkb25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbUl0ZXJhdG9yKGFycikge1xuICBpZiAodHlwZW9mIGFyciAhPT0gJ29iamVjdCcgfHwgYXJyID09PSBudWxsIHx8IGxpYi5pc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9IGVsc2UgaWYgKHN1cHBvcnRzSXRlcmF0b3JzICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcnIpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKGFycik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRnJhbWU6IEZyYW1lLFxuICBtYWtlTWFjcm86IG1ha2VNYWNybyxcbiAgbWFrZUtleXdvcmRBcmdzOiBtYWtlS2V5d29yZEFyZ3MsXG4gIG51bUFyZ3M6IG51bUFyZ3MsXG4gIHN1cHByZXNzVmFsdWU6IHN1cHByZXNzVmFsdWUsXG4gIGVuc3VyZURlZmluZWQ6IGVuc3VyZURlZmluZWQsXG4gIG1lbWJlckxvb2t1cDogbWVtYmVyTG9va3VwLFxuICBjb250ZXh0T3JGcmFtZUxvb2t1cDogY29udGV4dE9yRnJhbWVMb29rdXAsXG4gIGNhbGxXcmFwOiBjYWxsV3JhcCxcbiAgaGFuZGxlRXJyb3I6IGhhbmRsZUVycm9yLFxuICBpc0FycmF5OiBsaWIuaXNBcnJheSxcbiAga2V5czogbGliLmtleXMsXG4gIFNhZmVTdHJpbmc6IFNhZmVTdHJpbmcsXG4gIGNvcHlTYWZlbmVzczogY29weVNhZmVuZXNzLFxuICBtYXJrU2FmZTogbWFya1NhZmUsXG4gIGFzeW5jRWFjaDogYXN5bmNFYWNoLFxuICBhc3luY0FsbDogYXN5bmNBbGwsXG4gIGluT3BlcmF0b3I6IGxpYi5pbk9wZXJhdG9yLFxuICBmcm9tSXRlcmF0b3I6IGZyb21JdGVyYXRvclxufTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgT2JqID0gX3JlcXVpcmUuT2JqO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZUFuZENoZWNrKG9iaiwgdHlwZSwgcmVzdWx0cykge1xuICBpZiAob2JqIGluc3RhbmNlb2YgdHlwZSkge1xuICAgIHJlc3VsdHMucHVzaChvYmopO1xuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICBvYmouZmluZEFsbCh0eXBlLCByZXN1bHRzKTtcbiAgfVxufVxuXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iaikge1xuICBfaW5oZXJpdHNMb29zZShOb2RlLCBfT2JqKTtcblxuICBmdW5jdGlvbiBOb2RlKCkge1xuICAgIHJldHVybiBfT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBOb2RlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobGluZW5vLCBjb2xubykge1xuICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcbiAgICB0aGlzLmNvbG5vID0gY29sbm87XG4gICAgdGhpcy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCB0d28gYXJncyBhcmUgbGluZS9jb2wgbnVtYmVycywgc28gb2Zmc2V0IGJ5IDJcbiAgICAgIHZhciB2YWwgPSBfYXJndW1lbnRzW2kgKyAyXTsgLy8gRmllbGRzIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQsIGJ1dCBudWxsLiBJdCBtYWtlc1xuICAgICAgLy8gdGVzdGluZyBlYXNpZXIgdG8gbm9ybWFsaXplIHZhbHVlcy5cblxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF90aGlzW2ZpZWxkXSA9IHZhbDtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZmluZEFsbCA9IGZ1bmN0aW9uIGZpbmRBbGwodHlwZSwgcmVzdWx0cykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZENoZWNrKGNoaWxkLCB0eXBlLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRDaGVjayhfdGhpczJbZmllbGRdLCB0eXBlLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIF9wcm90by5pdGVyRmllbGRzID0gZnVuY3Rpb24gaXRlckZpZWxkcyhmdW5jKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgZnVuYyhfdGhpczNbZmllbGRdLCBmaWVsZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE5vZGU7XG59KE9iaik7IC8vIEFic3RyYWN0IG5vZGVzXG5cblxudmFyIFZhbHVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZSkge1xuICBfaW5oZXJpdHNMb29zZShWYWx1ZSwgX05vZGUpO1xuXG4gIGZ1bmN0aW9uIFZhbHVlKCkge1xuICAgIHJldHVybiBfTm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmFsdWUsIFt7XG4gICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1ZhbHVlJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmllbGRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gWyd2YWx1ZSddO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWYWx1ZTtcbn0oTm9kZSk7IC8vIENvbmNyZXRlIG5vZGVzXG5cblxudmFyIE5vZGVMaXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZTIpIHtcbiAgX2luaGVyaXRzTG9vc2UoTm9kZUxpc3QsIF9Ob2RlMik7XG5cbiAgZnVuY3Rpb24gTm9kZUxpc3QoKSB7XG4gICAgcmV0dXJuIF9Ob2RlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IE5vZGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmluaXQgPSBmdW5jdGlvbiBpbml0KGxpbmVubywgY29sbm8sIG5vZGVzKSB7XG4gICAgX05vZGUyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgbGluZW5vLCBjb2xubywgbm9kZXMgfHwgW10pO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhOb2RlTGlzdCwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnTm9kZUxpc3QnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWVsZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ2NoaWxkcmVuJ107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5vZGVMaXN0O1xufShOb2RlKTtcblxudmFyIFJvb3QgPSBOb2RlTGlzdC5leHRlbmQoJ1Jvb3QnKTtcbnZhciBMaXRlcmFsID0gVmFsdWUuZXh0ZW5kKCdMaXRlcmFsJyk7XG52YXIgU3ltYm9sID0gVmFsdWUuZXh0ZW5kKCdTeW1ib2wnKTtcbnZhciBHcm91cCA9IE5vZGVMaXN0LmV4dGVuZCgnR3JvdXAnKTtcbnZhciBBcnJheU5vZGUgPSBOb2RlTGlzdC5leHRlbmQoJ0FycmF5Jyk7XG52YXIgUGFpciA9IE5vZGUuZXh0ZW5kKCdQYWlyJywge1xuICBmaWVsZHM6IFsna2V5JywgJ3ZhbHVlJ11cbn0pO1xudmFyIERpY3QgPSBOb2RlTGlzdC5leHRlbmQoJ0RpY3QnKTtcbnZhciBMb29rdXBWYWwgPSBOb2RlLmV4dGVuZCgnTG9va3VwVmFsJywge1xuICBmaWVsZHM6IFsndGFyZ2V0JywgJ3ZhbCddXG59KTtcbnZhciBJZiA9IE5vZGUuZXh0ZW5kKCdJZicsIHtcbiAgZmllbGRzOiBbJ2NvbmQnLCAnYm9keScsICdlbHNlXyddXG59KTtcbnZhciBJZkFzeW5jID0gSWYuZXh0ZW5kKCdJZkFzeW5jJyk7XG52YXIgSW5saW5lSWYgPSBOb2RlLmV4dGVuZCgnSW5saW5lSWYnLCB7XG4gIGZpZWxkczogWydjb25kJywgJ2JvZHknLCAnZWxzZV8nXVxufSk7XG52YXIgRm9yID0gTm9kZS5leHRlbmQoJ0ZvcicsIHtcbiAgZmllbGRzOiBbJ2FycicsICduYW1lJywgJ2JvZHknLCAnZWxzZV8nXVxufSk7XG52YXIgQXN5bmNFYWNoID0gRm9yLmV4dGVuZCgnQXN5bmNFYWNoJyk7XG52YXIgQXN5bmNBbGwgPSBGb3IuZXh0ZW5kKCdBc3luY0FsbCcpO1xudmFyIE1hY3JvID0gTm9kZS5leHRlbmQoJ01hY3JvJywge1xuICBmaWVsZHM6IFsnbmFtZScsICdhcmdzJywgJ2JvZHknXVxufSk7XG52YXIgQ2FsbGVyID0gTWFjcm8uZXh0ZW5kKCdDYWxsZXInKTtcbnZhciBJbXBvcnQgPSBOb2RlLmV4dGVuZCgnSW1wb3J0Jywge1xuICBmaWVsZHM6IFsndGVtcGxhdGUnLCAndGFyZ2V0JywgJ3dpdGhDb250ZXh0J11cbn0pO1xuXG52YXIgRnJvbUltcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZyb21JbXBvcnQsIF9Ob2RlMyk7XG5cbiAgZnVuY3Rpb24gRnJvbUltcG9ydCgpIHtcbiAgICByZXR1cm4gX05vZGUzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRnJvbUltcG9ydC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5pbml0ID0gZnVuY3Rpb24gaW5pdChsaW5lbm8sIGNvbG5vLCB0ZW1wbGF0ZSwgbmFtZXMsIHdpdGhDb250ZXh0KSB7XG4gICAgX05vZGUzLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgbGluZW5vLCBjb2xubywgdGVtcGxhdGUsIG5hbWVzIHx8IG5ldyBOb2RlTGlzdCgpLCB3aXRoQ29udGV4dCk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKEZyb21JbXBvcnQsIFt7XG4gICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0Zyb21JbXBvcnQnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWVsZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ3RlbXBsYXRlJywgJ25hbWVzJywgJ3dpdGhDb250ZXh0J107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZyb21JbXBvcnQ7XG59KE5vZGUpO1xuXG52YXIgRnVuQ2FsbCA9IE5vZGUuZXh0ZW5kKCdGdW5DYWxsJywge1xuICBmaWVsZHM6IFsnbmFtZScsICdhcmdzJ11cbn0pO1xudmFyIEZpbHRlciA9IEZ1bkNhbGwuZXh0ZW5kKCdGaWx0ZXInKTtcbnZhciBGaWx0ZXJBc3luYyA9IEZpbHRlci5leHRlbmQoJ0ZpbHRlckFzeW5jJywge1xuICBmaWVsZHM6IFsnbmFtZScsICdhcmdzJywgJ3N5bWJvbCddXG59KTtcbnZhciBLZXl3b3JkQXJncyA9IERpY3QuZXh0ZW5kKCdLZXl3b3JkQXJncycpO1xudmFyIEJsb2NrID0gTm9kZS5leHRlbmQoJ0Jsb2NrJywge1xuICBmaWVsZHM6IFsnbmFtZScsICdib2R5J11cbn0pO1xudmFyIFN1cGVyID0gTm9kZS5leHRlbmQoJ1N1cGVyJywge1xuICBmaWVsZHM6IFsnYmxvY2tOYW1lJywgJ3N5bWJvbCddXG59KTtcbnZhciBUZW1wbGF0ZVJlZiA9IE5vZGUuZXh0ZW5kKCdUZW1wbGF0ZVJlZicsIHtcbiAgZmllbGRzOiBbJ3RlbXBsYXRlJ11cbn0pO1xudmFyIEV4dGVuZHMgPSBUZW1wbGF0ZVJlZi5leHRlbmQoJ0V4dGVuZHMnKTtcbnZhciBJbmNsdWRlID0gTm9kZS5leHRlbmQoJ0luY2x1ZGUnLCB7XG4gIGZpZWxkczogWyd0ZW1wbGF0ZScsICdpZ25vcmVNaXNzaW5nJ11cbn0pO1xudmFyIFNldCA9IE5vZGUuZXh0ZW5kKCdTZXQnLCB7XG4gIGZpZWxkczogWyd0YXJnZXRzJywgJ3ZhbHVlJ11cbn0pO1xudmFyIFN3aXRjaCA9IE5vZGUuZXh0ZW5kKCdTd2l0Y2gnLCB7XG4gIGZpZWxkczogWydleHByJywgJ2Nhc2VzJywgJ2RlZmF1bHQnXVxufSk7XG52YXIgQ2FzZSA9IE5vZGUuZXh0ZW5kKCdDYXNlJywge1xuICBmaWVsZHM6IFsnY29uZCcsICdib2R5J11cbn0pO1xudmFyIE91dHB1dCA9IE5vZGVMaXN0LmV4dGVuZCgnT3V0cHV0Jyk7XG52YXIgQ2FwdHVyZSA9IE5vZGUuZXh0ZW5kKCdDYXB0dXJlJywge1xuICBmaWVsZHM6IFsnYm9keSddXG59KTtcbnZhciBUZW1wbGF0ZURhdGEgPSBMaXRlcmFsLmV4dGVuZCgnVGVtcGxhdGVEYXRhJyk7XG52YXIgVW5hcnlPcCA9IE5vZGUuZXh0ZW5kKCdVbmFyeU9wJywge1xuICBmaWVsZHM6IFsndGFyZ2V0J11cbn0pO1xudmFyIEJpbk9wID0gTm9kZS5leHRlbmQoJ0Jpbk9wJywge1xuICBmaWVsZHM6IFsnbGVmdCcsICdyaWdodCddXG59KTtcbnZhciBJbiA9IEJpbk9wLmV4dGVuZCgnSW4nKTtcbnZhciBJcyA9IEJpbk9wLmV4dGVuZCgnSXMnKTtcbnZhciBPciA9IEJpbk9wLmV4dGVuZCgnT3InKTtcbnZhciBBbmQgPSBCaW5PcC5leHRlbmQoJ0FuZCcpO1xudmFyIE5vdCA9IFVuYXJ5T3AuZXh0ZW5kKCdOb3QnKTtcbnZhciBBZGQgPSBCaW5PcC5leHRlbmQoJ0FkZCcpO1xudmFyIENvbmNhdCA9IEJpbk9wLmV4dGVuZCgnQ29uY2F0Jyk7XG52YXIgU3ViID0gQmluT3AuZXh0ZW5kKCdTdWInKTtcbnZhciBNdWwgPSBCaW5PcC5leHRlbmQoJ011bCcpO1xudmFyIERpdiA9IEJpbk9wLmV4dGVuZCgnRGl2Jyk7XG52YXIgRmxvb3JEaXYgPSBCaW5PcC5leHRlbmQoJ0Zsb29yRGl2Jyk7XG52YXIgTW9kID0gQmluT3AuZXh0ZW5kKCdNb2QnKTtcbnZhciBQb3cgPSBCaW5PcC5leHRlbmQoJ1BvdycpO1xudmFyIE5lZyA9IFVuYXJ5T3AuZXh0ZW5kKCdOZWcnKTtcbnZhciBQb3MgPSBVbmFyeU9wLmV4dGVuZCgnUG9zJyk7XG52YXIgQ29tcGFyZSA9IE5vZGUuZXh0ZW5kKCdDb21wYXJlJywge1xuICBmaWVsZHM6IFsnZXhwcicsICdvcHMnXVxufSk7XG52YXIgQ29tcGFyZU9wZXJhbmQgPSBOb2RlLmV4dGVuZCgnQ29tcGFyZU9wZXJhbmQnLCB7XG4gIGZpZWxkczogWydleHByJywgJ3R5cGUnXVxufSk7XG52YXIgQ2FsbEV4dGVuc2lvbiA9IE5vZGUuZXh0ZW5kKCdDYWxsRXh0ZW5zaW9uJywge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGV4dCwgcHJvcCwgYXJncywgY29udGVudEFyZ3MpIHtcbiAgICB0aGlzLnBhcmVudCgpO1xuICAgIHRoaXMuZXh0TmFtZSA9IGV4dC5fX25hbWUgfHwgZXh0O1xuICAgIHRoaXMucHJvcCA9IHByb3A7XG4gICAgdGhpcy5hcmdzID0gYXJncyB8fCBuZXcgTm9kZUxpc3QoKTtcbiAgICB0aGlzLmNvbnRlbnRBcmdzID0gY29udGVudEFyZ3MgfHwgW107XG4gICAgdGhpcy5hdXRvZXNjYXBlID0gZXh0LmF1dG9lc2NhcGU7XG4gIH0sXG4gIGZpZWxkczogWydleHROYW1lJywgJ3Byb3AnLCAnYXJncycsICdjb250ZW50QXJncyddXG59KTtcbnZhciBDYWxsRXh0ZW5zaW9uQXN5bmMgPSBDYWxsRXh0ZW5zaW9uLmV4dGVuZCgnQ2FsbEV4dGVuc2lvbkFzeW5jJyk7IC8vIFRoaXMgaXMgaGFja3ksIGJ1dCB0aGlzIGlzIGp1c3QgYSBkZWJ1Z2dpbmcgZnVuY3Rpb24gYW55d2F5XG5cbmZ1bmN0aW9uIHByaW50KHN0ciwgaW5kZW50LCBpbmxpbmUpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSwgaSkge1xuICAgIGlmIChsaW5lICYmIChpbmxpbmUgJiYgaSA+IDAgfHwgIWlubGluZSkpIHtcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCcgJy5yZXBlYXQoaW5kZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIG5sID0gaSA9PT0gbGluZXMubGVuZ3RoIC0gMSA/ICcnIDogJ1xcbic7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXCJcIiArIGxpbmUgKyBubCk7XG4gIH0pO1xufSAvLyBQcmludCB0aGUgQVNUIGluIGEgbmljZWx5IGZvcm1hdHRlZCB0cmVlIGZvcm1hdCBmb3IgZGVidWdnaW5cblxuXG5mdW5jdGlvbiBwcmludE5vZGVzKG5vZGUsIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgcHJpbnQobm9kZS50eXBlbmFtZSArICc6ICcsIGluZGVudCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgIHByaW50KCdcXG4nKTtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHByaW50Tm9kZXMobiwgaW5kZW50ICsgMik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIENhbGxFeHRlbnNpb24pIHtcbiAgICBwcmludChub2RlLmV4dE5hbWUgKyBcIi5cIiArIG5vZGUucHJvcCArIFwiXFxuXCIpO1xuXG4gICAgaWYgKG5vZGUuYXJncykge1xuICAgICAgcHJpbnROb2Rlcyhub2RlLmFyZ3MsIGluZGVudCArIDIpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNvbnRlbnRBcmdzKSB7XG4gICAgICBub2RlLmNvbnRlbnRBcmdzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcHJpbnROb2RlcyhuLCBpbmRlbnQgKyAyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgcHJvcHMgPSBudWxsO1xuICAgIG5vZGUuaXRlckZpZWxkcyhmdW5jdGlvbiAodmFsLCBmaWVsZE5hbWUpIHtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIG5vZGVzLnB1c2goW2ZpZWxkTmFtZSwgdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgICBwcm9wc1tmaWVsZE5hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBwcmludChKU09OLnN0cmluZ2lmeShwcm9wcywgbnVsbCwgMikgKyAnXFxuJywgbnVsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50KCdcXG4nKTtcbiAgICB9XG5cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgZmllbGROYW1lID0gX3JlZlswXSxcbiAgICAgICAgICBuID0gX3JlZlsxXTtcbiAgICAgIHByaW50KFwiW1wiICsgZmllbGROYW1lICsgXCJdID0+XCIsIGluZGVudCArIDIpO1xuICAgICAgcHJpbnROb2RlcyhuLCBpbmRlbnQgKyA0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZTogTm9kZSxcbiAgUm9vdDogUm9vdCxcbiAgTm9kZUxpc3Q6IE5vZGVMaXN0LFxuICBWYWx1ZTogVmFsdWUsXG4gIExpdGVyYWw6IExpdGVyYWwsXG4gIFN5bWJvbDogU3ltYm9sLFxuICBHcm91cDogR3JvdXAsXG4gIEFycmF5OiBBcnJheU5vZGUsXG4gIFBhaXI6IFBhaXIsXG4gIERpY3Q6IERpY3QsXG4gIE91dHB1dDogT3V0cHV0LFxuICBDYXB0dXJlOiBDYXB0dXJlLFxuICBUZW1wbGF0ZURhdGE6IFRlbXBsYXRlRGF0YSxcbiAgSWY6IElmLFxuICBJZkFzeW5jOiBJZkFzeW5jLFxuICBJbmxpbmVJZjogSW5saW5lSWYsXG4gIEZvcjogRm9yLFxuICBBc3luY0VhY2g6IEFzeW5jRWFjaCxcbiAgQXN5bmNBbGw6IEFzeW5jQWxsLFxuICBNYWNybzogTWFjcm8sXG4gIENhbGxlcjogQ2FsbGVyLFxuICBJbXBvcnQ6IEltcG9ydCxcbiAgRnJvbUltcG9ydDogRnJvbUltcG9ydCxcbiAgRnVuQ2FsbDogRnVuQ2FsbCxcbiAgRmlsdGVyOiBGaWx0ZXIsXG4gIEZpbHRlckFzeW5jOiBGaWx0ZXJBc3luYyxcbiAgS2V5d29yZEFyZ3M6IEtleXdvcmRBcmdzLFxuICBCbG9jazogQmxvY2ssXG4gIFN1cGVyOiBTdXBlcixcbiAgRXh0ZW5kczogRXh0ZW5kcyxcbiAgSW5jbHVkZTogSW5jbHVkZSxcbiAgU2V0OiBTZXQsXG4gIFN3aXRjaDogU3dpdGNoLFxuICBDYXNlOiBDYXNlLFxuICBMb29rdXBWYWw6IExvb2t1cFZhbCxcbiAgQmluT3A6IEJpbk9wLFxuICBJbjogSW4sXG4gIElzOiBJcyxcbiAgT3I6IE9yLFxuICBBbmQ6IEFuZCxcbiAgTm90OiBOb3QsXG4gIEFkZDogQWRkLFxuICBDb25jYXQ6IENvbmNhdCxcbiAgU3ViOiBTdWIsXG4gIE11bDogTXVsLFxuICBEaXY6IERpdixcbiAgRmxvb3JEaXY6IEZsb29yRGl2LFxuICBNb2Q6IE1vZCxcbiAgUG93OiBQb3csXG4gIE5lZzogTmVnLFxuICBQb3M6IFBvcyxcbiAgQ29tcGFyZTogQ29tcGFyZSxcbiAgQ29tcGFyZU9wZXJhbmQ6IENvbXBhcmVPcGVyYW5kLFxuICBDYWxsRXh0ZW5zaW9uOiBDYWxsRXh0ZW5zaW9uLFxuICBDYWxsRXh0ZW5zaW9uQXN5bmM6IENhbGxFeHRlbnNpb25Bc3luYyxcbiAgcHJpbnROb2RlczogcHJpbnROb2Rlc1xufTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgdHJhbnNmb3JtZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxudmFyIG5vZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUuVGVtcGxhdGVFcnJvcjtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMiksXG4gICAgRnJhbWUgPSBfcmVxdWlyZTIuRnJhbWU7XG5cbnZhciBfcmVxdWlyZTMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIE9iaiA9IF9yZXF1aXJlMy5PYmo7IC8vIFRoZXNlIGFyZSBhbGwgdGhlIHNhbWUgZm9yIG5vdywgYnV0IHNob3VsZG4ndCBiZSBwYXNzZWQgc3RyYWlnaHRcbi8vIHRocm91Z2hcblxuXG52YXIgY29tcGFyZU9wcyA9IHtcbiAgJz09JzogJz09JyxcbiAgJz09PSc6ICc9PT0nLFxuICAnIT0nOiAnIT0nLFxuICAnIT09JzogJyE9PScsXG4gICc8JzogJzwnLFxuICAnPic6ICc+JyxcbiAgJzw9JzogJzw9JyxcbiAgJz49JzogJz49J1xufTtcblxudmFyIENvbXBpbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbXBpbGVyLCBfT2JqKTtcblxuICBmdW5jdGlvbiBDb21waWxlcigpIHtcbiAgICByZXR1cm4gX09iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcGlsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh0ZW1wbGF0ZU5hbWUsIHRocm93T25VbmRlZmluZWQpIHtcbiAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICB0aGlzLmNvZGVidWYgPSBbXTtcbiAgICB0aGlzLmxhc3RJZCA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyU3RhY2sgPSBbXTtcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcbiAgICB0aGlzLmluQmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLnRocm93T25VbmRlZmluZWQgPSB0aHJvd09uVW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by5mYWlsID0gZnVuY3Rpb24gZmFpbChtc2csIGxpbmVubywgY29sbm8pIHtcbiAgICBpZiAobGluZW5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpbmVubyArPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xubyArPSAxO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUZW1wbGF0ZUVycm9yKG1zZywgbGluZW5vLCBjb2xubyk7XG4gIH07XG5cbiAgX3Byb3RvLl9wdXNoQnVmZmVyID0gZnVuY3Rpb24gX3B1c2hCdWZmZXIoKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHRoaXMuYnVmZmVyU3RhY2sucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgdGhpcy5idWZmZXIgPSBpZDtcblxuICAgIHRoaXMuX2VtaXQoXCJ2YXIgXCIgKyB0aGlzLmJ1ZmZlciArIFwiID0gXFxcIlxcXCI7XCIpO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIF9wcm90by5fcG9wQnVmZmVyID0gZnVuY3Rpb24gX3BvcEJ1ZmZlcigpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyU3RhY2sucG9wKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0ID0gZnVuY3Rpb24gX2VtaXQoY29kZSkge1xuICAgIHRoaXMuY29kZWJ1Zi5wdXNoKGNvZGUpO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdExpbmUgPSBmdW5jdGlvbiBfZW1pdExpbmUoY29kZSkge1xuICAgIHRoaXMuX2VtaXQoY29kZSArICdcXG4nKTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXRMaW5lcyA9IGZ1bmN0aW9uIF9lbWl0TGluZXMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBsaW5lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGxpbmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZW1pdExpbmUobGluZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0RnVuY0JlZ2luID0gZnVuY3Rpb24gX2VtaXRGdW5jQmVnaW4obm9kZSwgbmFtZSkge1xuICAgIHRoaXMuYnVmZmVyID0gJ291dHB1dCc7XG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzID0gJyc7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImZ1bmN0aW9uIFwiICsgbmFtZSArIFwiKGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsIGNiKSB7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgbGluZW5vID0gXCIgKyBub2RlLmxpbmVubyArIFwiO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIGNvbG5vID0gXCIgKyBub2RlLmNvbG5vICsgXCI7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyB0aGlzLmJ1ZmZlciArIFwiID0gXFxcIlxcXCI7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3RyeSB7Jyk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0RnVuY0VuZCA9IGZ1bmN0aW9uIF9lbWl0RnVuY0VuZChub1JldHVybikge1xuICAgIGlmICghbm9SZXR1cm4pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCdjYihudWxsLCAnICsgdGhpcy5idWZmZXIgKyAnKTsnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zZVNjb3BlTGV2ZWxzKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSBjYXRjaCAoZSkgeycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJyAgY2IocnVudGltZS5oYW5kbGVFcnJvcihlLCBsaW5lbm8sIGNvbG5vKSk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uX2FkZFNjb3BlTGV2ZWwgPSBmdW5jdGlvbiBfYWRkU2NvcGVMZXZlbCgpIHtcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgKz0gJ30pJztcbiAgfTtcblxuICBfcHJvdG8uX2Nsb3NlU2NvcGVMZXZlbHMgPSBmdW5jdGlvbiBfY2xvc2VTY29wZUxldmVscygpIHtcbiAgICB0aGlzLl9lbWl0TGluZSh0aGlzLl9zY29wZUNsb3NlcnMgKyAnOycpO1xuXG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzID0gJyc7XG4gIH07XG5cbiAgX3Byb3RvLl93aXRoU2NvcGVkU3ludGF4ID0gZnVuY3Rpb24gX3dpdGhTY29wZWRTeW50YXgoZnVuYykge1xuICAgIHZhciBfc2NvcGVDbG9zZXJzID0gdGhpcy5fc2NvcGVDbG9zZXJzO1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9ICcnO1xuICAgIGZ1bmMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2Nsb3NlU2NvcGVMZXZlbHMoKTtcblxuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9IF9zY29wZUNsb3NlcnM7XG4gIH07XG5cbiAgX3Byb3RvLl9tYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiBfbWFrZUNhbGxiYWNrKHJlcykge1xuICAgIHZhciBlcnIgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgcmV0dXJuICdmdW5jdGlvbignICsgZXJyICsgKHJlcyA/ICcsJyArIHJlcyA6ICcnKSArICcpIHtcXG4nICsgJ2lmKCcgKyBlcnIgKyAnKSB7IGNiKCcgKyBlcnIgKyAnKTsgcmV0dXJuOyB9JztcbiAgfTtcblxuICBfcHJvdG8uX3RtcGlkID0gZnVuY3Rpb24gX3RtcGlkKCkge1xuICAgIHRoaXMubGFzdElkKys7XG4gICAgcmV0dXJuICd0XycgKyB0aGlzLmxhc3RJZDtcbiAgfTtcblxuICBfcHJvdG8uX3RlbXBsYXRlTmFtZSA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVOYW1lID09IG51bGwgPyAndW5kZWZpbmVkJyA6IEpTT04uc3RyaW5naWZ5KHRoaXMudGVtcGxhdGVOYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVDaGlsZHJlbiA9IGZ1bmN0aW9uIF9jb21waWxlQ2hpbGRyZW4obm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIF90aGlzMi5jb21waWxlKGNoaWxkLCBmcmFtZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlQWdncmVnYXRlID0gZnVuY3Rpb24gX2NvbXBpbGVBZ2dyZWdhdGUobm9kZSwgZnJhbWUsIHN0YXJ0Q2hhciwgZW5kQ2hhcikge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKHN0YXJ0Q2hhcikge1xuICAgICAgdGhpcy5fZW1pdChzdGFydENoYXIpO1xuICAgIH1cblxuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBfdGhpczMuX2VtaXQoJywnKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMzLmNvbXBpbGUoY2hpbGQsIGZyYW1lKTtcbiAgICB9KTtcblxuICAgIGlmIChlbmRDaGFyKSB7XG4gICAgICB0aGlzLl9lbWl0KGVuZENoYXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVFeHByZXNzaW9uID0gZnVuY3Rpb24gX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gVE9ETzogSSdtIG5vdCByZWFsbHkgc3VyZSBpZiB0aGlzIHR5cGUgY2hlY2sgaXMgd29ydGggaXQgb3JcbiAgICAvLyBub3QuXG4gICAgdGhpcy5hc3NlcnRUeXBlKG5vZGUsIG5vZGVzLkxpdGVyYWwsIG5vZGVzLlN5bWJvbCwgbm9kZXMuR3JvdXAsIG5vZGVzLkFycmF5LCBub2Rlcy5EaWN0LCBub2Rlcy5GdW5DYWxsLCBub2Rlcy5DYWxsZXIsIG5vZGVzLkZpbHRlciwgbm9kZXMuTG9va3VwVmFsLCBub2Rlcy5Db21wYXJlLCBub2Rlcy5JbmxpbmVJZiwgbm9kZXMuSW4sIG5vZGVzLklzLCBub2Rlcy5BbmQsIG5vZGVzLk9yLCBub2Rlcy5Ob3QsIG5vZGVzLkFkZCwgbm9kZXMuQ29uY2F0LCBub2Rlcy5TdWIsIG5vZGVzLk11bCwgbm9kZXMuRGl2LCBub2Rlcy5GbG9vckRpdiwgbm9kZXMuTW9kLCBub2Rlcy5Qb3csIG5vZGVzLk5lZywgbm9kZXMuUG9zLCBub2Rlcy5Db21wYXJlLCBub2Rlcy5Ob2RlTGlzdCk7XG4gICAgdGhpcy5jb21waWxlKG5vZGUsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uYXNzZXJ0VHlwZSA9IGZ1bmN0aW9uIGFzc2VydFR5cGUobm9kZSkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdHlwZXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgdHlwZXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHQ7XG4gICAgfSkpIHtcbiAgICAgIHRoaXMuZmFpbChcImFzc2VydFR5cGU6IGludmFsaWQgdHlwZTogXCIgKyBub2RlLnR5cGVuYW1lLCBub2RlLmxpbmVubywgbm9kZS5jb2xubyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ2FsbEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGNvbXBpbGVDYWxsRXh0ZW5zaW9uKG5vZGUsIGZyYW1lLCBhc3luYykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIGFyZ3MgPSBub2RlLmFyZ3M7XG4gICAgdmFyIGNvbnRlbnRBcmdzID0gbm9kZS5jb250ZW50QXJncztcbiAgICB2YXIgYXV0b2VzY2FwZSA9IHR5cGVvZiBub2RlLmF1dG9lc2NhcGUgPT09ICdib29sZWFuJyA/IG5vZGUuYXV0b2VzY2FwZSA6IHRydWU7XG5cbiAgICBpZiAoIWFzeW5jKSB7XG4gICAgICB0aGlzLl9lbWl0KHRoaXMuYnVmZmVyICsgXCIgKz0gcnVudGltZS5zdXBwcmVzc1ZhbHVlKFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0KFwiZW52LmdldEV4dGVuc2lvbihcXFwiXCIgKyBub2RlLmV4dE5hbWUgKyBcIlxcXCIpW1xcXCJcIiArIG5vZGUucHJvcCArIFwiXFxcIl0oXCIpO1xuXG4gICAgdGhpcy5fZW1pdCgnY29udGV4dCcpO1xuXG4gICAgaWYgKGFyZ3MgfHwgY29udGVudEFyZ3MpIHtcbiAgICAgIHRoaXMuX2VtaXQoJywnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncykge1xuICAgICAgaWYgKCEoYXJncyBpbnN0YW5jZW9mIG5vZGVzLk5vZGVMaXN0KSkge1xuICAgICAgICB0aGlzLmZhaWwoJ2NvbXBpbGVDYWxsRXh0ZW5zaW9uOiBhcmd1bWVudHMgbXVzdCBiZSBhIE5vZGVMaXN0LCAnICsgJ3VzZSBgcGFyc2VyLnBhcnNlU2lnbmF0dXJlYCcpO1xuICAgICAgfVxuXG4gICAgICBhcmdzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaSkge1xuICAgICAgICAvLyBUYWcgYXJndW1lbnRzIGFyZSBwYXNzZWQgbm9ybWFsbHkgdG8gdGhlIGNhbGwuIE5vdGVcbiAgICAgICAgLy8gdGhhdCBrZXl3b3JkIGFyZ3VtZW50cyBhcmUgdHVybmVkIGludG8gYSBzaW5nbGUganNcbiAgICAgICAgLy8gb2JqZWN0IGFzIHRoZSBsYXN0IGFyZ3VtZW50LCBpZiB0aGV5IGV4aXN0LlxuICAgICAgICBfdGhpczQuX2NvbXBpbGVFeHByZXNzaW9uKGFyZywgZnJhbWUpO1xuXG4gICAgICAgIGlmIChpICE9PSBhcmdzLmNoaWxkcmVuLmxlbmd0aCAtIDEgfHwgY29udGVudEFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXM0Ll9lbWl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50QXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnRlbnRBcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaSkge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBfdGhpczQuX2VtaXQoJywnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBfdGhpczQuX2VtaXRMaW5lKCdmdW5jdGlvbihjYikgeycpO1xuXG4gICAgICAgICAgX3RoaXM0Ll9lbWl0TGluZSgnaWYoIWNiKSB7IGNiID0gZnVuY3Rpb24oZXJyKSB7IGlmKGVycikgeyB0aHJvdyBlcnI7IH19fScpO1xuXG4gICAgICAgICAgdmFyIGlkID0gX3RoaXM0Ll9wdXNoQnVmZmVyKCk7XG5cbiAgICAgICAgICBfdGhpczQuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM0LmNvbXBpbGUoYXJnLCBmcmFtZSk7XG5cbiAgICAgICAgICAgIF90aGlzNC5fZW1pdExpbmUoXCJjYihudWxsLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF90aGlzNC5fcG9wQnVmZmVyKCk7XG5cbiAgICAgICAgICBfdGhpczQuX2VtaXRMaW5lKFwicmV0dXJuIFwiICsgaWQgKyBcIjtcIik7XG5cbiAgICAgICAgICBfdGhpczQuX2VtaXRMaW5lKCd9Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM0Ll9lbWl0KCdudWxsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhc3luYykge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCcsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2socmVzKSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKHRoaXMuYnVmZmVyICsgXCIgKz0gcnVudGltZS5zdXBwcmVzc1ZhbHVlKFwiICsgcmVzICsgXCIsIFwiICsgYXV0b2VzY2FwZSArIFwiICYmIGVudi5vcHRzLmF1dG9lc2NhcGUpO1wiKTtcblxuICAgICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KCcpJyk7XG5cbiAgICAgIHRoaXMuX2VtaXQoXCIsIFwiICsgYXV0b2VzY2FwZSArIFwiICYmIGVudi5vcHRzLmF1dG9lc2NhcGUpO1xcblwiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDYWxsRXh0ZW5zaW9uQXN5bmMgPSBmdW5jdGlvbiBjb21waWxlQ2FsbEV4dGVuc2lvbkFzeW5jKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5jb21waWxlQ2FsbEV4dGVuc2lvbihub2RlLCBmcmFtZSwgdHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVOb2RlTGlzdCA9IGZ1bmN0aW9uIGNvbXBpbGVOb2RlTGlzdChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVDaGlsZHJlbihub2RlLCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVMaXRlcmFsID0gZnVuY3Rpb24gY29tcGlsZUxpdGVyYWwobm9kZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB2YWwgPSBub2RlLnZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIik7XG5cbiAgICAgIHRoaXMuX2VtaXQoXCJcXFwiXCIgKyB2YWwgKyBcIlxcXCJcIik7XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbWl0KCdudWxsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQobm9kZS52YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVTeW1ib2wgPSBmdW5jdGlvbiBjb21waWxlU3ltYm9sKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBub2RlLnZhbHVlO1xuICAgIHZhciB2ID0gZnJhbWUubG9va3VwKG5hbWUpO1xuXG4gICAgaWYgKHYpIHtcbiAgICAgIHRoaXMuX2VtaXQodik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUuY29udGV4dE9yRnJhbWVMb29rdXAoJyArICdjb250ZXh0LCBmcmFtZSwgXCInICsgbmFtZSArICdcIiknKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVHcm91cCA9IGZ1bmN0aW9uIGNvbXBpbGVHcm91cChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZSwgZnJhbWUsICcoJywgJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUFycmF5ID0gZnVuY3Rpb24gY29tcGlsZUFycmF5KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgJ1snLCAnXScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRGljdCA9IGZ1bmN0aW9uIGNvbXBpbGVEaWN0KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgJ3snLCAnfScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlUGFpciA9IGZ1bmN0aW9uIGNvbXBpbGVQYWlyKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIGtleSA9IG5vZGUua2V5O1xuICAgIHZhciB2YWwgPSBub2RlLnZhbHVlO1xuXG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIG5vZGVzLlN5bWJvbCkge1xuICAgICAga2V5ID0gbmV3IG5vZGVzLkxpdGVyYWwoa2V5LmxpbmVubywga2V5LmNvbG5vLCBrZXkudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIShrZXkgaW5zdGFuY2VvZiBub2Rlcy5MaXRlcmFsICYmIHR5cGVvZiBrZXkudmFsdWUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgdGhpcy5mYWlsKCdjb21waWxlUGFpcjogRGljdCBrZXlzIG11c3QgYmUgc3RyaW5ncyBvciBuYW1lcycsIGtleS5saW5lbm8sIGtleS5jb2xubyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21waWxlKGtleSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnOiAnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKHZhbCwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSW5saW5lSWYgPSBmdW5jdGlvbiBjb21waWxlSW5saW5lSWYobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCcoJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5jb25kLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCc/Jyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCc6Jyk7XG5cbiAgICBpZiAobm9kZS5lbHNlXyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jb21waWxlKG5vZGUuZWxzZV8sIGZyYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdCgnXCJcIicpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUluID0gZnVuY3Rpb24gY29tcGlsZUluKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5pbk9wZXJhdG9yKCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnLCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUlzID0gZnVuY3Rpb24gY29tcGlsZUlzKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gZmlyc3QsIHdlIG5lZWQgdG8gdHJ5IHRvIGdldCB0aGUgbmFtZSBvZiB0aGUgdGVzdCBmdW5jdGlvbiwgaWYgaXQncyBhXG4gICAgLy8gY2FsbGFibGUgKGkuZS4sIGhhcyBhcmdzKSBhbmQgbm90IGEgc3ltYm9sLlxuICAgIHZhciByaWdodCA9IG5vZGUucmlnaHQubmFtZSA/IG5vZGUucmlnaHQubmFtZS52YWx1ZSAvLyBvdGhlcndpc2UgZ28gd2l0aCB0aGUgc3ltYm9sIHZhbHVlXG4gICAgOiBub2RlLnJpZ2h0LnZhbHVlO1xuXG4gICAgdGhpcy5fZW1pdCgnZW52LmdldFRlc3QoXCInICsgcmlnaHQgKyAnXCIpLmNhbGwoY29udGV4dCwgJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7IC8vIGNvbXBpbGUgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGNhbGxhYmxlIGlmIHRoZXkgZXhpc3RcblxuICAgIGlmIChub2RlLnJpZ2h0LmFyZ3MpIHtcbiAgICAgIHRoaXMuX2VtaXQoJywnKTtcblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQuYXJncywgZnJhbWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXQoJykgPT09IHRydWUnKTtcbiAgfTtcblxuICBfcHJvdG8uX2Jpbk9wRW1pdHRlciA9IGZ1bmN0aW9uIF9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsIHN0cikge1xuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoc3RyKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG4gIH0gLy8gZW5zdXJlIGNvbmNhdGVuYXRpb24gaW5zdGVhZCBvZiBhZGRpdGlvblxuICAvLyBieSBhZGRpbmcgZW1wdHkgc3RyaW5nIGluIGJldHdlZW5cbiAgO1xuXG4gIF9wcm90by5jb21waWxlT3IgPSBmdW5jdGlvbiBjb21waWxlT3Iobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnIHx8ICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQW5kID0gZnVuY3Rpb24gY29tcGlsZUFuZChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgJiYgJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVBZGQgPSBmdW5jdGlvbiBjb21waWxlQWRkKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyArICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ29uY2F0ID0gZnVuY3Rpb24gY29tcGlsZUNvbmNhdChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgKyBcIlwiICsgJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVTdWIgPSBmdW5jdGlvbiBjb21waWxlU3ViKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAtICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTXVsID0gZnVuY3Rpb24gY29tcGlsZU11bChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgKiAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZURpdiA9IGZ1bmN0aW9uIGNvbXBpbGVEaXYobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnIC8gJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVNb2QgPSBmdW5jdGlvbiBjb21waWxlTW9kKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAlICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTm90ID0gZnVuY3Rpb24gY29tcGlsZU5vdChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJyEnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnRhcmdldCwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRmxvb3JEaXYgPSBmdW5jdGlvbiBjb21waWxlRmxvb3JEaXYobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCdNYXRoLmZsb29yKCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnIC8gJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5yaWdodCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlUG93ID0gZnVuY3Rpb24gY29tcGlsZVBvdyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ01hdGgucG93KCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnLCAnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVOZWcgPSBmdW5jdGlvbiBjb21waWxlTmVnKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnLScpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVQb3MgPSBmdW5jdGlvbiBjb21waWxlUG9zKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnKycpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDb21wYXJlID0gZnVuY3Rpb24gY29tcGlsZUNvbXBhcmUobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmV4cHIsIGZyYW1lKTtcbiAgICBub2RlLm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgX3RoaXM1Ll9lbWl0KFwiIFwiICsgY29tcGFyZU9wc1tvcC50eXBlXSArIFwiIFwiKTtcblxuICAgICAgX3RoaXM1LmNvbXBpbGUob3AuZXhwciwgZnJhbWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTG9va3VwVmFsID0gZnVuY3Rpb24gY29tcGlsZUxvb2t1cFZhbChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUubWVtYmVyTG9va3VwKCgnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpLCcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS52YWwsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uX2dldE5vZGVOYW1lID0gZnVuY3Rpb24gX2dldE5vZGVOYW1lKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZW5hbWUpIHtcbiAgICAgIGNhc2UgJ1N5bWJvbCc6XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuXG4gICAgICBjYXNlICdGdW5DYWxsJzpcbiAgICAgICAgcmV0dXJuICd0aGUgcmV0dXJuIHZhbHVlIG9mICgnICsgdGhpcy5fZ2V0Tm9kZU5hbWUobm9kZS5uYW1lKSArICcpJztcblxuICAgICAgY2FzZSAnTG9va3VwVmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUudGFyZ2V0KSArICdbXCInICsgdGhpcy5fZ2V0Tm9kZU5hbWUobm9kZS52YWwpICsgJ1wiXSc7XG5cbiAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gJy0tZXhwcmVzc2lvbi0tJztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGdW5DYWxsID0gZnVuY3Rpb24gY29tcGlsZUZ1bkNhbGwobm9kZSwgZnJhbWUpIHtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIGxpbmUvY29sIGluZm8gYXQgcnVudGltZSBieSBzZXR0aW5nc1xuICAgIC8vIHZhcmlhYmxlcyB3aXRoaW4gYW4gZXhwcmVzc2lvbi4gQW4gZXhwcmVzc2lvbiBpbiBqYXZhc2NyaXB0XG4gICAgLy8gbGlrZSAoeCwgeSwgeikgcmV0dXJucyB0aGUgbGFzdCB2YWx1ZSwgYW5kIHggYW5kIHkgY2FuIGJlXG4gICAgLy8gYW55dGhpbmdcbiAgICB0aGlzLl9lbWl0KCcobGluZW5vID0gJyArIG5vZGUubGluZW5vICsgJywgY29sbm8gPSAnICsgbm9kZS5jb2xubyArICcsICcpO1xuXG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5jYWxsV3JhcCgnKTsgLy8gQ29tcGlsZSBpdCBhcyBub3JtYWwuXG5cblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUubmFtZSwgZnJhbWUpOyAvLyBPdXRwdXQgdGhlIG5hbWUgb2Ygd2hhdCB3ZSdyZSBjYWxsaW5nIHNvIHdlIGNhbiBnZXQgZnJpZW5kbHkgZXJyb3JzXG4gICAgLy8gaWYgdGhlIGxvb2t1cCBmYWlscy5cblxuXG4gICAgdGhpcy5fZW1pdCgnLCBcIicgKyB0aGlzLl9nZXROb2RlTmFtZShub2RlLm5hbWUpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIiwgY29udGV4dCwgJyk7XG5cbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUuYXJncywgZnJhbWUsICdbJywgJ10pJyk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGaWx0ZXIgPSBmdW5jdGlvbiBjb21waWxlRmlsdGVyKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgdGhpcy5hc3NlcnRUeXBlKG5hbWUsIG5vZGVzLlN5bWJvbCk7XG5cbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0RmlsdGVyKFwiJyArIG5hbWUudmFsdWUgKyAnXCIpLmNhbGwoY29udGV4dCwgJyk7XG5cbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUuYXJncywgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRmlsdGVyQXN5bmMgPSBmdW5jdGlvbiBjb21waWxlRmlsdGVyQXN5bmMobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICB2YXIgc3ltYm9sID0gbm9kZS5zeW1ib2wudmFsdWU7XG4gICAgdGhpcy5hc3NlcnRUeXBlKG5hbWUsIG5vZGVzLlN5bWJvbCk7XG4gICAgZnJhbWUuc2V0KHN5bWJvbCwgc3ltYm9sKTtcblxuICAgIHRoaXMuX2VtaXQoJ2Vudi5nZXRGaWx0ZXIoXCInICsgbmFtZS52YWx1ZSArICdcIikuY2FsbChjb250ZXh0LCAnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZS5hcmdzLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKHN5bWJvbCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlS2V5d29yZEFyZ3MgPSBmdW5jdGlvbiBjb21waWxlS2V5d29yZEFyZ3Mobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCdydW50aW1lLm1ha2VLZXl3b3JkQXJncygnKTtcblxuICAgIHRoaXMuY29tcGlsZURpY3Qobm9kZSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlU2V0ID0gZnVuY3Rpb24gY29tcGlsZVNldChub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IFtdOyAvLyBMb29rdXAgdGhlIHZhcmlhYmxlIG5hbWVzIGZvciBlYWNoIGlkZW50aWZpZXIgYW5kIGNyZWF0ZVxuICAgIC8vIG5ldyBvbmVzIGlmIG5lY2Vzc2FyeVxuXG4gICAgbm9kZS50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdmFyIG5hbWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICB2YXIgaWQgPSBmcmFtZS5sb29rdXAobmFtZSk7XG5cbiAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlkID0gX3RoaXM2Ll90bXBpZCgpOyAvLyBOb3RlOiBUaGlzIHJlbGllcyBvbiBqcyBhbGxvd2luZyBzY29wZSBhY3Jvc3NcbiAgICAgICAgLy8gYmxvY2tzLCBpbiBjYXNlIHRoaXMgaXMgY3JlYXRlZCBpbnNpZGUgYW4gYGlmYFxuXG4gICAgICAgIF90aGlzNi5fZW1pdExpbmUoJ3ZhciAnICsgaWQgKyAnOycpO1xuICAgICAgfVxuXG4gICAgICBpZHMucHVzaChpZCk7XG4gICAgfSk7XG5cbiAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgdGhpcy5fZW1pdChpZHMuam9pbignID0gJykgKyAnID0gJyk7XG5cbiAgICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudmFsdWUsIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJzsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdChpZHMuam9pbignID0gJykgKyAnID0gJyk7XG5cbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJzsnKTtcbiAgICB9XG5cbiAgICBub2RlLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0LCBpKSB7XG4gICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICB2YXIgbmFtZSA9IHRhcmdldC52YWx1ZTsgLy8gV2UgYXJlIHJ1bm5pbmcgdGhpcyBmb3IgZXZlcnkgdmFyLCBidXQgaXQncyB2ZXJ5XG4gICAgICAvLyB1bmNvbW1vbiB0byBhc3NpZ24gdG8gbXVsdGlwbGUgdmFycyBhbnl3YXlcblxuICAgICAgX3RoaXM2Ll9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGlkICsgXCIsIHRydWUpO1wiKTtcblxuICAgICAgX3RoaXM2Ll9lbWl0TGluZSgnaWYoZnJhbWUudG9wTGV2ZWwpIHsnKTtcblxuICAgICAgX3RoaXM2Ll9lbWl0TGluZShcImNvbnRleHQuc2V0VmFyaWFibGUoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG5cbiAgICAgIF90aGlzNi5fZW1pdExpbmUoJ30nKTtcblxuICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgICAgX3RoaXM2Ll9lbWl0TGluZSgnaWYoZnJhbWUudG9wTGV2ZWwpIHsnKTtcblxuICAgICAgICBfdGhpczYuX2VtaXRMaW5lKFwiY29udGV4dC5hZGRFeHBvcnQoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG5cbiAgICAgICAgX3RoaXM2Ll9lbWl0TGluZSgnfScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlU3dpdGNoID0gZnVuY3Rpb24gY29tcGlsZVN3aXRjaChub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgdGhpcy5fZW1pdCgnc3dpdGNoICgnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmV4cHIsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJykgeycpO1xuXG4gICAgbm9kZS5jYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICBfdGhpczcuX2VtaXQoJ2Nhc2UgJyk7XG5cbiAgICAgIF90aGlzNy5jb21waWxlKGMuY29uZCwgZnJhbWUpO1xuXG4gICAgICBfdGhpczcuX2VtaXQoJzogJyk7XG5cbiAgICAgIF90aGlzNy5jb21waWxlKGMuYm9keSwgZnJhbWUpOyAvLyBwcmVzZXJ2ZSBmYWxsLXRocm91Z2hzXG5cblxuICAgICAgaWYgKGMuYm9keS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgX3RoaXM3Ll9lbWl0TGluZSgnYnJlYWs7Jyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgICB0aGlzLl9lbWl0KCdkZWZhdWx0OicpO1xuXG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5kZWZhdWx0LCBmcmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdCgnfScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSWYgPSBmdW5jdGlvbiBjb21waWxlSWYobm9kZSwgZnJhbWUsIGFzeW5jKSB7XG4gICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICB0aGlzLl9lbWl0KCdpZignKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuY29uZCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJykgeycpO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczguY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcblxuICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIF90aGlzOC5fZW1pdCgnY2IoKScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUuZWxzZV8pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9XFxuZWxzZSB7Jyk7XG5cbiAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczguY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG5cbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgX3RoaXM4Ll9lbWl0KCdjYigpJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoYXN5bmMpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9XFxuZWxzZSB7Jyk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJ2NiKCknKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSWZBc3luYyA9IGZ1bmN0aW9uIGNvbXBpbGVJZkFzeW5jKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnKGZ1bmN0aW9uKGNiKSB7Jyk7XG5cbiAgICB0aGlzLmNvbXBpbGVJZihub2RlLCBmcmFtZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9lbWl0KCd9KSgnICsgdGhpcy5fbWFrZUNhbGxiYWNrKCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdExvb3BCaW5kaW5ncyA9IGZ1bmN0aW9uIF9lbWl0TG9vcEJpbmRpbmdzKG5vZGUsIGFyciwgaSwgbGVuKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICB2YXIgYmluZGluZ3MgPSBbe1xuICAgICAgbmFtZTogJ2luZGV4JyxcbiAgICAgIHZhbDogaSArIFwiICsgMVwiXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2luZGV4MCcsXG4gICAgICB2YWw6IGlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncmV2aW5kZXgnLFxuICAgICAgdmFsOiBsZW4gKyBcIiAtIFwiICsgaVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdyZXZpbmRleDAnLFxuICAgICAgdmFsOiBsZW4gKyBcIiAtIFwiICsgaSArIFwiIC0gMVwiXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2ZpcnN0JyxcbiAgICAgIHZhbDogaSArIFwiID09PSAwXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGFzdCcsXG4gICAgICB2YWw6IGkgKyBcIiA9PT0gXCIgKyBsZW4gKyBcIiAtIDFcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgdmFsOiBsZW5cbiAgICB9XTtcbiAgICBiaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICBfdGhpczkuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJsb29wLlwiICsgYi5uYW1lICsgXCJcXFwiLCBcIiArIGIudmFsICsgXCIpO1wiKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZvciA9IGZ1bmN0aW9uIGNvbXBpbGVGb3Iobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAvLyBTb21lIG9mIHRoaXMgY29kZSBpcyB1Z2x5LCBidXQgaXQga2VlcHMgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYXMgZmFzdCBhcyBwb3NzaWJsZS4gRm9yQXN5bmMgYWxzbyBzaGFyZXMgc29tZSBvZiB0aGlzLCBidXRcbiAgICAvLyBub3QgbXVjaC5cbiAgICB2YXIgaSA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgbGVuID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBhcnIgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgZnJhbWUgPSBmcmFtZS5wdXNoKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUgPSBmcmFtZS5wdXNoKCk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0KFwidmFyIFwiICsgYXJyICsgXCIgPSBcIik7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLmFyciwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJzsnKTtcblxuICAgIHRoaXMuX2VtaXQoXCJpZihcIiArIGFyciArIFwiKSB7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoYXJyICsgJyA9IHJ1bnRpbWUuZnJvbUl0ZXJhdG9yKCcgKyBhcnIgKyAnKTsnKTsgLy8gSWYgbXVsdGlwbGUgbmFtZXMgYXJlIHBhc3NlZCwgd2UgbmVlZCB0byBiaW5kIHRoZW1cbiAgICAvLyBhcHByb3ByaWF0ZWx5XG5cblxuICAgIGlmIChub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5BcnJheSkge1xuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBpICsgXCI7XCIpOyAvLyBUaGUgb2JqZWN0IGNvdWxkIGJlIGFuIGFycm95IG9yIG9iamVjdC4gTm90ZSB0aGF0IHRoZVxuICAgICAgLy8gYm9keSBvZiB0aGUgbG9vcCBpcyBkdXBsaWNhdGVkIGZvciBlYWNoIGNvbmRpdGlvbiwgYnV0XG4gICAgICAvLyB3ZSBhcmUgb3B0aW1pemluZyBmb3Igc3BlZWQgb3ZlciBzaXplLlxuXG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiaWYocnVudGltZS5pc0FycmF5KFwiICsgYXJyICsgXCIpKSB7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIGxlbiArIFwiID0gXCIgKyBhcnIgKyBcIi5sZW5ndGg7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZvcihcIiArIGkgKyBcIj0wOyBcIiArIGkgKyBcIiA8IFwiICsgYXJyICsgXCIubGVuZ3RoOyBcIiArIGkgKyBcIisrKSB7XCIpOyAvLyBCaW5kIGVhY2ggZGVjbGFyZWQgdmFyXG5cblxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCB1KSB7XG4gICAgICAgIHZhciB0aWQgPSBfdGhpczEwLl90bXBpZCgpO1xuXG4gICAgICAgIF90aGlzMTAuX2VtaXRMaW5lKFwidmFyIFwiICsgdGlkICsgXCIgPSBcIiArIGFyciArIFwiW1wiICsgaSArIFwiXVtcIiArIHUgKyBcIl07XCIpO1xuXG4gICAgICAgIF90aGlzMTAuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIGNoaWxkICsgXCJcXFwiLCBcIiArIGFyciArIFwiW1wiICsgaSArIFwiXVtcIiArIHUgKyBcIl0pO1wiKTtcblxuICAgICAgICBmcmFtZS5zZXQobm9kZS5uYW1lLmNoaWxkcmVuW3VdLnZhbHVlLCB0aWQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9IGVsc2UgeycpOyAvLyBJdGVyYXRlIG92ZXIgdGhlIGtleS92YWx1ZXMgb2YgYW4gb2JqZWN0XG5cblxuICAgICAgdmFyIF9ub2RlJG5hbWUkY2hpbGRyZW4gPSBub2RlLm5hbWUuY2hpbGRyZW4sXG4gICAgICAgICAga2V5ID0gX25vZGUkbmFtZSRjaGlsZHJlblswXSxcbiAgICAgICAgICB2YWwgPSBfbm9kZSRuYW1lJGNoaWxkcmVuWzFdO1xuXG4gICAgICB2YXIgayA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICAgIHZhciB2ID0gdGhpcy5fdG1waWQoKTtcblxuICAgICAgZnJhbWUuc2V0KGtleS52YWx1ZSwgayk7XG4gICAgICBmcmFtZS5zZXQodmFsLnZhbHVlLCB2KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoaSArIFwiID0gLTE7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIGxlbiArIFwiID0gcnVudGltZS5rZXlzKFwiICsgYXJyICsgXCIpLmxlbmd0aDtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZm9yKHZhciBcIiArIGsgKyBcIiBpbiBcIiArIGFyciArIFwiKSB7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShpICsgXCIrKztcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgdiArIFwiID0gXCIgKyBhcnIgKyBcIltcIiArIGsgKyBcIl07XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBrZXkudmFsdWUgKyBcIlxcXCIsIFwiICsgayArIFwiKTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIHZhbC52YWx1ZSArIFwiXFxcIiwgXCIgKyB2ICsgXCIpO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG5cbiAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEwLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gR2VuZXJhdGUgYSB0eXBpY2FsIGFycmF5IGl0ZXJhdGlvblxuICAgICAgdmFyIF92ID0gdGhpcy5fdG1waWQoKTtcblxuICAgICAgZnJhbWUuc2V0KG5vZGUubmFtZS52YWx1ZSwgX3YpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIGxlbiArIFwiID0gXCIgKyBhcnIgKyBcIi5sZW5ndGg7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZvcih2YXIgXCIgKyBpICsgXCI9MDsgXCIgKyBpICsgXCIgPCBcIiArIGFyciArIFwiLmxlbmd0aDsgXCIgKyBpICsgXCIrKykge1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBfdiArIFwiID0gXCIgKyBhcnIgKyBcIltcIiArIGkgKyBcIl07XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBub2RlLm5hbWUudmFsdWUgKyBcIlxcXCIsIFwiICsgX3YgKyBcIik7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TG9vcEJpbmRpbmdzKG5vZGUsIGFyciwgaSwgbGVuKTtcblxuICAgICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICBpZiAobm9kZS5lbHNlXykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmICghJyArIGxlbiArICcpIHsnKTtcblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUuZWxzZV8sIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUgPSBmcmFtZS5wb3AoKTsnKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVBc3luY0xvb3AgPSBmdW5jdGlvbiBfY29tcGlsZUFzeW5jTG9vcChub2RlLCBmcmFtZSwgcGFyYWxsZWwpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICAvLyBUaGlzIHNoYXJlcyBzb21lIGNvZGUgd2l0aCB0aGUgRm9yIHRhZywgYnV0IG5vdCBlbm91Z2ggdG9cbiAgICAvLyB3b3JyeSBhYm91dC4gVGhpcyBpdGVyYXRlcyBhY3Jvc3MgYW4gb2JqZWN0IGFzeW5jaHJvbm91c2x5LFxuICAgIC8vIGJ1dCBub3QgaW4gcGFyYWxsZWwuXG4gICAgdmFyIGkgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGxlbiA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgYXJyID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBhc3luY01ldGhvZCA9IHBhcmFsbGVsID8gJ2FzeW5jQWxsJyA6ICdhc3luY0VhY2gnO1xuICAgIGZyYW1lID0gZnJhbWUucHVzaCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucHVzaCgpOycpO1xuXG4gICAgdGhpcy5fZW1pdCgndmFyICcgKyBhcnIgKyAnID0gcnVudGltZS5mcm9tSXRlcmF0b3IoJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLmFyciwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJyk7Jyk7XG5cbiAgICBpZiAobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuQXJyYXkpIHtcbiAgICAgIHZhciBhcnJheUxlbiA9IG5vZGUubmFtZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX2VtaXQoXCJydW50aW1lLlwiICsgYXN5bmNNZXRob2QgKyBcIihcIiArIGFyciArIFwiLCBcIiArIGFycmF5TGVuICsgXCIsIGZ1bmN0aW9uKFwiKTtcblxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgX3RoaXMxMS5fZW1pdChuYW1lLnZhbHVlICsgXCIsXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXQoaSArICcsJyArIGxlbiArICcsbmV4dCkgeycpO1xuXG4gICAgICBub2RlLm5hbWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgaWQgPSBuYW1lLnZhbHVlO1xuICAgICAgICBmcmFtZS5zZXQoaWQsIGlkKTtcblxuICAgICAgICBfdGhpczExLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBpZCArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkID0gbm9kZS5uYW1lLnZhbHVlO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInJ1bnRpbWUuXCIgKyBhc3luY01ldGhvZCArIFwiKFwiICsgYXJyICsgXCIsIDEsIGZ1bmN0aW9uKFwiICsgaWQgKyBcIiwgXCIgKyBpICsgXCIsIFwiICsgbGVuICsgXCIsbmV4dCkge1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lLnNldChcIicgKyBpZCArICdcIiwgJyArIGlkICsgJyk7Jyk7XG5cbiAgICAgIGZyYW1lLnNldChpZCwgaWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYnVmO1xuXG4gICAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgICAgYnVmID0gX3RoaXMxMS5fcHVzaEJ1ZmZlcigpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczExLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG5cbiAgICAgIF90aGlzMTEuX2VtaXRMaW5lKCduZXh0KCcgKyBpICsgKGJ1ZiA/ICcsJyArIGJ1ZiA6ICcnKSArICcpOycpO1xuXG4gICAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgICAgX3RoaXMxMS5fcG9wQnVmZmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9LCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKG91dHB1dCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSh0aGlzLmJ1ZmZlciArICcgKz0gJyArIG91dHB1dCArICc7Jyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuZWxzZV8pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCdpZiAoIScgKyBhcnIgKyAnLmxlbmd0aCkgeycpO1xuXG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5lbHNlXywgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9IGZyYW1lLnBvcCgpOycpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQXN5bmNFYWNoID0gZnVuY3Rpb24gY29tcGlsZUFzeW5jRWFjaChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVBc3luY0xvb3Aobm9kZSwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQXN5bmNBbGwgPSBmdW5jdGlvbiBjb21waWxlQXN5bmNBbGwobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQXN5bmNMb29wKG5vZGUsIGZyYW1lLCB0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVNYWNybyA9IGZ1bmN0aW9uIF9jb21waWxlTWFjcm8obm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBrd2FyZ3MgPSBudWxsO1xuXG4gICAgdmFyIGZ1bmNJZCA9ICdtYWNyb18nICsgdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBrZWVwRnJhbWUgPSBmcmFtZSAhPT0gdW5kZWZpbmVkOyAvLyBUeXBlIGNoZWNrIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBhcmdzXG5cbiAgICBub2RlLmFyZ3MuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICBpZiAoaSA9PT0gbm9kZS5hcmdzLmNoaWxkcmVuLmxlbmd0aCAtIDEgJiYgYXJnIGluc3RhbmNlb2Ygbm9kZXMuRGljdCkge1xuICAgICAgICBrd2FyZ3MgPSBhcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczEyLmFzc2VydFR5cGUoYXJnLCBub2Rlcy5TeW1ib2wpO1xuXG4gICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByZWFsTmFtZXMgPSBbXS5jb25jYXQoYXJncy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBcImxfXCIgKyBuLnZhbHVlO1xuICAgIH0pLCBbJ2t3YXJncyddKTsgLy8gUXVvdGVkIGFyZ3VtZW50IG5hbWVzXG5cbiAgICB2YXIgYXJnTmFtZXMgPSBhcmdzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbi52YWx1ZSArIFwiXFxcIlwiO1xuICAgIH0pO1xuICAgIHZhciBrd2FyZ05hbWVzID0gKGt3YXJncyAmJiBrd2FyZ3MuY2hpbGRyZW4gfHwgW10pLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbi5rZXkudmFsdWUgKyBcIlxcXCJcIjtcbiAgICB9KTsgLy8gV2UgcGFzcyBhIGZ1bmN0aW9uIHRvIG1ha2VNYWNybyB3aGljaCBkZXN0cnVjdHVyZXMgdGhlXG4gICAgLy8gYXJndW1lbnRzIHNvIHN1cHBvcnQgc2V0dGluZyBwb3NpdGlvbmFsIGFyZ3Mgd2l0aCBrZXl3b3Jkc1xuICAgIC8vIGFyZ3MgYW5kIHBhc3Npbmcga2V5d29yZCBhcmdzIGFzIHBvc2l0aW9uYWwgYXJnc1xuICAgIC8vIChlc3NlbnRpYWxseSBkZWZhdWx0IHZhbHVlcykuIFNlZSBydW50aW1lLmpzLlxuXG4gICAgdmFyIGN1cnJGcmFtZTtcblxuICAgIGlmIChrZWVwRnJhbWUpIHtcbiAgICAgIGN1cnJGcmFtZSA9IGZyYW1lLnB1c2godHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJGcmFtZSA9IG5ldyBGcmFtZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lcyhcInZhciBcIiArIGZ1bmNJZCArIFwiID0gcnVudGltZS5tYWtlTWFjcm8oXCIsIFwiW1wiICsgYXJnTmFtZXMuam9pbignLCAnKSArIFwiXSwgXCIsIFwiW1wiICsga3dhcmdOYW1lcy5qb2luKCcsICcpICsgXCJdLCBcIiwgXCJmdW5jdGlvbiAoXCIgKyByZWFsTmFtZXMuam9pbignLCAnKSArIFwiKSB7XCIsICd2YXIgY2FsbGVyRnJhbWUgPSBmcmFtZTsnLCAnZnJhbWUgPSAnICsgKGtlZXBGcmFtZSA/ICdmcmFtZS5wdXNoKHRydWUpOycgOiAnbmV3IHJ1bnRpbWUuRnJhbWUoKTsnKSwgJ2t3YXJncyA9IGt3YXJncyB8fCB7fTsnLCAnaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrd2FyZ3MsIFwiY2FsbGVyXCIpKSB7JywgJ2ZyYW1lLnNldChcImNhbGxlclwiLCBrd2FyZ3MuY2FsbGVyKTsgfScpOyAvLyBFeHBvc2UgdGhlIGFyZ3VtZW50cyB0byB0aGUgdGVtcGxhdGUuIERvbid0IG5lZWQgdG8gdXNlXG4gICAgLy8gcmFuZG9tIG5hbWVzIGJlY2F1c2UgdGhlIGZ1bmN0aW9uXG4gICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgcnVuLXRpbWUgc2NvcGUgZm9yIHVzXG5cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBfdGhpczEyLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBhcmcudmFsdWUgKyBcIlxcXCIsIGxfXCIgKyBhcmcudmFsdWUgKyBcIik7XCIpO1xuXG4gICAgICBjdXJyRnJhbWUuc2V0KGFyZy52YWx1ZSwgXCJsX1wiICsgYXJnLnZhbHVlKTtcbiAgICB9KTsgLy8gRXhwb3NlIHRoZSBrZXl3b3JkIGFyZ3VtZW50c1xuXG4gICAgaWYgKGt3YXJncykge1xuICAgICAga3dhcmdzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYWlyLmtleS52YWx1ZTtcblxuICAgICAgICBfdGhpczEyLl9lbWl0KFwiZnJhbWUuc2V0KFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiKTtcblxuICAgICAgICBfdGhpczEyLl9lbWl0KFwiT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGt3YXJncywgXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIik7XG5cbiAgICAgICAgX3RoaXMxMi5fZW1pdChcIiA/IGt3YXJnc1tcXFwiXCIgKyBuYW1lICsgXCJcXFwiXSA6IFwiKTtcblxuICAgICAgICBfdGhpczEyLl9jb21waWxlRXhwcmVzc2lvbihwYWlyLnZhbHVlLCBjdXJyRnJhbWUpO1xuXG4gICAgICAgIF90aGlzMTIuX2VtaXQoJyk7Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYnVmZmVySWQgPSB0aGlzLl9wdXNoQnVmZmVyKCk7XG5cbiAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMTIuY29tcGlsZShub2RlLmJvZHksIGN1cnJGcmFtZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUgPSAnICsgKGtlZXBGcmFtZSA/ICdmcmFtZS5wb3AoKTsnIDogJ2NhbGxlckZyYW1lOycpKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwicmV0dXJuIG5ldyBydW50aW1lLlNhZmVTdHJpbmcoXCIgKyBidWZmZXJJZCArIFwiKTtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSk7Jyk7XG5cbiAgICB0aGlzLl9wb3BCdWZmZXIoKTtcblxuICAgIHJldHVybiBmdW5jSWQ7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVNYWNybyA9IGZ1bmN0aW9uIGNvbXBpbGVNYWNybyhub2RlLCBmcmFtZSkge1xuICAgIHZhciBmdW5jSWQgPSB0aGlzLl9jb21waWxlTWFjcm8obm9kZSk7IC8vIEV4cG9zZSB0aGUgbWFjcm8gdG8gdGhlIHRlbXBsYXRlc1xuXG5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICBmcmFtZS5zZXQobmFtZSwgZnVuY0lkKTtcblxuICAgIGlmIChmcmFtZS5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgZnVuY0lkICsgXCIpO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUubmFtZS52YWx1ZS5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgICB0aGlzLl9lbWl0TGluZShcImNvbnRleHQuYWRkRXhwb3J0KFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpO1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJjb250ZXh0LnNldFZhcmlhYmxlKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgZnVuY0lkICsgXCIpO1wiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDYWxsZXIgPSBmdW5jdGlvbiBjb21waWxlQ2FsbGVyKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gYmFzaWNhbGx5IGFuIGFub255bW91cyBcIm1hY3JvIGV4cHJlc3Npb25cIlxuICAgIHRoaXMuX2VtaXQoJyhmdW5jdGlvbiAoKXsnKTtcblxuICAgIHZhciBmdW5jSWQgPSB0aGlzLl9jb21waWxlTWFjcm8obm9kZSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdChcInJldHVybiBcIiArIGZ1bmNJZCArIFwiO30pKClcIik7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlR2V0VGVtcGxhdGUgPSBmdW5jdGlvbiBfY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCBlYWdlckNvbXBpbGUsIGlnbm9yZU1pc3NpbmcpIHtcbiAgICB2YXIgcGFyZW50VGVtcGxhdGVJZCA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgcGFyZW50TmFtZSA9IHRoaXMuX3RlbXBsYXRlTmFtZSgpO1xuXG4gICAgdmFyIGNiID0gdGhpcy5fbWFrZUNhbGxiYWNrKHBhcmVudFRlbXBsYXRlSWQpO1xuXG4gICAgdmFyIGVhZ2VyQ29tcGlsZUFyZyA9IGVhZ2VyQ29tcGlsZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgdmFyIGlnbm9yZU1pc3NpbmdBcmcgPSBpZ25vcmVNaXNzaW5nID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIHRoaXMuX2VtaXQoJ2Vudi5nZXRUZW1wbGF0ZSgnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudGVtcGxhdGUsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiLCBcIiArIGVhZ2VyQ29tcGlsZUFyZyArIFwiLCBcIiArIHBhcmVudE5hbWUgKyBcIiwgXCIgKyBpZ25vcmVNaXNzaW5nQXJnICsgXCIsIFwiICsgY2IpO1xuXG4gICAgcmV0dXJuIHBhcmVudFRlbXBsYXRlSWQ7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJbXBvcnQgPSBmdW5jdGlvbiBjb21waWxlSW1wb3J0KG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIHRhcmdldCA9IG5vZGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgdmFyIGlkID0gdGhpcy5fY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoaWQgKyAnLmdldEV4cG9ydGVkKCcgKyAobm9kZS53aXRoQ29udGV4dCA/ICdjb250ZXh0LmdldFZhcmlhYmxlcygpLCBmcmFtZSwgJyA6ICcnKSArIHRoaXMuX21ha2VDYWxsYmFjayhpZCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgZnJhbWUuc2V0KHRhcmdldCwgaWQpO1xuXG4gICAgaWYgKGZyYW1lLnBhcmVudCkge1xuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgdGFyZ2V0ICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdExpbmUoXCJjb250ZXh0LnNldFZhcmlhYmxlKFxcXCJcIiArIHRhcmdldCArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlRnJvbUltcG9ydCA9IGZ1bmN0aW9uIGNvbXBpbGVGcm9tSW1wb3J0KG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgdmFyIGltcG9ydGVkSWQgPSB0aGlzLl9jb21waWxlR2V0VGVtcGxhdGUobm9kZSwgZnJhbWUsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShpbXBvcnRlZElkICsgJy5nZXRFeHBvcnRlZCgnICsgKG5vZGUud2l0aENvbnRleHQgPyAnY29udGV4dC5nZXRWYXJpYWJsZXMoKSwgZnJhbWUsICcgOiAnJykgKyB0aGlzLl9tYWtlQ2FsbGJhY2soaW1wb3J0ZWRJZCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgbm9kZS5uYW1lcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lTm9kZSkge1xuICAgICAgdmFyIG5hbWU7XG4gICAgICB2YXIgYWxpYXM7XG5cbiAgICAgIHZhciBpZCA9IF90aGlzMTMuX3RtcGlkKCk7XG5cbiAgICAgIGlmIChuYW1lTm9kZSBpbnN0YW5jZW9mIG5vZGVzLlBhaXIpIHtcbiAgICAgICAgbmFtZSA9IG5hbWVOb2RlLmtleS52YWx1ZTtcbiAgICAgICAgYWxpYXMgPSBuYW1lTm9kZS52YWx1ZS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBuYW1lTm9kZS52YWx1ZTtcbiAgICAgICAgYWxpYXMgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICBfdGhpczEzLl9lbWl0TGluZShcImlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArIGltcG9ydGVkSWQgKyBcIiwgXFxcIlwiICsgbmFtZSArIFwiXFxcIikpIHtcIik7XG5cbiAgICAgIF90aGlzMTMuX2VtaXRMaW5lKFwidmFyIFwiICsgaWQgKyBcIiA9IFwiICsgaW1wb3J0ZWRJZCArIFwiLlwiICsgbmFtZSArIFwiO1wiKTtcblxuICAgICAgX3RoaXMxMy5fZW1pdExpbmUoJ30gZWxzZSB7Jyk7XG5cbiAgICAgIF90aGlzMTMuX2VtaXRMaW5lKFwiY2IobmV3IEVycm9yKFxcXCJjYW5ub3QgaW1wb3J0ICdcIiArIG5hbWUgKyBcIidcXFwiKSk7IHJldHVybjtcIik7XG5cbiAgICAgIF90aGlzMTMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICAgIGZyYW1lLnNldChhbGlhcywgaWQpO1xuXG4gICAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICAgIF90aGlzMTMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIGFsaWFzICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzMTMuX2VtaXRMaW5lKFwiY29udGV4dC5zZXRWYXJpYWJsZShcXFwiXCIgKyBhbGlhcyArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVCbG9jayA9IGZ1bmN0aW9uIGNvbXBpbGVCbG9jayhub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fdG1waWQoKTsgLy8gSWYgd2UgYXJlIGV4ZWN1dGluZyBvdXRzaWRlIGEgYmxvY2sgKGNyZWF0aW5nIGEgdG9wLWxldmVsXG4gICAgLy8gYmxvY2spLCB3ZSByZWFsbHkgZG9uJ3Qgd2FudCB0byBleGVjdXRlIGl0cyBjb2RlIGJlY2F1c2UgaXRcbiAgICAvLyB3aWxsIGV4ZWN1dGUgdHdpY2U6IG9uY2Ugd2hlbiB0aGUgY2hpbGQgdGVtcGxhdGUgcnVucyBhbmRcbiAgICAvLyBhZ2FpbiB3aGVuIHRoZSBwYXJlbnQgdGVtcGxhdGUgcnVucy4gTm90ZSB0aGF0IGJsb2Nrc1xuICAgIC8vIHdpdGhpbiBibG9ja3Mgd2lsbCAqYWx3YXlzKiBleGVjdXRlIGltbWVkaWF0ZWx5ICphbmQqXG4gICAgLy8gd2hlcmV2ZXIgZWxzZSB0aGV5IGFyZSBpbnZva2VkIChsaWtlIHVzZWQgaW4gYSBwYXJlbnRcbiAgICAvLyB0ZW1wbGF0ZSkuIFRoaXMgbWF5IGhhdmUgYmVoYXZpb3JhbCBkaWZmZXJlbmNlcyBmcm9tIGppbmphXG4gICAgLy8gYmVjYXVzZSBibG9ja3MgY2FuIGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgaXQgc2VlbXMgbGlrZSBhXG4gICAgLy8gd2FzdGUgb2YgcGVyZm9ybWFuY2UgdG8gYWx3YXlzIGV4ZWN1dGUgaHVnZSB0b3AtbGV2ZWxcbiAgICAvLyBibG9ja3MgdHdpY2VcblxuXG4gICAgaWYgKCF0aGlzLmluQmxvY2spIHtcbiAgICAgIHRoaXMuX2VtaXQoJyhwYXJlbnRUZW1wbGF0ZSA/IGZ1bmN0aW9uKGUsIGMsIGYsIHIsIGNiKSB7IGNiKFwiXCIpOyB9IDogJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdChcImNvbnRleHQuZ2V0QmxvY2soXFxcIlwiICsgbm9kZS5uYW1lLnZhbHVlICsgXCJcXFwiKVwiKTtcblxuICAgIGlmICghdGhpcy5pbkJsb2NrKSB7XG4gICAgICB0aGlzLl9lbWl0KCcpJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJyhlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKGlkKSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSh0aGlzLmJ1ZmZlciArIFwiICs9IFwiICsgaWQgKyBcIjtcIik7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVTdXBlciA9IGZ1bmN0aW9uIGNvbXBpbGVTdXBlcihub2RlLCBmcmFtZSkge1xuICAgIHZhciBuYW1lID0gbm9kZS5ibG9ja05hbWUudmFsdWU7XG4gICAgdmFyIGlkID0gbm9kZS5zeW1ib2wudmFsdWU7XG5cbiAgICB2YXIgY2IgPSB0aGlzLl9tYWtlQ2FsbGJhY2soaWQpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJjb250ZXh0LmdldFN1cGVyKGVudiwgXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgYl9cIiArIG5hbWUgKyBcIiwgZnJhbWUsIHJ1bnRpbWUsIFwiICsgY2IpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoaWQgKyBcIiA9IHJ1bnRpbWUubWFya1NhZmUoXCIgKyBpZCArIFwiKTtcIik7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICBmcmFtZS5zZXQoaWQsIGlkKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUV4dGVuZHMgPSBmdW5jdGlvbiBjb21waWxlRXh0ZW5kcyhub2RlLCBmcmFtZSkge1xuICAgIHZhciBrID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBwYXJlbnRUZW1wbGF0ZUlkID0gdGhpcy5fY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCB0cnVlLCBmYWxzZSk7IC8vIGV4dGVuZHMgaXMgYSBkeW5hbWljIHRhZyBhbmQgY2FuIG9jY3VyIHdpdGhpbiBhIGJsb2NrIGxpa2VcbiAgICAvLyBgaWZgLCBzbyBpZiB0aGlzIGhhcHBlbnMgd2UgbmVlZCB0byBjYXB0dXJlIHRoZSBwYXJlbnRcbiAgICAvLyB0ZW1wbGF0ZSBpbiB0aGUgdG9wLWxldmVsIHNjb3BlXG5cblxuICAgIHRoaXMuX2VtaXRMaW5lKFwicGFyZW50VGVtcGxhdGUgPSBcIiArIHBhcmVudFRlbXBsYXRlSWQpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJmb3IodmFyIFwiICsgayArIFwiIGluIHBhcmVudFRlbXBsYXRlLmJsb2Nrcykge1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiY29udGV4dC5hZGRCbG9jayhcIiArIGsgKyBcIiwgcGFyZW50VGVtcGxhdGUuYmxvY2tzW1wiICsgayArIFwiXSk7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUluY2x1ZGUgPSBmdW5jdGlvbiBjb21waWxlSW5jbHVkZShub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXRMaW5lKCd2YXIgdGFza3MgPSBbXTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd0YXNrcy5wdXNoKCcpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2Z1bmN0aW9uKGNhbGxiYWNrKSB7Jyk7XG5cbiAgICB2YXIgaWQgPSB0aGlzLl9jb21waWxlR2V0VGVtcGxhdGUobm9kZSwgZnJhbWUsIGZhbHNlLCBub2RlLmlnbm9yZU1pc3NpbmcpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJjYWxsYmFjayhudWxsLFwiICsgaWQgKyBcIik7fSk7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuXG4gICAgdmFyIGlkMiA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndGFza3MucHVzaCgnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmdW5jdGlvbih0ZW1wbGF0ZSwgY2FsbGJhY2speycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3RlbXBsYXRlLnJlbmRlcihjb250ZXh0LmdldFZhcmlhYmxlcygpLCBmcmFtZSwgJyArIHRoaXMuX21ha2VDYWxsYmFjayhpZDIpKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdjYWxsYmFjayhudWxsLCcgKyBpZDIgKyAnKTt9KTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9KTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd0YXNrcy5wdXNoKCcpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2Z1bmN0aW9uKHJlc3VsdCwgY2FsbGJhY2speycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUodGhpcy5idWZmZXIgKyBcIiArPSByZXN1bHQ7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2NhbGxiYWNrKG51bGwpOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2Vudi53YXRlcmZhbGwodGFza3MsIGZ1bmN0aW9uKCl7Jyk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVUZW1wbGF0ZURhdGEgPSBmdW5jdGlvbiBjb21waWxlVGVtcGxhdGVEYXRhKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5jb21waWxlTGl0ZXJhbChub2RlLCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDYXB0dXJlID0gZnVuY3Rpb24gY29tcGlsZUNhcHR1cmUobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHRlbXBvcmFyaWx5IG92ZXJyaWRlIHRoZSBjdXJyZW50IGJ1ZmZlciBpZCBhcyAnb3V0cHV0J1xuICAgIC8vIHNvIHRoZSBzZXQgYmxvY2sgd3JpdGVzIHRvIHRoZSBjYXB0dXJlIG91dHB1dCBpbnN0ZWFkIG9mIHRoZSBidWZmZXJcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgdGhpcy5idWZmZXIgPSAnb3V0cHV0JztcblxuICAgIHRoaXMuX2VtaXRMaW5lKCcoZnVuY3Rpb24oKSB7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndmFyIG91dHB1dCA9IFwiXCI7Jyk7XG5cbiAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMTQuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdyZXR1cm4gb3V0cHV0OycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30pKCknKTsgLy8gYW5kIG9mIGNvdXJzZSwgcmV2ZXJ0IGJhY2sgdG8gdGhlIG9sZCBidWZmZXIgaWRcblxuXG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVPdXRwdXQgPSBmdW5jdGlvbiBjb21waWxlT3V0cHV0KG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgLy8gVGVtcGxhdGVEYXRhIGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgaXQgaXMgbmV2ZXJcbiAgICAgIC8vIGF1dG9lc2NhcGVkLCBzbyBzaW1wbHkgb3V0cHV0IGl0IGZvciBvcHRpbWl6YXRpb25cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLlRlbXBsYXRlRGF0YSkge1xuICAgICAgICBpZiAoY2hpbGQudmFsdWUpIHtcbiAgICAgICAgICBfdGhpczE1Ll9lbWl0KF90aGlzMTUuYnVmZmVyICsgXCIgKz0gXCIpO1xuXG4gICAgICAgICAgX3RoaXMxNS5jb21waWxlTGl0ZXJhbChjaGlsZCwgZnJhbWUpO1xuXG4gICAgICAgICAgX3RoaXMxNS5fZW1pdExpbmUoJzsnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMxNS5fZW1pdChfdGhpczE1LmJ1ZmZlciArIFwiICs9IHJ1bnRpbWUuc3VwcHJlc3NWYWx1ZShcIik7XG5cbiAgICAgICAgaWYgKF90aGlzMTUudGhyb3dPblVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTUuX2VtaXQoJ3J1bnRpbWUuZW5zdXJlRGVmaW5lZCgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMTUuY29tcGlsZShjaGlsZCwgZnJhbWUpO1xuXG4gICAgICAgIGlmIChfdGhpczE1LnRocm93T25VbmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczE1Ll9lbWl0KFwiLFwiICsgbm9kZS5saW5lbm8gKyBcIixcIiArIG5vZGUuY29sbm8gKyBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczE1Ll9lbWl0KCcsIGVudi5vcHRzLmF1dG9lc2NhcGUpO1xcbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlUm9vdCA9IGZ1bmN0aW9uIGNvbXBpbGVSb290KG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTYgPSB0aGlzO1xuXG4gICAgaWYgKGZyYW1lKSB7XG4gICAgICB0aGlzLmZhaWwoJ2NvbXBpbGVSb290OiByb290IG5vZGUgY2FuXFwndCBoYXZlIGZyYW1lJyk7XG4gICAgfVxuXG4gICAgZnJhbWUgPSBuZXcgRnJhbWUoKTtcblxuICAgIHRoaXMuX2VtaXRGdW5jQmVnaW4obm9kZSwgJ3Jvb3QnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd2YXIgcGFyZW50VGVtcGxhdGUgPSBudWxsOycpO1xuXG4gICAgdGhpcy5fY29tcGlsZUNoaWxkcmVuKG5vZGUsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdpZihwYXJlbnRUZW1wbGF0ZSkgeycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3BhcmVudFRlbXBsYXRlLnJvb3RSZW5kZXJGdW5jKGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsIGNiKTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9IGVsc2UgeycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJjYihudWxsLCBcIiArIHRoaXMuYnVmZmVyICsgXCIpO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICB0aGlzLl9lbWl0RnVuY0VuZCh0cnVlKTtcblxuICAgIHRoaXMuaW5CbG9jayA9IHRydWU7XG4gICAgdmFyIGJsb2NrTmFtZXMgPSBbXTtcbiAgICB2YXIgYmxvY2tzID0gbm9kZS5maW5kQWxsKG5vZGVzLkJsb2NrKTtcbiAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2ssIGkpIHtcbiAgICAgIHZhciBuYW1lID0gYmxvY2submFtZS52YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrTmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmxvY2sgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLlwiKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2tOYW1lcy5wdXNoKG5hbWUpO1xuXG4gICAgICBfdGhpczE2Ll9lbWl0RnVuY0JlZ2luKGJsb2NrLCBcImJfXCIgKyBuYW1lKTtcblxuICAgICAgdmFyIHRtcEZyYW1lID0gbmV3IEZyYW1lKCk7XG5cbiAgICAgIF90aGlzMTYuX2VtaXRMaW5lKCd2YXIgZnJhbWUgPSBmcmFtZS5wdXNoKHRydWUpOycpO1xuXG4gICAgICBfdGhpczE2LmNvbXBpbGUoYmxvY2suYm9keSwgdG1wRnJhbWUpO1xuXG4gICAgICBfdGhpczE2Ll9lbWl0RnVuY0VuZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3JldHVybiB7Jyk7XG5cbiAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2ssIGkpIHtcbiAgICAgIHZhciBibG9ja05hbWUgPSBcImJfXCIgKyBibG9jay5uYW1lLnZhbHVlO1xuXG4gICAgICBfdGhpczE2Ll9lbWl0TGluZShibG9ja05hbWUgKyBcIjogXCIgKyBibG9ja05hbWUgKyBcIixcIik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgncm9vdDogcm9vdFxcbn07Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGUgPSBmdW5jdGlvbiBjb21waWxlKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF9jb21waWxlID0gdGhpc1snY29tcGlsZScgKyBub2RlLnR5cGVuYW1lXTtcblxuICAgIGlmIChfY29tcGlsZSkge1xuICAgICAgX2NvbXBpbGUuY2FsbCh0aGlzLCBub2RlLCBmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbChcImNvbXBpbGU6IENhbm5vdCBjb21waWxlIG5vZGU6IFwiICsgbm9kZS50eXBlbmFtZSwgbm9kZS5saW5lbm8sIG5vZGUuY29sbm8pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0Q29kZSA9IGZ1bmN0aW9uIGdldENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZWJ1Zi5qb2luKCcnKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcGlsZXI7XG59KE9iaik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHNyYywgYXN5bmNGaWx0ZXJzLCBleHRlbnNpb25zLCBuYW1lLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBjID0gbmV3IENvbXBpbGVyKG5hbWUsIG9wdHMudGhyb3dPblVuZGVmaW5lZCk7IC8vIFJ1biB0aGUgZXh0ZW5zaW9uIHByZXByb2Nlc3NvcnMgYWdhaW5zdCB0aGUgc291cmNlLlxuXG4gICAgdmFyIHByZXByb2Nlc3NvcnMgPSAoZXh0ZW5zaW9ucyB8fCBbXSkubWFwKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgIHJldHVybiBleHQucHJlcHJvY2VzcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiAhIWY7XG4gICAgfSk7XG4gICAgdmFyIHByb2Nlc3NlZFNyYyA9IHByZXByb2Nlc3NvcnMucmVkdWNlKGZ1bmN0aW9uIChzLCBwcm9jZXNzb3IpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzb3Iocyk7XG4gICAgfSwgc3JjKTtcbiAgICBjLmNvbXBpbGUodHJhbnNmb3JtZXIudHJhbnNmb3JtKHBhcnNlci5wYXJzZShwcm9jZXNzZWRTcmMsIGV4dGVuc2lvbnMsIG9wdHMpLCBhc3luY0ZpbHRlcnMsIG5hbWUpKTtcbiAgICByZXR1cm4gYy5nZXRDb2RlKCk7XG4gIH0sXG4gIENvbXBpbGVyOiBDb21waWxlclxufTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgRW1pdHRlck9iaiA9IF9yZXF1aXJlLkVtaXR0ZXJPYmo7XG5cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1pdHRlck9iaikge1xuICBfaW5oZXJpdHNMb29zZShMb2FkZXIsIF9FbWl0dGVyT2JqKTtcblxuICBmdW5jdGlvbiBMb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9FbWl0dGVyT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmcm9tLCB0bykge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZyb20pLCB0byk7XG4gIH07XG5cbiAgX3Byb3RvLmlzUmVsYXRpdmUgPSBmdW5jdGlvbiBpc1JlbGF0aXZlKGZpbGVuYW1lKSB7XG4gICAgcmV0dXJuIGZpbGVuYW1lLmluZGV4T2YoJy4vJykgPT09IDAgfHwgZmlsZW5hbWUuaW5kZXhPZignLi4vJykgPT09IDA7XG4gIH07XG5cbiAgcmV0dXJuIExvYWRlcjtcbn0oRW1pdHRlck9iaik7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGFzYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIF93YXRlcmZhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBjb21waWxlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBmaWx0ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApLFxuICAgIEZpbGVTeXN0ZW1Mb2FkZXIgPSBfcmVxdWlyZS5GaWxlU3lzdGVtTG9hZGVyLFxuICAgIFdlYkxvYWRlciA9IF9yZXF1aXJlLldlYkxvYWRlcixcbiAgICBQcmVjb21waWxlZExvYWRlciA9IF9yZXF1aXJlLlByZWNvbXBpbGVkTG9hZGVyO1xuXG52YXIgdGVzdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxudmFyIGdsb2JhbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgT2JqID0gX3JlcXVpcmUyLk9iaixcbiAgICBFbWl0dGVyT2JqID0gX3JlcXVpcmUyLkVtaXR0ZXJPYmo7XG5cbnZhciBnbG9iYWxSdW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGhhbmRsZUVycm9yID0gZ2xvYmFsUnVudGltZS5oYW5kbGVFcnJvcixcbiAgICBGcmFtZSA9IGdsb2JhbFJ1bnRpbWUuRnJhbWU7XG5cbnZhciBleHByZXNzQXBwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7IC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBhc3luYyBBUEksICphbHdheXMqIGNhbGwgaXRcbi8vIGFzeW5jaHJvbm91c2x5IGV2ZW4gaWYgdGhlIHRlbXBsYXRlIHdhcyBzeW5jaHJvbm91cy5cblxuXG5mdW5jdGlvbiBjYWxsYmFja0FzYXAoY2IsIGVyciwgcmVzKSB7XG4gIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgIGNiKGVyciwgcmVzKTtcbiAgfSk7XG59XG4vKipcbiAqIEEgbm8tb3AgdGVtcGxhdGUsIGZvciB1c2Ugd2l0aCB7JSBpbmNsdWRlIGlnbm9yZSBtaXNzaW5nICV9XG4gKi9cblxuXG52YXIgbm9vcFRtcGxTcmMgPSB7XG4gIHR5cGU6ICdjb2RlJyxcbiAgb2JqOiB7XG4gICAgcm9vdDogZnVuY3Rpb24gcm9vdChlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYihoYW5kbGVFcnJvcihlLCBudWxsLCBudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgRW52aXJvbm1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKEVudmlyb25tZW50LCBfRW1pdHRlck9iaik7XG5cbiAgZnVuY3Rpb24gRW52aXJvbm1lbnQoKSB7XG4gICAgcmV0dXJuIF9FbWl0dGVyT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFbnZpcm9ubWVudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KGxvYWRlcnMsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gVGhlIGRldiBmbGFnIGRldGVybWluZXMgdGhlIHRyYWNlIHRoYXQnbGwgYmUgc2hvd24gb24gZXJyb3JzLlxuICAgIC8vIElmIHNldCB0byB0cnVlLCByZXR1cm5zIHRoZSBmdWxsIHRyYWNlIGZyb20gdGhlIGVycm9yIHBvaW50LFxuICAgIC8vIG90aGVyd2lzZSB3aWxsIHJldHVybiB0cmFjZSBzdGFydGluZyBmcm9tIFRlbXBsYXRlLnJlbmRlclxuICAgIC8vICh0aGUgZnVsbCB0cmFjZSBmcm9tIHdpdGhpbiBudW5qdWNrcyBtYXkgY29uZnVzZSBkZXZlbG9wZXJzIHVzaW5nXG4gICAgLy8gIHRoZSBsaWJyYXJ5KVxuICAgIC8vIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgb3B0cyA9IHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy5vcHRzLmRldiA9ICEhb3B0cy5kZXY7IC8vIFRoZSBhdXRvZXNjYXBlIGZsYWcgc2V0cyBnbG9iYWwgYXV0b2VzY2FwaW5nLiBJZiB0cnVlLFxuICAgIC8vIGV2ZXJ5IHN0cmluZyB2YXJpYWJsZSB3aWxsIGJlIGVzY2FwZWQgYnkgZGVmYXVsdC5cbiAgICAvLyBJZiBmYWxzZSwgc3RyaW5ncyBjYW4gYmUgbWFudWFsbHkgZXNjYXBlZCB1c2luZyB0aGUgYGVzY2FwZWAgZmlsdGVyLlxuICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcblxuICAgIHRoaXMub3B0cy5hdXRvZXNjYXBlID0gb3B0cy5hdXRvZXNjYXBlICE9IG51bGwgPyBvcHRzLmF1dG9lc2NhcGUgOiB0cnVlOyAvLyBJZiB0cnVlLCB0aGlzIHdpbGwgbWFrZSB0aGUgc3lzdGVtIHRocm93IGVycm9ycyBpZiB0cnlpbmdcbiAgICAvLyB0byBvdXRwdXQgYSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZVxuXG4gICAgdGhpcy5vcHRzLnRocm93T25VbmRlZmluZWQgPSAhIW9wdHMudGhyb3dPblVuZGVmaW5lZDtcbiAgICB0aGlzLm9wdHMudHJpbUJsb2NrcyA9ICEhb3B0cy50cmltQmxvY2tzO1xuICAgIHRoaXMub3B0cy5sc3RyaXBCbG9ja3MgPSAhIW9wdHMubHN0cmlwQmxvY2tzO1xuICAgIHRoaXMubG9hZGVycyA9IFtdO1xuXG4gICAgaWYgKCFsb2FkZXJzKSB7XG4gICAgICAvLyBUaGUgZmlsZXN5c3RlbSBsb2FkZXIgaXMgb25seSBhdmFpbGFibGUgc2VydmVyLXNpZGVcbiAgICAgIGlmIChGaWxlU3lzdGVtTG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVycyA9IFtuZXcgRmlsZVN5c3RlbUxvYWRlcigndmlld3MnKV07XG4gICAgICB9IGVsc2UgaWYgKFdlYkxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlcnMgPSBbbmV3IFdlYkxvYWRlcignL3ZpZXdzJyldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvYWRlcnMgPSBsaWIuaXNBcnJheShsb2FkZXJzKSA/IGxvYWRlcnMgOiBbbG9hZGVyc107XG4gICAgfSAvLyBJdCdzIGVhc3kgdG8gdXNlIHByZWNvbXBpbGVkIHRlbXBsYXRlczoganVzdCBpbmNsdWRlIHRoZW1cbiAgICAvLyBiZWZvcmUgeW91IGNvbmZpZ3VyZSBudW5qdWNrcyBhbmQgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBwaWNrIGl0IHVwIGFuZCB1c2UgaXRcblxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5udW5qdWNrc1ByZWNvbXBpbGVkKSB7XG4gICAgICB0aGlzLmxvYWRlcnMudW5zaGlmdChuZXcgUHJlY29tcGlsZWRMb2FkZXIod2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0TG9hZGVycygpO1xuXG4gICAgdGhpcy5nbG9iYWxzID0gZ2xvYmFscygpO1xuICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgIHRoaXMudGVzdHMgPSB7fTtcbiAgICB0aGlzLmFzeW5jRmlsdGVycyA9IFtdO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMuZXh0ZW5zaW9uc0xpc3QgPSBbXTtcblxuICAgIGxpYi5fZW50cmllcyhmaWx0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICAgICAgZmlsdGVyID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiBfdGhpcy5hZGRGaWx0ZXIobmFtZSwgZmlsdGVyKTtcbiAgICB9KTtcblxuICAgIGxpYi5fZW50cmllcyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZjJbMF0sXG4gICAgICAgICAgdGVzdCA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIF90aGlzLmFkZFRlc3QobmFtZSwgdGVzdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0TG9hZGVycyA9IGZ1bmN0aW9uIF9pbml0TG9hZGVycygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMubG9hZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgIC8vIENhY2hpbmcgYW5kIGNhY2hlIGJ1c3RpbmdcbiAgICAgIGxvYWRlci5jYWNoZSA9IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIGxvYWRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2FkZXIub24oJ3VwZGF0ZScsIGZ1bmN0aW9uIChuYW1lLCBmdWxsbmFtZSkge1xuICAgICAgICAgIGxvYWRlci5jYWNoZVtuYW1lXSA9IG51bGw7XG5cbiAgICAgICAgICBfdGhpczIuZW1pdCgndXBkYXRlJywgbmFtZSwgZnVsbG5hbWUsIGxvYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2FkZXIub24oJ2xvYWQnLCBmdW5jdGlvbiAobmFtZSwgc291cmNlKSB7XG4gICAgICAgICAgX3RoaXMyLmVtaXQoJ2xvYWQnLCBuYW1lLCBzb3VyY2UsIGxvYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlQ2FjaGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5sb2FkZXJzLmZvckVhY2goZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgbG9hZGVyLmNhY2hlID0ge307XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmFkZEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGFkZEV4dGVuc2lvbihuYW1lLCBleHRlbnNpb24pIHtcbiAgICBleHRlbnNpb24uX19uYW1lID0gbmFtZTtcbiAgICB0aGlzLmV4dGVuc2lvbnNbbmFtZV0gPSBleHRlbnNpb247XG4gICAgdGhpcy5leHRlbnNpb25zTGlzdC5wdXNoKGV4dGVuc2lvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIHJlbW92ZUV4dGVuc2lvbihuYW1lKSB7XG4gICAgdmFyIGV4dGVuc2lvbiA9IHRoaXMuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuXG4gICAgaWYgKCFleHRlbnNpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVuc2lvbnNMaXN0ID0gbGliLndpdGhvdXQodGhpcy5leHRlbnNpb25zTGlzdCwgZXh0ZW5zaW9uKTtcbiAgICBkZWxldGUgdGhpcy5leHRlbnNpb25zW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbiBnZXRFeHRlbnNpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLmhhc0V4dGVuc2lvbiA9IGZ1bmN0aW9uIGhhc0V4dGVuc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5leHRlbnNpb25zW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5hZGRHbG9iYWwgPSBmdW5jdGlvbiBhZGRHbG9iYWwobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmdsb2JhbHNbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZ2xvYmFsc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2xvYmFsIG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdsb2JhbHNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLmFkZEZpbHRlciA9IGZ1bmN0aW9uIGFkZEZpbHRlcihuYW1lLCBmdW5jLCBhc3luYykge1xuICAgIHZhciB3cmFwcGVkID0gZnVuYztcblxuICAgIGlmIChhc3luYykge1xuICAgICAgdGhpcy5hc3luY0ZpbHRlcnMucHVzaChuYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbHRlcnNbbmFtZV0gPSB3cmFwcGVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nZXRGaWx0ZXIgPSBmdW5jdGlvbiBnZXRGaWx0ZXIobmFtZSkge1xuICAgIGlmICghdGhpcy5maWx0ZXJzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5hZGRUZXN0ID0gZnVuY3Rpb24gYWRkVGVzdChuYW1lLCBmdW5jKSB7XG4gICAgdGhpcy50ZXN0c1tuYW1lXSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRlc3QgPSBmdW5jdGlvbiBnZXRUZXN0KG5hbWUpIHtcbiAgICBpZiAoIXRoaXMudGVzdHNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVzdCBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50ZXN0c1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8ucmVzb2x2ZVRlbXBsYXRlID0gZnVuY3Rpb24gcmVzb2x2ZVRlbXBsYXRlKGxvYWRlciwgcGFyZW50TmFtZSwgZmlsZW5hbWUpIHtcbiAgICB2YXIgaXNSZWxhdGl2ZSA9IGxvYWRlci5pc1JlbGF0aXZlICYmIHBhcmVudE5hbWUgPyBsb2FkZXIuaXNSZWxhdGl2ZShmaWxlbmFtZSkgOiBmYWxzZTtcbiAgICByZXR1cm4gaXNSZWxhdGl2ZSAmJiBsb2FkZXIucmVzb2x2ZSA/IGxvYWRlci5yZXNvbHZlKHBhcmVudE5hbWUsIGZpbGVuYW1lKSA6IGZpbGVuYW1lO1xuICB9O1xuXG4gIF9wcm90by5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uIGdldFRlbXBsYXRlKG5hbWUsIGVhZ2VyQ29tcGlsZSwgcGFyZW50TmFtZSwgaWdub3JlTWlzc2luZywgY2IpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdG1wbCA9IG51bGw7XG5cbiAgICBpZiAobmFtZSAmJiBuYW1lLnJhdykge1xuICAgICAgLy8gdGhpcyBmaXhlcyBhdXRvZXNjYXBlIGZvciB0ZW1wbGF0ZXMgcmVmZXJlbmNlZCBpbiBzeW1ib2xzXG4gICAgICBuYW1lID0gbmFtZS5yYXc7XG4gICAgfVxuXG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKHBhcmVudE5hbWUpKSB7XG4gICAgICBjYiA9IHBhcmVudE5hbWU7XG4gICAgICBwYXJlbnROYW1lID0gbnVsbDtcbiAgICAgIGVhZ2VyQ29tcGlsZSA9IGVhZ2VyQ29tcGlsZSB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGliLmlzRnVuY3Rpb24oZWFnZXJDb21waWxlKSkge1xuICAgICAgY2IgPSBlYWdlckNvbXBpbGU7XG4gICAgICBlYWdlckNvbXBpbGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICB0bXBsID0gbmFtZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW1wbGF0ZSBuYW1lcyBtdXN0IGJlIGEgc3RyaW5nOiAnICsgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbaV07XG4gICAgICAgIHRtcGwgPSBsb2FkZXIuY2FjaGVbdGhpcy5yZXNvbHZlVGVtcGxhdGUobG9hZGVyLCBwYXJlbnROYW1lLCBuYW1lKV07XG5cbiAgICAgICAgaWYgKHRtcGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0bXBsKSB7XG4gICAgICBpZiAoZWFnZXJDb21waWxlKSB7XG4gICAgICAgIHRtcGwuY29tcGlsZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IobnVsbCwgdG1wbCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG1wbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3luY1Jlc3VsdDtcblxuICAgIHZhciBjcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlKGVyciwgaW5mbykge1xuICAgICAgaWYgKCFpbmZvICYmICFlcnIgJiYgIWlnbm9yZU1pc3NpbmcpIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKCd0ZW1wbGF0ZSBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld1RtcGw7XG5cbiAgICAgIGlmICghaW5mbykge1xuICAgICAgICBuZXdUbXBsID0gbmV3IFRlbXBsYXRlKG5vb3BUbXBsU3JjLCBfdGhpczMsICcnLCBlYWdlckNvbXBpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VG1wbCA9IG5ldyBUZW1wbGF0ZShpbmZvLnNyYywgX3RoaXMzLCBpbmZvLnBhdGgsIGVhZ2VyQ29tcGlsZSk7XG5cbiAgICAgICAgaWYgKCFpbmZvLm5vQ2FjaGUpIHtcbiAgICAgICAgICBpbmZvLmxvYWRlci5jYWNoZVtuYW1lXSA9IG5ld1RtcGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKG51bGwsIG5ld1RtcGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3luY1Jlc3VsdCA9IG5ld1RtcGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYi5hc3luY0l0ZXIodGhpcy5sb2FkZXJzLCBmdW5jdGlvbiAobG9hZGVyLCBpLCBuZXh0LCBkb25lKSB7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUoZXJyLCBzcmMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgICBzcmMubG9hZGVyID0gbG9hZGVyO1xuICAgICAgICAgIGRvbmUobnVsbCwgc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVzb2x2ZSBuYW1lIHJlbGF0aXZlIHRvIHBhcmVudE5hbWVcblxuXG4gICAgICBuYW1lID0gdGhhdC5yZXNvbHZlVGVtcGxhdGUobG9hZGVyLCBwYXJlbnROYW1lLCBuYW1lKTtcblxuICAgICAgaWYgKGxvYWRlci5hc3luYykge1xuICAgICAgICBsb2FkZXIuZ2V0U291cmNlKG5hbWUsIGhhbmRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGUobnVsbCwgbG9hZGVyLmdldFNvdXJjZShuYW1lKSk7XG4gICAgICB9XG4gICAgfSwgY3JlYXRlVGVtcGxhdGUpO1xuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5leHByZXNzID0gZnVuY3Rpb24gZXhwcmVzcyhhcHApIHtcbiAgICByZXR1cm4gZXhwcmVzc0FwcCh0aGlzLCBhcHApO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIobmFtZSwgY3R4LCBjYikge1xuICAgIGlmIChsaWIuaXNGdW5jdGlvbihjdHgpKSB7XG4gICAgICBjYiA9IGN0eDtcbiAgICAgIGN0eCA9IG51bGw7XG4gICAgfSAvLyBXZSBzdXBwb3J0IGEgc3luY2hyb25vdXMgQVBJIHRvIG1ha2UgaXQgZWFzaWVyIHRvIG1pZ3JhdGVcbiAgICAvLyBleGlzdGluZyBjb2RlIHRvIGFzeW5jLiBUaGlzIHdvcmtzIGJlY2F1c2UgaWYgeW91IGRvbid0IGRvXG4gICAgLy8gYW55dGhpbmcgYXN5bmMgd29yaywgdGhlIHdob2xlIHRoaW5nIGlzIGFjdHVhbGx5IHJ1blxuICAgIC8vIHN5bmNocm9ub3VzbHkuXG5cblxuICAgIHZhciBzeW5jUmVzdWx0ID0gbnVsbDtcbiAgICB0aGlzLmdldFRlbXBsYXRlKG5hbWUsIGZ1bmN0aW9uIChlcnIsIHRtcGwpIHtcbiAgICAgIGlmIChlcnIgJiYgY2IpIHtcbiAgICAgICAgY2FsbGJhY2tBc2FwKGNiLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3luY1Jlc3VsdCA9IHRtcGwucmVuZGVyKGN0eCwgY2IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJTdHJpbmcgPSBmdW5jdGlvbiByZW5kZXJTdHJpbmcoc3JjLCBjdHgsIG9wdHMsIGNiKSB7XG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICBjYiA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHRtcGwgPSBuZXcgVGVtcGxhdGUoc3JjLCB0aGlzLCBvcHRzLnBhdGgpO1xuICAgIHJldHVybiB0bXBsLnJlbmRlcihjdHgsIGNiKTtcbiAgfTtcblxuICBfcHJvdG8ud2F0ZXJmYWxsID0gZnVuY3Rpb24gd2F0ZXJmYWxsKHRhc2tzLCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHJldHVybiBfd2F0ZXJmYWxsKHRhc2tzLCBjYWxsYmFjaywgZm9yY2VBc3luYyk7XG4gIH07XG5cbiAgcmV0dXJuIEVudmlyb25tZW50O1xufShFbWl0dGVyT2JqKTtcblxudmFyIENvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29udGV4dCwgX09iaik7XG5cbiAgZnVuY3Rpb24gQ29udGV4dCgpIHtcbiAgICByZXR1cm4gX09iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IENvbnRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuaW5pdCA9IGZ1bmN0aW9uIGluaXQoY3R4LCBibG9ja3MsIGVudikge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgLy8gSGFzIHRvIGJlIHRpZWQgdG8gYW4gZW52aXJvbm1lbnQgc28gd2UgY2FuIHRhcCBpbnRvIGl0cyBnbG9iYWxzLlxuICAgIHRoaXMuZW52ID0gZW52IHx8IG5ldyBFbnZpcm9ubWVudCgpOyAvLyBNYWtlIGEgZHVwbGljYXRlIG9mIGN0eFxuXG4gICAgdGhpcy5jdHggPSBsaWIuZXh0ZW5kKHt9LCBjdHgpO1xuICAgIHRoaXMuYmxvY2tzID0ge307XG4gICAgdGhpcy5leHBvcnRlZCA9IFtdO1xuICAgIGxpYi5rZXlzKGJsb2NrcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXM0LmFkZEJsb2NrKG5hbWUsIGJsb2Nrc1tuYW1lXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMi5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAobmFtZSkge1xuICAgIC8vIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IGNhbGxlZCBmdW5jdGlvbnMsIHNvIG9wdGltaXplIGZvclxuICAgIC8vIHRoZSB0eXBpY2FsIGNhc2Ugd2hlcmUgdGhlIG5hbWUgaXNuJ3QgaW4gdGhlIGdsb2JhbHNcbiAgICBpZiAobmFtZSBpbiB0aGlzLmVudi5nbG9iYWxzICYmICEobmFtZSBpbiB0aGlzLmN0eCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVudi5nbG9iYWxzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHhbbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIuc2V0VmFyaWFibGUgPSBmdW5jdGlvbiBzZXRWYXJpYWJsZShuYW1lLCB2YWwpIHtcbiAgICB0aGlzLmN0eFtuYW1lXSA9IHZhbDtcbiAgfTtcblxuICBfcHJvdG8yLmdldFZhcmlhYmxlcyA9IGZ1bmN0aW9uIGdldFZhcmlhYmxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRCbG9jayA9IGZ1bmN0aW9uIGFkZEJsb2NrKG5hbWUsIGJsb2NrKSB7XG4gICAgdGhpcy5ibG9ja3NbbmFtZV0gPSB0aGlzLmJsb2Nrc1tuYW1lXSB8fCBbXTtcbiAgICB0aGlzLmJsb2Nrc1tuYW1lXS5wdXNoKGJsb2NrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmdldEJsb2NrID0gZnVuY3Rpb24gZ2V0QmxvY2sobmFtZSkge1xuICAgIGlmICghdGhpcy5ibG9ja3NbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBibG9jayBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmxvY2tzW25hbWVdWzBdO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0U3VwZXIgPSBmdW5jdGlvbiBnZXRTdXBlcihlbnYsIG5hbWUsIGJsb2NrLCBmcmFtZSwgcnVudGltZSwgY2IpIHtcbiAgICB2YXIgaWR4ID0gbGliLmluZGV4T2YodGhpcy5ibG9ja3NbbmFtZV0gfHwgW10sIGJsb2NrKTtcbiAgICB2YXIgYmxrID0gdGhpcy5ibG9ja3NbbmFtZV1baWR4ICsgMV07XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEgfHwgIWJsaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzdXBlciBibG9jayBhdmFpbGFibGUgZm9yIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBibGsoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkRXhwb3J0ID0gZnVuY3Rpb24gYWRkRXhwb3J0KG5hbWUpIHtcbiAgICB0aGlzLmV4cG9ydGVkLnB1c2gobmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRFeHBvcnRlZCA9IGZ1bmN0aW9uIGdldEV4cG9ydGVkKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdmFyIGV4cG9ydGVkID0ge307XG4gICAgdGhpcy5leHBvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBleHBvcnRlZFtuYW1lXSA9IF90aGlzNS5jdHhbbmFtZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cG9ydGVkO1xuICB9O1xuXG4gIHJldHVybiBDb250ZXh0O1xufShPYmopO1xuXG52YXIgVGVtcGxhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmoyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRlbXBsYXRlLCBfT2JqMik7XG5cbiAgZnVuY3Rpb24gVGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIF9PYmoyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVGVtcGxhdGUucHJvdG90eXBlO1xuXG4gIF9wcm90bzMuaW5pdCA9IGZ1bmN0aW9uIGluaXQoc3JjLCBlbnYsIHBhdGgsIGVhZ2VyQ29tcGlsZSkge1xuICAgIHRoaXMuZW52ID0gZW52IHx8IG5ldyBFbnZpcm9ubWVudCgpO1xuXG4gICAgaWYgKGxpYi5pc09iamVjdChzcmMpKSB7XG4gICAgICBzd2l0Y2ggKHNyYy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgIHRoaXMudG1wbFByb3BzID0gc3JjLm9iajtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHRoaXMudG1wbFN0ciA9IHNyYy5vYmo7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRlbXBsYXRlIG9iamVjdCB0eXBlIFwiICsgc3JjLnR5cGUgKyBcIjsgZXhwZWN0ZWQgJ2NvZGUnLCBvciAnc3RyaW5nJ1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxpYi5pc1N0cmluZyhzcmMpKSB7XG4gICAgICB0aGlzLnRtcGxTdHIgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc3JjIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHNvdXJjZScpO1xuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG5cbiAgICBpZiAoZWFnZXJDb21waWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbGliLl9wcmV0dGlmeUVycm9yKHRoaXMucGF0aCwgdGhpcy5lbnYub3B0cy5kZXYsIGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY3R4LCBwYXJlbnRGcmFtZSwgY2IpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGN0eDtcbiAgICAgIGN0eCA9IHt9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmVudEZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHBhcmVudEZyYW1lO1xuICAgICAgcGFyZW50RnJhbWUgPSBudWxsO1xuICAgIH0gLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQgZnJhbWUsIHdlIGFyZSBiZWluZyBjYWxsZWQgZnJvbSBpbnRlcm5hbFxuICAgIC8vIGNvZGUgb2YgYW5vdGhlciB0ZW1wbGF0ZSwgYW5kIHRoZSBpbnRlcm5hbCBzeXN0ZW1cbiAgICAvLyBkZXBlbmRzIG9uIHRoZSBzeW5jL2FzeW5jIG5hdHVyZSBvZiB0aGUgcGFyZW50IHRlbXBsYXRlXG4gICAgLy8gdG8gYmUgaW5oZXJpdGVkLCBzbyBmb3JjZSBhbiBhc3luYyBjYWxsYmFja1xuXG5cbiAgICB2YXIgZm9yY2VBc3luYyA9ICFwYXJlbnRGcmFtZTsgLy8gQ2F0Y2ggY29tcGlsZSBlcnJvcnMgZm9yIGFzeW5jIHJlbmRlcmluZ1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBlcnIgPSBsaWIuX3ByZXR0aWZ5RXJyb3IodGhpcy5wYXRoLCB0aGlzLmVudi5vcHRzLmRldiwgZSk7XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tBc2FwKGNiLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoY3R4IHx8IHt9LCB0aGlzLmJsb2NrcywgdGhpcy5lbnYpO1xuICAgIHZhciBmcmFtZSA9IHBhcmVudEZyYW1lID8gcGFyZW50RnJhbWUucHVzaCh0cnVlKSA6IG5ldyBGcmFtZSgpO1xuICAgIGZyYW1lLnRvcExldmVsID0gdHJ1ZTtcbiAgICB2YXIgc3luY1Jlc3VsdCA9IG51bGw7XG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdGhpcy5yb290UmVuZGVyRnVuYyh0aGlzLmVudiwgY29udGV4dCwgZnJhbWUsIGdsb2JhbFJ1bnRpbWUsIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBhY3R1YWxseSBhIGJ1ZyBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUgKGJlY2F1c2Ugd2F0ZXJmYWxsXG4gICAgICAvLyB0YXNrcyBhcmUgYm90aCBub3QgcGFzc2luZyBlcnJvcnMgdXAgdGhlIGNoYWluIG9mIGNhbGxiYWNrcyBBTkQgYXJlIG5vdFxuICAgICAgLy8gY2F1c2luZyBhIHJldHVybiBmcm9tIHRoZSB0b3AtbW9zdCByZW5kZXIgZnVuY3Rpb24pLiBCdXQgZml4aW5nIHRoYXRcbiAgICAgIC8vIHdpbGwgcmVxdWlyZSBhIG1vcmUgc3Vic3RhbnRpYWwgY2hhbmdlIHRvIHRoZSBjb21waWxlci5cbiAgICAgIGlmIChkaWRFcnJvciAmJiBjYiAmJiB0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBwcmV2ZW50IG11bHRpcGxlIGNhbGxzIHRvIGNiXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIgPSBsaWIuX3ByZXR0aWZ5RXJyb3IoX3RoaXM2LnBhdGgsIF90aGlzNi5lbnYub3B0cy5kZXYsIGVycik7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGlmIChmb3JjZUFzeW5jKSB7XG4gICAgICAgICAgY2FsbGJhY2tBc2FwKGNiLCBlcnIsIHJlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IoZXJyLCByZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgc3luY1Jlc3VsdCA9IHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8zLmdldEV4cG9ydGVkID0gZnVuY3Rpb24gZ2V0RXhwb3J0ZWQoY3R4LCBwYXJlbnRGcmFtZSwgY2IpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgaWYgKHR5cGVvZiBjdHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gY3R4O1xuICAgICAgY3R4ID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJlbnRGcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBwYXJlbnRGcmFtZTtcbiAgICAgIHBhcmVudEZyYW1lID0gbnVsbDtcbiAgICB9IC8vIENhdGNoIGNvbXBpbGUgZXJyb3JzIGZvciBhc3luYyByZW5kZXJpbmdcblxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcmFtZSA9IHBhcmVudEZyYW1lID8gcGFyZW50RnJhbWUucHVzaCgpIDogbmV3IEZyYW1lKCk7XG4gICAgZnJhbWUudG9wTGV2ZWwgPSB0cnVlOyAvLyBSdW4gdGhlIHJvb3RSZW5kZXJGdW5jIHRvIHBvcHVsYXRlIHRoZSBjb250ZXh0IHdpdGggZXhwb3J0ZWQgdmFyc1xuXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChjdHggfHwge30sIHRoaXMuYmxvY2tzLCB0aGlzLmVudik7XG4gICAgdGhpcy5yb290UmVuZGVyRnVuYyh0aGlzLmVudiwgY29udGV4dCwgZnJhbWUsIGdsb2JhbFJ1bnRpbWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG51bGwsIGNvbnRleHQuZ2V0RXhwb3J0ZWQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuY29tcGlsZWQpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMy5fY29tcGlsZSA9IGZ1bmN0aW9uIF9jb21waWxlKCkge1xuICAgIHZhciBwcm9wcztcblxuICAgIGlmICh0aGlzLnRtcGxQcm9wcykge1xuICAgICAgcHJvcHMgPSB0aGlzLnRtcGxQcm9wcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNvdXJjZSA9IGNvbXBpbGVyLmNvbXBpbGUodGhpcy50bXBsU3RyLCB0aGlzLmVudi5hc3luY0ZpbHRlcnMsIHRoaXMuZW52LmV4dGVuc2lvbnNMaXN0LCB0aGlzLnBhdGgsIHRoaXMuZW52Lm9wdHMpO1xuICAgICAgdmFyIGZ1bmMgPSBuZXcgRnVuY3Rpb24oc291cmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuXG4gICAgICBwcm9wcyA9IGZ1bmMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrcyA9IHRoaXMuX2dldEJsb2Nrcyhwcm9wcyk7XG4gICAgdGhpcy5yb290UmVuZGVyRnVuYyA9IHByb3BzLnJvb3Q7XG4gICAgdGhpcy5jb21waWxlZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvMy5fZ2V0QmxvY2tzID0gZnVuY3Rpb24gX2dldEJsb2Nrcyhwcm9wcykge1xuICAgIHZhciBibG9ja3MgPSB7fTtcbiAgICBsaWIua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsuc2xpY2UoMCwgMikgPT09ICdiXycpIHtcbiAgICAgICAgYmxvY2tzW2suc2xpY2UoMildID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfTtcblxuICByZXR1cm4gVGVtcGxhdGU7XG59KE9iaik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFbnZpcm9ubWVudDogRW52aXJvbm1lbnQsXG4gIFRlbXBsYXRlOiBUZW1wbGF0ZVxufTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgbGV4ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgbm9kZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgT2JqID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKS5PYmo7XG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgUGFyc2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBhcnNlciwgX09iaik7XG5cbiAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIHJldHVybiBfT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh0b2tlbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB0aGlzLnBlZWtlZCA9IG51bGw7XG4gICAgdGhpcy5icmVha09uQmxvY2tzID0gbnVsbDtcbiAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IFtdO1xuICB9O1xuXG4gIF9wcm90by5uZXh0VG9rZW4gPSBmdW5jdGlvbiBuZXh0VG9rZW4od2l0aFdoaXRlc3BhY2UpIHtcbiAgICB2YXIgdG9rO1xuXG4gICAgaWYgKHRoaXMucGVla2VkKSB7XG4gICAgICBpZiAoIXdpdGhXaGl0ZXNwYWNlICYmIHRoaXMucGVla2VkLnR5cGUgPT09IGxleGVyLlRPS0VOX1dISVRFU1BBQ0UpIHtcbiAgICAgICAgdGhpcy5wZWVrZWQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rID0gdGhpcy5wZWVrZWQ7XG4gICAgICAgIHRoaXMucGVla2VkID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b2sgPSB0aGlzLnRva2Vucy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICghd2l0aFdoaXRlc3BhY2UpIHtcbiAgICAgIHdoaWxlICh0b2sgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1dISVRFU1BBQ0UpIHtcbiAgICAgICAgdG9rID0gdGhpcy50b2tlbnMubmV4dFRva2VuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvaztcbiAgfTtcblxuICBfcHJvdG8ucGVla1Rva2VuID0gZnVuY3Rpb24gcGVla1Rva2VuKCkge1xuICAgIHRoaXMucGVla2VkID0gdGhpcy5wZWVrZWQgfHwgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wZWVrZWQ7XG4gIH07XG5cbiAgX3Byb3RvLnB1c2hUb2tlbiA9IGZ1bmN0aW9uIHB1c2hUb2tlbih0b2spIHtcbiAgICBpZiAodGhpcy5wZWVrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHVzaFRva2VuOiBjYW4gb25seSBwdXNoIG9uZSB0b2tlbiBvbiBiZXR3ZWVuIHJlYWRzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wZWVrZWQgPSB0b2s7XG4gIH07XG5cbiAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnLCBsaW5lbm8sIGNvbG5vKSB7XG4gICAgaWYgKGxpbmVubyA9PT0gdW5kZWZpbmVkIHx8IGNvbG5vID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpIHx8IHt9O1xuICAgICAgbGluZW5vID0gdG9rLmxpbmVubztcbiAgICAgIGNvbG5vID0gdG9rLmNvbG5vO1xuICAgIH1cblxuICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGluZW5vICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbG5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbG5vICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBsaWIuVGVtcGxhdGVFcnJvcihtc2csIGxpbmVubywgY29sbm8pO1xuICB9O1xuXG4gIF9wcm90by5mYWlsID0gZnVuY3Rpb24gZmFpbChtc2csIGxpbmVubywgY29sbm8pIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKG1zZywgbGluZW5vLCBjb2xubyk7XG4gIH07XG5cbiAgX3Byb3RvLnNraXAgPSBmdW5jdGlvbiBza2lwKHR5cGUpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICghdG9rIHx8IHRvay50eXBlICE9PSB0eXBlKSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5leHBlY3QgPSBmdW5jdGlvbiBleHBlY3QodHlwZSkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKHRvay50eXBlICE9PSB0eXBlKSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyB0b2sudHlwZSwgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rO1xuICB9O1xuXG4gIF9wcm90by5za2lwVmFsdWUgPSBmdW5jdGlvbiBza2lwVmFsdWUodHlwZSwgdmFsKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAoIXRvayB8fCB0b2sudHlwZSAhPT0gdHlwZSB8fCB0b2sudmFsdWUgIT09IHZhbCkge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uc2tpcFN5bWJvbCA9IGZ1bmN0aW9uIHNraXBTeW1ib2wodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX1NZTUJPTCwgdmFsKTtcbiAgfTtcblxuICBfcHJvdG8uYWR2YW5jZUFmdGVyQmxvY2tFbmQgPSBmdW5jdGlvbiBhZHZhbmNlQWZ0ZXJCbG9ja0VuZChuYW1lKSB7XG4gICAgdmFyIHRvaztcblxuICAgIGlmICghbmFtZSkge1xuICAgICAgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgICAgaWYgKCF0b2spIHtcbiAgICAgICAgdGhpcy5mYWlsKCd1bmV4cGVjdGVkIGVuZCBvZiBmaWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fU1lNQk9MKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnYWR2YW5jZUFmdGVyQmxvY2tFbmQ6IGV4cGVjdGVkIHN5bWJvbCB0b2tlbiBvciAnICsgJ2V4cGxpY2l0IG5hbWUgdG8gYmUgcGFzc2VkJyk7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSB0aGlzLm5leHRUb2tlbigpLnZhbHVlO1xuICAgIH1cblxuICAgIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAodG9rICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19FTkQpIHtcbiAgICAgIGlmICh0b2sudmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIGJsb2NrIGVuZCBpbiAnICsgbmFtZSArICcgc3RhdGVtZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvaztcbiAgfTtcblxuICBfcHJvdG8uYWR2YW5jZUFmdGVyVmFyaWFibGVFbmQgPSBmdW5jdGlvbiBhZHZhbmNlQWZ0ZXJWYXJpYWJsZUVuZCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICh0b2sgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1ZBUklBQkxFX0VORCkge1xuICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSB0b2sudmFsdWUuY2hhckF0KHRvay52YWx1ZS5sZW5ndGggLSB0aGlzLnRva2Vucy50YWdzLlZBUklBQkxFX0VORC5sZW5ndGggLSAxKSA9PT0gJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCB2YXJpYWJsZSBlbmQnKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRm9yID0gZnVuY3Rpb24gcGFyc2VGb3IoKSB7XG4gICAgdmFyIGZvclRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIGVuZEJsb2NrO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnZm9yJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRm9yKGZvclRvay5saW5lbm8sIGZvclRvay5jb2xubyk7XG4gICAgICBlbmRCbG9jayA9ICdlbmRmb3InO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwU3ltYm9sKCdhc3luY0VhY2gnKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Bc3luY0VhY2goZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICAgIGVuZEJsb2NrID0gJ2VuZGVhY2gnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwU3ltYm9sKCdhc3luY0FsbCcpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkFzeW5jQWxsKGZvclRvay5saW5lbm8sIGZvclRvay5jb2xubyk7XG4gICAgICBlbmRCbG9jayA9ICdlbmRhbGwnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRm9yOiBleHBlY3RlZCBmb3J7QXN5bmN9JywgZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBub2RlLm5hbWUgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuXG4gICAgaWYgKCEobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuU3ltYm9sKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZvcjogdmFyaWFibGUgbmFtZSBleHBlY3RlZCBmb3IgbG9vcCcpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gdGhpcy5wZWVrVG9rZW4oKS50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IGxleGVyLlRPS0VOX0NPTU1BKSB7XG4gICAgICAvLyBrZXkvdmFsdWUgaXRlcmF0aW9uXG4gICAgICB2YXIga2V5ID0gbm9kZS5uYW1lO1xuICAgICAgbm9kZS5uYW1lID0gbmV3IG5vZGVzLkFycmF5KGtleS5saW5lbm8sIGtleS5jb2xubyk7XG4gICAgICBub2RlLm5hbWUuYWRkQ2hpbGQoa2V5KTtcblxuICAgICAgd2hpbGUgKHRoaXMuc2tpcChsZXhlci5UT0tFTl9DT01NQSkpIHtcbiAgICAgICAgdmFyIHByaW0gPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICBub2RlLm5hbWUuYWRkQ2hpbGQocHJpbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2luJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGb3I6IGV4cGVjdGVkIFwiaW5cIiBrZXl3b3JkIGZvciBsb29wJywgZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBub2RlLmFyciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChmb3JUb2sudmFsdWUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcyhlbmRCbG9jaywgJ2Vsc2UnKTtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2Vsc2UnKSkge1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgnZWxzZScpO1xuICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcyhlbmRCbG9jayk7XG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU1hY3JvID0gZnVuY3Rpb24gcGFyc2VNYWNybygpIHtcbiAgICB2YXIgbWFjcm9Ub2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ21hY3JvJykpIHtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgbWFjcm8nKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KHRydWUpO1xuICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZVNpZ25hdHVyZSgpO1xuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLk1hY3JvKG1hY3JvVG9rLmxpbmVubywgbWFjcm9Ub2suY29sbm8sIG5hbWUsIGFyZ3MpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQobWFjcm9Ub2sudmFsdWUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kbWFjcm8nKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQ2FsbCA9IGZ1bmN0aW9uIHBhcnNlQ2FsbCgpIHtcbiAgICAvLyBhIGNhbGwgYmxvY2sgaXMgcGFyc2VkIGFzIGEgbm9ybWFsIEZ1bkNhbGwsIGJ1dCB3aXRoIGFuIGFkZGVkXG4gICAgLy8gJ2NhbGxlcicga3dhcmcgd2hpY2ggaXMgYSBDYWxsZXIgbm9kZS5cbiAgICB2YXIgY2FsbFRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnY2FsbCcpKSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIGNhbGwnKTtcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVyQXJncyA9IHRoaXMucGFyc2VTaWduYXR1cmUodHJ1ZSkgfHwgbmV3IG5vZGVzLk5vZGVMaXN0KCk7XG4gICAgdmFyIG1hY3JvQ2FsbCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChjYWxsVG9rLnZhbHVlKTtcbiAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kY2FsbCcpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICB2YXIgY2FsbGVyTmFtZSA9IG5ldyBub2Rlcy5TeW1ib2woY2FsbFRvay5saW5lbm8sIGNhbGxUb2suY29sbm8sICdjYWxsZXInKTtcbiAgICB2YXIgY2FsbGVyTm9kZSA9IG5ldyBub2Rlcy5DYWxsZXIoY2FsbFRvay5saW5lbm8sIGNhbGxUb2suY29sbm8sIGNhbGxlck5hbWUsIGNhbGxlckFyZ3MsIGJvZHkpOyAvLyBhZGQgdGhlIGFkZGl0aW9uYWwgY2FsbGVyIGt3YXJnLCBhZGRpbmcga3dhcmdzIGlmIG5lY2Vzc2FyeVxuXG4gICAgdmFyIGFyZ3MgPSBtYWNyb0NhbGwuYXJncy5jaGlsZHJlbjtcblxuICAgIGlmICghKGFyZ3NbYXJncy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIG5vZGVzLktleXdvcmRBcmdzKSkge1xuICAgICAgYXJncy5wdXNoKG5ldyBub2Rlcy5LZXl3b3JkQXJncygpKTtcbiAgICB9XG5cbiAgICB2YXIga3dhcmdzID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGt3YXJncy5hZGRDaGlsZChuZXcgbm9kZXMuUGFpcihjYWxsVG9rLmxpbmVubywgY2FsbFRvay5jb2xubywgY2FsbGVyTmFtZSwgY2FsbGVyTm9kZSkpO1xuICAgIHJldHVybiBuZXcgbm9kZXMuT3V0cHV0KGNhbGxUb2subGluZW5vLCBjYWxsVG9rLmNvbG5vLCBbbWFjcm9DYWxsXSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlV2l0aENvbnRleHQgPSBmdW5jdGlvbiBwYXJzZVdpdGhDb250ZXh0KCkge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIHZhciB3aXRoQ29udGV4dCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCd3aXRoJykpIHtcbiAgICAgIHdpdGhDb250ZXh0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFN5bWJvbCgnd2l0aG91dCcpKSB7XG4gICAgICB3aXRoQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh3aXRoQ29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2NvbnRleHQnKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgY29udGV4dCBhZnRlciB3aXRoL3dpdGhvdXQnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3aXRoQ29udGV4dDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJbXBvcnQgPSBmdW5jdGlvbiBwYXJzZUltcG9ydCgpIHtcbiAgICB2YXIgaW1wb3J0VG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdpbXBvcnQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUltcG9ydDogZXhwZWN0ZWQgaW1wb3J0JywgaW1wb3J0VG9rLmxpbmVubywgaW1wb3J0VG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2FzJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VJbXBvcnQ6IGV4cGVjdGVkIFwiYXNcIiBrZXl3b3JkJywgaW1wb3J0VG9rLmxpbmVubywgaW1wb3J0VG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB2YXIgd2l0aENvbnRleHQgPSB0aGlzLnBhcnNlV2l0aENvbnRleHQoKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5JbXBvcnQoaW1wb3J0VG9rLmxpbmVubywgaW1wb3J0VG9rLmNvbG5vLCB0ZW1wbGF0ZSwgdGFyZ2V0LCB3aXRoQ29udGV4dCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChpbXBvcnRUb2sudmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUZyb20gPSBmdW5jdGlvbiBwYXJzZUZyb20oKSB7XG4gICAgdmFyIGZyb21Ub2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2Zyb20nKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IGV4cGVjdGVkIGZyb20nKTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2ltcG9ydCcpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgaW1wb3J0JywgZnJvbVRvay5saW5lbm8sIGZyb21Ub2suY29sbm8pO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5ldyBub2Rlcy5Ob2RlTGlzdCgpO1xuICAgIHZhciB3aXRoQ29udGV4dDtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgdmFyIG5leHRUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgICBpZiAobmV4dFRvay50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19FTkQpIHtcbiAgICAgICAgaWYgKCFuYW1lcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGltcG9ydCBuYW1lJywgZnJvbVRvay5saW5lbm8sIGZyb21Ub2suY29sbm8pO1xuICAgICAgICB9IC8vIFNpbmNlIHdlIGFyZSBtYW51YWxseSBhZHZhbmNpbmcgcGFzdCB0aGUgYmxvY2sgZW5kLFxuICAgICAgICAvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpdGVzcGFjZSBjb250cm9sIChub3JtYWxseVxuICAgICAgICAvLyB0aGlzIGlzIGRvbmUgaW4gYGFkdmFuY2VBZnRlckJsb2NrRW5kYFxuXG5cbiAgICAgICAgaWYgKG5leHRUb2sudmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWVzLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIXRoaXMuc2tpcChsZXhlci5UT0tFTl9DT01NQSkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IGV4cGVjdGVkIGNvbW1hJywgZnJvbVRvay5saW5lbm8sIGZyb21Ub2suY29sbm8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG5cbiAgICAgIGlmIChuYW1lLnZhbHVlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBuYW1lcyBzdGFydGluZyB3aXRoIGFuIHVuZGVyc2NvcmUgY2Fubm90IGJlIGltcG9ydGVkJywgbmFtZS5saW5lbm8sIG5hbWUuY29sbm8pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdhcycpKSB7XG4gICAgICAgIHZhciBhbGlhcyA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIG5hbWVzLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBuYW1lLCBhbGlhcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXMuYWRkQ2hpbGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdpdGhDb250ZXh0ID0gdGhpcy5wYXJzZVdpdGhDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Gcm9tSW1wb3J0KGZyb21Ub2subGluZW5vLCBmcm9tVG9rLmNvbG5vLCB0ZW1wbGF0ZSwgbmFtZXMsIHdpdGhDb250ZXh0KTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VCbG9jayA9IGZ1bmN0aW9uIHBhcnNlQmxvY2soKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnYmxvY2snKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUJsb2NrOiBleHBlY3RlZCBibG9jaycsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuQmxvY2sodGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuXG4gICAgaWYgKCEobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuU3ltYm9sKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUJsb2NrOiB2YXJpYWJsZSBuYW1lIGV4cGVjdGVkJywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRibG9jaycpO1xuICAgIHRoaXMuc2tpcFN5bWJvbCgnZW5kYmxvY2snKTtcbiAgICB0aGlzLnNraXBTeW1ib2wobm9kZS5uYW1lLnZhbHVlKTtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdG9rKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlQmxvY2s6IGV4cGVjdGVkIGVuZGJsb2NrLCBnb3QgZW5kIG9mIGZpbGUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRvay52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRXh0ZW5kcyA9IGZ1bmN0aW9uIHBhcnNlRXh0ZW5kcygpIHtcbiAgICB2YXIgdGFnTmFtZSA9ICdleHRlbmRzJztcbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKHRhZ05hbWUpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlVGVtcGxhdGVSZWY6IGV4cGVjdGVkICcgKyB0YWdOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5FeHRlbmRzKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgbm9kZS50ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0YWcudmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUluY2x1ZGUgPSBmdW5jdGlvbiBwYXJzZUluY2x1ZGUoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSAnaW5jbHVkZSc7XG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCh0YWdOYW1lKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUluY2x1ZGU6IGV4cGVjdGVkICcgKyB0YWdOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5JbmNsdWRlKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgbm9kZS50ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpZ25vcmUnKSAmJiB0aGlzLnNraXBTeW1ib2woJ21pc3NpbmcnKSkge1xuICAgICAgbm9kZS5pZ25vcmVNaXNzaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSWYgPSBmdW5jdGlvbiBwYXJzZUlmKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaWYnKSB8fCB0aGlzLnNraXBTeW1ib2woJ2VsaWYnKSB8fCB0aGlzLnNraXBTeW1ib2woJ2Vsc2VpZicpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLklmKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ2lmQXN5bmMnKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5JZkFzeW5jKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VJZjogZXhwZWN0ZWQgaWYsIGVsaWYsIG9yIGVsc2VpZicsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfVxuXG4gICAgbm9kZS5jb25kID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbGlmJywgJ2Vsc2VpZicsICdlbHNlJywgJ2VuZGlmJyk7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBzd2l0Y2ggKHRvayAmJiB0b2sudmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Vsc2VpZic6XG4gICAgICBjYXNlICdlbGlmJzpcbiAgICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VJZigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZWxzZSc6XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kaWYnKTtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZW5kaWYnOlxuICAgICAgICBub2RlLmVsc2VfID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUlmOiBleHBlY3RlZCBlbGlmLCBlbHNlLCBvciBlbmRpZiwgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlU2V0ID0gZnVuY3Rpb24gcGFyc2VTZXQoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnc2V0JykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VTZXQ6IGV4cGVjdGVkIHNldCcsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuU2V0KHRhZy5saW5lbm8sIHRhZy5jb2xubywgW10pO1xuICAgIHZhciB0YXJnZXQ7XG5cbiAgICB3aGlsZSAodGFyZ2V0ID0gdGhpcy5wYXJzZVByaW1hcnkoKSkge1xuICAgICAgbm9kZS50YXJnZXRzLnB1c2godGFyZ2V0KTtcblxuICAgICAgaWYgKCF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICc9JykpIHtcbiAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0JMT0NLX0VORCkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZVNldDogZXhwZWN0ZWQgPSBvciBibG9jayBlbmQgaW4gc2V0IHRhZycsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmJvZHkgPSBuZXcgbm9kZXMuQ2FwdHVyZSh0YWcubGluZW5vLCB0YWcuY29sbm8sIHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kc2V0JykpO1xuICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTd2l0Y2ggPSBmdW5jdGlvbiBwYXJzZVN3aXRjaCgpIHtcbiAgICAvKlxuICAgICAqIFN0b3JlIHRoZSB0YWcgbmFtZXMgaW4gdmFyaWFibGVzIGluIGNhc2Ugc29tZW9uZSBldmVyIHdhbnRzIHRvXG4gICAgICogY3VzdG9taXplIHRoaXMuXG4gICAgICovXG4gICAgdmFyIHN3aXRjaFN0YXJ0ID0gJ3N3aXRjaCc7XG4gICAgdmFyIHN3aXRjaEVuZCA9ICdlbmRzd2l0Y2gnO1xuICAgIHZhciBjYXNlU3RhcnQgPSAnY2FzZSc7XG4gICAgdmFyIGNhc2VEZWZhdWx0ID0gJ2RlZmF1bHQnOyAvLyBHZXQgdGhlIHN3aXRjaCB0YWcuXG5cbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTsgLy8gZmFpbCBlYXJseSBpZiB3ZSBnZXQgc29tZSB1bmV4cGVjdGVkIHRhZy5cblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKHN3aXRjaFN0YXJ0KSAmJiAhdGhpcy5za2lwU3ltYm9sKGNhc2VTdGFydCkgJiYgIXRoaXMuc2tpcFN5bWJvbChjYXNlRGVmYXVsdCkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VTd2l0Y2g6IGV4cGVjdGVkIFwic3dpdGNoLFwiIFwiY2FzZVwiIG9yIFwiZGVmYXVsdFwiJywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9IC8vIHBhcnNlIHRoZSBzd2l0Y2ggZXhwcmVzc2lvblxuXG5cbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IC8vIGFkdmFuY2UgdW50aWwgYSBzdGFydCBvZiBhIGNhc2UsIGEgZGVmYXVsdCBjYXNlIG9yIGFuIGVuZHN3aXRjaC5cblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoc3dpdGNoU3RhcnQpO1xuICAgIHRoaXMucGFyc2VVbnRpbEJsb2NrcyhjYXNlU3RhcnQsIGNhc2VEZWZhdWx0LCBzd2l0Y2hFbmQpOyAvLyB0aGlzIGlzIHRoZSBmaXJzdCBjYXNlLiBpdCBjb3VsZCBhbHNvIGJlIGFuIGVuZHN3aXRjaCwgd2UnbGwgY2hlY2suXG5cbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTsgLy8gY3JlYXRlIG5ldyB2YXJpYWJsZXMgZm9yIG91ciBjYXNlcyBhbmQgZGVmYXVsdCBjYXNlLlxuXG4gICAgdmFyIGNhc2VzID0gW107XG4gICAgdmFyIGRlZmF1bHRDYXNlOyAvLyB3aGlsZSB3ZSdyZSBkZWFsaW5nIHdpdGggbmV3IGNhc2VzIG5vZGVzLi4uXG5cbiAgICBkbyB7XG4gICAgICAvLyBza2lwIHRoZSBzdGFydCBzeW1ib2wgYW5kIGdldCB0aGUgY2FzZSBleHByZXNzaW9uXG4gICAgICB0aGlzLnNraXBTeW1ib2woY2FzZVN0YXJ0KTtcbiAgICAgIHZhciBjb25kID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoc3dpdGNoU3RhcnQpOyAvLyBnZXQgdGhlIGJvZHkgb2YgdGhlIGNhc2Ugbm9kZSBhbmQgYWRkIGl0IHRvIHRoZSBhcnJheSBvZiBjYXNlcy5cblxuICAgICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoY2FzZVN0YXJ0LCBjYXNlRGVmYXVsdCwgc3dpdGNoRW5kKTtcbiAgICAgIGNhc2VzLnB1c2gobmV3IG5vZGVzLkNhc2UodG9rLmxpbmUsIHRvay5jb2wsIGNvbmQsIGJvZHkpKTsgLy8gZ2V0IG91ciBuZXh0IGNhc2VcblxuICAgICAgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB9IHdoaWxlICh0b2sgJiYgdG9rLnZhbHVlID09PSBjYXNlU3RhcnQpOyAvLyB3ZSBlaXRoZXIgaGF2ZSBhIGRlZmF1bHQgY2FzZSBvciBhIHN3aXRjaCBlbmQuXG5cblxuICAgIHN3aXRjaCAodG9rLnZhbHVlKSB7XG4gICAgICBjYXNlIGNhc2VEZWZhdWx0OlxuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGRlZmF1bHRDYXNlID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKHN3aXRjaEVuZCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2Ugc3dpdGNoRW5kOlxuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBvdGhlcndpc2UgYmFpbCBiZWNhdXNlIEVPRlxuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU3dpdGNoOiBleHBlY3RlZCBcImNhc2UsXCIgXCJkZWZhdWx0XCIgb3IgXCJlbmRzd2l0Y2gsXCIgZ290IEVPRi4nKTtcbiAgICB9IC8vIGFuZCByZXR1cm4gdGhlIHN3aXRjaCBub2RlLlxuXG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLlN3aXRjaCh0YWcubGluZW5vLCB0YWcuY29sbm8sIGV4cHIsIGNhc2VzLCBkZWZhdWx0Q2FzZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAodG9rLnR5cGUgIT09IGxleGVyLlRPS0VOX1NZTUJPTCkge1xuICAgICAgdGhpcy5mYWlsKCd0YWcgbmFtZSBleHBlY3RlZCcsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnJlYWtPbkJsb2NrcyAmJiBsaWIuaW5kZXhPZih0aGlzLmJyZWFrT25CbG9ja3MsIHRvay52YWx1ZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYXcoKTtcblxuICAgICAgY2FzZSAndmVyYmF0aW0nOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJhdygndmVyYmF0aW0nKTtcblxuICAgICAgY2FzZSAnaWYnOlxuICAgICAgY2FzZSAnaWZBc3luYyc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWYoKTtcblxuICAgICAgY2FzZSAnZm9yJzpcbiAgICAgIGNhc2UgJ2FzeW5jRWFjaCc6XG4gICAgICBjYXNlICdhc3luY0FsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKCk7XG5cbiAgICAgIGNhc2UgJ2Jsb2NrJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xuXG4gICAgICBjYXNlICdleHRlbmRzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHRlbmRzKCk7XG5cbiAgICAgIGNhc2UgJ2luY2x1ZGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUluY2x1ZGUoKTtcblxuICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTZXQoKTtcblxuICAgICAgY2FzZSAnbWFjcm8nOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1hY3JvKCk7XG5cbiAgICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGwoKTtcblxuICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnQoKTtcblxuICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnJvbSgpO1xuXG4gICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZpbHRlclN0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaCgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5leHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXh0ID0gdGhpcy5leHRlbnNpb25zW2ldO1xuXG4gICAgICAgICAgICBpZiAobGliLmluZGV4T2YoZXh0LnRhZ3MgfHwgW10sIHRvay52YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHQucGFyc2UodGhpcywgbm9kZXMsIGxleGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZhaWwoJ3Vua25vd24gYmxvY2sgdGFnOiAnICsgdG9rLnZhbHVlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVJhdyA9IGZ1bmN0aW9uIHBhcnNlUmF3KHRhZ05hbWUpIHtcbiAgICB0YWdOYW1lID0gdGFnTmFtZSB8fCAncmF3JztcbiAgICB2YXIgZW5kVGFnTmFtZSA9ICdlbmQnICsgdGFnTmFtZTsgLy8gTG9vayBmb3IgdXBjb21pbmcgcmF3IGJsb2NrcyAoaWdub3JlIGFsbCBvdGhlciBraW5kcyBvZiBibG9ja3MpXG5cbiAgICB2YXIgcmF3QmxvY2tSZWdleCA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPyl7JVxcXFxzKignICsgdGFnTmFtZSArICd8JyArIGVuZFRhZ05hbWUgKyAnKVxcXFxzKig/PSV9KSV9Jyk7XG4gICAgdmFyIHJhd0xldmVsID0gMTtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIG1hdGNoZXMgPSBudWxsOyAvLyBTa2lwIG9wZW5pbmcgcmF3IHRva2VuXG4gICAgLy8gS2VlcCB0aGlzIHRva2VuIHRvIHRyYWNrIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzXG5cbiAgICB2YXIgYmVndW4gPSB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7IC8vIEV4aXQgd2hlbiB0aGVyZSdzIG5vdGhpbmcgdG8gbWF0Y2hcbiAgICAvLyBvciB3aGVuIHdlJ3ZlIGZvdW5kIHRoZSBtYXRjaGluZyBcImVuZHJhd1wiIGJsb2NrXG5cbiAgICB3aGlsZSAoKG1hdGNoZXMgPSB0aGlzLnRva2Vucy5fZXh0cmFjdFJlZ2V4KHJhd0Jsb2NrUmVnZXgpKSAmJiByYXdMZXZlbCA+IDApIHtcbiAgICAgIHZhciBhbGwgPSBtYXRjaGVzWzBdO1xuICAgICAgdmFyIHByZSA9IG1hdGNoZXNbMV07XG4gICAgICB2YXIgYmxvY2tOYW1lID0gbWF0Y2hlc1syXTsgLy8gQWRqdXN0IHJhd2xldmVsXG5cbiAgICAgIGlmIChibG9ja05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcmF3TGV2ZWwgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYmxvY2tOYW1lID09PSBlbmRUYWdOYW1lKSB7XG4gICAgICAgIHJhd0xldmVsIC09IDE7XG4gICAgICB9IC8vIEFkZCB0byBzdHJcblxuXG4gICAgICBpZiAocmF3TGV2ZWwgPT09IDApIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBleGNsdWRlIHRoZSBsYXN0IFwiZW5kcmF3XCJcbiAgICAgICAgc3RyICs9IHByZTsgLy8gTW92ZSB0b2tlbml6ZXIgdG8gYmVnaW5uaW5nIG9mIGVuZHJhdyBibG9ja1xuXG4gICAgICAgIHRoaXMudG9rZW5zLmJhY2tOKGFsbC5sZW5ndGggLSBwcmUubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBhbGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5PdXRwdXQoYmVndW4ubGluZW5vLCBiZWd1bi5jb2xubywgW25ldyBub2Rlcy5UZW1wbGF0ZURhdGEoYmVndW4ubGluZW5vLCBiZWd1bi5jb2xubywgc3RyKV0pO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVBvc3RmaXggPSBmdW5jdGlvbiBwYXJzZVBvc3RmaXgobm9kZSkge1xuICAgIHZhciBsb29rdXA7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICB3aGlsZSAodG9rKSB7XG4gICAgICBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0xFRlRfUEFSRU4pIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gY2FsbFxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkZ1bkNhbGwodG9rLmxpbmVubywgdG9rLmNvbG5vLCBub2RlLCB0aGlzLnBhcnNlU2lnbmF0dXJlKCkpO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUKSB7XG4gICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICBsb29rdXAgPSB0aGlzLnBhcnNlQWdncmVnYXRlKCk7XG5cbiAgICAgICAgaWYgKGxvb2t1cC5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5mYWlsKCdpbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkxvb2t1cFZhbCh0b2subGluZW5vLCB0b2suY29sbm8sIG5vZGUsIGxvb2t1cC5jaGlsZHJlblswXSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9PUEVSQVRPUiAmJiB0b2sudmFsdWUgPT09ICcuJykge1xuICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICAgICAgaWYgKHZhbC50eXBlICE9PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIG5hbWUgYXMgbG9va3VwIHZhbHVlLCBnb3QgJyArIHZhbC52YWx1ZSwgdmFsLmxpbmVubywgdmFsLmNvbG5vKTtcbiAgICAgICAgfSAvLyBNYWtlIGEgbGl0ZXJhbCBzdHJpbmcgYmVjYXVzZSBpdCdzIG5vdCBhIHZhcmlhYmxlXG4gICAgICAgIC8vIHJlZmVyZW5jZVxuXG5cbiAgICAgICAgbG9va3VwID0gbmV3IG5vZGVzLkxpdGVyYWwodmFsLmxpbmVubywgdmFsLmNvbG5vLCB2YWwudmFsdWUpO1xuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkxvb2t1cFZhbCh0b2subGluZW5vLCB0b2suY29sbm8sIG5vZGUsIGxvb2t1cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUlubGluZUlmKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSW5saW5lSWYgPSBmdW5jdGlvbiBwYXJzZUlubGluZUlmKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZU9yKCk7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpZicpKSB7XG4gICAgICB2YXIgY29uZE5vZGUgPSB0aGlzLnBhcnNlT3IoKTtcbiAgICAgIHZhciBib2R5Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLklubGluZUlmKG5vZGUubGluZW5vLCBub2RlLmNvbG5vKTtcbiAgICAgIG5vZGUuYm9keSA9IGJvZHlOb2RlO1xuICAgICAgbm9kZS5jb25kID0gY29uZE5vZGU7XG5cbiAgICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2Vsc2UnKSkge1xuICAgICAgICBub2RlLmVsc2VfID0gdGhpcy5wYXJzZU9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmVsc2VfID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VPciA9IGZ1bmN0aW9uIHBhcnNlT3IoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlQW5kKCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwU3ltYm9sKCdvcicpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlQW5kKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLk9yKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQW5kID0gZnVuY3Rpb24gcGFyc2VBbmQoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlTm90KCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwU3ltYm9sKCdhbmQnKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZU5vdCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5BbmQobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VOb3QgPSBmdW5jdGlvbiBwYXJzZU5vdCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ25vdCcpKSB7XG4gICAgICByZXR1cm4gbmV3IG5vZGVzLk5vdCh0b2subGluZW5vLCB0b2suY29sbm8sIHRoaXMucGFyc2VOb3QoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VJbigpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUluID0gZnVuY3Rpb24gcGFyc2VJbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VJcygpO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCB0b2tlbiBpcyAnbm90J1xuICAgICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICAgIGlmICghdG9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW52ZXJ0ID0gdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1NZTUJPTCAmJiB0b2sudmFsdWUgPT09ICdub3QnOyAvLyBpZiBpdCB3YXNuJ3QgJ25vdCcsIHB1dCBpdCBiYWNrXG5cbiAgICAgIGlmICghaW52ZXJ0KSB7XG4gICAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2luJykpIHtcbiAgICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZUlzKCk7XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSW4obm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcblxuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Ob3Qobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSdkIGZvdW5kIGEgJ25vdCcgYnV0IHRoaXMgd2Fzbid0IGFuICdpbicsIHB1dCBiYWNrIHRoZSAnbm90J1xuICAgICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9IC8vIEkgcHV0IHRoaXMgcmlnaHQgYWZ0ZXIgXCJpblwiIGluIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHN0YWNrLiBUaGF0IGNhblxuICAvLyBvYnZpb3VzbHkgYmUgY2hhbmdlZCB0byBiZSBjbG9zZXIgdG8gSmluamEuXG4gIDtcblxuICBfcHJvdG8ucGFyc2VJcyA9IGZ1bmN0aW9uIHBhcnNlSXMoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlQ29tcGFyZSgpOyAvLyBsb29rIGZvciBhbiBpc1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaXMnKSkge1xuICAgICAgLy8gbG9vayBmb3IgYSBub3RcbiAgICAgIHZhciBub3QgPSB0aGlzLnNraXBTeW1ib2woJ25vdCcpOyAvLyBnZXQgdGhlIG5leHQgbm9kZVxuXG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlQ29tcGFyZSgpOyAvLyBjcmVhdGUgYW4gSXMgbm9kZSB1c2luZyB0aGUgbmV4dCBub2RlIGFuZCB0aGUgaW5mbyBmcm9tIG91ciBJcyBub2RlLlxuXG4gICAgICBub2RlID0gbmV3IG5vZGVzLklzKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7IC8vIGlmIHdlIGhhdmUgYSBOb3QsIGNyZWF0ZSBhIE5vdCBub2RlIGZyb20gb3VyIElzIG5vZGUuXG5cbiAgICAgIGlmIChub3QpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Ob3Qobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUpO1xuICAgICAgfVxuICAgIH0gLy8gcmV0dXJuIHRoZSBub2RlLlxuXG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VDb21wYXJlID0gZnVuY3Rpb24gcGFyc2VDb21wYXJlKCkge1xuICAgIHZhciBjb21wYXJlT3BzID0gWyc9PScsICc9PT0nLCAnIT0nLCAnIT09JywgJzwnLCAnPicsICc8PScsICc+PSddO1xuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUNvbmNhdCgpO1xuICAgIHZhciBvcHMgPSBbXTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICAgIGlmICghdG9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJlT3BzLmluZGV4T2YodG9rLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgb3BzLnB1c2gobmV3IG5vZGVzLkNvbXBhcmVPcGVyYW5kKHRvay5saW5lbm8sIHRvay5jb2xubywgdGhpcy5wYXJzZUNvbmNhdCgpLCB0b2sudmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IG5vZGVzLkNvbXBhcmUob3BzWzBdLmxpbmVubywgb3BzWzBdLmNvbG5vLCBleHByLCBvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gIH0gLy8gZmluZHMgdGhlICd+JyBmb3Igc3RyaW5nIGNvbmNhdGVuYXRpb25cbiAgO1xuXG4gIF9wcm90by5wYXJzZUNvbmNhdCA9IGZ1bmN0aW9uIHBhcnNlQ29uY2F0KCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUFkZCgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX1RJTERFLCAnficpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlQWRkKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkNvbmNhdChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUFkZCA9IGZ1bmN0aW9uIHBhcnNlQWRkKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZVN1YigpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnKycpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlU3ViKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkFkZChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN1YiA9IGZ1bmN0aW9uIHBhcnNlU3ViKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZU11bCgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLScpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlTXVsKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlN1Yihub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU11bCA9IGZ1bmN0aW9uIHBhcnNlTXVsKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZURpdigpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnKicpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlRGl2KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLk11bChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZURpdiA9IGZ1bmN0aW9uIHBhcnNlRGl2KCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUZsb29yRGl2KCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcvJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VGbG9vckRpdigpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5EaXYobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGbG9vckRpdiA9IGZ1bmN0aW9uIHBhcnNlRmxvb3JEaXYoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlTW9kKCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcvLycpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlTW9kKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkZsb29yRGl2KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTW9kID0gZnVuY3Rpb24gcGFyc2VNb2QoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlUG93KCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICclJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VQb3coKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTW9kKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUG93ID0gZnVuY3Rpb24gcGFyc2VQb3coKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlVW5hcnkoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJyoqJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VVbmFyeSgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Qb3cobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VVbmFyeSA9IGZ1bmN0aW9uIHBhcnNlVW5hcnkobm9GaWx0ZXJzKSB7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICctJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTmVnKHRvay5saW5lbm8sIHRvay5jb2xubywgdGhpcy5wYXJzZVVuYXJ5KHRydWUpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnKycpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlBvcyh0b2subGluZW5vLCB0b2suY29sbm8sIHRoaXMucGFyc2VVbmFyeSh0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgIH1cblxuICAgIGlmICghbm9GaWx0ZXJzKSB7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUZpbHRlcihub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gcGFyc2VQcmltYXJ5KG5vUG9zdGZpeCkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgIHZhciB2YWw7XG4gICAgdmFyIG5vZGUgPSBudWxsO1xuXG4gICAgaWYgKCF0b2spIHtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgZXhwcmVzc2lvbiwgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fU1RSSU5HKSB7XG4gICAgICB2YWwgPSB0b2sudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fSU5UKSB7XG4gICAgICB2YWwgPSBwYXJzZUludCh0b2sudmFsdWUsIDEwKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9GTE9BVCkge1xuICAgICAgdmFsID0gcGFyc2VGbG9hdCh0b2sudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JPT0xFQU4pIHtcbiAgICAgIGlmICh0b2sudmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICB2YWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b2sudmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgdmFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhaWwoJ2ludmFsaWQgYm9vbGVhbjogJyArIHRvay52YWx1ZSwgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9OT05FKSB7XG4gICAgICB2YWwgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1JFR0VYKSB7XG4gICAgICB2YWwgPSBuZXcgUmVnRXhwKHRvay52YWx1ZS5ib2R5LCB0b2sudmFsdWUuZmxhZ3MpO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5MaXRlcmFsKHRvay5saW5lbm8sIHRvay5jb2xubywgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU3ltYm9sKHRvay5saW5lbm8sIHRvay5jb2xubywgdG9rLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlIGlmIGl0J3MgYW4gYWdncmVnYXRlIHR5cGUsIHdlIG5lZWQgdG8gcHVzaCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgZGVsaW1pdGVyIHRva2VuIGJhY2sgb25cbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUFnZ3JlZ2F0ZSgpO1xuICAgIH1cblxuICAgIGlmICghbm9Qb3N0Zml4KSB7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZVBvc3RmaXgobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yKFwidW5leHBlY3RlZCB0b2tlbjogXCIgKyB0b2sudmFsdWUsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYXJzZUZpbHRlck5hbWUgPSBmdW5jdGlvbiBwYXJzZUZpbHRlck5hbWUoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMuZXhwZWN0KGxleGVyLlRPS0VOX1NZTUJPTCk7XG4gICAgdmFyIG5hbWUgPSB0b2sudmFsdWU7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcuJykpIHtcbiAgICAgIG5hbWUgKz0gJy4nICsgdGhpcy5leHBlY3QobGV4ZXIuVE9LRU5fU1lNQk9MKS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLlN5bWJvbCh0b2subGluZW5vLCB0b2suY29sbm8sIG5hbWUpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUZpbHRlckFyZ3MgPSBmdW5jdGlvbiBwYXJzZUZpbHRlckFyZ3Mobm9kZSkge1xuICAgIGlmICh0aGlzLnBlZWtUb2tlbigpLnR5cGUgPT09IGxleGVyLlRPS0VOX0xFRlRfUEFSRU4pIHtcbiAgICAgIC8vIEdldCBhIEZ1bkNhbGwgbm9kZSBhbmQgYWRkIHRoZSBwYXJhbWV0ZXJzIHRvIHRoZVxuICAgICAgLy8gZmlsdGVyXG4gICAgICB2YXIgY2FsbCA9IHRoaXMucGFyc2VQb3N0Zml4KG5vZGUpO1xuICAgICAgcmV0dXJuIGNhbGwuYXJncy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRmlsdGVyID0gZnVuY3Rpb24gcGFyc2VGaWx0ZXIobm9kZSkge1xuICAgIHdoaWxlICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fUElQRSkpIHtcbiAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUZpbHRlck5hbWUoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRmlsdGVyKG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBuYW1lLCBuZXcgbm9kZXMuTm9kZUxpc3QobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIFtub2RlXS5jb25jYXQodGhpcy5wYXJzZUZpbHRlckFyZ3Mobm9kZSkpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRmlsdGVyU3RhdGVtZW50ID0gZnVuY3Rpb24gcGFyc2VGaWx0ZXJTdGF0ZW1lbnQoKSB7XG4gICAgdmFyIGZpbHRlclRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnZmlsdGVyJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGaWx0ZXJTdGF0ZW1lbnQ6IGV4cGVjdGVkIGZpbHRlcicpO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZUZpbHRlck5hbWUoKTtcbiAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VGaWx0ZXJBcmdzKG5hbWUpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoZmlsdGVyVG9rLnZhbHVlKTtcbiAgICB2YXIgYm9keSA9IG5ldyBub2Rlcy5DYXB0dXJlKG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGZpbHRlcicpKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuRmlsdGVyKG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBuYW1lLCBuZXcgbm9kZXMuTm9kZUxpc3QobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIFtib2R5XS5jb25jYXQoYXJncykpKTtcbiAgICByZXR1cm4gbmV3IG5vZGVzLk91dHB1dChuYW1lLmxpbmVubywgbmFtZS5jb2xubywgW25vZGVdKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBZ2dyZWdhdGUgPSBmdW5jdGlvbiBwYXJzZUFnZ3JlZ2F0ZSgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIHN3aXRjaCAodG9rLnR5cGUpIHtcbiAgICAgIGNhc2UgbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTjpcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Hcm91cCh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBsZXhlci5UT0tFTl9MRUZUX0JSQUNLRVQ6XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQXJyYXkodG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbGV4ZXIuVE9LRU5fTEVGVF9DVVJMWTpcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5EaWN0KHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHZhciB0eXBlID0gdGhpcy5wZWVrVG9rZW4oKS50eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbGV4ZXIuVE9LRU5fUklHSFRfUEFSRU4gfHwgdHlwZSA9PT0gbGV4ZXIuVE9LRU5fUklHSFRfQlJBQ0tFVCB8fCB0eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9DVVJMWSkge1xuICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIXRoaXMuc2tpcChsZXhlci5UT0tFTl9DT01NQSkpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlQWdncmVnYXRlOiBleHBlY3RlZCBjb21tYSBhZnRlciBleHByZXNzaW9uJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkRpY3QpIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGVycm9yc1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5wYXJzZVByaW1hcnkoKTsgLy8gV2UgZXhwZWN0IGEga2V5L3ZhbHVlIHBhaXIgZm9yIGRpY3RzLCBzZXBhcmF0ZWQgYnkgYVxuICAgICAgICAvLyBjb2xvblxuXG4gICAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTE9OKSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VBZ2dyZWdhdGU6IGV4cGVjdGVkIGNvbG9uIGFmdGVyIGRpY3Qga2V5JywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgfSAvLyBUT0RPOiBjaGVjayBmb3IgZXJyb3JzXG5cblxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBub2RlLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKGtleS5saW5lbm8sIGtleS5jb2xubywga2V5LCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGVycm9yc1xuICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIG5vZGUuYWRkQ2hpbGQoZXhwcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlU2lnbmF0dXJlID0gZnVuY3Rpb24gcGFyc2VTaWduYXR1cmUodG9sZXJhbnQsIG5vUGFyZW5zKSB7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIW5vUGFyZW5zICYmIHRvay50eXBlICE9PSBsZXhlci5UT0tFTl9MRUZUX1BBUkVOKSB7XG4gICAgICBpZiAodG9sZXJhbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIGFyZ3VtZW50cycsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9MRUZUX1BBUkVOKSB7XG4gICAgICB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gbmV3IG5vZGVzLk5vZGVMaXN0KHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgdmFyIGt3YXJncyA9IG5ldyBub2Rlcy5LZXl3b3JkQXJncyh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIHZhciBjaGVja0NvbW1hID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICAgIGlmICghbm9QYXJlbnMgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1JJR0hUX1BBUkVOKSB7XG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChub1BhcmVucyAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfRU5EKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDb21tYSAmJiAhdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU2lnbmF0dXJlOiBleHBlY3RlZCBjb21tYSBhZnRlciBleHByZXNzaW9uJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICAgIGlmICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJz0nKSkge1xuICAgICAgICAgIGt3YXJncy5hZGRDaGlsZChuZXcgbm9kZXMuUGFpcihhcmcubGluZW5vLCBhcmcuY29sbm8sIGFyZywgdGhpcy5wYXJzZUV4cHJlc3Npb24oKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MuYWRkQ2hpbGQoYXJnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGVja0NvbW1hID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoa3dhcmdzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgYXJncy5hZGRDaGlsZChrd2FyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBhcmdzO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVVudGlsQmxvY2tzID0gZnVuY3Rpb24gcGFyc2VVbnRpbEJsb2NrcygpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMuYnJlYWtPbkJsb2NrcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBibG9ja05hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYmxvY2tOYW1lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLmJyZWFrT25CbG9ja3MgPSBibG9ja05hbWVzO1xuICAgIHZhciByZXQgPSB0aGlzLnBhcnNlKCk7XG4gICAgdGhpcy5icmVha09uQmxvY2tzID0gcHJldjtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU5vZGVzID0gZnVuY3Rpb24gcGFyc2VOb2RlcygpIHtcbiAgICB2YXIgdG9rO1xuICAgIHZhciBidWYgPSBbXTtcblxuICAgIHdoaWxlICh0b2sgPSB0aGlzLm5leHRUb2tlbigpKSB7XG4gICAgICBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0RBVEEpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0b2sudmFsdWU7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgICAgICB2YXIgbmV4dFZhbCA9IG5leHRUb2tlbiAmJiBuZXh0VG9rZW4udmFsdWU7IC8vIElmIHRoZSBsYXN0IHRva2VuIGhhcyBcIi1cIiB3ZSBuZWVkIHRvIHRyaW0gdGhlXG4gICAgICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiB0aGUgZGF0YS4gVGhpcyBpcyBtYXJrZWQgd2l0aFxuICAgICAgICAvLyB0aGUgYGRyb3BMZWFkaW5nV2hpdGVzcGFjZWAgdmFyaWFibGUuXG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgKGRvbid0IHVzZSByZWdleClcbiAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbiAgICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICB9IC8vIFNhbWUgZm9yIHRoZSBzdWNjZWVkaW5nIGJsb2NrIHN0YXJ0IHRva2VuXG5cblxuICAgICAgICBpZiAobmV4dFRva2VuICYmIChuZXh0VG9rZW4udHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfU1RBUlQgJiYgbmV4dFZhbC5jaGFyQXQobmV4dFZhbC5sZW5ndGggLSAxKSA9PT0gJy0nIHx8IG5leHRUb2tlbi50eXBlID09PSBsZXhlci5UT0tFTl9WQVJJQUJMRV9TVEFSVCAmJiBuZXh0VmFsLmNoYXJBdCh0aGlzLnRva2Vucy50YWdzLlZBUklBQkxFX1NUQVJULmxlbmd0aCkgPT09ICctJyB8fCBuZXh0VG9rZW4udHlwZSA9PT0gbGV4ZXIuVE9LRU5fQ09NTUVOVCAmJiBuZXh0VmFsLmNoYXJBdCh0aGlzLnRva2Vucy50YWdzLkNPTU1FTlRfU1RBUlQubGVuZ3RoKSA9PT0gJy0nKSkge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgb3B0aW1pemVkIChkb24ndCB1c2UgcmVnZXgpXG4gICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBidWYucHVzaChuZXcgbm9kZXMuT3V0cHV0KHRvay5saW5lbm8sIHRvay5jb2xubywgW25ldyBub2Rlcy5UZW1wbGF0ZURhdGEodG9rLmxpbmVubywgdG9rLmNvbG5vLCBkYXRhKV0pKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX1NUQVJUKSB7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgIHZhciBuID0gdGhpcy5wYXJzZVN0YXRlbWVudCgpO1xuXG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmLnB1c2gobik7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9WQVJJQUJMRV9TVEFSVCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyVmFyaWFibGVFbmQoKTtcbiAgICAgICAgYnVmLnB1c2gobmV3IG5vZGVzLk91dHB1dCh0b2subGluZW5vLCB0b2suY29sbm8sIFtlXSkpO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQ09NTUVOVCkge1xuICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IHRvay52YWx1ZS5jaGFyQXQodG9rLnZhbHVlLmxlbmd0aCAtIHRoaXMudG9rZW5zLnRhZ3MuQ09NTUVOVF9FTkQubGVuZ3RoIC0gMSkgPT09ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElnbm9yZSBjb21tZW50cywgb3RoZXJ3aXNlIHRoaXMgc2hvdWxkIGJlIGFuIGVycm9yXG4gICAgICAgIHRoaXMuZmFpbCgnVW5leHBlY3RlZCB0b2tlbiBhdCB0b3AtbGV2ZWw6ICcgKyB0b2sudHlwZSwgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgIHJldHVybiBuZXcgbm9kZXMuTm9kZUxpc3QoMCwgMCwgdGhpcy5wYXJzZU5vZGVzKCkpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUFzUm9vdCA9IGZ1bmN0aW9uIHBhcnNlQXNSb290KCkge1xuICAgIHJldHVybiBuZXcgbm9kZXMuUm9vdCgwLCAwLCB0aGlzLnBhcnNlTm9kZXMoKSk7XG4gIH07XG5cbiAgcmV0dXJuIFBhcnNlcjtcbn0oT2JqKTsgLy8gdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4vLyB2YXIgbCA9IGxleGVyLmxleCgneyUtIGlmIHggLSV9XFxuIGhlbGxvIHslIGVuZGlmICV9Jyk7XG4vLyB2YXIgdDtcbi8vIHdoaWxlKCh0ID0gbC5uZXh0VG9rZW4oKSkpIHtcbi8vICAgICBjb25zb2xlLmxvZyh1dGlsLmluc3BlY3QodCkpO1xuLy8gfVxuLy8gdmFyIHAgPSBuZXcgUGFyc2VyKGxleGVyLmxleCgnaGVsbG8geyUgZmlsdGVyIHRpdGxlICV9JyArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdIZWxsbyBtYWRhbSBob3cgYXJlIHlvdScgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneyUgZW5kZmlsdGVyICV9JykpO1xuLy8gdmFyIG4gPSBwLnBhcnNlQXNSb290KCk7XG4vLyBub2Rlcy5wcmludE5vZGVzKG4pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogZnVuY3Rpb24gcGFyc2Uoc3JjLCBleHRlbnNpb25zLCBvcHRzKSB7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGxleGVyLmxleChzcmMsIG9wdHMpKTtcblxuICAgIGlmIChleHRlbnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucGFyc2VBc1Jvb3QoKTtcbiAgfSxcbiAgUGFyc2VyOiBQYXJzZXJcbn07XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIHdoaXRlc3BhY2VDaGFycyA9IFwiIFxcblxcdFxcclxceEEwXCI7XG52YXIgZGVsaW1DaGFycyA9ICcoKVtde30lKi0rfi8jLDp8Ljw+PSEnO1xudmFyIGludENoYXJzID0gJzAxMjM0NTY3ODknO1xudmFyIEJMT0NLX1NUQVJUID0gJ3slJztcbnZhciBCTE9DS19FTkQgPSAnJX0nO1xudmFyIFZBUklBQkxFX1NUQVJUID0gJ3t7JztcbnZhciBWQVJJQUJMRV9FTkQgPSAnfX0nO1xudmFyIENPTU1FTlRfU1RBUlQgPSAneyMnO1xudmFyIENPTU1FTlRfRU5EID0gJyN9JztcbnZhciBUT0tFTl9TVFJJTkcgPSAnc3RyaW5nJztcbnZhciBUT0tFTl9XSElURVNQQUNFID0gJ3doaXRlc3BhY2UnO1xudmFyIFRPS0VOX0RBVEEgPSAnZGF0YSc7XG52YXIgVE9LRU5fQkxPQ0tfU1RBUlQgPSAnYmxvY2stc3RhcnQnO1xudmFyIFRPS0VOX0JMT0NLX0VORCA9ICdibG9jay1lbmQnO1xudmFyIFRPS0VOX1ZBUklBQkxFX1NUQVJUID0gJ3ZhcmlhYmxlLXN0YXJ0JztcbnZhciBUT0tFTl9WQVJJQUJMRV9FTkQgPSAndmFyaWFibGUtZW5kJztcbnZhciBUT0tFTl9DT01NRU5UID0gJ2NvbW1lbnQnO1xudmFyIFRPS0VOX0xFRlRfUEFSRU4gPSAnbGVmdC1wYXJlbic7XG52YXIgVE9LRU5fUklHSFRfUEFSRU4gPSAncmlnaHQtcGFyZW4nO1xudmFyIFRPS0VOX0xFRlRfQlJBQ0tFVCA9ICdsZWZ0LWJyYWNrZXQnO1xudmFyIFRPS0VOX1JJR0hUX0JSQUNLRVQgPSAncmlnaHQtYnJhY2tldCc7XG52YXIgVE9LRU5fTEVGVF9DVVJMWSA9ICdsZWZ0LWN1cmx5JztcbnZhciBUT0tFTl9SSUdIVF9DVVJMWSA9ICdyaWdodC1jdXJseSc7XG52YXIgVE9LRU5fT1BFUkFUT1IgPSAnb3BlcmF0b3InO1xudmFyIFRPS0VOX0NPTU1BID0gJ2NvbW1hJztcbnZhciBUT0tFTl9DT0xPTiA9ICdjb2xvbic7XG52YXIgVE9LRU5fVElMREUgPSAndGlsZGUnO1xudmFyIFRPS0VOX1BJUEUgPSAncGlwZSc7XG52YXIgVE9LRU5fSU5UID0gJ2ludCc7XG52YXIgVE9LRU5fRkxPQVQgPSAnZmxvYXQnO1xudmFyIFRPS0VOX0JPT0xFQU4gPSAnYm9vbGVhbic7XG52YXIgVE9LRU5fTk9ORSA9ICdub25lJztcbnZhciBUT0tFTl9TWU1CT0wgPSAnc3ltYm9sJztcbnZhciBUT0tFTl9TUEVDSUFMID0gJ3NwZWNpYWwnO1xudmFyIFRPS0VOX1JFR0VYID0gJ3JlZ2V4JztcblxuZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGxpbmVubywgY29sbm8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsaW5lbm86IGxpbmVubyxcbiAgICBjb2xubzogY29sbm9cbiAgfTtcbn1cblxudmFyIFRva2VuaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRva2VuaXplcihzdHIsIG9wdHMpIHtcbiAgICB0aGlzLnN0ciA9IHN0cjtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLmxlbiA9IHN0ci5sZW5ndGg7XG4gICAgdGhpcy5saW5lbm8gPSAwO1xuICAgIHRoaXMuY29sbm8gPSAwO1xuICAgIHRoaXMuaW5fY29kZSA9IGZhbHNlO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciB0YWdzID0gb3B0cy50YWdzIHx8IHt9O1xuICAgIHRoaXMudGFncyA9IHtcbiAgICAgIEJMT0NLX1NUQVJUOiB0YWdzLmJsb2NrU3RhcnQgfHwgQkxPQ0tfU1RBUlQsXG4gICAgICBCTE9DS19FTkQ6IHRhZ3MuYmxvY2tFbmQgfHwgQkxPQ0tfRU5ELFxuICAgICAgVkFSSUFCTEVfU1RBUlQ6IHRhZ3MudmFyaWFibGVTdGFydCB8fCBWQVJJQUJMRV9TVEFSVCxcbiAgICAgIFZBUklBQkxFX0VORDogdGFncy52YXJpYWJsZUVuZCB8fCBWQVJJQUJMRV9FTkQsXG4gICAgICBDT01NRU5UX1NUQVJUOiB0YWdzLmNvbW1lbnRTdGFydCB8fCBDT01NRU5UX1NUQVJULFxuICAgICAgQ09NTUVOVF9FTkQ6IHRhZ3MuY29tbWVudEVuZCB8fCBDT01NRU5UX0VORFxuICAgIH07XG4gICAgdGhpcy50cmltQmxvY2tzID0gISFvcHRzLnRyaW1CbG9ja3M7XG4gICAgdGhpcy5sc3RyaXBCbG9ja3MgPSAhIW9wdHMubHN0cmlwQmxvY2tzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRva2VuaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm5leHRUb2tlbiA9IGZ1bmN0aW9uIG5leHRUb2tlbigpIHtcbiAgICB2YXIgbGluZW5vID0gdGhpcy5saW5lbm87XG4gICAgdmFyIGNvbG5vID0gdGhpcy5jb2xubztcbiAgICB2YXIgdG9rO1xuXG4gICAgaWYgKHRoaXMuaW5fY29kZSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBhcmUgaW4gYSBibG9jayBwYXJzZSBpdCBhcyBjb2RlXG4gICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICAvLyBXZSBoYXZlIG5vdGhpbmcgZWxzZSB0byBwYXJzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnXCInIHx8IGN1ciA9PT0gJ1xcJycpIHtcbiAgICAgICAgLy8gV2UndmUgaGl0IGEgc3RyaW5nXG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9TVFJJTkcsIHRoaXMuX3BhcnNlU3RyaW5nKGN1ciksIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmICh0b2sgPSB0aGlzLl9leHRyYWN0KHdoaXRlc3BhY2VDaGFycykpIHtcbiAgICAgICAgLy8gV2UgaGl0IHNvbWUgd2hpdGVzcGFjZVxuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fV0hJVEVTUEFDRSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLkJMT0NLX0VORCkpIHx8ICh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKCctJyArIHRoaXMudGFncy5CTE9DS19FTkQpKSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNoZWNrIGZvciB0aGUgYmxvY2sgZW5kIHRhZ1xuICAgICAgICAvL1xuICAgICAgICAvLyBJdCBpcyBhIHJlcXVpcmVtZW50IHRoYXQgc3RhcnQgYW5kIGVuZCB0YWdzIGFyZSBjb21wb3NlZCBvZlxuICAgICAgICAvLyBkZWxpbWl0ZXIgY2hhcmFjdGVycyAoJXt9W10gZXRjKSwgYW5kIG91ciBjb2RlIGFsd2F5c1xuICAgICAgICAvLyBicmVha3Mgb24gZGVsaW1pdGVycyBzbyB3ZSBjYW4gYXNzdW1lIHRoZSB0b2tlbiBwYXJzaW5nXG4gICAgICAgIC8vIGRvZXNuJ3QgY29uc3VtZSB0aGVzZSBlbHNld2hlcmVcbiAgICAgICAgdGhpcy5pbl9jb2RlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpbUJsb2Nrcykge1xuICAgICAgICAgIGN1ciA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgICAgICAgaWYgKGN1ciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIFNraXAgbmV3bGluZVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAvLyBTa2lwIENSTEYgbmV3bGluZVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcblxuICAgICAgICAgICAgaWYgKGN1ciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXYXMgbm90IGEgQ1JMRiwgc28gZ28gYmFja1xuICAgICAgICAgICAgICB0aGlzLmJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fQkxPQ0tfRU5ELCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmICgodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuVkFSSUFCTEVfRU5EKSkgfHwgKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcoJy0nICsgdGhpcy50YWdzLlZBUklBQkxFX0VORCkpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIHZhcmlhYmxlIGVuZCB0YWcgKHNlZSBhYm92ZSlcbiAgICAgICAgdGhpcy5pbl9jb2RlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9WQVJJQUJMRV9FTkQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3InICYmIHRoaXMuc3RyLmNoYXJBdCh0aGlzLmluZGV4ICsgMSkgPT09ICcvJykge1xuICAgICAgICAvLyBTa2lwIHBhc3QgJ3IvJy5cbiAgICAgICAgdGhpcy5mb3J3YXJkTigyKTsgLy8gRXh0cmFjdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSByZWdleCAtLSAvIGVuZHMgaXQsIFxcLyBkb2VzIG5vdC5cblxuICAgICAgICB2YXIgcmVnZXhCb2R5ID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJy8nICYmIHRoaXMucHJldmlvdXMoKSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdleEJvZHkgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hlY2sgZm9yIGZsYWdzLlxuICAgICAgICAvLyBUaGUgcG9zc2libGUgZmxhZ3MgYXJlIGFjY29yZGluZyB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHApXG5cblxuICAgICAgICB2YXIgUE9TU0lCTEVfRkxBR1MgPSBbJ2cnLCAnaScsICdtJywgJ3knXTtcbiAgICAgICAgdmFyIHJlZ2V4RmxhZ3MgPSAnJztcblxuICAgICAgICB3aGlsZSAoIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgICAgdmFyIGlzQ3VycmVudEFGbGFnID0gUE9TU0lCTEVfRkxBR1MuaW5kZXhPZih0aGlzLmN1cnJlbnQoKSkgIT09IC0xO1xuXG4gICAgICAgICAgaWYgKGlzQ3VycmVudEFGbGFnKSB7XG4gICAgICAgICAgICByZWdleEZsYWdzICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9SRUdFWCwge1xuICAgICAgICAgIGJvZHk6IHJlZ2V4Qm9keSxcbiAgICAgICAgICBmbGFnczogcmVnZXhGbGFnc1xuICAgICAgICB9LCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsaW1DaGFycy5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGhpdCBhIGRlbGltaXRlciAoYSBzcGVjaWFsIGNoYXIgbGlrZSBhIGJyYWNrZXQpXG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB2YXIgY29tcGxleE9wcyA9IFsnPT0nLCAnPT09JywgJyE9JywgJyE9PScsICc8PScsICc+PScsICcvLycsICcqKiddO1xuICAgICAgICB2YXIgY3VyQ29tcGxleCA9IGN1ciArIHRoaXMuY3VycmVudCgpO1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAobGliLmluZGV4T2YoY29tcGxleE9wcywgY3VyQ29tcGxleCkgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgY3VyID0gY3VyQ29tcGxleDsgLy8gU2VlIGlmIHRoaXMgaXMgYSBzdHJpY3QgZXF1YWxpdHkvaW5lcXVhbGl0eSBjb21wYXJhdG9yXG5cbiAgICAgICAgICBpZiAobGliLmluZGV4T2YoY29tcGxleE9wcywgY3VyQ29tcGxleCArIHRoaXMuY3VycmVudCgpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGN1ciA9IGN1ckNvbXBsZXggKyB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoY3VyKSB7XG4gICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fTEVGVF9QQVJFTjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUklHSFRfUEFSRU47XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0xFRlRfQlJBQ0tFVDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUklHSFRfQlJBQ0tFVDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fTEVGVF9DVVJMWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUklHSFRfQ1VSTFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0NPTU1BO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9DT0xPTjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfic6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fVElMREU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1BJUEU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fT1BFUkFUT1I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4odHlwZSwgY3VyLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGFyZSBub3QgYXQgd2hpdGVzcGFjZSBvciBhIGRlbGltaXRlciwgc28gZXh0cmFjdCB0aGVcbiAgICAgICAgLy8gdGV4dCBhbmQgcGFyc2UgaXRcbiAgICAgICAgdG9rID0gdGhpcy5fZXh0cmFjdFVudGlsKHdoaXRlc3BhY2VDaGFycyArIGRlbGltQ2hhcnMpO1xuXG4gICAgICAgIGlmICh0b2subWF0Y2goL15bLStdP1swLTldKyQvKSkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcblxuICAgICAgICAgICAgdmFyIGRlYyA9IHRoaXMuX2V4dHJhY3QoaW50Q2hhcnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fRkxPQVQsIHRvayArICcuJyArIGRlYywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9JTlQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRvay5tYXRjaCgvXih0cnVlfGZhbHNlKSQvKSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9CT09MRUFOLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICB9IGVsc2UgaWYgKHRvayA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX05PTkUsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBBZGRlZCB0byBtYWtlIHRoZSB0ZXN0IGBudWxsIGlzIG51bGxgIGV2YWx1YXRlIHRydXRoaWx5LlxuICAgICAgICAgICAqIE90aGVyd2lzZSwgTnVuanVja3Mgd2lsbCBsb29rIHVwIG51bGwgaW4gdGhlIGNvbnRleHQgYW5kXG4gICAgICAgICAgICogcmV0dXJuIGB1bmRlZmluZWRgLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LiBUaGlzICptYXkqIGhhdmVcbiAgICAgICAgICAgKiBjb25zZXF1ZW5jZXMgaXMgc29tZW9uZSBpcyB1c2luZyBudWxsIGluIHRoZWlyIHRlbXBsYXRlcyBhcyBhXG4gICAgICAgICAgICogdmFyaWFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gZWxzZSBpZiAodG9rID09PSAnbnVsbCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fTk9ORSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2spIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fU1lNQk9MLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSB3aGlsZSBwYXJzaW5nOiAnICsgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJzZSBvdXQgdGhlIHRlbXBsYXRlIHRleHQsIGJyZWFraW5nIG9uIHRhZ1xuICAgICAgLy8gZGVsaW1pdGVycyBiZWNhdXNlIHdlIG5lZWQgdG8gbG9vayBmb3IgYmxvY2svdmFyaWFibGUgc3RhcnRcbiAgICAgIC8vIHRhZ3MgKGRvbid0IHVzZSB0aGUgZnVsbCBkZWxpbUNoYXJzIGZvciBvcHRpbWl6YXRpb24pXG4gICAgICB2YXIgYmVnaW5DaGFycyA9IHRoaXMudGFncy5CTE9DS19TVEFSVC5jaGFyQXQoMCkgKyB0aGlzLnRhZ3MuVkFSSUFCTEVfU1RBUlQuY2hhckF0KDApICsgdGhpcy50YWdzLkNPTU1FTlRfU1RBUlQuY2hhckF0KDApICsgdGhpcy50YWdzLkNPTU1FTlRfRU5ELmNoYXJBdCgwKTtcblxuICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmICgodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQgKyAnLScpKSB8fCAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQpKSkge1xuICAgICAgICB0aGlzLmluX2NvZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fQkxPQ0tfU1RBUlQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5WQVJJQUJMRV9TVEFSVCArICctJykpIHx8ICh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5WQVJJQUJMRV9TVEFSVCkpKSB7XG4gICAgICAgIHRoaXMuaW5fY29kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9WQVJJQUJMRV9TVEFSVCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvayA9ICcnO1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgdmFyIGluQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5DT01NRU5UX1NUQVJUKSkge1xuICAgICAgICAgIGluQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgdG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQ09NTUVOVF9TVEFSVCk7XG4gICAgICAgIH0gLy8gQ29udGludWFsbHkgY29uc3VtZSB0ZXh0LCBicmVha2luZyBvbiB0aGUgdGFnIGRlbGltaXRlclxuICAgICAgICAvLyBjaGFyYWN0ZXJzIGFuZCBjaGVja2luZyB0byBzZWUgaWYgaXQncyBhIHN0YXJ0IHRhZy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgY291bGQgaGl0IHRoZSBlbmQgb2YgdGhlIHRlbXBsYXRlIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgLy8gb3VyIGxvb3BpbmcsIHNvIGNoZWNrIGZvciB0aGUgbnVsbCByZXR1cm4gdmFsdWUgZnJvbVxuICAgICAgICAvLyBfZXh0cmFjdFVudGlsXG5cblxuICAgICAgICB3aGlsZSAoKGRhdGEgPSB0aGlzLl9leHRyYWN0VW50aWwoYmVnaW5DaGFycykpICE9PSBudWxsKSB7XG4gICAgICAgICAgdG9rICs9IGRhdGE7XG5cbiAgICAgICAgICBpZiAoKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkJMT0NLX1NUQVJUKSB8fCB0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5WQVJJQUJMRV9TVEFSVCkgfHwgdGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuQ09NTUVOVF9TVEFSVCkpICYmICFpbkNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxzdHJpcEJsb2NrcyAmJiB0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5CTE9DS19TVEFSVCkgJiYgdGhpcy5jb2xubyA+IDAgJiYgdGhpcy5jb2xubyA8PSB0b2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0TGluZSA9IHRvay5zbGljZSgtdGhpcy5jb2xubyk7XG5cbiAgICAgICAgICAgICAgaWYgKC9eXFxzKyQvLnRlc3QobGFzdExpbmUpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGJsb2NrIGxlYWRpbmcgd2hpdGVzcGFjZSBmcm9tIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgdG9rID0gdG9rLnNsaWNlKDAsIC10aGlzLmNvbG5vKTtcblxuICAgICAgICAgICAgICAgIGlmICghdG9rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWxsIGRhdGEgcmVtb3ZlZCwgY29sbGFwc2UgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgbm9kZXNcbiAgICAgICAgICAgICAgICAgIC8vIGJ5IHJldHVybmluZyBuZXh0IHRva2VuIChibG9jayBzdGFydClcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBJZiBpdCBpcyBhIHN0YXJ0IHRhZywgc3RvcCBsb29waW5nXG5cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5DT01NRU5UX0VORCkpIHtcbiAgICAgICAgICAgIGlmICghaW5Db21tZW50KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgY29tbWVudCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2sgKz0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQ09NTUVOVF9FTkQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IG1hdGNoIGFueSB0YWcsIHNvIGFkZCB0aGUgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgLy8gY2Fycnkgb25cbiAgICAgICAgICAgIHRvayArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsICYmIGluQ29tbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgZW5kIG9mIGNvbW1lbnQsIGdvdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKGluQ29tbWVudCA/IFRPS0VOX0NPTU1FTlQgOiBUT0tFTl9EQVRBLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlU3RyaW5nKGRlbGltaXRlcikge1xuICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIHdoaWxlICghdGhpcy5pc0ZpbmlzaGVkKCkgJiYgdGhpcy5jdXJyZW50KCkgIT09IGRlbGltaXRlcikge1xuICAgICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgICBpZiAoY3VyID09PSAnXFxcXCcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnQoKSkge1xuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBjdXI7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgX3Byb3RvLl9tYXRjaGVzID0gZnVuY3Rpb24gX21hdGNoZXMoc3RyKSB7XG4gICAgaWYgKHRoaXMuaW5kZXggKyBzdHIubGVuZ3RoID4gdGhpcy5sZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtID0gdGhpcy5zdHIuc2xpY2UodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIHN0ci5sZW5ndGgpO1xuICAgIHJldHVybiBtID09PSBzdHI7XG4gIH07XG5cbiAgX3Byb3RvLl9leHRyYWN0U3RyaW5nID0gZnVuY3Rpb24gX2V4dHJhY3RTdHJpbmcoc3RyKSB7XG4gICAgaWYgKHRoaXMuX21hdGNoZXMoc3RyKSkge1xuICAgICAgdGhpcy5mb3J3YXJkTihzdHIubGVuZ3RoKTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9leHRyYWN0VW50aWwgPSBmdW5jdGlvbiBfZXh0cmFjdFVudGlsKGNoYXJTdHJpbmcpIHtcbiAgICAvLyBFeHRyYWN0IGFsbCBub24tbWF0Y2hpbmcgY2hhcnMsIHdpdGggdGhlIGRlZmF1bHQgbWF0Y2hpbmcgc2V0XG4gICAgLy8gdG8gZXZlcnl0aGluZ1xuICAgIHJldHVybiB0aGlzLl9leHRyYWN0TWF0Y2hpbmcodHJ1ZSwgY2hhclN0cmluZyB8fCAnJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9leHRyYWN0ID0gZnVuY3Rpb24gX2V4dHJhY3QoY2hhclN0cmluZykge1xuICAgIC8vIEV4dHJhY3QgYWxsIG1hdGNoaW5nIGNoYXJzIChubyBkZWZhdWx0LCBzbyBjaGFyU3RyaW5nIG11c3QgYmVcbiAgICAvLyBleHBsaWNpdClcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdE1hdGNoaW5nKGZhbHNlLCBjaGFyU3RyaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uX2V4dHJhY3RNYXRjaGluZyA9IGZ1bmN0aW9uIF9leHRyYWN0TWF0Y2hpbmcoYnJlYWtPbk1hdGNoLCBjaGFyU3RyaW5nKSB7XG4gICAgLy8gUHVsbCBvdXQgY2hhcmFjdGVycyB1bnRpbCBhIGJyZWFraW5nIGNoYXIgaXMgaGl0LlxuICAgIC8vIElmIGJyZWFrT25NYXRjaCBpcyBmYWxzZSwgYSBub24tbWF0Y2hpbmcgY2hhciBzdG9wcyBpdC5cbiAgICAvLyBJZiBicmVha09uTWF0Y2ggaXMgdHJ1ZSwgYSBtYXRjaGluZyBjaGFyIHN0b3BzIGl0LlxuICAgIGlmICh0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0ID0gY2hhclN0cmluZy5pbmRleE9mKHRoaXMuY3VycmVudCgpKTsgLy8gT25seSBwcm9jZWVkIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgZG9lc24ndCBtZWV0IG91ciBjb25kaXRpb25cblxuICAgIGlmIChicmVha09uTWF0Y2ggJiYgZmlyc3QgPT09IC0xIHx8ICFicmVha09uTWF0Y2ggJiYgZmlyc3QgIT09IC0xKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY3VycmVudCgpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7IC8vIEFuZCBwdWxsIG91dCBhbGwgdGhlIGNoYXJzIG9uZSBhdCBhIHRpbWUgdW50aWwgd2UgaGl0IGFcbiAgICAgIC8vIGJyZWFraW5nIGNoYXJcblxuICAgICAgdmFyIGlkeCA9IGNoYXJTdHJpbmcuaW5kZXhPZih0aGlzLmN1cnJlbnQoKSk7XG5cbiAgICAgIHdoaWxlICgoYnJlYWtPbk1hdGNoICYmIGlkeCA9PT0gLTEgfHwgIWJyZWFrT25NYXRjaCAmJiBpZHggIT09IC0xKSAmJiAhdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgdCArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIGlkeCA9IGNoYXJTdHJpbmcuaW5kZXhPZih0aGlzLmN1cnJlbnQoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICBfcHJvdG8uX2V4dHJhY3RSZWdleCA9IGZ1bmN0aW9uIF9leHRyYWN0UmVnZXgocmVnZXgpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHRoaXMuY3VycmVudFN0cigpLm1hdGNoKHJlZ2V4KTtcblxuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBNb3ZlIGZvcndhcmQgd2hhdGV2ZXIgd2FzIG1hdGNoZWRcblxuXG4gICAgdGhpcy5mb3J3YXJkTihtYXRjaGVzWzBdLmxlbmd0aCk7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH07XG5cbiAgX3Byb3RvLmlzRmluaXNoZWQgPSBmdW5jdGlvbiBpc0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMubGVuO1xuICB9O1xuXG4gIF9wcm90by5mb3J3YXJkTiA9IGZ1bmN0aW9uIGZvcndhcmROKG4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICB0aGlzLmluZGV4Kys7XG5cbiAgICBpZiAodGhpcy5wcmV2aW91cygpID09PSAnXFxuJykge1xuICAgICAgdGhpcy5saW5lbm8rKztcbiAgICAgIHRoaXMuY29sbm8gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG5vKys7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5iYWNrTiA9IGZ1bmN0aW9uIGJhY2tOKG4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdGhpcy5iYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5iYWNrID0gZnVuY3Rpb24gYmFjaygpIHtcbiAgICB0aGlzLmluZGV4LS07XG5cbiAgICBpZiAodGhpcy5jdXJyZW50KCkgPT09ICdcXG4nKSB7XG4gICAgICB0aGlzLmxpbmVuby0tO1xuICAgICAgdmFyIGlkeCA9IHRoaXMuc3JjLmxhc3RJbmRleE9mKCdcXG4nLCB0aGlzLmluZGV4IC0gMSk7XG5cbiAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29sbm8gPSB0aGlzLmluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb2xubyA9IHRoaXMuaW5kZXggLSBpZHg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbm8tLTtcbiAgICB9XG4gIH0gLy8gY3VycmVudCByZXR1cm5zIGN1cnJlbnQgY2hhcmFjdGVyXG4gIDtcblxuICBfcHJvdG8uY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyLmNoYXJBdCh0aGlzLmluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gY3VycmVudFN0ciByZXR1cm5zIHdoYXQncyBsZWZ0IG9mIHRoZSB1bnBhcnNlZCBzdHJpbmdcbiAgO1xuXG4gIF9wcm90by5jdXJyZW50U3RyID0gZnVuY3Rpb24gY3VycmVudFN0cigpIHtcbiAgICBpZiAoIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHIuc3Vic3RyKHRoaXMuaW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICBfcHJvdG8ucHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMuaW5kZXggLSAxKTtcbiAgfTtcblxuICByZXR1cm4gVG9rZW5pemVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGV4OiBmdW5jdGlvbiBsZXgoc3JjLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbml6ZXIoc3JjLCBvcHRzKTtcbiAgfSxcbiAgVE9LRU5fU1RSSU5HOiBUT0tFTl9TVFJJTkcsXG4gIFRPS0VOX1dISVRFU1BBQ0U6IFRPS0VOX1dISVRFU1BBQ0UsXG4gIFRPS0VOX0RBVEE6IFRPS0VOX0RBVEEsXG4gIFRPS0VOX0JMT0NLX1NUQVJUOiBUT0tFTl9CTE9DS19TVEFSVCxcbiAgVE9LRU5fQkxPQ0tfRU5EOiBUT0tFTl9CTE9DS19FTkQsXG4gIFRPS0VOX1ZBUklBQkxFX1NUQVJUOiBUT0tFTl9WQVJJQUJMRV9TVEFSVCxcbiAgVE9LRU5fVkFSSUFCTEVfRU5EOiBUT0tFTl9WQVJJQUJMRV9FTkQsXG4gIFRPS0VOX0NPTU1FTlQ6IFRPS0VOX0NPTU1FTlQsXG4gIFRPS0VOX0xFRlRfUEFSRU46IFRPS0VOX0xFRlRfUEFSRU4sXG4gIFRPS0VOX1JJR0hUX1BBUkVOOiBUT0tFTl9SSUdIVF9QQVJFTixcbiAgVE9LRU5fTEVGVF9CUkFDS0VUOiBUT0tFTl9MRUZUX0JSQUNLRVQsXG4gIFRPS0VOX1JJR0hUX0JSQUNLRVQ6IFRPS0VOX1JJR0hUX0JSQUNLRVQsXG4gIFRPS0VOX0xFRlRfQ1VSTFk6IFRPS0VOX0xFRlRfQ1VSTFksXG4gIFRPS0VOX1JJR0hUX0NVUkxZOiBUT0tFTl9SSUdIVF9DVVJMWSxcbiAgVE9LRU5fT1BFUkFUT1I6IFRPS0VOX09QRVJBVE9SLFxuICBUT0tFTl9DT01NQTogVE9LRU5fQ09NTUEsXG4gIFRPS0VOX0NPTE9OOiBUT0tFTl9DT0xPTixcbiAgVE9LRU5fVElMREU6IFRPS0VOX1RJTERFLFxuICBUT0tFTl9QSVBFOiBUT0tFTl9QSVBFLFxuICBUT0tFTl9JTlQ6IFRPS0VOX0lOVCxcbiAgVE9LRU5fRkxPQVQ6IFRPS0VOX0ZMT0FULFxuICBUT0tFTl9CT09MRUFOOiBUT0tFTl9CT09MRUFOLFxuICBUT0tFTl9OT05FOiBUT0tFTl9OT05FLFxuICBUT0tFTl9TWU1CT0w6IFRPS0VOX1NZTUJPTCxcbiAgVE9LRU5fU1BFQ0lBTDogVE9LRU5fU1BFQ0lBTCxcbiAgVE9LRU5fUkVHRVg6IFRPS0VOX1JFR0VYXG59O1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgTG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSksXG4gICAgUHJlY29tcGlsZWRMb2FkZXIgPSBfcmVxdWlyZS5QcmVjb21waWxlZExvYWRlcjtcblxudmFyIFdlYkxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcikge1xuICBfaW5oZXJpdHNMb29zZShXZWJMb2FkZXIsIF9Mb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIFdlYkxvYWRlcihiYXNlVVJMLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTG9hZGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5iYXNlVVJMID0gYmFzZVVSTCB8fCAnLic7XG4gICAgb3B0cyA9IG9wdHMgfHwge307IC8vIEJ5IGRlZmF1bHQsIHRoZSBjYWNoZSBpcyB0dXJuZWQgb2ZmIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgICAvLyB0byBcIndhdGNoXCIgdGVtcGxhdGVzIG92ZXIgSFRUUCwgc28gdGhleSBhcmUgcmUtZG93bmxvYWRlZFxuICAgIC8vIGFuZCBjb21waWxlZCBlYWNoIHRpbWUuIChSZW1lbWJlciwgUFJFQ09NUElMRSBZT1VSXG4gICAgLy8gVEVNUExBVEVTIGluIHByb2R1Y3Rpb24hKVxuXG4gICAgX3RoaXMudXNlQ2FjaGUgPSAhIW9wdHMudXNlQ2FjaGU7IC8vIFdlIGRlZmF1bHQgYGFzeW5jYCB0byBmYWxzZSBzbyB0aGF0IHRoZSBzaW1wbGUgc3luY2hyb25vdXNcbiAgICAvLyBBUEkgY2FuIGJlIHVzZWQgd2hlbiB5b3UgYXJlbid0IGRvaW5nIGFueXRoaW5nIGFzeW5jIGluXG4gICAgLy8geW91ciB0ZW1wbGF0ZXMgKHdoaWNoIGlzIG1vc3Qgb2YgdGhlIHRpbWUpLiBUaGlzIHBlcmZvcm1zIGFcbiAgICAvLyBzeW5jIGFqYXggcmVxdWVzdCwgYnV0IHRoYXQncyBvayBiZWNhdXNlIGl0IHNob3VsZCAqb25seSpcbiAgICAvLyBoYXBwZW4gaW4gZGV2ZWxvcG1lbnQuIFBSRUNPTVBJTEUgWU9VUiBURU1QTEFURVMuXG5cbiAgICBfdGhpcy5hc3luYyA9ICEhb3B0cy5hc3luYztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gV2ViTG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoZnJvbSwgdG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHRlbXBsYXRlcyBub3Qgc3VwcG9ydCBpbiB0aGUgYnJvd3NlciB5ZXQnKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U291cmNlID0gZnVuY3Rpb24gZ2V0U291cmNlKG5hbWUsIGNiKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgdXNlQ2FjaGUgPSB0aGlzLnVzZUNhY2hlO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdGhpcy5mZXRjaCh0aGlzLmJhc2VVUkwgKyAnLycgKyBuYW1lLCBmdW5jdGlvbiAoZXJyLCBzcmMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgICBwYXRoOiBuYW1lLFxuICAgICAgICAgIG5vQ2FjaGU6ICF1c2VDYWNoZVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzMi5lbWl0KCdsb2FkJywgbmFtZSwgcmVzdWx0KTtcblxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vIGlmIHRoaXMgV2ViTG9hZGVyIGlzbid0IHJ1bm5pbmcgYXN5bmNocm9ub3VzbHksIHRoZVxuICAgIC8vIGZldGNoIGFib3ZlIHdvdWxkIGFjdHVhbGx5IHJ1biBzeW5jIGFuZCB3ZSdsbCBoYXZlIGFcbiAgICAvLyByZXN1bHQgaGVyZVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uZmV0Y2ggPSBmdW5jdGlvbiBmZXRjaCh1cmwsIGNiKSB7XG4gICAgLy8gT25seSBpbiB0aGUgYnJvd3NlciBwbGVhc2VcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTG9hZGVyIGNhbiBvbmx5IGJ5IHVzZWQgaW4gYSBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgdmFyIGFqYXggPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZGluZyA9IHRydWU7XG5cbiAgICBhamF4Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhamF4LnJlYWR5U3RhdGUgPT09IDQgJiYgbG9hZGluZykge1xuICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGFqYXguc3RhdHVzID09PSAwIHx8IGFqYXguc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICBjYihudWxsLCBhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2Ioe1xuICAgICAgICAgICAgc3RhdHVzOiBhamF4LnN0YXR1cyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGFqYXgucmVzcG9uc2VUZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyAncz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgYWpheC5vcGVuKCdHRVQnLCB1cmwsIHRoaXMuYXN5bmMpO1xuICAgIGFqYXguc2VuZCgpO1xuICB9O1xuXG4gIHJldHVybiBXZWJMb2FkZXI7XG59KExvYWRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXZWJMb2FkZXI6IFdlYkxvYWRlcixcbiAgUHJlY29tcGlsZWRMb2FkZXI6IFByZWNvbXBpbGVkTG9hZGVyXG59O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLFxuICAgIEVudmlyb25tZW50ID0gX3JlcXVpcmUuRW52aXJvbm1lbnQsXG4gICAgVGVtcGxhdGUgPSBfcmVxdWlyZS5UZW1wbGF0ZTtcblxudmFyIExvYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBsb2FkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBwcmVjb21waWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBjb21waWxlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBwYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgbGV4ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgcnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBub2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBpbnN0YWxsSmluamFDb21wYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTsgLy8gQSBzaW5nbGUgaW5zdGFuY2Ugb2YgYW4gZW52aXJvbm1lbnQsIHNpbmNlIHRoaXMgaXMgc28gY29tbW9ubHkgdXNlZFxuXG5cbnZhciBlO1xuXG5mdW5jdGlvbiBjb25maWd1cmUodGVtcGxhdGVzUGF0aCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAobGliLmlzT2JqZWN0KHRlbXBsYXRlc1BhdGgpKSB7XG4gICAgb3B0cyA9IHRlbXBsYXRlc1BhdGg7XG4gICAgdGVtcGxhdGVzUGF0aCA9IG51bGw7XG4gIH1cblxuICB2YXIgVGVtcGxhdGVMb2FkZXI7XG5cbiAgaWYgKGxvYWRlcnMuRmlsZVN5c3RlbUxvYWRlcikge1xuICAgIFRlbXBsYXRlTG9hZGVyID0gbmV3IGxvYWRlcnMuRmlsZVN5c3RlbUxvYWRlcih0ZW1wbGF0ZXNQYXRoLCB7XG4gICAgICB3YXRjaDogb3B0cy53YXRjaCxcbiAgICAgIG5vQ2FjaGU6IG9wdHMubm9DYWNoZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxvYWRlcnMuV2ViTG9hZGVyKSB7XG4gICAgVGVtcGxhdGVMb2FkZXIgPSBuZXcgbG9hZGVycy5XZWJMb2FkZXIodGVtcGxhdGVzUGF0aCwge1xuICAgICAgdXNlQ2FjaGU6IG9wdHMud2ViICYmIG9wdHMud2ViLnVzZUNhY2hlLFxuICAgICAgYXN5bmM6IG9wdHMud2ViICYmIG9wdHMud2ViLmFzeW5jXG4gICAgfSk7XG4gIH1cblxuICBlID0gbmV3IEVudmlyb25tZW50KFRlbXBsYXRlTG9hZGVyLCBvcHRzKTtcblxuICBpZiAob3B0cyAmJiBvcHRzLmV4cHJlc3MpIHtcbiAgICBlLmV4cHJlc3Mob3B0cy5leHByZXNzKTtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LFxuICBUZW1wbGF0ZTogVGVtcGxhdGUsXG4gIExvYWRlcjogTG9hZGVyLFxuICBGaWxlU3lzdGVtTG9hZGVyOiBsb2FkZXJzLkZpbGVTeXN0ZW1Mb2FkZXIsXG4gIE5vZGVSZXNvbHZlTG9hZGVyOiBsb2FkZXJzLk5vZGVSZXNvbHZlTG9hZGVyLFxuICBQcmVjb21waWxlZExvYWRlcjogbG9hZGVycy5QcmVjb21waWxlZExvYWRlcixcbiAgV2ViTG9hZGVyOiBsb2FkZXJzLldlYkxvYWRlcixcbiAgY29tcGlsZXI6IGNvbXBpbGVyLFxuICBwYXJzZXI6IHBhcnNlcixcbiAgbGV4ZXI6IGxleGVyLFxuICBydW50aW1lOiBydW50aW1lLFxuICBsaWI6IGxpYixcbiAgbm9kZXM6IG5vZGVzLFxuICBpbnN0YWxsSmluamFDb21wYXQ6IGluc3RhbGxKaW5qYUNvbXBhdCxcbiAgY29uZmlndXJlOiBjb25maWd1cmUsXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBlID0gdW5kZWZpbmVkO1xuICB9LFxuICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHNyYywgZW52LCBwYXRoLCBlYWdlckNvbXBpbGUpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGVtcGxhdGUoc3JjLCBlbnYsIHBhdGgsIGVhZ2VyQ29tcGlsZSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKG5hbWUsIGN0eCwgY2IpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlLnJlbmRlcihuYW1lLCBjdHgsIGNiKTtcbiAgfSxcbiAgcmVuZGVyU3RyaW5nOiBmdW5jdGlvbiByZW5kZXJTdHJpbmcoc3JjLCBjdHgsIGNiKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBjb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZS5yZW5kZXJTdHJpbmcoc3JjLCBjdHgsIGNiKTtcbiAgfSxcbiAgcHJlY29tcGlsZTogcHJlY29tcGlsZSA/IHByZWNvbXBpbGUucHJlY29tcGlsZSA6IHVuZGVmaW5lZCxcbiAgcHJlY29tcGlsZVN0cmluZzogcHJlY29tcGlsZSA/IHByZWNvbXBpbGUucHJlY29tcGlsZVN0cmluZyA6IHVuZGVmaW5lZFxufTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLy8gUmF3VGFza3MgYXJlIHJlY3ljbGVkIHRvIHJlZHVjZSBHQyBjaHVybi5cbnZhciBmcmVlVGFza3MgPSBbXTtcbi8vIFdlIHF1ZXVlIGVycm9ycyB0byBlbnN1cmUgdGhleSBhcmUgdGhyb3duIGluIHJpZ2h0IG9yZGVyIChGSUZPKS5cbi8vIEFycmF5LWFzLXF1ZXVlIGlzIGdvb2QgZW5vdWdoIGhlcmUsIHNpbmNlIHdlIGFyZSBqdXN0IGRlYWxpbmcgd2l0aCBleGNlcHRpb25zLlxudmFyIHBlbmRpbmdFcnJvcnMgPSBbXTtcbnZhciByZXF1ZXN0RXJyb3JUaHJvdyA9IHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHRocm93Rmlyc3RFcnJvcik7XG5cbmZ1bmN0aW9uIHRocm93Rmlyc3RFcnJvcigpIHtcbiAgICBpZiAocGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgcGVuZGluZ0Vycm9ycy5zaGlmdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB2YXIgcmF3VGFzaztcbiAgICBpZiAoZnJlZVRhc2tzLmxlbmd0aCkge1xuICAgICAgICByYXdUYXNrID0gZnJlZVRhc2tzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd1Rhc2sgPSBuZXcgUmF3VGFzaygpO1xuICAgIH1cbiAgICByYXdUYXNrLnRhc2sgPSB0YXNrO1xuICAgIHJhd0FzYXAocmF3VGFzayk7XG59XG5cbi8vIFdlIHdyYXAgdGFza3Mgd2l0aCByZWN5Y2xhYmxlIHRhc2sgb2JqZWN0cy4gIEEgdGFzayBvYmplY3QgaW1wbGVtZW50c1xuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmZ1bmN0aW9uIFJhd1Rhc2soKSB7XG4gICAgdGhpcy50YXNrID0gbnVsbDtcbn1cblxuLy8gVGhlIHNvbGUgcHVycG9zZSBvZiB3cmFwcGluZyB0aGUgdGFzayBpcyB0byBjYXRjaCB0aGUgZXhjZXB0aW9uIGFuZCByZWN5Y2xlXG4vLyB0aGUgdGFzayBvYmplY3QgYWZ0ZXIgaXRzIHNpbmdsZSB1c2UuXG5SYXdUYXNrLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudGFzay5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGFzYXAub25lcnJvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBob29rIGV4aXN0cyBwdXJlbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXRcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgb24gaXRzIGV4aXN0ZW5jZS5cbiAgICAgICAgICAgIGFzYXAub25lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBhIHdlYiBicm93c2VyLCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuIEhvd2V2ZXIsIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBzbG93aW5nIGRvd24gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdGFza3MsIHdlIHJldGhyb3cgdGhlIGVycm9yIGluIGFcbiAgICAgICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgICAgICBwZW5kaW5nRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIGZyZWVUYXNrc1tmcmVlVGFza3MubGVuZ3RoXSA9IHRoaXM7XG4gICAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgSU8sIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVkcmF3XG4vLyBldmVudHMgaW4gYnJvd3NlcnMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG1ldGhvZCB0aGF0IGF0dGVtcHRzIHRvIGtpY2tcbi8vIG9mZiBhIGBmbHVzaGAgZXZlbnQgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS4gYGZsdXNoYCB3aWxsIGF0dGVtcHQgdG8gZXhoYXVzdFxuLy8gdGhlIGV2ZW50IHF1ZXVlIGJlZm9yZSB5aWVsZGluZyB0byB0aGUgYnJvd3NlcidzIG93biBldmVudCBsb29wLlxudmFyIHJlcXVlc3RGbHVzaDtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuLy8gZXZlcnkgYXZhaWxhYmxlIFNhdWNlTGFicyBTZWxlbml1bSB3ZWIgZHJpdmVyIHdvcmtlciBhdCB0aW1lIG9mIHdyaXRpbmcuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xbUctNVVZR3VwNXF4R2RFTVdraFA2QldDejA1M05VYjJFMVFvVVRVMTZ1QS9lZGl0I2dpZD03ODM3MjQ1OTNcblxuLy8gU2FmYXJpIDYgYW5kIDYuMSBmb3IgZGVza3RvcCwgaVBhZCwgYW5kIGlQaG9uZSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdFxuLy8gaGF2ZSBXZWJLaXRNdXRhdGlvbk9ic2VydmVyIGJ1dCBub3QgdW4tcHJlZml4ZWQgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11c3QgdXNlIGBnbG9iYWxgIG9yIGBzZWxmYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIHRvIHdvcmsgaW4gYm90aCBmcmFtZXMgYW5kIHdlYlxuLy8gd29ya2Vycy4gYGdsb2JhbGAgaXMgYSBwcm92aXNpb24gb2YgQnJvd3NlcmlmeSwgTXIsIE1ycywgb3IgTW9wLlxuXG4vKiBnbG9iYWxzIHNlbGYgKi9cbnZhciBzY29wZSA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiBzZWxmO1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gc2NvcGUuTXV0YXRpb25PYnNlcnZlciB8fCBzY29wZS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG4vLyBNdXRhdGlvbk9ic2VydmVycyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBoYXZlIGhpZ2ggcHJpb3JpdHkgYW5kIHdvcmtcbi8vIHJlbGlhYmx5IGV2ZXJ5d2hlcmUgdGhleSBhcmUgaW1wbGVtZW50ZWQuXG4vLyBUaGV5IGFyZSBpbXBsZW1lbnRlZCBpbiBhbGwgbW9kZXJuIGJyb3dzZXJzLlxuLy9cbi8vIC0gQW5kcm9pZCA0LTQuM1xuLy8gLSBDaHJvbWUgMjYtMzRcbi8vIC0gRmlyZWZveCAxNC0yOVxuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciAxMVxuLy8gLSBpUGFkIFNhZmFyaSA2LTcuMVxuLy8gLSBpUGhvbmUgU2FmYXJpIDctNy4xXG4vLyAtIFNhZmFyaSA2LTdcbmlmICh0eXBlb2YgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcblxuLy8gTWVzc2FnZUNoYW5uZWxzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGdpdmUgZGlyZWN0IGFjY2VzcyB0byB0aGUgSFRNTFxuLy8gdGFzayBxdWV1ZSwgYXJlIGltcGxlbWVudGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLCBTYWZhcmkgNS4wLTEsIGFuZCBPcGVyYVxuLy8gMTEtMTIsIGFuZCBpbiB3ZWIgd29ya2VycyBpbiBtYW55IGVuZ2luZXMuXG4vLyBBbHRob3VnaCBtZXNzYWdlIGNoYW5uZWxzIHlpZWxkIHRvIGFueSBxdWV1ZWQgcmVuZGVyaW5nIGFuZCBJTyB0YXNrcywgdGhleVxuLy8gd291bGQgYmUgYmV0dGVyIHRoYW4gaW1wb3NpbmcgdGhlIDRtcyBkZWxheSBvZiB0aW1lcnMuXG4vLyBIb3dldmVyLCB0aGV5IGRvIG5vdCB3b3JrIHJlbGlhYmx5IGluIEludGVybmV0IEV4cGxvcmVyIG9yIFNhZmFyaS5cblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG5cbi8vIFRpbWVycyBhcmUgaW1wbGVtZW50ZWQgdW5pdmVyc2FsbHkuXG4vLyBXZSBmYWxsIGJhY2sgdG8gdGltZXJzIGluIHdvcmtlcnMgaW4gbW9zdCBlbmdpbmVzLCBhbmQgaW4gZm9yZWdyb3VuZFxuLy8gY29udGV4dHMgaW4gdGhlIGZvbGxvd2luZyBicm93c2Vycy5cbi8vIEhvd2V2ZXIsIG5vdGUgdGhhdCBldmVuIHRoaXMgc2ltcGxlIGNhc2UgcmVxdWlyZXMgbnVhbmNlcyB0byBvcGVyYXRlIGluIGFcbi8vIGJyb2FkIHNwZWN0cnVtIG9mIGJyb3dzZXJzLlxuLy9cbi8vIC0gRmlyZWZveCAzLTEzXG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDYtOVxuLy8gLSBpUGFkIFNhZmFyaSA0LjNcbi8vIC0gTHlueCAyLjguN1xufSBlbHNlIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoZmx1c2gpO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCByZXF1ZXN0cyB0aGF0IHRoZSBoaWdoIHByaW9yaXR5IGV2ZW50IHF1ZXVlIGJlIGZsdXNoZWQgYXNcbi8vIHNvb24gYXMgcG9zc2libGUuXG4vLyBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFuIGVycm9yIHRocm93biBpbiBhIHRhc2sgZnJvbSBzdGFsbGluZyB0aGUgZXZlbnRcbi8vIHF1ZXVlIGlmIHRoZSBleGNlcHRpb24gaGFuZGxlZCBieSBOb2RlLmpz4oCZc1xuLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcblxuLy8gVG8gcmVxdWVzdCBhIGhpZ2ggcHJpb3JpdHkgZXZlbnQsIHdlIGluZHVjZSBhIG11dGF0aW9uIG9ic2VydmVyIGJ5IHRvZ2dsaW5nXG4vLyB0aGUgdGV4dCBvZiBhIHRleHQgbm9kZSBiZXR3ZWVuIFwiMVwiIGFuZCBcIi0xXCIuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICB0b2dnbGUgPSAtdG9nZ2xlO1xuICAgICAgICBub2RlLmRhdGEgPSB0b2dnbGU7XG4gICAgfTtcbn1cblxuLy8gVGhlIG1lc3NhZ2UgY2hhbm5lbCB0ZWNobmlxdWUgd2FzIGRpc2NvdmVyZWQgYnkgTWFsdGUgVWJsIGFuZCB3YXMgdGhlXG4vLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4vLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuXG4vLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4vLyBwYWdlJ3MgZmlyc3QgbG9hZC4gVGhhbmtmdWxseSwgdGhpcyB2ZXJzaW9uIG9mIFNhZmFyaSBzdXBwb3J0c1xuLy8gTXV0YXRpb25PYnNlcnZlcnMsIHNvIHdlIGRvbid0IG5lZWQgdG8gZmFsbCBiYWNrIGluIHRoYXQgY2FzZS5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU1lc3NhZ2VDaGFubmVsKGNhbGxiYWNrKSB7XG4vLyAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbi8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbi8vIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuLy8gRXZlbiBpZiB3ZSB3ZXJlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbi8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4vLyBgc2V0SW1tZWRpYXRlYCBtdXN0IGJlIGNhbGxlZCAqYnkgbmFtZSogYW5kIHRoZXJlZm9yZSBtdXN0IGJlIHdyYXBwZWQgaW4gYVxuLy8gY2xvc3VyZS5cbi8vIE5ldmVyIGZvcmdldC5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBTYWZhcmkgNi4wIGhhcyBhIHByb2JsZW0gd2hlcmUgdGltZXJzIHdpbGwgZ2V0IGxvc3Qgd2hpbGUgdGhlIHVzZXIgaXNcbi8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuLy8gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB0aGF0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQgaW5zdGVhZC5cbi8vIEhvd2V2ZXIsIGlmIHdlIGV2ZXIgZWxlY3QgdG8gdXNlIHRpbWVycyBpbiBTYWZhcmksIHRoZSBwcmV2YWxlbnQgd29yay1hcm91bmRcbi8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuXG4vLyBgc2V0VGltZW91dGAgZG9lcyBub3QgY2FsbCB0aGUgcGFzc2VkIGNhbGxiYWNrIGlmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW5cbi8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3Rcbi8vIGV2ZW4gdGhlbi5cblxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChoYW5kbGVUaW1lciwgMCk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoaXMgdGltZXIgZ2V0cyBmcmVxdWVudGx5IGRyb3BwZWQgaW4gRmlyZWZveFxuICAgICAgICAvLyB3b3JrZXJzLCB3ZSBlbmxpc3QgYW4gaW50ZXJ2YWwgaGFuZGxlIHRoYXQgd2lsbCB0cnkgdG8gZmlyZVxuICAgICAgICAvLyBhbiBldmVudCAyMCB0aW1lcyBwZXIgc2Vjb25kIHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChoYW5kbGVUaW1lciwgNTApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVyKCkge1xuICAgICAgICAgICAgLy8gV2hpY2hldmVyIHRpbWVyIHN1Y2NlZWRzIHdpbGwgY2FuY2VsIGJvdGggdGltZXJzIGFuZFxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIGZvciBgYXNhcC5qc2Agb25seS5cbi8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdCBkZXBlbmRzIG9uXG4vLyBpdHMgZXhpc3RlbmNlLlxucmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIgPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXI7XG5cbi8vIEFTQVAgd2FzIG9yaWdpbmFsbHkgYSBuZXh0VGljayBzaGltIGluY2x1ZGVkIGluIFEuIFRoaXMgd2FzIGZhY3RvcmVkIG91dFxuLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbi8vIGFtZW5kbWVudHMuIFRoZXNlIGRlY2lzaW9ucywgcGFydGljdWxhcmx5IHRvIG1hcmdpbmFsaXplIE1lc3NhZ2VDaGFubmVsIGFuZFxuLy8gdG8gY2FwdHVyZSB0aGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiBpbiBhIGNsb3N1cmUsIHdlcmUgaW50ZWdyYXRlZFxuLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL2NkZGY3MjMyNTQ2YTljZjg1ODUyNGI3NWNkZTZmOWVkZjcyNjIwYTcvbGliL3JzdnAvYXNhcC5qc1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpKVxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvLyBNSVQgbGljZW5zZSAoYnkgRWxhbiBTaGFua2VyKS5cbihmdW5jdGlvbihnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXhlY3V0ZVN5bmMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpe1xuICAgICAgYXJnc1swXS5hcHBseShudWxsLCBhcmdzLnNwbGljZSgxKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBleGVjdXRlQXN5bmMgPSBmdW5jdGlvbihmbil7XG4gICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWFrZUl0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgIH07XG4gICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICB9O1xuICBcbiAgdmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihtYXliZUFycmF5KXtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1heWJlQXJyYXkpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIHZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgdmFyIG5leHRUaWNrID0gZm9yY2VBc3luYyA/IGV4ZWN1dGVBc3luYyA6IGV4ZWN1dGVTeW5jO1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHdyYXBJdGVyYXRvcihtYWtlSXRlcmF0b3IodGFza3MpKSgpO1xuICB9O1xuXG4gIGlmICh0cnVlKSB7XG4gICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB3YXRlcmZhbGw7XG4gICAgfSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTsgLy8gUmVxdWlyZUpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdhdGVyZmFsbDsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxzLndhdGVyZmFsbCA9IHdhdGVyZmFsbDsgLy8gPHNjcmlwdD5cbiAgfVxufSkodGhpcyk7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXZlbnRMaXN0ZW5lcigpIHtcbiAgICAgIGlmIChlcnJvckxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIHZhciBlcnJvckxpc3RlbmVyO1xuXG4gICAgLy8gQWRkaW5nIGFuIGVycm9yIGxpc3RlbmVyIGlzIG5vdCBvcHRpb25hbCBiZWNhdXNlXG4gICAgLy8gaWYgYW4gZXJyb3IgaXMgdGhyb3duIG9uIGFuIGV2ZW50IGVtaXR0ZXIgd2UgY2Fubm90XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGFjdHVhbCBldmVudCB3ZSBhcmUgd2FpdGluZyB3aWxsXG4gICAgLy8gYmUgZmlyZWQuIFRoZSByZXN1bHQgY291bGQgYmUgYSBzaWxlbnQgd2F5IHRvIGNyZWF0ZVxuICAgIC8vIG1lbW9yeSBvciBmaWxlIGRlc2NyaXB0b3IgbGVha3MsIHdoaWNoIGlzIHNvbWV0aGluZ1xuICAgIC8vIHdlIHNob3VsZCBhdm9pZC5cbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgZXJyb3JMaXN0ZW5lciA9IGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcblxuICAgICAgZW1pdHRlci5vbmNlKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgfSk7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbm9kZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIHN5bSA9IDA7XG5cbmZ1bmN0aW9uIGdlbnN5bSgpIHtcbiAgcmV0dXJuICdob2xlXycgKyBzeW0rKztcbn0gLy8gY29weS1vbi13cml0ZSB2ZXJzaW9uIG9mIG1hcFxuXG5cbmZ1bmN0aW9uIG1hcENPVyhhcnIsIGZ1bmMpIHtcbiAgdmFyIHJlcyA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGZ1bmMoYXJyW2ldKTtcblxuICAgIGlmIChpdGVtICE9PSBhcnJbaV0pIHtcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJlcyA9IGFyci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICByZXNbaV0gPSBpdGVtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgfHwgYXJyO1xufVxuXG5mdW5jdGlvbiB3YWxrKGFzdCwgZnVuYywgZGVwdGhGaXJzdCkge1xuICBpZiAoIShhc3QgaW5zdGFuY2VvZiBub2Rlcy5Ob2RlKSkge1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICBpZiAoIWRlcHRoRmlyc3QpIHtcbiAgICB2YXIgYXN0VCA9IGZ1bmMoYXN0KTtcblxuICAgIGlmIChhc3RUICYmIGFzdFQgIT09IGFzdCkge1xuICAgICAgcmV0dXJuIGFzdFQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzdCBpbnN0YW5jZW9mIG5vZGVzLk5vZGVMaXN0KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbWFwQ09XKGFzdC5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiB3YWxrKG5vZGUsIGZ1bmMsIGRlcHRoRmlyc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9PSBhc3QuY2hpbGRyZW4pIHtcbiAgICAgIGFzdCA9IG5ldyBub2Rlc1thc3QudHlwZW5hbWVdKGFzdC5saW5lbm8sIGFzdC5jb2xubywgY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXh0ZW5zaW9uKSB7XG4gICAgdmFyIGFyZ3MgPSB3YWxrKGFzdC5hcmdzLCBmdW5jLCBkZXB0aEZpcnN0KTtcbiAgICB2YXIgY29udGVudEFyZ3MgPSBtYXBDT1coYXN0LmNvbnRlbnRBcmdzLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIHdhbGsobm9kZSwgZnVuYywgZGVwdGhGaXJzdCk7XG4gICAgfSk7XG5cbiAgICBpZiAoYXJncyAhPT0gYXN0LmFyZ3MgfHwgY29udGVudEFyZ3MgIT09IGFzdC5jb250ZW50QXJncykge1xuICAgICAgYXN0ID0gbmV3IG5vZGVzW2FzdC50eXBlbmFtZV0oYXN0LmV4dE5hbWUsIGFzdC5wcm9wLCBhcmdzLCBjb250ZW50QXJncyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcm9wcyA9IGFzdC5maWVsZHMubWFwKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIGFzdFtmaWVsZF07XG4gICAgfSk7XG4gICAgdmFyIHByb3BzVCA9IG1hcENPVyhwcm9wcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiB3YWxrKHByb3AsIGZ1bmMsIGRlcHRoRmlyc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKHByb3BzVCAhPT0gcHJvcHMpIHtcbiAgICAgIGFzdCA9IG5ldyBub2Rlc1thc3QudHlwZW5hbWVdKGFzdC5saW5lbm8sIGFzdC5jb2xubyk7XG4gICAgICBwcm9wc1QuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICBhc3RbYXN0LmZpZWxkc1tpXV0gPSBwcm9wO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcHRoRmlyc3QgPyBmdW5jKGFzdCkgfHwgYXN0IDogYXN0O1xufVxuXG5mdW5jdGlvbiBkZXB0aFdhbGsoYXN0LCBmdW5jKSB7XG4gIHJldHVybiB3YWxrKGFzdCwgZnVuYywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMsIHByb3ApIHtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciB3YWxrZWQgPSBkZXB0aFdhbGsocHJvcCA/IG5vZGVbcHJvcF0gOiBub2RlLCBmdW5jdGlvbiAoZGVzY05vZGUpIHtcbiAgICB2YXIgc3ltYm9sO1xuXG4gICAgaWYgKGRlc2NOb2RlIGluc3RhbmNlb2Ygbm9kZXMuQmxvY2spIHtcbiAgICAgIHJldHVybiBkZXNjTm9kZTtcbiAgICB9IGVsc2UgaWYgKGRlc2NOb2RlIGluc3RhbmNlb2Ygbm9kZXMuRmlsdGVyICYmIGxpYi5pbmRleE9mKGFzeW5jRmlsdGVycywgZGVzY05vZGUubmFtZS52YWx1ZSkgIT09IC0xIHx8IGRlc2NOb2RlIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbkFzeW5jKSB7XG4gICAgICBzeW1ib2wgPSBuZXcgbm9kZXMuU3ltYm9sKGRlc2NOb2RlLmxpbmVubywgZGVzY05vZGUuY29sbm8sIGdlbnN5bSgpKTtcbiAgICAgIGNoaWxkcmVuLnB1c2gobmV3IG5vZGVzLkZpbHRlckFzeW5jKGRlc2NOb2RlLmxpbmVubywgZGVzY05vZGUuY29sbm8sIGRlc2NOb2RlLm5hbWUsIGRlc2NOb2RlLmFyZ3MsIHN5bWJvbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBzeW1ib2w7XG4gIH0pO1xuXG4gIGlmIChwcm9wKSB7XG4gICAgbm9kZVtwcm9wXSA9IHdhbGtlZDtcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gd2Fsa2VkO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Ob2RlTGlzdChub2RlLmxpbmVubywgbm9kZS5jb2xubywgY2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpZnRGaWx0ZXJzKGFzdCwgYXN5bmNGaWx0ZXJzKSB7XG4gIHJldHVybiBkZXB0aFdhbGsoYXN0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuT3V0cHV0KSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2V0KSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ3ZhbHVlJyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRm9yKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2FycicpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2NvbmQnKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXh0ZW5zaW9uKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2FyZ3MnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsaWZ0U3VwZXIoYXN0KSB7XG4gIHJldHVybiB3YWxrKGFzdCwgZnVuY3Rpb24gKGJsb2NrTm9kZSkge1xuICAgIGlmICghKGJsb2NrTm9kZSBpbnN0YW5jZW9mIG5vZGVzLkJsb2NrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYXNTdXBlciA9IGZhbHNlO1xuICAgIHZhciBzeW1ib2wgPSBnZW5zeW0oKTtcbiAgICBibG9ja05vZGUuYm9keSA9IHdhbGsoYmxvY2tOb2RlLmJvZHksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZ1bkNhbGwgJiYgbm9kZS5uYW1lLnZhbHVlID09PSAnc3VwZXInKSB7XG4gICAgICAgIGhhc1N1cGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBub2Rlcy5TeW1ib2wobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIHN5bWJvbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzU3VwZXIpIHtcbiAgICAgIGJsb2NrTm9kZS5ib2R5LmNoaWxkcmVuLnVuc2hpZnQobmV3IG5vZGVzLlN1cGVyKDAsIDAsIGJsb2NrTm9kZS5uYW1lLCBuZXcgbm9kZXMuU3ltYm9sKDAsIDAsIHN5bWJvbCkpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0U3RhdGVtZW50cyhhc3QpIHtcbiAgcmV0dXJuIGRlcHRoV2Fsayhhc3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5Gb3IpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBhc3luYyA9IGZhbHNlO1xuICAgIHdhbGsobm9kZSwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5GaWx0ZXJBc3luYyB8fCBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLklmQXN5bmMgfHwgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5Bc3luY0VhY2ggfHwgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5Bc3luY0FsbCB8fCBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLkNhbGxFeHRlbnNpb25Bc3luYykge1xuICAgICAgICBhc3luYyA9IHRydWU7IC8vIFN0b3AgaXRlcmF0aW5nIGJ5IHJldHVybmluZyB0aGUgbm9kZVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcblxuICAgIGlmIChhc3luYykge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5JZikge1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLklmQXN5bmMobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUuY29uZCwgbm9kZS5ib2R5LCBub2RlLmVsc2VfKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZvciAmJiAhKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5Bc3luY0FsbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBub2Rlcy5Bc3luY0VhY2gobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUuYXJyLCBub2RlLm5hbWUsIG5vZGUuYm9keSwgbm9kZS5lbHNlXyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNwcyhhc3QsIGFzeW5jRmlsdGVycykge1xuICByZXR1cm4gY29udmVydFN0YXRlbWVudHMobGlmdFN1cGVyKGxpZnRGaWx0ZXJzKGFzdCwgYXN5bmNGaWx0ZXJzKSkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0oYXN0LCBhc3luY0ZpbHRlcnMpIHtcbiAgcmV0dXJuIGNwcyhhc3QsIGFzeW5jRmlsdGVycyB8fCBbXSk7XG59IC8vIHZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuLy8gdmFyIHNyYyA9ICdoZWxsbyB7JSBmb28gJX17JSBlbmRmb28gJX0gZW5kJztcbi8vIHZhciBhc3QgPSB0cmFuc2Zvcm0ocGFyc2VyLnBhcnNlKHNyYywgW25ldyBGb29FeHRlbnNpb24oKV0pLCBbJ2JhciddKTtcbi8vIG5vZGVzLnByaW50Tm9kZXMoYXN0KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbn07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciByID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5mdW5jdGlvbiBub3JtYWxpemUodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLmFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBpc05hTihudW0pIHtcbiAgcmV0dXJuIG51bSAhPT0gbnVtOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5mdW5jdGlvbiBiYXRjaChhcnIsIGxpbmVjb3VudCwgZmlsbFdpdGgpIHtcbiAgdmFyIGk7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIHRtcCA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIGxpbmVjb3VudCA9PT0gMCAmJiB0bXAubGVuZ3RoKSB7XG4gICAgICByZXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gW107XG4gICAgfVxuXG4gICAgdG1wLnB1c2goYXJyW2ldKTtcbiAgfVxuXG4gIGlmICh0bXAubGVuZ3RoKSB7XG4gICAgaWYgKGZpbGxXaXRoKSB7XG4gICAgICBmb3IgKGkgPSB0bXAubGVuZ3RoOyBpIDwgbGluZWNvdW50OyBpKyspIHtcbiAgICAgICAgdG1wLnB1c2goZmlsbFdpdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcy5wdXNoKHRtcCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLmJhdGNoID0gYmF0Y2g7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgdmFyIHJldCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCByZXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXQuc2xpY2UoMSkpO1xufVxuXG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuXG5mdW5jdGlvbiBjZW50ZXIoc3RyLCB3aWR0aCkge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHdpZHRoID0gd2lkdGggfHwgODA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gd2lkdGgpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIHNwYWNlcyA9IHdpZHRoIC0gc3RyLmxlbmd0aDtcbiAgdmFyIHByZSA9IGxpYi5yZXBlYXQoJyAnLCBzcGFjZXMgLyAyIC0gc3BhY2VzICUgMik7XG4gIHZhciBwb3N0ID0gbGliLnJlcGVhdCgnICcsIHNwYWNlcyAvIDIpO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCBwcmUgKyBzdHIgKyBwb3N0KTtcbn1cblxuZXhwb3J0cy5jZW50ZXIgPSBjZW50ZXI7XG5cbmZ1bmN0aW9uIGRlZmF1bHRfKHZhbCwgZGVmLCBib29sKSB7XG4gIGlmIChib29sKSB7XG4gICAgcmV0dXJuIHZhbCB8fCBkZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmO1xuICB9XG59IC8vIFRPRE86IGl0IGlzIGNvbmZ1c2luZyB0byBleHBvcnQgc29tZXRoaW5nIGNhbGxlZCAnZGVmYXVsdCdcblxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBkZWZhdWx0XzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cblxuZnVuY3Rpb24gZGljdHNvcnQodmFsLCBjYXNlU2Vuc2l0aXZlLCBieSkge1xuICBpZiAoIWxpYi5pc09iamVjdCh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IGxpYi5UZW1wbGF0ZUVycm9yKCdkaWN0c29ydCBmaWx0ZXI6IHZhbCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIGFycmF5ID0gW107IC8vIGRlbGliZXJhdGVseSBpbmNsdWRlIHByb3BlcnRpZXMgZnJvbSB0aGUgb2JqZWN0J3MgcHJvdG90eXBlXG5cbiAgZm9yICh2YXIgayBpbiB2YWwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICBhcnJheS5wdXNoKFtrLCB2YWxba11dKTtcbiAgfVxuXG4gIHZhciBzaTtcblxuICBpZiAoYnkgPT09IHVuZGVmaW5lZCB8fCBieSA9PT0gJ2tleScpIHtcbiAgICBzaSA9IDA7XG4gIH0gZWxzZSBpZiAoYnkgPT09ICd2YWx1ZScpIHtcbiAgICBzaSA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGxpYi5UZW1wbGF0ZUVycm9yKCdkaWN0c29ydCBmaWx0ZXI6IFlvdSBjYW4gb25seSBzb3J0IGJ5IGVpdGhlciBrZXkgb3IgdmFsdWUnKTtcbiAgfVxuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24gKHQxLCB0Mikge1xuICAgIHZhciBhID0gdDFbc2ldO1xuICAgIHZhciBiID0gdDJbc2ldO1xuXG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBpZiAobGliLmlzU3RyaW5nKGEpKSB7XG4gICAgICAgIGEgPSBhLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaWIuaXNTdHJpbmcoYikpIHtcbiAgICAgICAgYiA9IGIudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA9PT0gYiA/IDAgOiAtMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnRzLmRpY3Rzb3J0ID0gZGljdHNvcnQ7XG5cbmZ1bmN0aW9uIGR1bXAob2JqLCBzcGFjZXMpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgc3BhY2VzKTtcbn1cblxuZXhwb3J0cy5kdW1wID0gZHVtcDtcblxuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICBpZiAoc3RyIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHN0ciA9IHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShsaWIuZXNjYXBlKHN0ci50b1N0cmluZygpKSk7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuXG5mdW5jdGlvbiBzYWZlKHN0cikge1xuICBpZiAoc3RyIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHN0ciA9IHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShzdHIudG9TdHJpbmcoKSk7XG59XG5cbmV4cG9ydHMuc2FmZSA9IHNhZmU7XG5cbmZ1bmN0aW9uIGZpcnN0KGFycikge1xuICByZXR1cm4gYXJyWzBdO1xufVxuXG5leHBvcnRzLmZpcnN0ID0gZmlyc3Q7XG5cbmZ1bmN0aW9uIGZvcmNlZXNjYXBlKHN0cikge1xuICBzdHIgPSBzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQgPyAnJyA6IHN0cjtcbiAgcmV0dXJuIHIubWFya1NhZmUobGliLmVzY2FwZShzdHIudG9TdHJpbmcoKSkpO1xufVxuXG5leHBvcnRzLmZvcmNlZXNjYXBlID0gZm9yY2Vlc2NhcGU7XG5cbmZ1bmN0aW9uIGdyb3VwYnkoYXJyLCBhdHRyKSB7XG4gIHJldHVybiBsaWIuZ3JvdXBCeShhcnIsIGF0dHIsIHRoaXMuZW52Lm9wdHMudGhyb3dPblVuZGVmaW5lZCk7XG59XG5cbmV4cG9ydHMuZ3JvdXBieSA9IGdyb3VwYnk7XG5cbmZ1bmN0aW9uIGluZGVudChzdHIsIHdpZHRoLCBpbmRlbnRmaXJzdCkge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG5cbiAgaWYgKHN0ciA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB3aWR0aCA9IHdpZHRoIHx8IDQ7IC8vIGxldCByZXMgPSAnJztcblxuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuICB2YXIgc3AgPSBsaWIucmVwZWF0KCcgJywgd2lkdGgpO1xuICB2YXIgcmVzID0gbGluZXMubWFwKGZ1bmN0aW9uIChsLCBpKSB7XG4gICAgcmV0dXJuIGkgPT09IDAgJiYgIWluZGVudGZpcnN0ID8gbCA6IFwiXCIgKyBzcCArIGw7XG4gIH0pLmpvaW4oJ1xcbicpO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCByZXMpO1xufVxuXG5leHBvcnRzLmluZGVudCA9IGluZGVudDtcblxuZnVuY3Rpb24gam9pbihhcnIsIGRlbCwgYXR0cikge1xuICBkZWwgPSBkZWwgfHwgJyc7XG5cbiAgaWYgKGF0dHIpIHtcbiAgICBhcnIgPSBsaWIubWFwKGFyciwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2W2F0dHJdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFyci5qb2luKGRlbCk7XG59XG5cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuXG5leHBvcnRzLmxhc3QgPSBsYXN0O1xuXG5mdW5jdGlvbiBsZW5ndGhGaWx0ZXIodmFsKSB7XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZSh2YWwsICcnKTtcblxuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIC8vIEVDTUFTY3JpcHQgMjAxNSBNYXBzIGFuZCBTZXRzXG4gICAgICByZXR1cm4gdmFsdWUuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAobGliLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSkge1xuICAgICAgLy8gT2JqZWN0cyAoYmVzaWRlcyBTYWZlU3RyaW5ncyksIG5vbi1wcmltYXRpdmUgQXJyYXlzXG4gICAgICByZXR1cm4gbGliLmtleXModmFsdWUpLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbmV4cG9ydHMubGVuZ3RoID0gbGVuZ3RoRmlsdGVyO1xuXG5mdW5jdGlvbiBsaXN0KHZhbCkge1xuICBpZiAobGliLmlzU3RyaW5nKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLnNwbGl0KCcnKTtcbiAgfSBlbHNlIGlmIChsaWIuaXNPYmplY3QodmFsKSkge1xuICAgIHJldHVybiBsaWIuX2VudHJpZXModmFsIHx8IHt9KS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBrZXkgPSBfcmVmWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZlsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobGliLmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGxpYi5UZW1wbGF0ZUVycm9yKCdsaXN0IGZpbHRlcjogdHlwZSBub3QgaXRlcmFibGUnKTtcbiAgfVxufVxuXG5leHBvcnRzLmxpc3QgPSBsaXN0O1xuXG5mdW5jdGlvbiBsb3dlcihzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydHMubG93ZXIgPSBsb3dlcjtcblxuZnVuY3Rpb24gbmwyYnIoc3RyKSB7XG4gIGlmIChzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCBzdHIucmVwbGFjZSgvXFxyXFxufFxcbi9nLCAnPGJyIC8+XFxuJykpO1xufVxuXG5leHBvcnRzLm5sMmJyID0gbmwyYnI7XG5cbmZ1bmN0aW9uIHJhbmRvbShhcnIpIHtcbiAgcmV0dXJuIGFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKV07XG59XG5cbmV4cG9ydHMucmFuZG9tID0gcmFuZG9tO1xuLyoqXG4gKiBDb25zdHJ1Y3Qgc2VsZWN0IG9yIHJlamVjdCBmaWx0ZXJcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdGVkVGVzdFJlc3VsdFxuICogQHJldHVybnMge2Z1bmN0aW9uKGFycmF5LCBzdHJpbmcsICopOiBhcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3RPclJlamVjdChleHBlY3RlZFRlc3RSZXN1bHQpIHtcbiAgZnVuY3Rpb24gZmlsdGVyKGFyciwgdGVzdE5hbWUsIHNlY29uZEFyZykge1xuICAgIGlmICh0ZXN0TmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0ZXN0TmFtZSA9ICd0cnV0aHknO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICB2YXIgdGVzdCA9IGNvbnRleHQuZW52LmdldFRlc3QodGVzdE5hbWUpO1xuICAgIHJldHVybiBsaWIudG9BcnJheShhcnIpLmZpbHRlcihmdW5jdGlvbiBleGFtaW5lVGVzdFJlc3VsdChpdGVtKSB7XG4gICAgICByZXR1cm4gdGVzdC5jYWxsKGNvbnRleHQsIGl0ZW0sIHNlY29uZEFyZykgPT09IGV4cGVjdGVkVGVzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXI7XG59XG5cbmV4cG9ydHMucmVqZWN0ID0gZ2V0U2VsZWN0T3JSZWplY3QoZmFsc2UpO1xuXG5mdW5jdGlvbiByZWplY3RhdHRyKGFyciwgYXR0cikge1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiAhaXRlbVthdHRyXTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucmVqZWN0YXR0ciA9IHJlamVjdGF0dHI7XG5leHBvcnRzLnNlbGVjdCA9IGdldFNlbGVjdE9yUmVqZWN0KHRydWUpO1xuXG5mdW5jdGlvbiBzZWxlY3RhdHRyKGFyciwgYXR0cikge1xuICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiAhIWl0ZW1bYXR0cl07XG4gIH0pO1xufVxuXG5leHBvcnRzLnNlbGVjdGF0dHIgPSBzZWxlY3RhdHRyO1xuXG5mdW5jdGlvbiByZXBsYWNlKHN0ciwgb2xkLCBuZXdfLCBtYXhDb3VudCkge1xuICB2YXIgb3JpZ2luYWxTdHIgPSBzdHI7XG5cbiAgaWYgKG9sZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShvbGQsIG5ld18pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtYXhDb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtYXhDb3VudCA9IC0xO1xuICB9XG5cbiAgdmFyIHJlcyA9ICcnOyAvLyBPdXRwdXRcbiAgLy8gQ2FzdCBOdW1iZXJzIGluIHRoZSBzZWFyY2ggdGVybSB0byBzdHJpbmdcblxuICBpZiAodHlwZW9mIG9sZCA9PT0gJ251bWJlcicpIHtcbiAgICBvbGQgPSAnJyArIG9sZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2xkICE9PSAnc3RyaW5nJykge1xuICAgIC8vIElmIGl0IGlzIHNvbWV0aGluZyBvdGhlciB0aGFuIG51bWJlciBvciBzdHJpbmcsXG4gICAgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJpbmdcbiAgICByZXR1cm4gc3RyO1xuICB9IC8vIENhc3QgbnVtYmVycyBpbiB0aGUgcmVwbGFjZW1lbnQgdG8gc3RyaW5nXG5cblxuICBpZiAodHlwZW9mIHN0ciA9PT0gJ251bWJlcicpIHtcbiAgICBzdHIgPSAnJyArIHN0cjtcbiAgfSAvLyBJZiBieSBub3csIHdlIGRvbid0IGhhdmUgYSBzdHJpbmcsIHRocm93IGl0IGJhY2tcblxuXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyAmJiAhKHN0ciBpbnN0YW5jZW9mIHIuU2FmZVN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9IC8vIFNob3J0Q2lyY3VpdHNcblxuXG4gIGlmIChvbGQgPT09ICcnKSB7XG4gICAgLy8gTWltaWMgdGhlIHB5dGhvbiBiZWhhdmlvdXI6IGVtcHR5IHN0cmluZyBpcyByZXBsYWNlZFxuICAgIC8vIGJ5IHJlcGxhY2VtZW50IGUuZy4gXCJhYmNcInxyZXBsYWNlKFwiXCIsIFwiLlwiKSAtPiAuYS5iLmMuXG4gICAgcmVzID0gbmV3XyArIHN0ci5zcGxpdCgnJykuam9pbihuZXdfKSArIG5ld187XG4gICAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0SW5kZXggPSBzdHIuaW5kZXhPZihvbGQpOyAvLyBpZiAjIG9mIHJlcGxhY2VtZW50cyB0byBwZXJmb3JtIGlzIDAsIG9yIHRoZSBzdHJpbmcgdG8gZG9lc1xuICAvLyBub3QgY29udGFpbiB0aGUgb2xkIHZhbHVlLCByZXR1cm4gdGhlIHN0cmluZ1xuXG4gIGlmIChtYXhDb3VudCA9PT0gMCB8fCBuZXh0SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBwb3MgPSAwO1xuICB2YXIgY291bnQgPSAwOyAvLyAjIG9mIHJlcGxhY2VtZW50cyBtYWRlXG5cbiAgd2hpbGUgKG5leHRJbmRleCA+IC0xICYmIChtYXhDb3VudCA9PT0gLTEgfHwgY291bnQgPCBtYXhDb3VudCkpIHtcbiAgICAvLyBHcmFiIHRoZSBuZXh0IGNodW5rIG9mIHNyYyBzdHJpbmcgYW5kIGFkZCBpdCB3aXRoIHRoZVxuICAgIC8vIHJlcGxhY2VtZW50LCB0byB0aGUgcmVzdWx0XG4gICAgcmVzICs9IHN0ci5zdWJzdHJpbmcocG9zLCBuZXh0SW5kZXgpICsgbmV3XzsgLy8gSW5jcmVtZW50IG91ciBwb2ludGVyIGluIHRoZSBzcmMgc3RyaW5nXG5cbiAgICBwb3MgPSBuZXh0SW5kZXggKyBvbGQubGVuZ3RoO1xuICAgIGNvdW50Kys7IC8vIFNlZSBpZiB0aGVyZSBhcmUgYW55IG1vcmUgcmVwbGFjZW1lbnRzIHRvIGJlIG1hZGVcblxuICAgIG5leHRJbmRleCA9IHN0ci5pbmRleE9mKG9sZCwgcG9zKTtcbiAgfSAvLyBXZSd2ZSBlaXRoZXIgcmVhY2hlZCB0aGUgZW5kLCBvciBkb25lIHRoZSBtYXggIyBvZlxuICAvLyByZXBsYWNlbWVudHMsIHRhY2sgb24gYW55IHJlbWFpbmluZyBzdHJpbmdcblxuXG4gIGlmIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgcmVzICs9IHN0ci5zdWJzdHJpbmcocG9zKTtcbiAgfVxuXG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhvcmlnaW5hbFN0ciwgcmVzKTtcbn1cblxuZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcblxuZnVuY3Rpb24gcmV2ZXJzZSh2YWwpIHtcbiAgdmFyIGFycjtcblxuICBpZiAobGliLmlzU3RyaW5nKHZhbCkpIHtcbiAgICBhcnIgPSBsaXN0KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29weSBpdFxuICAgIGFyciA9IGxpYi5tYXAodmFsLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSk7XG4gIH1cblxuICBhcnIucmV2ZXJzZSgpO1xuXG4gIGlmIChsaWIuaXNTdHJpbmcodmFsKSkge1xuICAgIHJldHVybiByLmNvcHlTYWZlbmVzcyh2YWwsIGFyci5qb2luKCcnKSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlO1xuXG5mdW5jdGlvbiByb3VuZCh2YWwsIHByZWNpc2lvbiwgbWV0aG9kKSB7XG4gIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gIHZhciByb3VuZGVyO1xuXG4gIGlmIChtZXRob2QgPT09ICdjZWlsJykge1xuICAgIHJvdW5kZXIgPSBNYXRoLmNlaWw7XG4gIH0gZWxzZSBpZiAobWV0aG9kID09PSAnZmxvb3InKSB7XG4gICAgcm91bmRlciA9IE1hdGguZmxvb3I7XG4gIH0gZWxzZSB7XG4gICAgcm91bmRlciA9IE1hdGgucm91bmQ7XG4gIH1cblxuICByZXR1cm4gcm91bmRlcih2YWwgKiBmYWN0b3IpIC8gZmFjdG9yO1xufVxuXG5leHBvcnRzLnJvdW5kID0gcm91bmQ7XG5cbmZ1bmN0aW9uIHNsaWNlKGFyciwgc2xpY2VzLCBmaWxsV2l0aCkge1xuICB2YXIgc2xpY2VMZW5ndGggPSBNYXRoLmZsb29yKGFyci5sZW5ndGggLyBzbGljZXMpO1xuICB2YXIgZXh0cmEgPSBhcnIubGVuZ3RoICUgc2xpY2VzO1xuICB2YXIgcmVzID0gW107XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VzOyBpKyspIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQgKyBpICogc2xpY2VMZW5ndGg7XG5cbiAgICBpZiAoaSA8IGV4dHJhKSB7XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gb2Zmc2V0ICsgKGkgKyAxKSAqIHNsaWNlTGVuZ3RoO1xuICAgIHZhciBjdXJyU2xpY2UgPSBhcnIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoZmlsbFdpdGggJiYgaSA+PSBleHRyYSkge1xuICAgICAgY3VyclNsaWNlLnB1c2goZmlsbFdpdGgpO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGN1cnJTbGljZSk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5cbmZ1bmN0aW9uIHN1bShhcnIsIGF0dHIsIHN0YXJ0KSB7XG4gIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKGF0dHIpIHtcbiAgICBhcnIgPSBsaWIubWFwKGFyciwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2W2F0dHJdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0ICsgYXJyLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhICsgYjtcbiAgfSwgMCk7XG59XG5cbmV4cG9ydHMuc3VtID0gc3VtO1xuZXhwb3J0cy5zb3J0ID0gci5tYWtlTWFjcm8oWyd2YWx1ZScsICdyZXZlcnNlJywgJ2Nhc2Vfc2Vuc2l0aXZlJywgJ2F0dHJpYnV0ZSddLCBbXSwgZnVuY3Rpb24gc29ydEZpbHRlcihhcnIsIHJldmVyc2VkLCBjYXNlU2VucywgYXR0cikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIENvcHkgaXRcbiAgdmFyIGFycmF5ID0gbGliLm1hcChhcnIsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xuICB2YXIgZ2V0QXR0cmlidXRlID0gbGliLmdldEF0dHJHZXR0ZXIoYXR0cik7XG4gIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgeCA9IGF0dHIgPyBnZXRBdHRyaWJ1dGUoYSkgOiBhO1xuICAgIHZhciB5ID0gYXR0ciA/IGdldEF0dHJpYnV0ZShiKSA6IGI7XG5cbiAgICBpZiAoX3RoaXMuZW52Lm9wdHMudGhyb3dPblVuZGVmaW5lZCAmJiBhdHRyICYmICh4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNvcnQ6IGF0dHJpYnV0ZSBcXFwiXCIgKyBhdHRyICsgXCJcXFwiIHJlc29sdmVkIHRvIHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhc2VTZW5zICYmIGxpYi5pc1N0cmluZyh4KSAmJiBsaWIuaXNTdHJpbmcoeSkpIHtcbiAgICAgIHggPSB4LnRvTG93ZXJDYXNlKCk7XG4gICAgICB5ID0geS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIHJldmVyc2VkID8gMSA6IC0xO1xuICAgIH0gZWxzZSBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiByZXZlcnNlZCA/IC0xIDogMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycmF5O1xufSk7XG5cbmZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKG9iaiwgb2JqKTtcbn1cblxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbmZ1bmN0aW9uIHN0cmlwdGFncyhpbnB1dCwgcHJlc2VydmVMaW5lYnJlYWtzKSB7XG4gIGlucHV0ID0gbm9ybWFsaXplKGlucHV0LCAnJyk7XG4gIHZhciB0YWdzID0gLzxcXC8/KFthLXpdW2EtejAtOV0qKVxcYltePl0qPnw8IS0tW1xcc1xcU10qPy0tPi9naTtcbiAgdmFyIHRyaW1tZWRJbnB1dCA9IHRyaW0oaW5wdXQucmVwbGFjZSh0YWdzLCAnJykpO1xuICB2YXIgcmVzID0gJyc7XG5cbiAgaWYgKHByZXNlcnZlTGluZWJyZWFrcykge1xuICAgIHJlcyA9IHRyaW1tZWRJbnB1dC5yZXBsYWNlKC9eICt8ICskL2dtLCAnJykgLy8gcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICAgIC5yZXBsYWNlKC8gKy9nLCAnICcpIC8vIHNxdWFzaCBhZGphY2VudCBzcGFjZXNcbiAgICAucmVwbGFjZSgvKFxcclxcbikvZywgJ1xcbicpIC8vIG5vcm1hbGl6ZSBsaW5lYnJlYWtzIChDUkxGIC0+IExGKVxuICAgIC5yZXBsYWNlKC9cXG5cXG5cXG4rL2csICdcXG5cXG4nKTsgLy8gc3F1YXNoIGFibm9ybWFsIGFkamFjZW50IGxpbmVicmVha3NcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB0cmltbWVkSW5wdXQucmVwbGFjZSgvXFxzKy9naSwgJyAnKTtcbiAgfVxuXG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhpbnB1dCwgcmVzKTtcbn1cblxuZXhwb3J0cy5zdHJpcHRhZ3MgPSBzdHJpcHRhZ3M7XG5cbmZ1bmN0aW9uIHRpdGxlKHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHZhciB3b3JkcyA9IHN0ci5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHJldHVybiBjYXBpdGFsaXplKHdvcmQpO1xuICB9KTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgd29yZHMuam9pbignICcpKTtcbn1cblxuZXhwb3J0cy50aXRsZSA9IHRpdGxlO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpKTtcbn1cblxuZXhwb3J0cy50cmltID0gdHJpbTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUoaW5wdXQsIGxlbmd0aCwga2lsbHdvcmRzLCBlbmQpIHtcbiAgdmFyIG9yaWcgPSBpbnB1dDtcbiAgaW5wdXQgPSBub3JtYWxpemUoaW5wdXQsICcnKTtcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IDI1NTtcblxuICBpZiAoaW5wdXQubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGlmIChraWxsd29yZHMpIHtcbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpZHggPSBpbnB1dC5sYXN0SW5kZXhPZignICcsIGxlbmd0aCk7XG5cbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgaWR4ID0gbGVuZ3RoO1xuICAgIH1cblxuICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIGlkeCk7XG4gIH1cblxuICBpbnB1dCArPSBlbmQgIT09IHVuZGVmaW5lZCAmJiBlbmQgIT09IG51bGwgPyBlbmQgOiAnLi4uJztcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKG9yaWcsIGlucHV0KTtcbn1cblxuZXhwb3J0cy50cnVuY2F0ZSA9IHRydW5jYXRlO1xuXG5mdW5jdGlvbiB1cHBlcihzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5cbmV4cG9ydHMudXBwZXIgPSB1cHBlcjtcblxuZnVuY3Rpb24gdXJsZW5jb2RlKG9iaikge1xuICB2YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gIGlmIChsaWIuaXNTdHJpbmcob2JqKSkge1xuICAgIHJldHVybiBlbmMob2JqKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5dmFscyA9IGxpYi5pc0FycmF5KG9iaikgPyBvYmogOiBsaWIuX2VudHJpZXMob2JqKTtcbiAgICByZXR1cm4ga2V5dmFscy5tYXAoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgayA9IF9yZWYyWzBdLFxuICAgICAgICAgIHYgPSBfcmVmMlsxXTtcbiAgICAgIHJldHVybiBlbmMoaykgKyBcIj1cIiArIGVuYyh2KTtcbiAgICB9KS5qb2luKCcmJyk7XG4gIH1cbn1cblxuZXhwb3J0cy51cmxlbmNvZGUgPSB1cmxlbmNvZGU7IC8vIEZvciB0aGUgamluamEgcmVnZXhwLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vamluamEyL2Jsb2IvZjE1YjgxNGRjYmE2YWExMmJjNzRkMWY3ZDBjODgxZDU1ZjcxMjZiZS9qaW5qYTIvdXRpbHMucHkjTDIwLUwyM1xuXG52YXIgcHVuY1JlID0gL14oPzpcXCh8PHwmbHQ7KT8oLio/KSg/OlxcLnwsfFxcKXxcXG58Jmd0Oyk/JC87IC8vIGZyb20gaHR0cDovL2Jsb2cuZ2Vydi5uZXQvMjAxMS8wNS9odG1sNV9lbWFpbF9hZGRyZXNzX3JlZ2V4cC9cblxudmFyIGVtYWlsUmUgPSAvXltcXHcuISMkJSYnKitcXC1cXC89P1xcXmB7fH1+XStAW2EtelxcZFxcLV0rKFxcLlthLXpcXGRcXC1dKykrJC9pO1xudmFyIGh0dHBIdHRwc1JlID0gL15odHRwcz86XFwvXFwvLiokLztcbnZhciB3d3dSZSA9IC9ed3d3XFwuLztcbnZhciB0bGRSZSA9IC9cXC4oPzpvcmd8bmV0fGNvbSkoPzpcXDp8XFwvfCQpLztcblxuZnVuY3Rpb24gdXJsaXplKHN0ciwgbGVuZ3RoLCBub2ZvbGxvdykge1xuICBpZiAoaXNOYU4obGVuZ3RoKSkge1xuICAgIGxlbmd0aCA9IEluZmluaXR5O1xuICB9XG5cbiAgdmFyIG5vRm9sbG93QXR0ciA9IG5vZm9sbG93ID09PSB0cnVlID8gJyByZWw9XCJub2ZvbGxvd1wiJyA6ICcnO1xuICB2YXIgd29yZHMgPSBzdHIuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcihmdW5jdGlvbiAod29yZCkge1xuICAgIC8vIElmIHRoZSB3b3JkIGhhcyBubyBsZW5ndGgsIGJhaWwuIFRoaXMgY2FuIGhhcHBlbiBmb3Igc3RyIHdpdGhcbiAgICAvLyB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIHJldHVybiB3b3JkICYmIHdvcmQubGVuZ3RoO1xuICB9KS5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHdvcmQubWF0Y2gocHVuY1JlKTtcbiAgICB2YXIgcG9zc2libGVVcmwgPSBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IHdvcmQ7XG4gICAgdmFyIHNob3J0VXJsID0gcG9zc2libGVVcmwuc3Vic3RyKDAsIGxlbmd0aCk7IC8vIHVybCB0aGF0IHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHNcblxuICAgIGlmIChodHRwSHR0cHNSZS50ZXN0KHBvc3NpYmxlVXJsKSkge1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiXCIgKyBwb3NzaWJsZVVybCArIFwiXFxcIlwiICsgbm9Gb2xsb3dBdHRyICsgXCI+XCIgKyBzaG9ydFVybCArIFwiPC9hPlwiO1xuICAgIH0gLy8gdXJsIHRoYXQgc3RhcnRzIHdpdGggd3d3LlxuXG5cbiAgICBpZiAod3d3UmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcImh0dHA6Ly9cIiArIHBvc3NpYmxlVXJsICsgXCJcXFwiXCIgKyBub0ZvbGxvd0F0dHIgKyBcIj5cIiArIHNob3J0VXJsICsgXCI8L2E+XCI7XG4gICAgfSAvLyBhbiBlbWFpbCBhZGRyZXNzIG9mIHRoZSBmb3JtIHVzZXJuYW1lQGRvbWFpbi50bGRcblxuXG4gICAgaWYgKGVtYWlsUmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIm1haWx0bzpcIiArIHBvc3NpYmxlVXJsICsgXCJcXFwiPlwiICsgcG9zc2libGVVcmwgKyBcIjwvYT5cIjtcbiAgICB9IC8vIHVybCB0aGF0IGVuZHMgaW4gLmNvbSwgLm9yZyBvciAubmV0IHRoYXQgaXMgbm90IGFuIGVtYWlsIGFkZHJlc3NcblxuXG4gICAgaWYgKHRsZFJlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJodHRwOi8vXCIgKyBwb3NzaWJsZVVybCArIFwiXFxcIlwiICsgbm9Gb2xsb3dBdHRyICsgXCI+XCIgKyBzaG9ydFVybCArIFwiPC9hPlwiO1xuICAgIH1cblxuICAgIHJldHVybiB3b3JkO1xuICB9KTtcbiAgcmV0dXJuIHdvcmRzLmpvaW4oJycpO1xufVxuXG5leHBvcnRzLnVybGl6ZSA9IHVybGl6ZTtcblxuZnVuY3Rpb24gd29yZGNvdW50KHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHZhciB3b3JkcyA9IHN0ciA/IHN0ci5tYXRjaCgvXFx3Ky9nKSA6IG51bGw7XG4gIHJldHVybiB3b3JkcyA/IHdvcmRzLmxlbmd0aCA6IG51bGw7XG59XG5cbmV4cG9ydHMud29yZGNvdW50ID0gd29yZGNvdW50O1xuXG5mdW5jdGlvbiBmbG9hdCh2YWwsIGRlZikge1xuICB2YXIgcmVzID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4ocmVzKSA/IGRlZiA6IHJlcztcbn1cblxuZXhwb3J0cy5mbG9hdCA9IGZsb2F0O1xudmFyIGludEZpbHRlciA9IHIubWFrZU1hY3JvKFsndmFsdWUnLCAnZGVmYXVsdCcsICdiYXNlJ10sIFtdLCBmdW5jdGlvbiBkb0ludCh2YWx1ZSwgZGVmYXVsdFZhbHVlLCBiYXNlKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICBiYXNlID0gMTA7XG4gIH1cblxuICB2YXIgcmVzID0gcGFyc2VJbnQodmFsdWUsIGJhc2UpO1xuICByZXR1cm4gaXNOYU4ocmVzKSA/IGRlZmF1bHRWYWx1ZSA6IHJlcztcbn0pO1xuZXhwb3J0cy5pbnQgPSBpbnRGaWx0ZXI7IC8vIEFsaWFzZXNcblxuZXhwb3J0cy5kID0gZXhwb3J0cy5kZWZhdWx0O1xuZXhwb3J0cy5lID0gZXhwb3J0cy5lc2NhcGU7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBMb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgUHJlY29tcGlsZWRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Mb2FkZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoUHJlY29tcGlsZWRMb2FkZXIsIF9Mb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIFByZWNvbXBpbGVkTG9hZGVyKGNvbXBpbGVkVGVtcGxhdGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfTG9hZGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5wcmVjb21waWxlZCA9IGNvbXBpbGVkVGVtcGxhdGVzIHx8IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQcmVjb21waWxlZExvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFNvdXJjZSA9IGZ1bmN0aW9uIGdldFNvdXJjZShuYW1lKSB7XG4gICAgaWYgKHRoaXMucHJlY29tcGlsZWRbbmFtZV0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICBvYmo6IHRoaXMucHJlY29tcGlsZWRbbmFtZV1cbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDogbmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUHJlY29tcGlsZWRMb2FkZXI7XG59KExvYWRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQcmVjb21waWxlZExvYWRlcjogUHJlY29tcGlsZWRMb2FkZXJcbn07XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFNhZmVTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLlNhZmVTdHJpbmc7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaXMgYSBmdW5jdGlvbiwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbGxhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydHMuY2FsbGFibGUgPSBjYWxsYWJsZTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBzdHJpY3RseSBub3QgYHVuZGVmaW5lZGAuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnRzLmRlZmluZWQgPSBkZWZpbmVkO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBkaXZpc2JsZSBieSB0aGUgdGVzdCdzIGFyZ3VtZW50XG4gKiAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGRpdmlzaWJsZWJ5KG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgJSB0d28gPT09IDA7XG59XG5cbmV4cG9ydHMuZGl2aXNpYmxlYnkgPSBkaXZpc2libGVieTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaGFzIGJlZW4gZXNjYXBlZCAoaS5lLiwgaXMgYSBTYWZlU3RyaW5nKS5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2FmZVN0cmluZztcbn1cblxuZXhwb3J0cy5lc2NhcGVkID0gZXNjYXBlZDtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKiBAcGFyYW0geyBhbnkgfSBvbmVcbiAqIEBwYXJhbSB7IGFueSB9IHR3b1xuICovXG5cbmZ1bmN0aW9uIGVxdWFsdG8ob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA9PT0gdHdvO1xufVxuXG5leHBvcnRzLmVxdWFsdG8gPSBlcXVhbHRvOyAvLyBBbGlhc2VzXG5cbmV4cG9ydHMuZXEgPSBleHBvcnRzLmVxdWFsdG87XG5leHBvcnRzLnNhbWVhcyA9IGV4cG9ydHMuZXF1YWx0bztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGV2ZW5seSBkaXZpc2libGUgYnkgMi5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMDtcbn1cblxuZXhwb3J0cy5ldmVuID0gZXZlbjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGZhbHN5IC0gaWYgSSByZWNhbGwgY29ycmVjdGx5LCAnJywgMCwgZmFsc2UsXG4gKiB1bmRlZmluZWQsIE5hTiBvciBudWxsLiBJIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHN0aWNrIHRvIHRoZSBkZWZhdWx0IEpTXG4gKiBiZWhhdmlvciBvciBhdHRlbXB0IHRvIHJlcGxpY2F0ZSB3aGF0IFB5dGhvbiBiZWxpZXZlcyBzaG91bGQgYmUgZmFsc3kgKGkuZS4sXG4gKiBlbXB0eSBhcnJheXMsIGVtcHR5IGRpY3RzLCBub3QgMC4uLikuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBmYWxzeSh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlO1xufVxuXG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG8gdGhlIHRlc3Qnc1xuICogYXJndW1lbnQgKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBnZShvbmUsIHR3bykge1xuICByZXR1cm4gb25lID49IHR3bztcbn1cblxuZXhwb3J0cy5nZSA9IGdlO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBncmVhdGVyIHRoYW4gdGhlIHRlc3QncyBhcmd1bWVudFxuICogKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBncmVhdGVydGhhbihvbmUsIHR3bykge1xuICByZXR1cm4gb25lID4gdHdvO1xufVxuXG5leHBvcnRzLmdyZWF0ZXJ0aGFuID0gZ3JlYXRlcnRoYW47IC8vIGFsaWFzXG5cbmV4cG9ydHMuZ3QgPSBleHBvcnRzLmdyZWF0ZXJ0aGFuO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRlc3Qnc1xuICogYXJndW1lbnQgKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBsZShvbmUsIHR3bykge1xuICByZXR1cm4gb25lIDw9IHR3bztcbn1cblxuZXhwb3J0cy5sZSA9IGxlO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gdGhlIHRlc3QncyBwYXNzZWQgYXJndW1lbnRcbiAqICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbGVzc3RoYW4ob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA8IHR3bztcbn1cblxuZXhwb3J0cy5sZXNzdGhhbiA9IGxlc3N0aGFuOyAvLyBhbGlhc1xuXG5leHBvcnRzLmx0ID0gZXhwb3J0cy5sZXNzdGhhbjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHN0cmluZyBpcyBsb3dlcmNhc2VkLlxuICogQHBhcmFtIHsgc3RyaW5nIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbG93ZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlO1xufVxuXG5leHBvcnRzLmxvd2VyID0gbG93ZXI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdGVzdCdzXG4gKiBhcmd1bWVudCAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIG5lKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgIT09IHR3bztcbn1cblxuZXhwb3J0cy5uZSA9IG5lO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHZhbHVlIGlzIHN0cmljdGx5IGVxdWFsIHRvIGBudWxsYC5cbiAqIEBwYXJhbSB7IGFueSB9XG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIG51bGxUZXN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cblxuZXhwb3J0cy5udWxsID0gbnVsbFRlc3Q7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7IGFueSB9XG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyAqbm90KiBldmVubHkgZGl2aXNpYmxlIGJ5IDIuXG4gKiBAcGFyYW0geyBudW1iZXIgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBvZGQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMTtcbn1cblxuZXhwb3J0cy5vZGQgPSBvZGQ7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgYGZhbHNlYCBpZiBub3QuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgbm90IGluIHRoZSBsaXN0IG9mIHRoaW5ncyBjb25zaWRlcmVkIGZhbHN5OlxuICogJycsIG51bGwsIHVuZGVmaW5lZCwgMCwgTmFOIGFuZCBmYWxzZS5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZTtcbn1cblxuZXhwb3J0cy50cnV0aHkgPSB0cnV0aHk7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiB1bmRlZmluZWRUZXN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnRzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZFRlc3Q7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzdHJpbmcgaXMgdXBwZXJjYXNlZC5cbiAqIEBwYXJhbSB7IHN0cmluZyB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIHVwcGVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50b1VwcGVyQ2FzZSgpID09PSB2YWx1ZTtcbn1cblxuZXhwb3J0cy51cHBlciA9IHVwcGVyO1xuLyoqXG4gKiBJZiBFUzYgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSwgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGltcGxlbWVudHMgdGhlXG4gKiBgU3ltYm9sLml0ZXJhdG9yYCBtZXRob2QuIElmIG5vdCwgaXQncyBhIHN0cmluZyBvciBBcnJheS5cbiAqXG4gKiBDb3VsZCBwb3RlbnRpYWxseSBjYXVzZSBpc3N1ZXMgaWYgYSBicm93c2VyIGV4aXN0cyB0aGF0IGhhcyBTZXQgYW5kIE1hcCBidXRcbiAqIG5vdCBTeW1ib2wuXG4gKlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICEhdmFsdWVbU3ltYm9sLml0ZXJhdG9yXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgfVxufVxuXG5leHBvcnRzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4vKipcbiAqIElmIEVTNiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlLCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGhhc2hcbiAqIG9yIGFuIEVTNiBNYXAuIE90aGVyd2lzZSBqdXN0IHJldHVybiBpZiBpdCdzIGFuIG9iamVjdCBoYXNoLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbWFwcGluZyh2YWx1ZSkge1xuICAvLyBvbmx5IG1hcHMgYW5kIG9iamVjdCBoYXNoZXNcbiAgdmFyIGJvb2wgPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gIGlmIChTZXQpIHtcbiAgICByZXR1cm4gYm9vbCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYm9vbDtcbiAgfVxufVxuXG5leHBvcnRzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jeWNsZXIoaXRlbXMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBpbmRleCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBpZiAoaW5kZXggPj0gaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50ID0gaXRlbXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9qb2luZXIoc2VwKSB7XG4gIHNlcCA9IHNlcCB8fCAnLCc7XG4gIHZhciBmaXJzdCA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGZpcnN0ID8gJycgOiBzZXA7XG4gICAgZmlyc3QgPSBmYWxzZTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xufSAvLyBNYWtpbmcgdGhpcyBhIGZ1bmN0aW9uIGluc3RlYWQgc28gaXQgcmV0dXJucyBhIG5ldyBvYmplY3Rcbi8vIGVhY2ggdGltZSBpdCdzIGNhbGxlZC4gVGhhdCB3YXksIGlmIHNvbWV0aGluZyBsaWtlIGFuIGVudmlyb25tZW50XG4vLyB1c2VzIGl0LCB0aGV5IHdpbGwgZWFjaCBoYXZlIHRoZWlyIG93biBjb3B5LlxuXG5cbmZ1bmN0aW9uIGdsb2JhbHMoKSB7XG4gIHJldHVybiB7XG4gICAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBzdGVwID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0ZXApIHtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcnIgPSBbXTtcblxuICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0b3A7IGkgKz0gc3RlcCkge1xuICAgICAgICAgIGFyci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaSA9IHN0YXJ0OyBfaSA+IHN0b3A7IF9pICs9IHN0ZXApIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZvci1kaXJlY3Rpb25cbiAgICAgICAgICBhcnIucHVzaChfaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIGN5Y2xlcjogZnVuY3Rpb24gY3ljbGVyKCkge1xuICAgICAgcmV0dXJuIF9jeWNsZXIoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfSxcbiAgICBqb2luZXI6IGZ1bmN0aW9uIGpvaW5lcihzZXApIHtcbiAgICAgIHJldHVybiBfam9pbmVyKHNlcCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbHM7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cHJlc3MoZW52LCBhcHApIHtcbiAgZnVuY3Rpb24gTnVuanVja3NWaWV3KG5hbWUsIG9wdHMpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucGF0aCA9IG5hbWU7XG4gICAgdGhpcy5kZWZhdWx0RW5naW5lID0gb3B0cy5kZWZhdWx0RW5naW5lO1xuICAgIHRoaXMuZXh0ID0gcGF0aC5leHRuYW1lKG5hbWUpO1xuXG4gICAgaWYgKCF0aGlzLmV4dCAmJiAhdGhpcy5kZWZhdWx0RW5naW5lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRlZmF1bHQgZW5naW5lIHdhcyBzcGVjaWZpZWQgYW5kIG5vIGV4dGVuc2lvbiB3YXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmV4dCkge1xuICAgICAgdGhpcy5uYW1lICs9IHRoaXMuZXh0ID0gKHRoaXMuZGVmYXVsdEVuZ2luZVswXSAhPT0gJy4nID8gJy4nIDogJycpICsgdGhpcy5kZWZhdWx0RW5naW5lO1xuICAgIH1cbiAgfVxuXG4gIE51bmp1Y2tzVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKG9wdHMsIGNiKSB7XG4gICAgZW52LnJlbmRlcih0aGlzLm5hbWUsIG9wdHMsIGNiKTtcbiAgfTtcblxuICBhcHAuc2V0KCd2aWV3JywgTnVuanVja3NWaWV3KTtcbiAgYXBwLnNldCgnbnVuanVja3NFbnYnLCBlbnYpO1xuICByZXR1cm4gZW52O1xufTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgX3ByZXR0aWZ5RXJyb3IgPSBfcmVxdWlyZS5fcHJldHRpZnlFcnJvcjtcblxudmFyIGNvbXBpbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oNyksXG4gICAgRW52aXJvbm1lbnQgPSBfcmVxdWlyZTIuRW52aXJvbm1lbnQ7XG5cbnZhciBwcmVjb21waWxlR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbmZ1bmN0aW9uIG1hdGNoKGZpbGVuYW1lLCBwYXR0ZXJucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0dGVybnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5zLnNvbWUoZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZmlsZW5hbWUubWF0Y2gocGF0dGVybik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlU3RyaW5nKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5pc1N0cmluZyA9IHRydWU7XG4gIHZhciBlbnYgPSBvcHRzLmVudiB8fCBuZXcgRW52aXJvbm1lbnQoW10pO1xuICB2YXIgd3JhcHBlciA9IG9wdHMud3JhcHBlciB8fCBwcmVjb21waWxlR2xvYmFsO1xuXG4gIGlmICghb3B0cy5uYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgXCJuYW1lXCIgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gY29tcGlsaW5nIGEgc3RyaW5nJyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcihbX3ByZWNvbXBpbGUoc3RyLCBvcHRzLm5hbWUsIGVudildLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gcHJlY29tcGlsZShpbnB1dCwgb3B0cykge1xuICAvLyBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGF2YWlsYWJsZTpcbiAgLy9cbiAgLy8gKiBuYW1lOiBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSAoYXV0by1nZW5lcmF0ZWQgd2hlbiBjb21waWxpbmcgYSBkaXJlY3RvcnkpXG4gIC8vICogaXNTdHJpbmc6IGlucHV0IGlzIGEgc3RyaW5nLCBub3QgYSBmaWxlIHBhdGhcbiAgLy8gKiBhc0Z1bmN0aW9uOiBnZW5lcmF0ZSBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gIC8vICogZm9yY2U6IGtlZXAgY29tcGlsaW5nIG9uIGVycm9yXG4gIC8vICogZW52OiB0aGUgRW52aXJvbm1lbnQgdG8gdXNlIChnZXRzIGV4dGVuc2lvbnMgYW5kIGFzeW5jIGZpbHRlcnMgZnJvbSBpdClcbiAgLy8gKiBpbmNsdWRlOiB3aGljaCBmaWxlL2ZvbGRlcnMgdG8gaW5jbHVkZSAoZm9sZGVycyBhcmUgYXV0by1pbmNsdWRlZCwgZmlsZXMgYXJlIGF1dG8tZXhjbHVkZWQpXG4gIC8vICogZXhjbHVkZTogd2hpY2ggZmlsZS9mb2xkZXJzIHRvIGV4Y2x1ZGUgKGZvbGRlcnMgYXJlIGF1dG8taW5jbHVkZWQsIGZpbGVzIGFyZSBhdXRvLWV4Y2x1ZGVkKVxuICAvLyAqIHdyYXBwZXI6IGZ1bmN0aW9uKHRlbXBsYXRlcywgb3B0cykgey4uLn1cbiAgLy8gICAgICAgQ3VzdG9taXplIHRoZSBvdXRwdXQgZm9ybWF0IHRvIHN0b3JlIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgLy8gICAgICAgQnkgZGVmYXVsdCwgdGVtcGxhdGVzIGFyZSBzdG9yZWQgaW4gYSBnbG9iYWwgdmFyaWFibGUgdXNlZCBieSB0aGUgcnVudGltZS5cbiAgLy8gICAgICAgQSBjdXN0b20gbG9hZGVyIHdpbGwgYmUgbmVjZXNzYXJ5IHRvIGxvYWQgeW91ciBjdXN0b20gd3JhcHBlci5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBlbnYgPSBvcHRzLmVudiB8fCBuZXcgRW52aXJvbm1lbnQoW10pO1xuICB2YXIgd3JhcHBlciA9IG9wdHMud3JhcHBlciB8fCBwcmVjb21waWxlR2xvYmFsO1xuXG4gIGlmIChvcHRzLmlzU3RyaW5nKSB7XG4gICAgcmV0dXJuIHByZWNvbXBpbGVTdHJpbmcoaW5wdXQsIG9wdHMpO1xuICB9XG5cbiAgdmFyIHBhdGhTdGF0cyA9IGZzLmV4aXN0c1N5bmMoaW5wdXQpICYmIGZzLnN0YXRTeW5jKGlucHV0KTtcbiAgdmFyIHByZWNvbXBpbGVkID0gW107XG4gIHZhciB0ZW1wbGF0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRUZW1wbGF0ZXMoZGlyKSB7XG4gICAgZnMucmVhZGRpclN5bmMoZGlyKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICB2YXIgZmlsZXBhdGggPSBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcbiAgICAgIHZhciBzdWJwYXRoID0gZmlsZXBhdGguc3Vic3RyKHBhdGguam9pbihpbnB1dCwgJy8nKS5sZW5ndGgpO1xuICAgICAgdmFyIHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlcGF0aCk7XG5cbiAgICAgIGlmIChzdGF0ICYmIHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBzdWJwYXRoICs9ICcvJztcblxuICAgICAgICBpZiAoIW1hdGNoKHN1YnBhdGgsIG9wdHMuZXhjbHVkZSkpIHtcbiAgICAgICAgICBhZGRUZW1wbGF0ZXMoZmlsZXBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKHN1YnBhdGgsIG9wdHMuaW5jbHVkZSkpIHtcbiAgICAgICAgdGVtcGxhdGVzLnB1c2goZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBhdGhTdGF0cy5pc0ZpbGUoKSkge1xuICAgIHByZWNvbXBpbGVkLnB1c2goX3ByZWNvbXBpbGUoZnMucmVhZEZpbGVTeW5jKGlucHV0LCAndXRmLTgnKSwgb3B0cy5uYW1lIHx8IGlucHV0LCBlbnYpKTtcbiAgfSBlbHNlIGlmIChwYXRoU3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGFkZFRlbXBsYXRlcyhpbnB1dCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSB0ZW1wbGF0ZXNbaV0ucmVwbGFjZShwYXRoLmpvaW4oaW5wdXQsICcvJyksICcnKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJlY29tcGlsZWQucHVzaChfcHJlY29tcGlsZShmcy5yZWFkRmlsZVN5bmModGVtcGxhdGVzW2ldLCAndXRmLTgnKSwgbmFtZSwgZW52KSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChvcHRzLmZvcmNlKSB7XG4gICAgICAgICAgLy8gRG9uJ3Qgc3RvcCBnZW5lcmF0aW5nIHRoZSBvdXRwdXQgaWYgd2UncmVcbiAgICAgICAgICAvLyBmb3JjaW5nIGNvbXBpbGF0aW9uLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcihwcmVjb21waWxlZCwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIF9wcmVjb21waWxlKHN0ciwgbmFtZSwgZW52KSB7XG4gIGVudiA9IGVudiB8fCBuZXcgRW52aXJvbm1lbnQoW10pO1xuICB2YXIgYXN5bmNGaWx0ZXJzID0gZW52LmFzeW5jRmlsdGVycztcbiAgdmFyIGV4dGVuc2lvbnMgPSBlbnYuZXh0ZW5zaW9uc0xpc3Q7XG4gIHZhciB0ZW1wbGF0ZTtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuXG4gIHRyeSB7XG4gICAgdGVtcGxhdGUgPSBjb21waWxlci5jb21waWxlKHN0ciwgYXN5bmNGaWx0ZXJzLCBleHRlbnNpb25zLCBuYW1lLCBlbnYub3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9wcmV0dGlmeUVycm9yKG5hbWUsIGZhbHNlLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJlY29tcGlsZTogcHJlY29tcGlsZSxcbiAgcHJlY29tcGlsZVN0cmluZzogcHJlY29tcGlsZVN0cmluZ1xufTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBwcmVjb21waWxlR2xvYmFsKHRlbXBsYXRlcywgb3B0cykge1xuICB2YXIgb3V0ID0gJyc7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBKU09OLnN0cmluZ2lmeSh0ZW1wbGF0ZXNbaV0ubmFtZSk7XG4gICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVzW2ldLnRlbXBsYXRlO1xuICAgIG91dCArPSAnKGZ1bmN0aW9uKCkgeycgKyAnKHdpbmRvdy5udW5qdWNrc1ByZWNvbXBpbGVkID0gd2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQgfHwge30pJyArICdbJyArIG5hbWUgKyAnXSA9IChmdW5jdGlvbigpIHtcXG4nICsgdGVtcGxhdGUgKyAnXFxufSkoKTtcXG4nO1xuXG4gICAgaWYgKG9wdHMuYXNGdW5jdGlvbikge1xuICAgICAgb3V0ICs9ICdyZXR1cm4gZnVuY3Rpb24oY3R4LCBjYikgeyByZXR1cm4gbnVuanVja3MucmVuZGVyKCcgKyBuYW1lICsgJywgY3R4LCBjYik7IH1cXG4nO1xuICAgIH1cblxuICAgIG91dCArPSAnfSkoKTtcXG4nO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVjb21waWxlR2xvYmFsO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wYXQoKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgbGlrZSBgbnVuanVja3MuaW5zdGFsbENvbXBhdGAgc28gdGhhdCBgdGhpc2BcbiAgLy8gcmVmZXJlbmNlcyB0aGUgbnVuanVja3MgaW5zdGFuY2VcblxuICB2YXIgcnVudGltZSA9IHRoaXMucnVudGltZTtcbiAgdmFyIGxpYiA9IHRoaXMubGliOyAvLyBIYW5kbGUgc2xpbSBjYXNlIHdoZXJlIHRoZXNlICdtb2R1bGVzJyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgYnVpbHQgc291cmNlXG5cbiAgdmFyIENvbXBpbGVyID0gdGhpcy5jb21waWxlci5Db21waWxlcjtcbiAgdmFyIFBhcnNlciA9IHRoaXMucGFyc2VyLlBhcnNlcjtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIGxleGVyID0gdGhpcy5sZXhlcjtcbiAgdmFyIG9yaWdfY29udGV4dE9yRnJhbWVMb29rdXAgPSBydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwO1xuICB2YXIgb3JpZ19tZW1iZXJMb29rdXAgPSBydW50aW1lLm1lbWJlckxvb2t1cDtcbiAgdmFyIG9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZTtcbiAgdmFyIG9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlO1xuXG4gIGlmIChDb21waWxlcikge1xuICAgIG9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZSA9IENvbXBpbGVyLnByb3RvdHlwZS5hc3NlcnRUeXBlO1xuICB9XG5cbiAgaWYgKFBhcnNlcikge1xuICAgIG9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFnZ3JlZ2F0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICBydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwID0gb3JpZ19jb250ZXh0T3JGcmFtZUxvb2t1cDtcbiAgICBydW50aW1lLm1lbWJlckxvb2t1cCA9IG9yaWdfbWVtYmVyTG9va3VwO1xuXG4gICAgaWYgKENvbXBpbGVyKSB7XG4gICAgICBDb21waWxlci5wcm90b3R5cGUuYXNzZXJ0VHlwZSA9IG9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZTtcbiAgICB9XG5cbiAgICBpZiAoUGFyc2VyKSB7XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWdncmVnYXRlID0gb3JpZ19QYXJzZXJfcGFyc2VBZ2dyZWdhdGU7XG4gICAgfVxuICB9XG5cbiAgcnVudGltZS5jb250ZXh0T3JGcmFtZUxvb2t1cCA9IGZ1bmN0aW9uIGNvbnRleHRPckZyYW1lTG9va3VwKGNvbnRleHQsIGZyYW1lLCBrZXkpIHtcbiAgICB2YXIgdmFsID0gb3JpZ19jb250ZXh0T3JGcmFtZUxvb2t1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdUcnVlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgJ0ZhbHNlJzpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlICdOb25lJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRva2Vuc1N0YXRlKHRva2Vucykge1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogdG9rZW5zLmluZGV4LFxuICAgICAgbGluZW5vOiB0b2tlbnMubGluZW5vLFxuICAgICAgY29sbm86IHRva2Vucy5jb2xub1xuICAgIH07XG4gIH1cblxuICBpZiAoXCJTVERcIiAhPT0gJ1NMSU0nICYmIG5vZGVzICYmIENvbXBpbGVyICYmIFBhcnNlcikge1xuICAgIC8vIGkuZS4sIG5vdCBzbGltIG1vZGVcbiAgICB2YXIgU2xpY2UgPSBub2Rlcy5Ob2RlLmV4dGVuZCgnU2xpY2UnLCB7XG4gICAgICBmaWVsZHM6IFsnc3RhcnQnLCAnc3RvcCcsICdzdGVwJ10sXG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KGxpbmVubywgY29sbm8sIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgbmV3IG5vZGVzLkxpdGVyYWwobGluZW5vLCBjb2xubywgbnVsbCk7XG4gICAgICAgIHN0b3AgPSBzdG9wIHx8IG5ldyBub2Rlcy5MaXRlcmFsKGxpbmVubywgY29sbm8sIG51bGwpO1xuICAgICAgICBzdGVwID0gc3RlcCB8fCBuZXcgbm9kZXMuTGl0ZXJhbChsaW5lbm8sIGNvbG5vLCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQobGluZW5vLCBjb2xubywgc3RhcnQsIHN0b3AsIHN0ZXApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgQ29tcGlsZXIucHJvdG90eXBlLmFzc2VydFR5cGUgPSBmdW5jdGlvbiBhc3NlcnRUeXBlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU2xpY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVTbGljZSA9IGZ1bmN0aW9uIGNvbXBpbGVTbGljZShub2RlLCBmcmFtZSkge1xuICAgICAgdGhpcy5fZW1pdCgnKCcpO1xuXG4gICAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnN0YXJ0LCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJyksKCcpO1xuXG4gICAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnN0b3AsIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdCgnKSwoJyk7XG5cbiAgICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuc3RlcCwgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0KCcpJyk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBZ2dyZWdhdGUgPSBmdW5jdGlvbiBwYXJzZUFnZ3JlZ2F0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBvcmlnU3RhdGUgPSBnZXRUb2tlbnNTdGF0ZSh0aGlzLnRva2Vucyk7IC8vIFNldCBiYWNrIG9uZSBhY2NvdW50aW5nIGZvciBvcGVuaW5nIGJyYWNrZXQvcGFyZW5zXG5cbiAgICAgIG9yaWdTdGF0ZS5jb2xuby0tO1xuICAgICAgb3JpZ1N0YXRlLmluZGV4LS07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZS5hcHBseSh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGVyclN0YXRlID0gZ2V0VG9rZW5zU3RhdGUodGhpcy50b2tlbnMpO1xuXG4gICAgICAgIHZhciByZXRocm93ID0gZnVuY3Rpb24gcmV0aHJvdygpIHtcbiAgICAgICAgICBsaWIuX2Fzc2lnbihfdGhpcy50b2tlbnMsIGVyclN0YXRlKTtcblxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9OyAvLyBSZXNldCB0byBzdGF0ZSBiZWZvcmUgb3JpZ2luYWwgcGFyc2VBZ2dyZWdhdGUgY2FsbGVkXG5cblxuICAgICAgICBsaWIuX2Fzc2lnbih0aGlzLnRva2Vucywgb3JpZ1N0YXRlKTtcblxuICAgICAgICB0aGlzLnBlZWtlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgICAgICBpZiAodG9rLnR5cGUgIT09IGxleGVyLlRPS0VOX0xFRlRfQlJBQ0tFVCkge1xuICAgICAgICAgIHRocm93IHJldGhyb3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgU2xpY2UodG9rLmxpbmVubywgdG9rLmNvbG5vKTsgLy8gSWYgd2UgZG9uJ3QgZW5jb3VudGVyIGEgY29sb24gd2hpbGUgcGFyc2luZywgdGhpcyBpcyBub3QgYSBzbGljZSxcbiAgICAgICAgLy8gc28gcmUtcmFpc2UgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi5cblxuICAgICAgICB2YXIgaXNTbGljZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG5vZGUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2tpcChsZXhlci5UT0tFTl9SSUdIVF9CUkFDS0VUKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPT09IG5vZGUuZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGlzU2xpY2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKCdwYXJzZVNsaWNlOiB0b28gbWFueSBzbGljZSBjb21wb25lbnRzJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09MT04pKSB7XG4gICAgICAgICAgICBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbm9kZS5maWVsZHNbaV07XG4gICAgICAgICAgICBub2RlW2ZpZWxkXSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgICBpc1NsaWNlID0gdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTE9OKSB8fCBpc1NsaWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTbGljZSkge1xuICAgICAgICAgIHRocm93IHJldGhyb3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgbm9kZXMuQXJyYXkodG9rLmxpbmVubywgdG9rLmNvbG5vLCBbbm9kZV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzbGljZUxvb2t1cChvYmosIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgb2JqID0gb2JqIHx8IFtdO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICBzdGFydCA9IHN0ZXAgPCAwID8gb2JqLmxlbmd0aCAtIDEgOiAwO1xuICAgIH1cblxuICAgIGlmIChzdG9wID09PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RlcCA8IDAgPyAtMSA6IG9iai5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChzdG9wIDwgMCkge1xuICAgICAgc3RvcCArPSBvYmoubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ICs9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDs7IGkgKz0gc3RlcCkge1xuICAgICAgaWYgKGkgPCAwIHx8IGkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCA+IDAgJiYgaSA+PSBzdG9wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCA8IDAgJiYgaSA8PSBzdG9wKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRzLnB1c2gocnVudGltZS5tZW1iZXJMb29rdXAob2JqLCBpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH1cblxuICB2YXIgQVJSQVlfTUVNQkVSUyA9IHtcbiAgICBwb3A6IGZ1bmN0aW9uIHBvcChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0sXG4gICAgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaChlbGVtZW50KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlRXJyb3InKTtcbiAgICB9LFxuICAgIGNvdW50OiBmdW5jdGlvbiBjb3VudChlbGVtZW50KSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuICAgIGluZGV4OiBmdW5jdGlvbiBpbmRleChlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKChpID0gdGhpcy5pbmRleE9mKGVsZW1lbnQpKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZUVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoaW5kZXgsIGVsZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgZWxlbSk7XG4gICAgfVxuICB9O1xuICB2YXIgT0JKRUNUX01FTUJFUlMgPSB7XG4gICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgICAgcmV0dXJuIGxpYi5fZW50cmllcyh0aGlzKTtcbiAgICB9LFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIGxpYi5fdmFsdWVzKHRoaXMpO1xuICAgIH0sXG4gICAga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgICAgIHJldHVybiBsaWIua2V5cyh0aGlzKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSwgZGVmKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpc1trZXldO1xuXG4gICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0ID0gZGVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG4gICAgaGFzX2tleTogZnVuY3Rpb24gaGFzX2tleShrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBwb3A6IGZ1bmN0aW9uIHBvcChrZXksIGRlZikge1xuICAgICAgdmFyIG91dHB1dCA9IHRoaXNba2V5XTtcblxuICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkICYmIGRlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dCA9IGRlZjtcbiAgICAgIH0gZWxzZSBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlFcnJvcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIHBvcGl0ZW06IGZ1bmN0aW9uIHBvcGl0ZW0oKSB7XG4gICAgICB2YXIga2V5cyA9IGxpYi5rZXlzKHRoaXMpO1xuXG4gICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5RXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGsgPSBrZXlzWzBdO1xuICAgICAgdmFyIHZhbCA9IHRoaXNba107XG4gICAgICBkZWxldGUgdGhpc1trXTtcbiAgICAgIHJldHVybiBbaywgdmFsXTtcbiAgICB9LFxuICAgIHNldGRlZmF1bHQ6IGZ1bmN0aW9uIHNldGRlZmF1bHQoa2V5LCBkZWYpIHtcbiAgICAgIGlmIChkZWYgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWYgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShrZXkgaW4gdGhpcykpIHtcbiAgICAgICAgdGhpc1trZXldID0gZGVmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoa3dhcmdzKSB7XG4gICAgICBsaWIuX2Fzc2lnbih0aGlzLCBrd2FyZ3MpO1xuXG4gICAgICByZXR1cm4gbnVsbDsgLy8gQWx3YXlzIHJldHVybnMgTm9uZVxuICAgIH1cbiAgfTtcbiAgT0JKRUNUX01FTUJFUlMuaXRlcml0ZW1zID0gT0JKRUNUX01FTUJFUlMuaXRlbXM7XG4gIE9CSkVDVF9NRU1CRVJTLml0ZXJ2YWx1ZXMgPSBPQkpFQ1RfTUVNQkVSUy52YWx1ZXM7XG4gIE9CSkVDVF9NRU1CRVJTLml0ZXJrZXlzID0gT0JKRUNUX01FTUJFUlMua2V5cztcblxuICBydW50aW1lLm1lbWJlckxvb2t1cCA9IGZ1bmN0aW9uIG1lbWJlckxvb2t1cChvYmosIHZhbCwgYXV0b2VzY2FwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gc2xpY2VMb29rdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBvYmogPSBvYmogfHwge307IC8vIElmIHRoZSBvYmplY3QgaXMgYW4gb2JqZWN0LCByZXR1cm4gYW55IG9mIHRoZSBtZXRob2RzIHRoYXQgUHl0aG9uIHdvdWxkXG4gICAgLy8gb3RoZXJ3aXNlIHByb3ZpZGUuXG5cbiAgICBpZiAobGliLmlzQXJyYXkob2JqKSAmJiBoYXNPd25Qcm9wKEFSUkFZX01FTUJFUlMsIHZhbCkpIHtcbiAgICAgIHJldHVybiBBUlJBWV9NRU1CRVJTW3ZhbF0uYmluZChvYmopO1xuICAgIH1cblxuICAgIGlmIChsaWIuaXNPYmplY3Qob2JqKSAmJiBoYXNPd25Qcm9wKE9CSkVDVF9NRU1CRVJTLCB2YWwpKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX01FTUJFUlNbdmFsXS5iaW5kKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdfbWVtYmVyTG9va3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIHVuaW5zdGFsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YWxsQ29tcGF0O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bmp1Y2tzLmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBSZXNvbmFuY2VBdWRpbyBsaWJyYXJ5IGNvbW1vbiB1dGlsaXRpZXMsIG1hdGhlbWF0aWNhbCBjb25zdGFudHMsXG4gKiBhbmQgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vKipcbiAqIEBjbGFzcyBVdGlsc1xuICogQGRlc2NyaXB0aW9uIEEgc2V0IG9mIGRlZmF1bHRzLCBjb25zdGFudHMgYW5kIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBVdGlscygpIHt9O1xuXG5cbi8qKlxuICogRGVmYXVsdCBpbnB1dCBnYWluIChsaW5lYXIpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9TT1VSQ0VfR0FJTiA9IDE7XG5cblxuLyoqXG4gKiBNYXhpbXVtIG91dHNpZGUtdGhlLXJvb20gZGlzdGFuY2UgdG8gYXR0ZW51YXRlIGZhci1maWVsZCBsaXN0ZW5lciBieS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkxJU1RFTkVSX01BWF9PVVRTSURFX1JPT01fRElTVEFOQ0UgPSAxO1xuXG5cbi8qKlxuICogTWF4aW11bSBvdXRzaWRlLXRoZS1yb29tIGRpc3RhbmNlIHRvIGF0dGVudWF0ZSBmYXItZmllbGQgc291cmNlcyBieS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLlNPVVJDRV9NQVhfT1VUU0lERV9ST09NX0RJU1RBTkNFID0gMTtcblxuXG4vKipcbiAqIERlZmF1bHQgZGlzdGFuY2UgZnJvbSBsaXN0ZW5lciB3aGVuIHNldHRpbmcgYW5nbGUuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1NPVVJDRV9ESVNUQU5DRSA9IDE7XG5cblxuLyoqIEB0eXBlIHtGbG9hdDMyQXJyYXl9ICovXG5VdGlscy5ERUZBVUxUX1BPU0lUSU9OID0gWzAsIDAsIDBdO1xuXG5cbi8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xuVXRpbHMuREVGQVVMVF9GT1JXQVJEID0gWzAsIDAsIC0xXTtcblxuXG4vKiogQHR5cGUge0Zsb2F0MzJBcnJheX0gKi9cblV0aWxzLkRFRkFVTFRfVVAgPSBbMCwgMSwgMF07XG5cblxuLyoqIEB0eXBlIHtGbG9hdDMyQXJyYXl9ICovXG5VdGlscy5ERUZBVUxUX1JJR0hUID0gWzEsIDAsIDBdO1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORCA9IDM0MztcblxuXG4vKiogUm9sbG9mZiBtb2RlbHMgKGUuZy4gJ2xvZ2FyaXRobWljJywgJ2xpbmVhcicsIG9yICdub25lJykuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTID0gWydsb2dhcml0aG1pYycsICdsaW5lYXInLCAnbm9uZSddO1xuXG5cbi8qKiBEZWZhdWx0IHJvbGxvZmYgbW9kZWwgKCdsb2dhcml0aG1pYycpLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGID0gJ2xvZ2FyaXRobWljJztcblxuXG4vKiogQHR5cGUge051bWJlcn0gKi9cblV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFID0gMTtcblxuXG4vKiogQHR5cGUge051bWJlcn0gKi9cblV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFID0gMTAwMDtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFscGhhIChpLmUuIG1pY3JvcGhvbmUgcGF0dGVybikuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBID0gMDtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHBhdHRlcm4gc2hhcnBuZXNzIChpLmUuIHBhdHRlcm4gZXhwb25lbnQpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1MgPSAxO1xuXG5cbi8qKlxuICogRGVmYXVsdCBhemltdXRoIChpbiBkZWdyZWVzKS4gU3VpdGFibGUgcmFuZ2UgaXMgMCB0byAzNjAuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX0FaSU1VVEggPSAwO1xuXG5cbi8qKlxuICogRGVmYXVsdCBlbGV2YXRpb24gKGluIGRlZ3JlcykuXG4gKiBTdWl0YWJsZSByYW5nZSBpcyBmcm9tIC05MCAoYmVsb3cpIHRvIDkwIChhYm92ZSkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX0VMRVZBVElPTiA9IDA7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUiA9IDE7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzb3VyY2Ugd2lkdGguXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSCA9IDA7XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBkZWxheSAoaW4gc2Vjb25kcykgb2YgYSBzaW5nbGUgd2FsbCByZWZsZWN0aW9uLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01BWF9EVVJBVElPTiA9IDAuNTtcblxuXG4vKipcbiAqIFRoZSAtMTJkQiBjdXRvZmYgZnJlcXVlbmN5IChpbiBIZXJ0eikgZm9yIHRoZSBsb3dwYXNzIGZpbHRlciBhcHBsaWVkIHRvXG4gKiBhbGwgcmVmbGVjdGlvbnMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ1VUT0ZGX0ZSRVFVRU5DWSA9IDY0MDA7IC8vIFVzZXMgLTEyZEIgY3V0b2ZmLlxuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcmVmbGVjdGlvbiBjb2VmZmljaWVudHMgKHdoZXJlIDAgPSBubyByZWZsZWN0aW9uLCAxID0gcGVyZmVjdFxuICogcmVmbGVjdGlvbiwgLTEgPSBtaXJyb3JlZCByZWZsZWN0aW9uICgxODAtZGVncmVlcyBvdXQgb2YgcGhhc2UpKS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMgPSB7XG4gIGxlZnQ6IDAsIHJpZ2h0OiAwLCBmcm9udDogMCwgYmFjazogMCwgZG93bjogMCwgdXA6IDAsXG59O1xuXG5cbi8qKlxuICogVGhlIG1pbmltdW0gZGlzdGFuY2Ugd2UgY29uc2lkZXIgdGhlIGxpc3RlbmVyIHRvIGJlIHRvIGFueSBnaXZlbiB3YWxsLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSA9IDE7XG5cblxuLyoqXG4gKiBEZWZhdWx0IHJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TID0ge1xuICB3aWR0aDogMCwgaGVpZ2h0OiAwLCBkZXB0aDogMCxcbn07XG5cblxuLyoqXG4gKiBUaGUgbXVsdGlwbGllciB0byBhcHBseSB0byBkaXN0YW5jZXMgZnJvbSB0aGUgbGlzdGVuZXIgdG8gZWFjaCB3YWxsLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgPSAxO1xuXG5cbi8qKiBUaGUgZGVmYXVsdCBiYW5kd2lkdGggKGluIG9jdGF2ZXMpIG9mIHRoZSBjZW50ZXIgZnJlcXVlbmNpZXMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9CQU5EV0lEVEggPSAxO1xuXG5cbi8qKiBUaGUgZGVmYXVsdCBtdWx0aXBsaWVyIGFwcGxpZWQgd2hlbiBjb21wdXRpbmcgdGFpbCBsZW5ndGhzLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfRFVSQVRJT05fTVVMVElQTElFUiA9IDE7XG5cblxuLyoqXG4gKiBUaGUgbGF0ZSByZWZsZWN0aW9ucyBwcmUtZGVsYXkgKGluIG1pbGxpc2Vjb25kcykuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9QUkVERUxBWSA9IDEuNTtcblxuXG4vKipcbiAqIFRoZSBsZW5ndGggb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgaW1wdWxzZSByZXNwb25zZSB0byBhcHBseSBhXG4gKiBoYWxmLUhhbm4gd2luZG93IHRvLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfVEFJTF9PTlNFVCA9IDMuODtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGdhaW4gKGxpbmVhcikuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9HQUlOID0gMC4wMTtcblxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGltcHVsc2UgcmVzcG9uc2UgbGVuZ3RoIChpbiBzZWNvbmRzKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX01BWF9EVVJBVElPTiA9IDM7XG5cblxuLyoqXG4gKiBDZW50ZXIgZnJlcXVlbmNpZXMgb2YgdGhlIG11bHRpYmFuZCBsYXRlIHJlZmxlY3Rpb25zLlxuICogTmluZSBiYW5kcyBhcmUgY29tcHV0ZWQgYnk6IDMxLjI1ICogMl4oMDo4KS5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTID0gW1xuICAzMS4yNSwgNjIuNSwgMTI1LCAyNTAsIDUwMCwgMTAwMCwgMjAwMCwgNDAwMCwgODAwMCxcbl07XG5cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGZyZXF1ZW5jeSBiYW5kcy5cbiAqL1xuVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMgPVxuICBVdGlscy5ERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMubGVuZ3RoO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbXVsdGliYW5kIFJUNjAgZHVyYXRpb25zIChpbiBzZWNvbmRzKS5cbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX0RVUkFUSU9OUyA9XG4gIG5ldyBGbG9hdDMyQXJyYXkoVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMpO1xuXG5cbi8qKlxuICogUHJlLWRlZmluZWQgZnJlcXVlbmN5LWRlcGVuZGVudCBhYnNvcnB0aW9uIGNvZWZmaWNpZW50cyBmb3IgbGlzdGVkIG1hdGVyaWFscy5cbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgbWF0ZXJpYWxzIGFyZTpcbiAqIDx1bD5cbiAqIDxsaT4ndHJhbnNwYXJlbnQnPC9saT5cbiAqIDxsaT4nYWNvdXN0aWMtY2VpbGluZy10aWxlcyc8L2xpPlxuICogPGxpPidicmljay1iYXJlJzwvbGk+XG4gKiA8bGk+J2JyaWNrLXBhaW50ZWQnPC9saT5cbiAqIDxsaT4nY29uY3JldGUtYmxvY2stY29hcnNlJzwvbGk+XG4gKiA8bGk+J2NvbmNyZXRlLWJsb2NrLXBhaW50ZWQnPC9saT5cbiAqIDxsaT4nY3VydGFpbi1oZWF2eSc8L2xpPlxuICogPGxpPidmaWJlci1nbGFzcy1pbnN1bGF0aW9uJzwvbGk+XG4gKiA8bGk+J2dsYXNzLXRoaW4nPC9saT5cbiAqIDxsaT4nZ2xhc3MtdGhpY2snPC9saT5cbiAqIDxsaT4nZ3Jhc3MnPC9saT5cbiAqIDxsaT4nbGlub2xldW0tb24tY29uY3JldGUnPC9saT5cbiAqIDxsaT4nbWFyYmxlJzwvbGk+XG4gKiA8bGk+J21ldGFsJzwvbGk+XG4gKiA8bGk+J3BhcnF1ZXQtb24tY29uY3JldGUnPC9saT5cbiAqIDxsaT4ncGxhc3Rlci1zbW9vdGgnPC9saT5cbiAqIDxsaT4ncGx5d29vZC1wYW5lbCc8L2xpPlxuICogPGxpPidwb2xpc2hlZC1jb25jcmV0ZS1vci10aWxlJzwvbGk+XG4gKiA8bGk+J3NoZWV0cm9jayc8L2xpPlxuICogPGxpPid3YXRlci1vci1pY2Utc3VyZmFjZSc8L2xpPlxuICogPGxpPid3b29kLWNlaWxpbmcnPC9saT5cbiAqIDxsaT4nd29vZC1wYW5lbCc8L2xpPlxuICogPGxpPid1bmlmb3JtJzwvbGk+XG4gKiA8L3VsPlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbHMuUk9PTV9NQVRFUklBTF9DT0VGRklDSUVOVFMgPSB7XG4gICd0cmFuc3BhcmVudCc6XG4gIFsxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwXSxcbiAgJ2Fjb3VzdGljLWNlaWxpbmctdGlsZXMnOlxuICBbMC42NzIsIDAuNjc1LCAwLjcwMCwgMC42NjAsIDAuNzIwLCAwLjkyMCwgMC44ODAsIDAuNzUwLCAxLjAwMF0sXG4gICdicmljay1iYXJlJzpcbiAgWzAuMDMwLCAwLjAzMCwgMC4wMzAsIDAuMDMwLCAwLjAzMCwgMC4wNDAsIDAuMDUwLCAwLjA3MCwgMC4xNDBdLFxuICAnYnJpY2stcGFpbnRlZCc6XG4gIFswLjAwNiwgMC4wMDcsIDAuMDEwLCAwLjAxMCwgMC4wMjAsIDAuMDIwLCAwLjAyMCwgMC4wMzAsIDAuMDYwXSxcbiAgJ2NvbmNyZXRlLWJsb2NrLWNvYXJzZSc6XG4gIFswLjM2MCwgMC4zNjAsIDAuMzYwLCAwLjQ0MCwgMC4zMTAsIDAuMjkwLCAwLjM5MCwgMC4yNTAsIDAuNTAwXSxcbiAgJ2NvbmNyZXRlLWJsb2NrLXBhaW50ZWQnOlxuICBbMC4wOTIsIDAuMDkwLCAwLjEwMCwgMC4wNTAsIDAuMDYwLCAwLjA3MCwgMC4wOTAsIDAuMDgwLCAwLjE2MF0sXG4gICdjdXJ0YWluLWhlYXZ5JzpcbiAgWzAuMDczLCAwLjEwNiwgMC4xNDAsIDAuMzUwLCAwLjU1MCwgMC43MjAsIDAuNzAwLCAwLjY1MCwgMS4wMDBdLFxuICAnZmliZXItZ2xhc3MtaW5zdWxhdGlvbic6XG4gIFswLjE5MywgMC4yMjAsIDAuMjIwLCAwLjgyMCwgMC45OTAsIDAuOTkwLCAwLjk5MCwgMC45OTAsIDEuMDAwXSxcbiAgJ2dsYXNzLXRoaW4nOlxuICBbMC4xODAsIDAuMTY5LCAwLjE4MCwgMC4wNjAsIDAuMDQwLCAwLjAzMCwgMC4wMjAsIDAuMDIwLCAwLjA0MF0sXG4gICdnbGFzcy10aGljayc6XG4gIFswLjM1MCwgMC4zNTAsIDAuMzUwLCAwLjI1MCwgMC4xODAsIDAuMTIwLCAwLjA3MCwgMC4wNDAsIDAuMDgwXSxcbiAgJ2dyYXNzJzpcbiAgWzAuMDUwLCAwLjA1MCwgMC4xNTAsIDAuMjUwLCAwLjQwMCwgMC41NTAsIDAuNjAwLCAwLjYwMCwgMC42MDBdLFxuICAnbGlub2xldW0tb24tY29uY3JldGUnOlxuICBbMC4wMjAsIDAuMDIwLCAwLjAyMCwgMC4wMzAsIDAuMDMwLCAwLjAzMCwgMC4wMzAsIDAuMDIwLCAwLjA0MF0sXG4gICdtYXJibGUnOlxuICBbMC4wMTAsIDAuMDEwLCAwLjAxMCwgMC4wMTAsIDAuMDEwLCAwLjAxMCwgMC4wMjAsIDAuMDIwLCAwLjA0MF0sXG4gICdtZXRhbCc6XG4gIFswLjAzMCwgMC4wMzUsIDAuMDQwLCAwLjA0MCwgMC4wNTAsIDAuMDUwLCAwLjA1MCwgMC4wNzAsIDAuMDkwXSxcbiAgJ3BhcnF1ZXQtb24tY29uY3JldGUnOlxuICBbMC4wMjgsIDAuMDMwLCAwLjA0MCwgMC4wNDAsIDAuMDcwLCAwLjA2MCwgMC4wNjAsIDAuMDcwLCAwLjE0MF0sXG4gICdwbGFzdGVyLXJvdWdoJzpcbiAgWzAuMDE3LCAwLjAxOCwgMC4wMjAsIDAuMDMwLCAwLjA0MCwgMC4wNTAsIDAuMDQwLCAwLjAzMCwgMC4wNjBdLFxuICAncGxhc3Rlci1zbW9vdGgnOlxuICBbMC4wMTEsIDAuMDEyLCAwLjAxMywgMC4wMTUsIDAuMDIwLCAwLjAzMCwgMC4wNDAsIDAuMDUwLCAwLjEwMF0sXG4gICdwbHl3b29kLXBhbmVsJzpcbiAgWzAuNDAwLCAwLjM0MCwgMC4yODAsIDAuMjIwLCAwLjE3MCwgMC4wOTAsIDAuMTAwLCAwLjExMCwgMC4yMjBdLFxuICAncG9saXNoZWQtY29uY3JldGUtb3ItdGlsZSc6XG4gIFswLjAwOCwgMC4wMDgsIDAuMDEwLCAwLjAxMCwgMC4wMTUsIDAuMDIwLCAwLjAyMCwgMC4wMjAsIDAuMDQwXSxcbiAgJ3NoZWV0LXJvY2snOlxuICBbMC4yOTAsIDAuMjc5LCAwLjI5MCwgMC4xMDAsIDAuMDUwLCAwLjA0MCwgMC4wNzAsIDAuMDkwLCAwLjE4MF0sXG4gICd3YXRlci1vci1pY2Utc3VyZmFjZSc6XG4gIFswLjAwNiwgMC4wMDYsIDAuMDA4LCAwLjAwOCwgMC4wMTMsIDAuMDE1LCAwLjAyMCwgMC4wMjUsIDAuMDUwXSxcbiAgJ3dvb2QtY2VpbGluZyc6XG4gIFswLjE1MCwgMC4xNDcsIDAuMTUwLCAwLjExMCwgMC4xMDAsIDAuMDcwLCAwLjA2MCwgMC4wNzAsIDAuMTQwXSxcbiAgJ3dvb2QtcGFuZWwnOlxuICBbMC4yODAsIDAuMjgwLCAwLjI4MCwgMC4yMjAsIDAuMTcwLCAwLjA5MCwgMC4xMDAsIDAuMTEwLCAwLjIyMF0sXG4gICd1bmlmb3JtJzpcbiAgWzAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDBdLFxufTtcblxuXG4vKipcbiAqIERlZmF1bHQgbWF0ZXJpYWxzIHRoYXQgdXNlIHN0cmluZ3MgZnJvbVxuICoge0BsaW5rY29kZSBVdGlscy5NQVRFUklBTF9DT0VGRklDSUVOVFMgTUFURVJJQUxfQ09FRkZJQ0lFTlRTfVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyA9IHtcbiAgbGVmdDogJ3RyYW5zcGFyZW50JywgcmlnaHQ6ICd0cmFuc3BhcmVudCcsIGZyb250OiAndHJhbnNwYXJlbnQnLFxuICBiYWNrOiAndHJhbnNwYXJlbnQnLCBkb3duOiAndHJhbnNwYXJlbnQnLCB1cDogJ3RyYW5zcGFyZW50Jyxcbn07XG5cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGJhbmRzIHRvIGF2ZXJhZ2Ugb3ZlciB3aGVuIGNvbXB1dGluZyByZWZsZWN0aW9uIGNvZWZmaWNpZW50cy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLk5VTUJFUl9SRUZMRUNUSU9OX0FWRVJBR0lOR19CQU5EUyA9IDM7XG5cblxuLyoqXG4gKiBUaGUgc3RhcnRpbmcgYmFuZCB0byBhdmVyYWdlIG92ZXIgd2hlbiBjb21wdXRpbmcgcmVmbGVjdGlvbiBjb2VmZmljaWVudHMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ST09NX1NUQVJUSU5HX0FWRVJBR0lOR19CQU5EID0gNDtcblxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIHRocmVzaG9sZCBmb3Igcm9vbSB2b2x1bWUuXG4gKiBSb29tIG1vZGVsIGlzIGRpc2FibGVkIGlmIHZvbHVtZSBpcyBiZWxvdyB0aGlzIHZhbHVlLlxuICogQHR5cGUge051bWJlcn0gKi9cblV0aWxzLlJPT01fTUlOX1ZPTFVNRSA9IDFlLTQ7XG5cblxuLyoqXG4gKiBBaXIgYWJzb3JwdGlvbiBjb2VmZmljaWVudHMgcGVyIGZyZXF1ZW5jeSBiYW5kLlxuICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAqL1xuVXRpbHMuUk9PTV9BSVJfQUJTT1JQVElPTl9DT0VGRklDSUVOVFMgPVxuICBbMC4wMDA2LCAwLjAwMDYsIDAuMDAwNywgMC4wMDA4LCAwLjAwMTAsIDAuMDAxNSwgMC4wMDI2LCAwLjAwNjAsIDAuMDIwN107XG5cblxuLyoqXG4gKiBBIHNjYWxhciBjb3JyZWN0aW9uIHZhbHVlIHRvIGVuc3VyZSBTYWJpbmUgYW5kIEV5cmluZyBwcm9kdWNlIHRoZSBzYW1lIFJUNjBcbiAqIHZhbHVlIGF0IHRoZSBjcm9zcy1vdmVyIHRocmVzaG9sZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLlJPT01fRVlSSU5HX0NPUlJFQ1RJT05fQ09FRkZJQ0lFTlQgPSAxLjM4O1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLlRXT19QSSA9IDYuMjgzMTg1MzA3MTc5NTk7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuVFdFTlRZX0ZPVVJfTE9HMTAgPSA1NS4yNjIwNDIyMzE4NTcxO1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLkxPRzEwMDAgPSA2LjkwNzc1NTI3ODk4MjE0O1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLkxPRzJfRElWMiA9IDAuMzQ2NTczNTkwMjc5OTczO1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLkRFR1JFRVNfVE9fUkFESUFOUyA9IDAuMDE3NDUzMjkyNTE5OTQzO1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLlJBRElBTlNfVE9fREVHUkVFUyA9IDU3LjI5NTc3OTUxMzA4MjMyMztcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5FUFNJTE9OX0ZMT0FUID0gMWUtODtcblxuXG4vKipcbiAqIFJlc29uYW5jZUF1ZGlvIGxpYnJhcnkgbG9nZ2luZyBmdW5jdGlvbi5cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7YW55fSBNZXNzYWdlIHRvIGJlIHByaW50ZWQgb3V0LlxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSh3aW5kb3cuY29uc29sZSwgW1xuICAgICclY1tSZXNvbmFuY2VBdWRpb10lYyAnXG4gICAgICArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpICsgJyAlYyhAJ1xuICAgICAgKyBwZXJmb3JtYW5jZS5ub3coKS50b0ZpeGVkKDIpICsgJ21zKScsXG4gICAgJ2JhY2tncm91bmQ6ICNCQkRFRkI7IGNvbG9yOiAjRkY1NzIyOyBmb250LXdlaWdodDogNzAwJyxcbiAgICAnZm9udC13ZWlnaHQ6IDQwMCcsXG4gICAgJ2NvbG9yOiAjQUFBJyxcbiAgXSk7XG59O1xuXG5cbi8qKlxuICogTm9ybWFsaXplIGEgMy1kIHZlY3Rvci5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2IDMtZWxlbWVudCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IDMtZWxlbWVudCB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5ub3JtYWxpemVWZWN0b3IgPSBmdW5jdGlvbih2KSB7XG4gIGxldCBuID0gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXSk7XG4gIGlmIChuID4gZXhwb3J0cy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgbiA9IDEgLyBuO1xuICAgIHZbMF0gKj0gbjtcbiAgICB2WzFdICo9IG47XG4gICAgdlsyXSAqPSBuO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuXG4vKipcbiAqIENyb3NzLXByb2R1Y3QgYmV0d2VlbiB0d28gMy1kIHZlY3RvcnMuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYSAzLWVsZW1lbnQgdmVjdG9yLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGIgMy1lbGVtZW50IHZlY3Rvci5cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLmNyb3NzUHJvZHVjdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLFxuICAgIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sXG4gICAgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXSxcbiAgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFNwYXRpYWxseSBlbmNvZGVzIGlucHV0IHVzaW5nIHdlaWdodGVkIHNwaGVyaWNhbCBoYXJtb25pY3MuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgVGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBFbmNvZGVyXG4gKiBAZGVzY3JpcHRpb24gU3BhdGlhbGx5IGVuY29kZXMgaW5wdXQgdXNpbmcgd2VpZ2h0ZWQgc3BoZXJpY2FsIGhhcm1vbmljcy5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFtYmlzb25pY09yZGVyXG4gKiBEZXNpcmVkIGFtYmlzb25pYyBvcmRlci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVIgREVGQVVMVF9BTUJJU09OSUNfT1JERVJ9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYXppbXV0aFxuICogQXppbXV0aCAoaW4gZGVncmVlcykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQVpJTVVUSCBERUZBVUxUX0FaSU1VVEh9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZWxldmF0aW9uXG4gKiBFbGV2YXRpb24gKGluIGRlZ3JlZXMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0VMRVZBVElPTiBERUZBVUxUX0VMRVZBVElPTn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICogU291cmNlIHdpZHRoIChpbiBkZWdyZWVzKS4gV2hlcmUgMCBkZWdyZWVzIGlzIGEgcG9pbnQgc291cmNlIGFuZCAzNjAgZGVncmVlc1xuICogaXMgYW4gb21uaWRpcmVjdGlvbmFsIHNvdXJjZS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEggREVGQVVMVF9TT1VSQ0VfV0lEVEh9LlxuICovXG5mdW5jdGlvbiBFbmNvZGVyKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgRW5jb2RlclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBFbmNvZGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbWJpc29uaWNPcmRlciA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyID0gVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYXppbXV0aCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmF6aW11dGggPSBVdGlscy5ERUZBVUxUX0FaSU1VVEg7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZWxldmF0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZWxldmF0aW9uID0gVXRpbHMuREVGQVVMVF9FTEVWQVRJT047XG4gIH1cbiAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGggPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IFV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIO1xuICB9XG5cbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgLy8gQ3JlYXRlIEkvTyBub2Rlcy5cbiAgdGhpcy5pbnB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9jaGFubmVsR2FpbiA9IFtdO1xuICB0aGlzLl9tZXJnZXIgPSB1bmRlZmluZWQ7XG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gU2V0IGluaXRpYWwgb3JkZXIsIGFuZ2xlIGFuZCBzb3VyY2Ugd2lkdGguXG4gIHRoaXMuc2V0QW1iaXNvbmljT3JkZXIob3B0aW9ucy5hbWJpc29uaWNPcmRlcik7XG4gIHRoaXMuX2F6aW11dGggPSBvcHRpb25zLmF6aW11dGg7XG4gIHRoaXMuX2VsZXZhdGlvbiA9IG9wdGlvbnMuZWxldmF0aW9uO1xuICB0aGlzLnNldFNvdXJjZVdpZHRoKG9wdGlvbnMuc291cmNlV2lkdGgpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgRGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuXG4gKi9cbkVuY29kZXIucHJvdG90eXBlLnNldEFtYmlzb25pY09yZGVyID0gZnVuY3Rpb24oYW1iaXNvbmljT3JkZXIpIHtcbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPSBFbmNvZGVyLnZhbGlkYXRlQW1iaXNvbmljT3JkZXIoYW1iaXNvbmljT3JkZXIpO1xuXG4gIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NoYW5uZWxHYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5fY2hhbm5lbEdhaW5baV0uZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0aGlzLl9tZXJnZXIgIT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fbWVyZ2VyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fY2hhbm5lbEdhaW47XG4gIGRlbGV0ZSB0aGlzLl9tZXJnZXI7XG5cbiAgLy8gQ3JlYXRlIGF1ZGlvIGdyYXBoLlxuICBsZXQgbnVtQ2hhbm5lbHMgPSAodGhpcy5fYW1iaXNvbmljT3JkZXIgKyAxKSAqICh0aGlzLl9hbWJpc29uaWNPcmRlciArIDEpO1xuICB0aGlzLl9tZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIobnVtQ2hhbm5lbHMpO1xuICB0aGlzLl9jaGFubmVsR2FpbiA9IG5ldyBBcnJheShudW1DaGFubmVscyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhbm5lbHM7IGkrKykge1xuICAgIHRoaXMuX2NoYW5uZWxHYWluW2ldID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2NoYW5uZWxHYWluW2ldKTtcbiAgICB0aGlzLl9jaGFubmVsR2FpbltpXS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgaSk7XG4gIH1cbiAgdGhpcy5fbWVyZ2VyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbmNvZGVkIHNvdXJjZSBzaWduYWwuXG4gKiBAcGFyYW0ge051bWJlcn0gYXppbXV0aFxuICogQXppbXV0aCAoaW4gZGVncmVlcykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQVpJTVVUSCBERUZBVUxUX0FaSU1VVEh9LlxuICogQHBhcmFtIHtOdW1iZXJ9IGVsZXZhdGlvblxuICogRWxldmF0aW9uIChpbiBkZWdyZWVzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9FTEVWQVRJT04gREVGQVVMVF9FTEVWQVRJT059LlxuICovXG5FbmNvZGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSBmdW5jdGlvbihhemltdXRoLCBlbGV2YXRpb24pIHtcbiAgLy8gRm9ybWF0IGlucHV0IGRpcmVjdGlvbiB0byBuZWFyZXN0IGluZGljZXMuXG4gIGlmIChhemltdXRoID09IHVuZGVmaW5lZCB8fCBpc05hTihhemltdXRoKSkge1xuICAgIGF6aW11dGggPSBVdGlscy5ERUZBVUxUX0FaSU1VVEg7XG4gIH1cbiAgaWYgKGVsZXZhdGlvbiA9PSB1bmRlZmluZWQgfHwgaXNOYU4oZWxldmF0aW9uKSkge1xuICAgIGVsZXZhdGlvbiA9IFV0aWxzLkRFRkFVTFRfRUxFVkFUSU9OO1xuICB9XG5cbiAgLy8gU3RvcmUgdGhlIGZvcm1hdHRlZCBpbnB1dCAoZm9yIHVwZGF0aW5nIHNvdXJjZSB3aWR0aCkuXG4gIHRoaXMuX2F6aW11dGggPSBhemltdXRoO1xuICB0aGlzLl9lbGV2YXRpb24gPSBlbGV2YXRpb247XG5cbiAgLy8gRm9ybWF0IGRpcmVjdGlvbiBmb3IgaW5kZXggbG9va3Vwcy5cbiAgYXppbXV0aCA9IE1hdGgucm91bmQoYXppbXV0aCAlIDM2MCk7XG4gIGlmIChhemltdXRoIDwgMCkge1xuICAgIGF6aW11dGggKz0gMzYwO1xuICB9XG4gIGVsZXZhdGlvbiA9IE1hdGgucm91bmQoTWF0aC5taW4oOTAsIE1hdGgubWF4KC05MCwgZWxldmF0aW9uKSkpICsgOTA7XG5cbiAgLy8gQXNzaWduIGdhaW5zIHRvIGVhY2ggb3V0cHV0LlxuICB0aGlzLl9jaGFubmVsR2FpblswXS5nYWluLnZhbHVlID0gVGFibGVzLk1BWF9SRV9XRUlHSFRTW3RoaXMuX3NwcmVhZEluZGV4XVswXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5fYW1iaXNvbmljT3JkZXI7IGkrKykge1xuICAgIGxldCBkZWdyZWVXZWlnaHQgPSBUYWJsZXMuTUFYX1JFX1dFSUdIVFNbdGhpcy5fc3ByZWFkSW5kZXhdW2ldO1xuICAgIGZvciAobGV0IGogPSAtaTsgaiA8PSBpOyBqKyspIHtcbiAgICAgIGxldCBhY25DaGFubmVsID0gKGkgKiBpKSArIGkgKyBqO1xuICAgICAgbGV0IGVsZXZhdGlvbkluZGV4ID0gaSAqIChpICsgMSkgLyAyICsgTWF0aC5hYnMoaikgLSAxO1xuICAgICAgbGV0IHZhbCA9IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTWzFdW2VsZXZhdGlvbl1bZWxldmF0aW9uSW5kZXhdO1xuICAgICAgaWYgKGogIT0gMCkge1xuICAgICAgICBsZXQgYXppbXV0aEluZGV4ID0gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSICsgaiAtIDE7XG4gICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgIGF6aW11dGhJbmRleCA9IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUiArIGo7XG4gICAgICAgIH1cbiAgICAgICAgdmFsICo9IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTWzBdW2F6aW11dGhdW2F6aW11dGhJbmRleF07XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFubmVsR2FpblthY25DaGFubmVsXS5nYWluLnZhbHVlID0gdmFsICogZGVncmVlV2VpZ2h0O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIHdpZHRoIChpbiBkZWdyZWVzKS4gV2hlcmUgMCBkZWdyZWVzIGlzIGEgcG9pbnQgc291cmNlIGFuZCAzNjBcbiAqIGRlZ3JlZXMgaXMgYW4gb21uaWRpcmVjdGlvbmFsIHNvdXJjZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VXaWR0aCAoaW4gZGVncmVlcykuXG4gKi9cbkVuY29kZXIucHJvdG90eXBlLnNldFNvdXJjZVdpZHRoID0gZnVuY3Rpb24oc291cmNlV2lkdGgpIHtcbiAgLy8gVGhlIE1BWF9SRV9XRUlHSFRTIGlzIGEgMzYwIHggKFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUisxKVxuICAvLyBzaXplIHRhYmxlLlxuICB0aGlzLl9zcHJlYWRJbmRleCA9IE1hdGgubWluKDM1OSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChzb3VyY2VXaWR0aCkpKTtcbiAgdGhpcy5zZXREaXJlY3Rpb24odGhpcy5fYXppbXV0aCwgdGhpcy5fZWxldmF0aW9uKTtcbn07XG5cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIERlc2lyZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHJldHVybiB7TnVtYmVyfSBWYWxpZGF0ZWQvYWRqdXN0ZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHByaXZhdGVcbiAqL1xuRW5jb2Rlci52YWxpZGF0ZUFtYmlzb25pY09yZGVyID0gZnVuY3Rpb24oYW1iaXNvbmljT3JkZXIpIHtcbiAgaWYgKGlzTmFOKGFtYmlzb25pY09yZGVyKSB8fCBhbWJpc29uaWNPcmRlciA9PSB1bmRlZmluZWQpIHtcbiAgICBVdGlscy5sb2coJ0Vycm9yOiBJbnZhbGlkIGFtYmlzb25pYyBvcmRlcicsXG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciwgJ1xcblVzaW5nIGFtYmlzb25pY09yZGVyPTEgaW5zdGVhZC4nKTtcbiAgICBhbWJpc29uaWNPcmRlciA9IDE7XG4gIH0gZWxzZSBpZiAoYW1iaXNvbmljT3JkZXIgPCAxKSB7XG4gICAgVXRpbHMubG9nKCdFcnJvcjogVW5hYmxlIHRvIHJlbmRlciBhbWJpc29uaWMgb3JkZXInLFxuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIsICcoTWluIG9yZGVyIGlzIDEpJyxcbiAgICAnXFxuVXNpbmcgbWluIG9yZGVyIGluc3RlYWQuJyk7XG4gICAgYW1iaXNvbmljT3JkZXIgPSAxO1xuICB9IGVsc2UgaWYgKGFtYmlzb25pY09yZGVyID4gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSKSB7XG4gICAgVXRpbHMubG9nKCdFcnJvcjogVW5hYmxlIHRvIHJlbmRlciBhbWJpc29uaWMgb3JkZXInLFxuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIsICcoTWF4IG9yZGVyIGlzJyxcbiAgICBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIsICcpXFxuVXNpbmcgbWF4IG9yZGVyIGluc3RlYWQuJyk7XG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciA9IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUjtcbiAgfVxuICByZXR1cm4gYW1iaXNvbmljT3JkZXI7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRW5jb2RlcjtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgTGlzdGVuZXIgbW9kZWwgdG8gc3BhdGlhbGl6ZSBzb3VyY2VzIGluIGFuIGVudmlyb25tZW50LlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgT21uaXRvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmNvbnN0IEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIExpc3RlbmVyXG4gKiBAZGVzY3JpcHRpb24gTGlzdGVuZXIgbW9kZWwgdG8gc3BhdGlhbGl6ZSBzb3VyY2VzIGluIGFuIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYW1iaXNvbmljT3JkZXJcbiAqIERlc2lyZWQgYW1iaXNvbmljIG9yZGVyLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUiBERUZBVUxUX0FNQklTT05JQ19PUkRFUn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5wb3NpdGlvblxuICogSW5pdGlhbCBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMuZm9yd2FyZFxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCBmb3J3YXJkIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9GT1JXQVJEIERFRkFVTFRfRk9SV0FSRH0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy51cFxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCB1cCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfVVAgREVGQVVMVF9VUH0uXG4gKi9cbmZ1bmN0aW9uIExpc3RlbmVyKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIChpbiBtZXRlcnMpLlxuICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IHBvc2l0aW9uXG4gICAqIEBtZW1iZXJvZiBMaXN0ZW5lclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgTGlzdGVuZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQmluYXVyYWxseS1yZW5kZXJlZCBzdGVyZW8gKDItY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBMaXN0ZW5lclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gYW1iaXNvbmljT3V0cHV0XG4gICAqIEBtZW1iZXJvZiBMaXN0ZW5lclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmFtYmlzb25pY09yZGVyID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUjtcbiAgfVxuICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnBvc2l0aW9uID0gVXRpbHMuREVGQVVMVF9QT1NJVElPTi5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcndhcmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5mb3J3YXJkID0gVXRpbHMuREVGQVVMVF9GT1JXQVJELnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy51cCA9IFV0aWxzLkRFRkFVTFRfVVAuc2xpY2UoKTtcbiAgfVxuXG4gIC8vIE1lbWJlciB2YXJpYWJsZXMuXG4gIHRoaXMucG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICB0aGlzLl90ZW1wTWF0cml4MyA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG5cbiAgLy8gU2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBIUklSIGZpbHRlcnMgdXNpbmcgMi1jaGFubmVsIGNodW5rcyBzaW5jZVxuICAvLyBtdWx0aWNoYW5uZWwgYXVkaW8gaXMgbm90IHlldCBzdXBwb3J0ZWQgYnkgYSBtYWpvcml0eSBvZiBicm93c2Vycy5cbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPVxuICAgIEVuY29kZXIudmFsaWRhdGVBbWJpc29uaWNPcmRlcihvcHRpb25zLmFtYmlzb25pY09yZGVyKTtcblxuICAgIC8vIENyZWF0ZSBhdWRpbyBub2Rlcy5cbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIGlmICh0aGlzLl9hbWJpc29uaWNPcmRlciA9PSAxKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBPbW5pdG9uZS5PbW5pdG9uZS5jcmVhdGVGT0FSZW5kZXJlcihjb250ZXh0LCB7fSk7XG4gIH0gZWxzZSBpZiAodGhpcy5fYW1iaXNvbmljT3JkZXIgPiAxKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBPbW5pdG9uZS5PbW5pdG9uZS5jcmVhdGVIT0FSZW5kZXJlcihjb250ZXh0LCB7XG4gICAgICBhbWJpc29uaWNPcmRlcjogdGhpcy5fYW1iaXNvbmljT3JkZXIsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUaGVzZSBub2RlcyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBzYWZlbHkgYXN5bmNocm9ub3VzbHkgbG9hZCBPbW5pdG9uZVxuICAvLyB3aGlsZSB0aGUgcmVzdCBvZiB0aGUgc2NlbmUgaXMgYmVpbmcgY3JlYXRlZC5cbiAgdGhpcy5pbnB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLmFtYmlzb25pY091dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIEluaXRpYWxpemUgT21uaXRvbmUgKGFzeW5jKSBhbmQgY29ubmVjdCB0byBhdWRpbyBncmFwaCB3aGVuIGNvbXBsZXRlLlxuICBsZXQgdGhhdCA9IHRoaXM7XG4gIHRoaXMuX3JlbmRlcmVyLmluaXRpYWxpemUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIC8vIENvbm5lY3QgcHJlLXJvdGF0ZWQgc291bmRmaWVsZCB0byByZW5kZXJlci5cbiAgICB0aGF0LmlucHV0LmNvbm5lY3QodGhhdC5fcmVuZGVyZXIuaW5wdXQpO1xuXG4gICAgLy8gQ29ubmVjdCByb3RhdGVkIHNvdW5kZmllbGQgdG8gYW1iaXNvbmljIG91dHB1dC5cbiAgICBpZiAodGhhdC5fYW1iaXNvbmljT3JkZXIgPiAxKSB7XG4gICAgICB0aGF0Ll9yZW5kZXJlci5faG9hUm90YXRvci5vdXRwdXQuY29ubmVjdCh0aGF0LmFtYmlzb25pY091dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3JlbmRlcmVyLl9mb2FSb3RhdG9yLm91dHB1dC5jb25uZWN0KHRoYXQuYW1iaXNvbmljT3V0cHV0KTtcbiAgICB9XG5cbiAgICAvLyBDb25uZWN0IGJpbmF1cmFsbHktcmVuZGVyZWQgc291bmRmaWVsZCB0byBiaW5hdXJhbCBvdXRwdXQuXG4gICAgdGhhdC5fcmVuZGVyZXIub3V0cHV0LmNvbm5lY3QodGhhdC5vdXRwdXQpO1xuICB9KTtcblxuICAvLyBTZXQgb3JpZW50YXRpb24gYW5kIHVwZGF0ZSByb3RhdGlvbiBtYXRyaXggYWNjb3JkaW5nbHkuXG4gIHRoaXMuc2V0T3JpZW50YXRpb24ob3B0aW9ucy5mb3J3YXJkWzBdLCBvcHRpb25zLmZvcndhcmRbMV0sXG4gICAgb3B0aW9ucy5mb3J3YXJkWzJdLCBvcHRpb25zLnVwWzBdLCBvcHRpb25zLnVwWzFdLCBvcHRpb25zLnVwWzJdKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSdzIG9yaWVudGF0aW9uIHVzaW5nIGZvcndhcmQgYW5kIHVwIHZlY3RvcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFhcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWVxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRaXG4gKiBAcGFyYW0ge051bWJlcn0gdXBYXG4gKiBAcGFyYW0ge051bWJlcn0gdXBZXG4gKiBAcGFyYW0ge051bWJlcn0gdXBaXG4gKi9cbkxpc3RlbmVyLnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGZvcndhcmRYLCBmb3J3YXJkWSwgZm9yd2FyZFosXG4gIHVwWCwgdXBZLCB1cFopIHtcbiAgbGV0IHJpZ2h0ID0gVXRpbHMuY3Jvc3NQcm9kdWN0KFtmb3J3YXJkWCwgZm9yd2FyZFksIGZvcndhcmRaXSxcbiAgICBbdXBYLCB1cFksIHVwWl0pO1xuICB0aGlzLl90ZW1wTWF0cml4M1swXSA9IHJpZ2h0WzBdO1xuICB0aGlzLl90ZW1wTWF0cml4M1sxXSA9IHJpZ2h0WzFdO1xuICB0aGlzLl90ZW1wTWF0cml4M1syXSA9IHJpZ2h0WzJdO1xuICB0aGlzLl90ZW1wTWF0cml4M1szXSA9IHVwWDtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbNF0gPSB1cFk7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzVdID0gdXBaO1xuICB0aGlzLl90ZW1wTWF0cml4M1s2XSA9IGZvcndhcmRYO1xuICB0aGlzLl90ZW1wTWF0cml4M1s3XSA9IGZvcndhcmRZO1xuICB0aGlzLl90ZW1wTWF0cml4M1s4XSA9IGZvcndhcmRaO1xuICB0aGlzLl9yZW5kZXJlci5zZXRSb3RhdGlvbk1hdHJpeDModGhpcy5fdGVtcE1hdHJpeDMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gdXNpbmcgYSBUaHJlZS5qcyBNYXRyaXg0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRyaXg0XG4gKiBUaGUgVGhyZWUuanMgTWF0cml4NCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBsaXN0ZW5lcidzIHdvcmxkIHRyYW5zZm9ybS5cbiAqL1xuTGlzdGVuZXIucHJvdG90eXBlLnNldEZyb21NYXRyaXggPSBmdW5jdGlvbihtYXRyaXg0KSB7XG4gIC8vIFVwZGF0ZSBhbWJpc29uaWMgcm90YXRpb24gbWF0cml4IGludGVybmFsbHkuXG4gIHRoaXMuX3JlbmRlcmVyLnNldFJvdGF0aW9uTWF0cml4NChtYXRyaXg0LmVsZW1lbnRzKTtcblxuICAvLyBFeHRyYWN0IHBvc2l0aW9uIGZyb20gbWF0cml4LlxuICB0aGlzLnBvc2l0aW9uWzBdID0gbWF0cml4NC5lbGVtZW50c1sxMl07XG4gIHRoaXMucG9zaXRpb25bMV0gPSBtYXRyaXg0LmVsZW1lbnRzWzEzXTtcbiAgdGhpcy5wb3NpdGlvblsyXSA9IG1hdHJpeDQuZWxlbWVudHNbMTRdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RlbmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFByZS1jb21wdXRlZCBsb29rdXAgdGFibGVzIGZvciBlbmNvZGluZyBhbWJpc29uaWMgc291cmNlcy5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8qKlxuICogUHJlLWNvbXB1dGVkIFNwaGVyaWNhbCBIYXJtb25pY3MgQ29lZmZpY2llbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGFuIGVmZmljaWVudCBsb29rdXAgdGFibGUgb2YgU0ggY29lZmZpY2llbnRzLiBJdFxuICogZXhwbG9pdHMgdGhlIHdheSBTSHMgYXJlIGdlbmVyYXRlZCAoaS5lLiBZbG0gPSBObG0gKiBQbG0gKiBFbSkuIFNpbmNlIE5sbVxuICogJiBQbG0gY29lZmZpY2llbnRzIG9ubHkgZGVwZW5kIG9uIHRoZXRhLCBhbmQgRW0gb25seSBkZXBlbmRzIG9uIHBoaSwgd2VcbiAqIGNhbiBzZXBhcmF0ZSB0aGUgZXF1YXRpb24gYWxvbmcgdGhlc2UgbGluZXMuIEVtIGRvZXMgbm90IGRlcGVuZCBvblxuICogZGVncmVlLCBzbyB3ZSBvbmx5IG5lZWQgdG8gY29tcHV0ZSAoMiAqIGwpIHBlciBhemltdXRoIEVtIHRvdGFsIGFuZFxuICogTmxtICogUGxtIGlzIHN5bW1ldHJpY2FsIGFjcm9zcyBpbmRleGVzLCBzbyBvbmx5IHBvc2l0aXZlIGluZGV4ZXMgYXJlXG4gKiBjb21wdXRlZCAoKGwgKyAxKSAqIChsICsgMikgLyAyIC0gMSkgcGVyIGVsZXZhdGlvbi5cbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKi9cbmV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDUyA9XG5bXG4gIFtcbiAgICBbMC4wMDAwMDAsIDAuMDAwMDAwLCAwLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gICAgWzAuMDUyMzM2LCAwLjAzNDg5OSwgMC4wMTc0NTIsIDAuOTk5ODQ4LCAwLjk5OTM5MSwgMC45OTg2MzBdLFxuICAgIFswLjEwNDUyOCwgMC4wNjk3NTYsIDAuMDM0ODk5LCAwLjk5OTM5MSwgMC45OTc1NjQsIDAuOTk0NTIyXSxcbiAgICBbMC4xNTY0MzQsIDAuMTA0NTI4LCAwLjA1MjMzNiwgMC45OTg2MzAsIDAuOTk0NTIyLCAwLjk4NzY4OF0sXG4gICAgWzAuMjA3OTEyLCAwLjEzOTE3MywgMC4wNjk3NTYsIDAuOTk3NTY0LCAwLjk5MDI2OCwgMC45NzgxNDhdLFxuICAgIFswLjI1ODgxOSwgMC4xNzM2NDgsIDAuMDg3MTU2LCAwLjk5NjE5NSwgMC45ODQ4MDgsIDAuOTY1OTI2XSxcbiAgICBbMC4zMDkwMTcsIDAuMjA3OTEyLCAwLjEwNDUyOCwgMC45OTQ1MjIsIDAuOTc4MTQ4LCAwLjk1MTA1N10sXG4gICAgWzAuMzU4MzY4LCAwLjI0MTkyMiwgMC4xMjE4NjksIDAuOTkyNTQ2LCAwLjk3MDI5NiwgMC45MzM1ODBdLFxuICAgIFswLjQwNjczNywgMC4yNzU2MzcsIDAuMTM5MTczLCAwLjk5MDI2OCwgMC45NjEyNjIsIDAuOTEzNTQ1XSxcbiAgICBbMC40NTM5OTAsIDAuMzA5MDE3LCAwLjE1NjQzNCwgMC45ODc2ODgsIDAuOTUxMDU3LCAwLjg5MTAwN10sXG4gICAgWzAuNTAwMDAwLCAwLjM0MjAyMCwgMC4xNzM2NDgsIDAuOTg0ODA4LCAwLjkzOTY5MywgMC44NjYwMjVdLFxuICAgIFswLjU0NDYzOSwgMC4zNzQ2MDcsIDAuMTkwODA5LCAwLjk4MTYyNywgMC45MjcxODQsIDAuODM4NjcxXSxcbiAgICBbMC41ODc3ODUsIDAuNDA2NzM3LCAwLjIwNzkxMiwgMC45NzgxNDgsIDAuOTEzNTQ1LCAwLjgwOTAxN10sXG4gICAgWzAuNjI5MzIwLCAwLjQzODM3MSwgMC4yMjQ5NTEsIDAuOTc0MzcwLCAwLjg5ODc5NCwgMC43NzcxNDZdLFxuICAgIFswLjY2OTEzMSwgMC40Njk0NzIsIDAuMjQxOTIyLCAwLjk3MDI5NiwgMC44ODI5NDgsIDAuNzQzMTQ1XSxcbiAgICBbMC43MDcxMDcsIDAuNTAwMDAwLCAwLjI1ODgxOSwgMC45NjU5MjYsIDAuODY2MDI1LCAwLjcwNzEwN10sXG4gICAgWzAuNzQzMTQ1LCAwLjUyOTkxOSwgMC4yNzU2MzcsIDAuOTYxMjYyLCAwLjg0ODA0OCwgMC42NjkxMzFdLFxuICAgIFswLjc3NzE0NiwgMC41NTkxOTMsIDAuMjkyMzcyLCAwLjk1NjMwNSwgMC44MjkwMzgsIDAuNjI5MzIwXSxcbiAgICBbMC44MDkwMTcsIDAuNTg3Nzg1LCAwLjMwOTAxNywgMC45NTEwNTcsIDAuODA5MDE3LCAwLjU4Nzc4NV0sXG4gICAgWzAuODM4NjcxLCAwLjYxNTY2MSwgMC4zMjU1NjgsIDAuOTQ1NTE5LCAwLjc4ODAxMSwgMC41NDQ2MzldLFxuICAgIFswLjg2NjAyNSwgMC42NDI3ODgsIDAuMzQyMDIwLCAwLjkzOTY5MywgMC43NjYwNDQsIDAuNTAwMDAwXSxcbiAgICBbMC44OTEwMDcsIDAuNjY5MTMxLCAwLjM1ODM2OCwgMC45MzM1ODAsIDAuNzQzMTQ1LCAwLjQ1Mzk5MF0sXG4gICAgWzAuOTEzNTQ1LCAwLjY5NDY1OCwgMC4zNzQ2MDcsIDAuOTI3MTg0LCAwLjcxOTM0MCwgMC40MDY3MzddLFxuICAgIFswLjkzMzU4MCwgMC43MTkzNDAsIDAuMzkwNzMxLCAwLjkyMDUwNSwgMC42OTQ2NTgsIDAuMzU4MzY4XSxcbiAgICBbMC45NTEwNTcsIDAuNzQzMTQ1LCAwLjQwNjczNywgMC45MTM1NDUsIDAuNjY5MTMxLCAwLjMwOTAxN10sXG4gICAgWzAuOTY1OTI2LCAwLjc2NjA0NCwgMC40MjI2MTgsIDAuOTA2MzA4LCAwLjY0Mjc4OCwgMC4yNTg4MTldLFxuICAgIFswLjk3ODE0OCwgMC43ODgwMTEsIDAuNDM4MzcxLCAwLjg5ODc5NCwgMC42MTU2NjEsIDAuMjA3OTEyXSxcbiAgICBbMC45ODc2ODgsIDAuODA5MDE3LCAwLjQ1Mzk5MCwgMC44OTEwMDcsIDAuNTg3Nzg1LCAwLjE1NjQzNF0sXG4gICAgWzAuOTk0NTIyLCAwLjgyOTAzOCwgMC40Njk0NzIsIDAuODgyOTQ4LCAwLjU1OTE5MywgMC4xMDQ1MjhdLFxuICAgIFswLjk5ODYzMCwgMC44NDgwNDgsIDAuNDg0ODEwLCAwLjg3NDYyMCwgMC41Mjk5MTksIDAuMDUyMzM2XSxcbiAgICBbMS4wMDAwMDAsIDAuODY2MDI1LCAwLjUwMDAwMCwgMC44NjYwMjUsIDAuNTAwMDAwLCAwLjAwMDAwMF0sXG4gICAgWzAuOTk4NjMwLCAwLjg4Mjk0OCwgMC41MTUwMzgsIDAuODU3MTY3LCAwLjQ2OTQ3MiwgLTAuMDUyMzM2XSxcbiAgICBbMC45OTQ1MjIsIDAuODk4Nzk0LCAwLjUyOTkxOSwgMC44NDgwNDgsIDAuNDM4MzcxLCAtMC4xMDQ1MjhdLFxuICAgIFswLjk4NzY4OCwgMC45MTM1NDUsIDAuNTQ0NjM5LCAwLjgzODY3MSwgMC40MDY3MzcsIC0wLjE1NjQzNF0sXG4gICAgWzAuOTc4MTQ4LCAwLjkyNzE4NCwgMC41NTkxOTMsIDAuODI5MDM4LCAwLjM3NDYwNywgLTAuMjA3OTEyXSxcbiAgICBbMC45NjU5MjYsIDAuOTM5NjkzLCAwLjU3MzU3NiwgMC44MTkxNTIsIDAuMzQyMDIwLCAtMC4yNTg4MTldLFxuICAgIFswLjk1MTA1NywgMC45NTEwNTcsIDAuNTg3Nzg1LCAwLjgwOTAxNywgMC4zMDkwMTcsIC0wLjMwOTAxN10sXG4gICAgWzAuOTMzNTgwLCAwLjk2MTI2MiwgMC42MDE4MTUsIDAuNzk4NjM2LCAwLjI3NTYzNywgLTAuMzU4MzY4XSxcbiAgICBbMC45MTM1NDUsIDAuOTcwMjk2LCAwLjYxNTY2MSwgMC43ODgwMTEsIDAuMjQxOTIyLCAtMC40MDY3MzddLFxuICAgIFswLjg5MTAwNywgMC45NzgxNDgsIDAuNjI5MzIwLCAwLjc3NzE0NiwgMC4yMDc5MTIsIC0wLjQ1Mzk5MF0sXG4gICAgWzAuODY2MDI1LCAwLjk4NDgwOCwgMC42NDI3ODgsIDAuNzY2MDQ0LCAwLjE3MzY0OCwgLTAuNTAwMDAwXSxcbiAgICBbMC44Mzg2NzEsIDAuOTkwMjY4LCAwLjY1NjA1OSwgMC43NTQ3MTAsIDAuMTM5MTczLCAtMC41NDQ2MzldLFxuICAgIFswLjgwOTAxNywgMC45OTQ1MjIsIDAuNjY5MTMxLCAwLjc0MzE0NSwgMC4xMDQ1MjgsIC0wLjU4Nzc4NV0sXG4gICAgWzAuNzc3MTQ2LCAwLjk5NzU2NCwgMC42ODE5OTgsIDAuNzMxMzU0LCAwLjA2OTc1NiwgLTAuNjI5MzIwXSxcbiAgICBbMC43NDMxNDUsIDAuOTk5MzkxLCAwLjY5NDY1OCwgMC43MTkzNDAsIDAuMDM0ODk5LCAtMC42NjkxMzFdLFxuICAgIFswLjcwNzEwNywgMS4wMDAwMDAsIDAuNzA3MTA3LCAwLjcwNzEwNywgMC4wMDAwMDAsIC0wLjcwNzEwN10sXG4gICAgWzAuNjY5MTMxLCAwLjk5OTM5MSwgMC43MTkzNDAsIDAuNjk0NjU4LCAtMC4wMzQ4OTksIC0wLjc0MzE0NV0sXG4gICAgWzAuNjI5MzIwLCAwLjk5NzU2NCwgMC43MzEzNTQsIDAuNjgxOTk4LCAtMC4wNjk3NTYsIC0wLjc3NzE0Nl0sXG4gICAgWzAuNTg3Nzg1LCAwLjk5NDUyMiwgMC43NDMxNDUsIDAuNjY5MTMxLCAtMC4xMDQ1MjgsIC0wLjgwOTAxN10sXG4gICAgWzAuNTQ0NjM5LCAwLjk5MDI2OCwgMC43NTQ3MTAsIDAuNjU2MDU5LCAtMC4xMzkxNzMsIC0wLjgzODY3MV0sXG4gICAgWzAuNTAwMDAwLCAwLjk4NDgwOCwgMC43NjYwNDQsIDAuNjQyNzg4LCAtMC4xNzM2NDgsIC0wLjg2NjAyNV0sXG4gICAgWzAuNDUzOTkwLCAwLjk3ODE0OCwgMC43NzcxNDYsIDAuNjI5MzIwLCAtMC4yMDc5MTIsIC0wLjg5MTAwN10sXG4gICAgWzAuNDA2NzM3LCAwLjk3MDI5NiwgMC43ODgwMTEsIDAuNjE1NjYxLCAtMC4yNDE5MjIsIC0wLjkxMzU0NV0sXG4gICAgWzAuMzU4MzY4LCAwLjk2MTI2MiwgMC43OTg2MzYsIDAuNjAxODE1LCAtMC4yNzU2MzcsIC0wLjkzMzU4MF0sXG4gICAgWzAuMzA5MDE3LCAwLjk1MTA1NywgMC44MDkwMTcsIDAuNTg3Nzg1LCAtMC4zMDkwMTcsIC0wLjk1MTA1N10sXG4gICAgWzAuMjU4ODE5LCAwLjkzOTY5MywgMC44MTkxNTIsIDAuNTczNTc2LCAtMC4zNDIwMjAsIC0wLjk2NTkyNl0sXG4gICAgWzAuMjA3OTEyLCAwLjkyNzE4NCwgMC44MjkwMzgsIDAuNTU5MTkzLCAtMC4zNzQ2MDcsIC0wLjk3ODE0OF0sXG4gICAgWzAuMTU2NDM0LCAwLjkxMzU0NSwgMC44Mzg2NzEsIDAuNTQ0NjM5LCAtMC40MDY3MzcsIC0wLjk4NzY4OF0sXG4gICAgWzAuMTA0NTI4LCAwLjg5ODc5NCwgMC44NDgwNDgsIDAuNTI5OTE5LCAtMC40MzgzNzEsIC0wLjk5NDUyMl0sXG4gICAgWzAuMDUyMzM2LCAwLjg4Mjk0OCwgMC44NTcxNjcsIDAuNTE1MDM4LCAtMC40Njk0NzIsIC0wLjk5ODYzMF0sXG4gICAgWzAuMDAwMDAwLCAwLjg2NjAyNSwgMC44NjYwMjUsIDAuNTAwMDAwLCAtMC41MDAwMDAsIC0xLjAwMDAwMF0sXG4gICAgWy0wLjA1MjMzNiwgMC44NDgwNDgsIDAuODc0NjIwLCAwLjQ4NDgxMCwgLTAuNTI5OTE5LCAtMC45OTg2MzBdLFxuICAgIFstMC4xMDQ1MjgsIDAuODI5MDM4LCAwLjg4Mjk0OCwgMC40Njk0NzIsIC0wLjU1OTE5MywgLTAuOTk0NTIyXSxcbiAgICBbLTAuMTU2NDM0LCAwLjgwOTAxNywgMC44OTEwMDcsIDAuNDUzOTkwLCAtMC41ODc3ODUsIC0wLjk4NzY4OF0sXG4gICAgWy0wLjIwNzkxMiwgMC43ODgwMTEsIDAuODk4Nzk0LCAwLjQzODM3MSwgLTAuNjE1NjYxLCAtMC45NzgxNDhdLFxuICAgIFstMC4yNTg4MTksIDAuNzY2MDQ0LCAwLjkwNjMwOCwgMC40MjI2MTgsIC0wLjY0Mjc4OCwgLTAuOTY1OTI2XSxcbiAgICBbLTAuMzA5MDE3LCAwLjc0MzE0NSwgMC45MTM1NDUsIDAuNDA2NzM3LCAtMC42NjkxMzEsIC0wLjk1MTA1N10sXG4gICAgWy0wLjM1ODM2OCwgMC43MTkzNDAsIDAuOTIwNTA1LCAwLjM5MDczMSwgLTAuNjk0NjU4LCAtMC45MzM1ODBdLFxuICAgIFstMC40MDY3MzcsIDAuNjk0NjU4LCAwLjkyNzE4NCwgMC4zNzQ2MDcsIC0wLjcxOTM0MCwgLTAuOTEzNTQ1XSxcbiAgICBbLTAuNDUzOTkwLCAwLjY2OTEzMSwgMC45MzM1ODAsIDAuMzU4MzY4LCAtMC43NDMxNDUsIC0wLjg5MTAwN10sXG4gICAgWy0wLjUwMDAwMCwgMC42NDI3ODgsIDAuOTM5NjkzLCAwLjM0MjAyMCwgLTAuNzY2MDQ0LCAtMC44NjYwMjVdLFxuICAgIFstMC41NDQ2MzksIDAuNjE1NjYxLCAwLjk0NTUxOSwgMC4zMjU1NjgsIC0wLjc4ODAxMSwgLTAuODM4NjcxXSxcbiAgICBbLTAuNTg3Nzg1LCAwLjU4Nzc4NSwgMC45NTEwNTcsIDAuMzA5MDE3LCAtMC44MDkwMTcsIC0wLjgwOTAxN10sXG4gICAgWy0wLjYyOTMyMCwgMC41NTkxOTMsIDAuOTU2MzA1LCAwLjI5MjM3MiwgLTAuODI5MDM4LCAtMC43NzcxNDZdLFxuICAgIFstMC42NjkxMzEsIDAuNTI5OTE5LCAwLjk2MTI2MiwgMC4yNzU2MzcsIC0wLjg0ODA0OCwgLTAuNzQzMTQ1XSxcbiAgICBbLTAuNzA3MTA3LCAwLjUwMDAwMCwgMC45NjU5MjYsIDAuMjU4ODE5LCAtMC44NjYwMjUsIC0wLjcwNzEwN10sXG4gICAgWy0wLjc0MzE0NSwgMC40Njk0NzIsIDAuOTcwMjk2LCAwLjI0MTkyMiwgLTAuODgyOTQ4LCAtMC42NjkxMzFdLFxuICAgIFstMC43NzcxNDYsIDAuNDM4MzcxLCAwLjk3NDM3MCwgMC4yMjQ5NTEsIC0wLjg5ODc5NCwgLTAuNjI5MzIwXSxcbiAgICBbLTAuODA5MDE3LCAwLjQwNjczNywgMC45NzgxNDgsIDAuMjA3OTEyLCAtMC45MTM1NDUsIC0wLjU4Nzc4NV0sXG4gICAgWy0wLjgzODY3MSwgMC4zNzQ2MDcsIDAuOTgxNjI3LCAwLjE5MDgwOSwgLTAuOTI3MTg0LCAtMC41NDQ2MzldLFxuICAgIFstMC44NjYwMjUsIDAuMzQyMDIwLCAwLjk4NDgwOCwgMC4xNzM2NDgsIC0wLjkzOTY5MywgLTAuNTAwMDAwXSxcbiAgICBbLTAuODkxMDA3LCAwLjMwOTAxNywgMC45ODc2ODgsIDAuMTU2NDM0LCAtMC45NTEwNTcsIC0wLjQ1Mzk5MF0sXG4gICAgWy0wLjkxMzU0NSwgMC4yNzU2MzcsIDAuOTkwMjY4LCAwLjEzOTE3MywgLTAuOTYxMjYyLCAtMC40MDY3MzddLFxuICAgIFstMC45MzM1ODAsIDAuMjQxOTIyLCAwLjk5MjU0NiwgMC4xMjE4NjksIC0wLjk3MDI5NiwgLTAuMzU4MzY4XSxcbiAgICBbLTAuOTUxMDU3LCAwLjIwNzkxMiwgMC45OTQ1MjIsIDAuMTA0NTI4LCAtMC45NzgxNDgsIC0wLjMwOTAxN10sXG4gICAgWy0wLjk2NTkyNiwgMC4xNzM2NDgsIDAuOTk2MTk1LCAwLjA4NzE1NiwgLTAuOTg0ODA4LCAtMC4yNTg4MTldLFxuICAgIFstMC45NzgxNDgsIDAuMTM5MTczLCAwLjk5NzU2NCwgMC4wNjk3NTYsIC0wLjk5MDI2OCwgLTAuMjA3OTEyXSxcbiAgICBbLTAuOTg3Njg4LCAwLjEwNDUyOCwgMC45OTg2MzAsIDAuMDUyMzM2LCAtMC45OTQ1MjIsIC0wLjE1NjQzNF0sXG4gICAgWy0wLjk5NDUyMiwgMC4wNjk3NTYsIDAuOTk5MzkxLCAwLjAzNDg5OSwgLTAuOTk3NTY0LCAtMC4xMDQ1MjhdLFxuICAgIFstMC45OTg2MzAsIDAuMDM0ODk5LCAwLjk5OTg0OCwgMC4wMTc0NTIsIC0wLjk5OTM5MSwgLTAuMDUyMzM2XSxcbiAgICBbLTEuMDAwMDAwLCAwLjAwMDAwMCwgMS4wMDAwMDAsIDAuMDAwMDAwLCAtMS4wMDAwMDAsIC0wLjAwMDAwMF0sXG4gICAgWy0wLjk5ODYzMCwgLTAuMDM0ODk5LCAwLjk5OTg0OCwgLTAuMDE3NDUyLCAtMC45OTkzOTEsIDAuMDUyMzM2XSxcbiAgICBbLTAuOTk0NTIyLCAtMC4wNjk3NTYsIDAuOTk5MzkxLCAtMC4wMzQ4OTksIC0wLjk5NzU2NCwgMC4xMDQ1MjhdLFxuICAgIFstMC45ODc2ODgsIC0wLjEwNDUyOCwgMC45OTg2MzAsIC0wLjA1MjMzNiwgLTAuOTk0NTIyLCAwLjE1NjQzNF0sXG4gICAgWy0wLjk3ODE0OCwgLTAuMTM5MTczLCAwLjk5NzU2NCwgLTAuMDY5NzU2LCAtMC45OTAyNjgsIDAuMjA3OTEyXSxcbiAgICBbLTAuOTY1OTI2LCAtMC4xNzM2NDgsIDAuOTk2MTk1LCAtMC4wODcxNTYsIC0wLjk4NDgwOCwgMC4yNTg4MTldLFxuICAgIFstMC45NTEwNTcsIC0wLjIwNzkxMiwgMC45OTQ1MjIsIC0wLjEwNDUyOCwgLTAuOTc4MTQ4LCAwLjMwOTAxN10sXG4gICAgWy0wLjkzMzU4MCwgLTAuMjQxOTIyLCAwLjk5MjU0NiwgLTAuMTIxODY5LCAtMC45NzAyOTYsIDAuMzU4MzY4XSxcbiAgICBbLTAuOTEzNTQ1LCAtMC4yNzU2MzcsIDAuOTkwMjY4LCAtMC4xMzkxNzMsIC0wLjk2MTI2MiwgMC40MDY3MzddLFxuICAgIFstMC44OTEwMDcsIC0wLjMwOTAxNywgMC45ODc2ODgsIC0wLjE1NjQzNCwgLTAuOTUxMDU3LCAwLjQ1Mzk5MF0sXG4gICAgWy0wLjg2NjAyNSwgLTAuMzQyMDIwLCAwLjk4NDgwOCwgLTAuMTczNjQ4LCAtMC45Mzk2OTMsIDAuNTAwMDAwXSxcbiAgICBbLTAuODM4NjcxLCAtMC4zNzQ2MDcsIDAuOTgxNjI3LCAtMC4xOTA4MDksIC0wLjkyNzE4NCwgMC41NDQ2MzldLFxuICAgIFstMC44MDkwMTcsIC0wLjQwNjczNywgMC45NzgxNDgsIC0wLjIwNzkxMiwgLTAuOTEzNTQ1LCAwLjU4Nzc4NV0sXG4gICAgWy0wLjc3NzE0NiwgLTAuNDM4MzcxLCAwLjk3NDM3MCwgLTAuMjI0OTUxLCAtMC44OTg3OTQsIDAuNjI5MzIwXSxcbiAgICBbLTAuNzQzMTQ1LCAtMC40Njk0NzIsIDAuOTcwMjk2LCAtMC4yNDE5MjIsIC0wLjg4Mjk0OCwgMC42NjkxMzFdLFxuICAgIFstMC43MDcxMDcsIC0wLjUwMDAwMCwgMC45NjU5MjYsIC0wLjI1ODgxOSwgLTAuODY2MDI1LCAwLjcwNzEwN10sXG4gICAgWy0wLjY2OTEzMSwgLTAuNTI5OTE5LCAwLjk2MTI2MiwgLTAuMjc1NjM3LCAtMC44NDgwNDgsIDAuNzQzMTQ1XSxcbiAgICBbLTAuNjI5MzIwLCAtMC41NTkxOTMsIDAuOTU2MzA1LCAtMC4yOTIzNzIsIC0wLjgyOTAzOCwgMC43NzcxNDZdLFxuICAgIFstMC41ODc3ODUsIC0wLjU4Nzc4NSwgMC45NTEwNTcsIC0wLjMwOTAxNywgLTAuODA5MDE3LCAwLjgwOTAxN10sXG4gICAgWy0wLjU0NDYzOSwgLTAuNjE1NjYxLCAwLjk0NTUxOSwgLTAuMzI1NTY4LCAtMC43ODgwMTEsIDAuODM4NjcxXSxcbiAgICBbLTAuNTAwMDAwLCAtMC42NDI3ODgsIDAuOTM5NjkzLCAtMC4zNDIwMjAsIC0wLjc2NjA0NCwgMC44NjYwMjVdLFxuICAgIFstMC40NTM5OTAsIC0wLjY2OTEzMSwgMC45MzM1ODAsIC0wLjM1ODM2OCwgLTAuNzQzMTQ1LCAwLjg5MTAwN10sXG4gICAgWy0wLjQwNjczNywgLTAuNjk0NjU4LCAwLjkyNzE4NCwgLTAuMzc0NjA3LCAtMC43MTkzNDAsIDAuOTEzNTQ1XSxcbiAgICBbLTAuMzU4MzY4LCAtMC43MTkzNDAsIDAuOTIwNTA1LCAtMC4zOTA3MzEsIC0wLjY5NDY1OCwgMC45MzM1ODBdLFxuICAgIFstMC4zMDkwMTcsIC0wLjc0MzE0NSwgMC45MTM1NDUsIC0wLjQwNjczNywgLTAuNjY5MTMxLCAwLjk1MTA1N10sXG4gICAgWy0wLjI1ODgxOSwgLTAuNzY2MDQ0LCAwLjkwNjMwOCwgLTAuNDIyNjE4LCAtMC42NDI3ODgsIDAuOTY1OTI2XSxcbiAgICBbLTAuMjA3OTEyLCAtMC43ODgwMTEsIDAuODk4Nzk0LCAtMC40MzgzNzEsIC0wLjYxNTY2MSwgMC45NzgxNDhdLFxuICAgIFstMC4xNTY0MzQsIC0wLjgwOTAxNywgMC44OTEwMDcsIC0wLjQ1Mzk5MCwgLTAuNTg3Nzg1LCAwLjk4NzY4OF0sXG4gICAgWy0wLjEwNDUyOCwgLTAuODI5MDM4LCAwLjg4Mjk0OCwgLTAuNDY5NDcyLCAtMC41NTkxOTMsIDAuOTk0NTIyXSxcbiAgICBbLTAuMDUyMzM2LCAtMC44NDgwNDgsIDAuODc0NjIwLCAtMC40ODQ4MTAsIC0wLjUyOTkxOSwgMC45OTg2MzBdLFxuICAgIFstMC4wMDAwMDAsIC0wLjg2NjAyNSwgMC44NjYwMjUsIC0wLjUwMDAwMCwgLTAuNTAwMDAwLCAxLjAwMDAwMF0sXG4gICAgWzAuMDUyMzM2LCAtMC44ODI5NDgsIDAuODU3MTY3LCAtMC41MTUwMzgsIC0wLjQ2OTQ3MiwgMC45OTg2MzBdLFxuICAgIFswLjEwNDUyOCwgLTAuODk4Nzk0LCAwLjg0ODA0OCwgLTAuNTI5OTE5LCAtMC40MzgzNzEsIDAuOTk0NTIyXSxcbiAgICBbMC4xNTY0MzQsIC0wLjkxMzU0NSwgMC44Mzg2NzEsIC0wLjU0NDYzOSwgLTAuNDA2NzM3LCAwLjk4NzY4OF0sXG4gICAgWzAuMjA3OTEyLCAtMC45MjcxODQsIDAuODI5MDM4LCAtMC41NTkxOTMsIC0wLjM3NDYwNywgMC45NzgxNDhdLFxuICAgIFswLjI1ODgxOSwgLTAuOTM5NjkzLCAwLjgxOTE1MiwgLTAuNTczNTc2LCAtMC4zNDIwMjAsIDAuOTY1OTI2XSxcbiAgICBbMC4zMDkwMTcsIC0wLjk1MTA1NywgMC44MDkwMTcsIC0wLjU4Nzc4NSwgLTAuMzA5MDE3LCAwLjk1MTA1N10sXG4gICAgWzAuMzU4MzY4LCAtMC45NjEyNjIsIDAuNzk4NjM2LCAtMC42MDE4MTUsIC0wLjI3NTYzNywgMC45MzM1ODBdLFxuICAgIFswLjQwNjczNywgLTAuOTcwMjk2LCAwLjc4ODAxMSwgLTAuNjE1NjYxLCAtMC4yNDE5MjIsIDAuOTEzNTQ1XSxcbiAgICBbMC40NTM5OTAsIC0wLjk3ODE0OCwgMC43NzcxNDYsIC0wLjYyOTMyMCwgLTAuMjA3OTEyLCAwLjg5MTAwN10sXG4gICAgWzAuNTAwMDAwLCAtMC45ODQ4MDgsIDAuNzY2MDQ0LCAtMC42NDI3ODgsIC0wLjE3MzY0OCwgMC44NjYwMjVdLFxuICAgIFswLjU0NDYzOSwgLTAuOTkwMjY4LCAwLjc1NDcxMCwgLTAuNjU2MDU5LCAtMC4xMzkxNzMsIDAuODM4NjcxXSxcbiAgICBbMC41ODc3ODUsIC0wLjk5NDUyMiwgMC43NDMxNDUsIC0wLjY2OTEzMSwgLTAuMTA0NTI4LCAwLjgwOTAxN10sXG4gICAgWzAuNjI5MzIwLCAtMC45OTc1NjQsIDAuNzMxMzU0LCAtMC42ODE5OTgsIC0wLjA2OTc1NiwgMC43NzcxNDZdLFxuICAgIFswLjY2OTEzMSwgLTAuOTk5MzkxLCAwLjcxOTM0MCwgLTAuNjk0NjU4LCAtMC4wMzQ4OTksIDAuNzQzMTQ1XSxcbiAgICBbMC43MDcxMDcsIC0xLjAwMDAwMCwgMC43MDcxMDcsIC0wLjcwNzEwNywgLTAuMDAwMDAwLCAwLjcwNzEwN10sXG4gICAgWzAuNzQzMTQ1LCAtMC45OTkzOTEsIDAuNjk0NjU4LCAtMC43MTkzNDAsIDAuMDM0ODk5LCAwLjY2OTEzMV0sXG4gICAgWzAuNzc3MTQ2LCAtMC45OTc1NjQsIDAuNjgxOTk4LCAtMC43MzEzNTQsIDAuMDY5NzU2LCAwLjYyOTMyMF0sXG4gICAgWzAuODA5MDE3LCAtMC45OTQ1MjIsIDAuNjY5MTMxLCAtMC43NDMxNDUsIDAuMTA0NTI4LCAwLjU4Nzc4NV0sXG4gICAgWzAuODM4NjcxLCAtMC45OTAyNjgsIDAuNjU2MDU5LCAtMC43NTQ3MTAsIDAuMTM5MTczLCAwLjU0NDYzOV0sXG4gICAgWzAuODY2MDI1LCAtMC45ODQ4MDgsIDAuNjQyNzg4LCAtMC43NjYwNDQsIDAuMTczNjQ4LCAwLjUwMDAwMF0sXG4gICAgWzAuODkxMDA3LCAtMC45NzgxNDgsIDAuNjI5MzIwLCAtMC43NzcxNDYsIDAuMjA3OTEyLCAwLjQ1Mzk5MF0sXG4gICAgWzAuOTEzNTQ1LCAtMC45NzAyOTYsIDAuNjE1NjYxLCAtMC43ODgwMTEsIDAuMjQxOTIyLCAwLjQwNjczN10sXG4gICAgWzAuOTMzNTgwLCAtMC45NjEyNjIsIDAuNjAxODE1LCAtMC43OTg2MzYsIDAuMjc1NjM3LCAwLjM1ODM2OF0sXG4gICAgWzAuOTUxMDU3LCAtMC45NTEwNTcsIDAuNTg3Nzg1LCAtMC44MDkwMTcsIDAuMzA5MDE3LCAwLjMwOTAxN10sXG4gICAgWzAuOTY1OTI2LCAtMC45Mzk2OTMsIDAuNTczNTc2LCAtMC44MTkxNTIsIDAuMzQyMDIwLCAwLjI1ODgxOV0sXG4gICAgWzAuOTc4MTQ4LCAtMC45MjcxODQsIDAuNTU5MTkzLCAtMC44MjkwMzgsIDAuMzc0NjA3LCAwLjIwNzkxMl0sXG4gICAgWzAuOTg3Njg4LCAtMC45MTM1NDUsIDAuNTQ0NjM5LCAtMC44Mzg2NzEsIDAuNDA2NzM3LCAwLjE1NjQzNF0sXG4gICAgWzAuOTk0NTIyLCAtMC44OTg3OTQsIDAuNTI5OTE5LCAtMC44NDgwNDgsIDAuNDM4MzcxLCAwLjEwNDUyOF0sXG4gICAgWzAuOTk4NjMwLCAtMC44ODI5NDgsIDAuNTE1MDM4LCAtMC44NTcxNjcsIDAuNDY5NDcyLCAwLjA1MjMzNl0sXG4gICAgWzEuMDAwMDAwLCAtMC44NjYwMjUsIDAuNTAwMDAwLCAtMC44NjYwMjUsIDAuNTAwMDAwLCAwLjAwMDAwMF0sXG4gICAgWzAuOTk4NjMwLCAtMC44NDgwNDgsIDAuNDg0ODEwLCAtMC44NzQ2MjAsIDAuNTI5OTE5LCAtMC4wNTIzMzZdLFxuICAgIFswLjk5NDUyMiwgLTAuODI5MDM4LCAwLjQ2OTQ3MiwgLTAuODgyOTQ4LCAwLjU1OTE5MywgLTAuMTA0NTI4XSxcbiAgICBbMC45ODc2ODgsIC0wLjgwOTAxNywgMC40NTM5OTAsIC0wLjg5MTAwNywgMC41ODc3ODUsIC0wLjE1NjQzNF0sXG4gICAgWzAuOTc4MTQ4LCAtMC43ODgwMTEsIDAuNDM4MzcxLCAtMC44OTg3OTQsIDAuNjE1NjYxLCAtMC4yMDc5MTJdLFxuICAgIFswLjk2NTkyNiwgLTAuNzY2MDQ0LCAwLjQyMjYxOCwgLTAuOTA2MzA4LCAwLjY0Mjc4OCwgLTAuMjU4ODE5XSxcbiAgICBbMC45NTEwNTcsIC0wLjc0MzE0NSwgMC40MDY3MzcsIC0wLjkxMzU0NSwgMC42NjkxMzEsIC0wLjMwOTAxN10sXG4gICAgWzAuOTMzNTgwLCAtMC43MTkzNDAsIDAuMzkwNzMxLCAtMC45MjA1MDUsIDAuNjk0NjU4LCAtMC4zNTgzNjhdLFxuICAgIFswLjkxMzU0NSwgLTAuNjk0NjU4LCAwLjM3NDYwNywgLTAuOTI3MTg0LCAwLjcxOTM0MCwgLTAuNDA2NzM3XSxcbiAgICBbMC44OTEwMDcsIC0wLjY2OTEzMSwgMC4zNTgzNjgsIC0wLjkzMzU4MCwgMC43NDMxNDUsIC0wLjQ1Mzk5MF0sXG4gICAgWzAuODY2MDI1LCAtMC42NDI3ODgsIDAuMzQyMDIwLCAtMC45Mzk2OTMsIDAuNzY2MDQ0LCAtMC41MDAwMDBdLFxuICAgIFswLjgzODY3MSwgLTAuNjE1NjYxLCAwLjMyNTU2OCwgLTAuOTQ1NTE5LCAwLjc4ODAxMSwgLTAuNTQ0NjM5XSxcbiAgICBbMC44MDkwMTcsIC0wLjU4Nzc4NSwgMC4zMDkwMTcsIC0wLjk1MTA1NywgMC44MDkwMTcsIC0wLjU4Nzc4NV0sXG4gICAgWzAuNzc3MTQ2LCAtMC41NTkxOTMsIDAuMjkyMzcyLCAtMC45NTYzMDUsIDAuODI5MDM4LCAtMC42MjkzMjBdLFxuICAgIFswLjc0MzE0NSwgLTAuNTI5OTE5LCAwLjI3NTYzNywgLTAuOTYxMjYyLCAwLjg0ODA0OCwgLTAuNjY5MTMxXSxcbiAgICBbMC43MDcxMDcsIC0wLjUwMDAwMCwgMC4yNTg4MTksIC0wLjk2NTkyNiwgMC44NjYwMjUsIC0wLjcwNzEwN10sXG4gICAgWzAuNjY5MTMxLCAtMC40Njk0NzIsIDAuMjQxOTIyLCAtMC45NzAyOTYsIDAuODgyOTQ4LCAtMC43NDMxNDVdLFxuICAgIFswLjYyOTMyMCwgLTAuNDM4MzcxLCAwLjIyNDk1MSwgLTAuOTc0MzcwLCAwLjg5ODc5NCwgLTAuNzc3MTQ2XSxcbiAgICBbMC41ODc3ODUsIC0wLjQwNjczNywgMC4yMDc5MTIsIC0wLjk3ODE0OCwgMC45MTM1NDUsIC0wLjgwOTAxN10sXG4gICAgWzAuNTQ0NjM5LCAtMC4zNzQ2MDcsIDAuMTkwODA5LCAtMC45ODE2MjcsIDAuOTI3MTg0LCAtMC44Mzg2NzFdLFxuICAgIFswLjUwMDAwMCwgLTAuMzQyMDIwLCAwLjE3MzY0OCwgLTAuOTg0ODA4LCAwLjkzOTY5MywgLTAuODY2MDI1XSxcbiAgICBbMC40NTM5OTAsIC0wLjMwOTAxNywgMC4xNTY0MzQsIC0wLjk4NzY4OCwgMC45NTEwNTcsIC0wLjg5MTAwN10sXG4gICAgWzAuNDA2NzM3LCAtMC4yNzU2MzcsIDAuMTM5MTczLCAtMC45OTAyNjgsIDAuOTYxMjYyLCAtMC45MTM1NDVdLFxuICAgIFswLjM1ODM2OCwgLTAuMjQxOTIyLCAwLjEyMTg2OSwgLTAuOTkyNTQ2LCAwLjk3MDI5NiwgLTAuOTMzNTgwXSxcbiAgICBbMC4zMDkwMTcsIC0wLjIwNzkxMiwgMC4xMDQ1MjgsIC0wLjk5NDUyMiwgMC45NzgxNDgsIC0wLjk1MTA1N10sXG4gICAgWzAuMjU4ODE5LCAtMC4xNzM2NDgsIDAuMDg3MTU2LCAtMC45OTYxOTUsIDAuOTg0ODA4LCAtMC45NjU5MjZdLFxuICAgIFswLjIwNzkxMiwgLTAuMTM5MTczLCAwLjA2OTc1NiwgLTAuOTk3NTY0LCAwLjk5MDI2OCwgLTAuOTc4MTQ4XSxcbiAgICBbMC4xNTY0MzQsIC0wLjEwNDUyOCwgMC4wNTIzMzYsIC0wLjk5ODYzMCwgMC45OTQ1MjIsIC0wLjk4NzY4OF0sXG4gICAgWzAuMTA0NTI4LCAtMC4wNjk3NTYsIDAuMDM0ODk5LCAtMC45OTkzOTEsIDAuOTk3NTY0LCAtMC45OTQ1MjJdLFxuICAgIFswLjA1MjMzNiwgLTAuMDM0ODk5LCAwLjAxNzQ1MiwgLTAuOTk5ODQ4LCAwLjk5OTM5MSwgLTAuOTk4NjMwXSxcbiAgICBbMC4wMDAwMDAsIC0wLjAwMDAwMCwgMC4wMDAwMDAsIC0xLjAwMDAwMCwgMS4wMDAwMDAsIC0xLjAwMDAwMF0sXG4gICAgWy0wLjA1MjMzNiwgMC4wMzQ4OTksIC0wLjAxNzQ1MiwgLTAuOTk5ODQ4LCAwLjk5OTM5MSwgLTAuOTk4NjMwXSxcbiAgICBbLTAuMTA0NTI4LCAwLjA2OTc1NiwgLTAuMDM0ODk5LCAtMC45OTkzOTEsIDAuOTk3NTY0LCAtMC45OTQ1MjJdLFxuICAgIFstMC4xNTY0MzQsIDAuMTA0NTI4LCAtMC4wNTIzMzYsIC0wLjk5ODYzMCwgMC45OTQ1MjIsIC0wLjk4NzY4OF0sXG4gICAgWy0wLjIwNzkxMiwgMC4xMzkxNzMsIC0wLjA2OTc1NiwgLTAuOTk3NTY0LCAwLjk5MDI2OCwgLTAuOTc4MTQ4XSxcbiAgICBbLTAuMjU4ODE5LCAwLjE3MzY0OCwgLTAuMDg3MTU2LCAtMC45OTYxOTUsIDAuOTg0ODA4LCAtMC45NjU5MjZdLFxuICAgIFstMC4zMDkwMTcsIDAuMjA3OTEyLCAtMC4xMDQ1MjgsIC0wLjk5NDUyMiwgMC45NzgxNDgsIC0wLjk1MTA1N10sXG4gICAgWy0wLjM1ODM2OCwgMC4yNDE5MjIsIC0wLjEyMTg2OSwgLTAuOTkyNTQ2LCAwLjk3MDI5NiwgLTAuOTMzNTgwXSxcbiAgICBbLTAuNDA2NzM3LCAwLjI3NTYzNywgLTAuMTM5MTczLCAtMC45OTAyNjgsIDAuOTYxMjYyLCAtMC45MTM1NDVdLFxuICAgIFstMC40NTM5OTAsIDAuMzA5MDE3LCAtMC4xNTY0MzQsIC0wLjk4NzY4OCwgMC45NTEwNTcsIC0wLjg5MTAwN10sXG4gICAgWy0wLjUwMDAwMCwgMC4zNDIwMjAsIC0wLjE3MzY0OCwgLTAuOTg0ODA4LCAwLjkzOTY5MywgLTAuODY2MDI1XSxcbiAgICBbLTAuNTQ0NjM5LCAwLjM3NDYwNywgLTAuMTkwODA5LCAtMC45ODE2MjcsIDAuOTI3MTg0LCAtMC44Mzg2NzFdLFxuICAgIFstMC41ODc3ODUsIDAuNDA2NzM3LCAtMC4yMDc5MTIsIC0wLjk3ODE0OCwgMC45MTM1NDUsIC0wLjgwOTAxN10sXG4gICAgWy0wLjYyOTMyMCwgMC40MzgzNzEsIC0wLjIyNDk1MSwgLTAuOTc0MzcwLCAwLjg5ODc5NCwgLTAuNzc3MTQ2XSxcbiAgICBbLTAuNjY5MTMxLCAwLjQ2OTQ3MiwgLTAuMjQxOTIyLCAtMC45NzAyOTYsIDAuODgyOTQ4LCAtMC43NDMxNDVdLFxuICAgIFstMC43MDcxMDcsIDAuNTAwMDAwLCAtMC4yNTg4MTksIC0wLjk2NTkyNiwgMC44NjYwMjUsIC0wLjcwNzEwN10sXG4gICAgWy0wLjc0MzE0NSwgMC41Mjk5MTksIC0wLjI3NTYzNywgLTAuOTYxMjYyLCAwLjg0ODA0OCwgLTAuNjY5MTMxXSxcbiAgICBbLTAuNzc3MTQ2LCAwLjU1OTE5MywgLTAuMjkyMzcyLCAtMC45NTYzMDUsIDAuODI5MDM4LCAtMC42MjkzMjBdLFxuICAgIFstMC44MDkwMTcsIDAuNTg3Nzg1LCAtMC4zMDkwMTcsIC0wLjk1MTA1NywgMC44MDkwMTcsIC0wLjU4Nzc4NV0sXG4gICAgWy0wLjgzODY3MSwgMC42MTU2NjEsIC0wLjMyNTU2OCwgLTAuOTQ1NTE5LCAwLjc4ODAxMSwgLTAuNTQ0NjM5XSxcbiAgICBbLTAuODY2MDI1LCAwLjY0Mjc4OCwgLTAuMzQyMDIwLCAtMC45Mzk2OTMsIDAuNzY2MDQ0LCAtMC41MDAwMDBdLFxuICAgIFstMC44OTEwMDcsIDAuNjY5MTMxLCAtMC4zNTgzNjgsIC0wLjkzMzU4MCwgMC43NDMxNDUsIC0wLjQ1Mzk5MF0sXG4gICAgWy0wLjkxMzU0NSwgMC42OTQ2NTgsIC0wLjM3NDYwNywgLTAuOTI3MTg0LCAwLjcxOTM0MCwgLTAuNDA2NzM3XSxcbiAgICBbLTAuOTMzNTgwLCAwLjcxOTM0MCwgLTAuMzkwNzMxLCAtMC45MjA1MDUsIDAuNjk0NjU4LCAtMC4zNTgzNjhdLFxuICAgIFstMC45NTEwNTcsIDAuNzQzMTQ1LCAtMC40MDY3MzcsIC0wLjkxMzU0NSwgMC42NjkxMzEsIC0wLjMwOTAxN10sXG4gICAgWy0wLjk2NTkyNiwgMC43NjYwNDQsIC0wLjQyMjYxOCwgLTAuOTA2MzA4LCAwLjY0Mjc4OCwgLTAuMjU4ODE5XSxcbiAgICBbLTAuOTc4MTQ4LCAwLjc4ODAxMSwgLTAuNDM4MzcxLCAtMC44OTg3OTQsIDAuNjE1NjYxLCAtMC4yMDc5MTJdLFxuICAgIFstMC45ODc2ODgsIDAuODA5MDE3LCAtMC40NTM5OTAsIC0wLjg5MTAwNywgMC41ODc3ODUsIC0wLjE1NjQzNF0sXG4gICAgWy0wLjk5NDUyMiwgMC44MjkwMzgsIC0wLjQ2OTQ3MiwgLTAuODgyOTQ4LCAwLjU1OTE5MywgLTAuMTA0NTI4XSxcbiAgICBbLTAuOTk4NjMwLCAwLjg0ODA0OCwgLTAuNDg0ODEwLCAtMC44NzQ2MjAsIDAuNTI5OTE5LCAtMC4wNTIzMzZdLFxuICAgIFstMS4wMDAwMDAsIDAuODY2MDI1LCAtMC41MDAwMDAsIC0wLjg2NjAyNSwgMC41MDAwMDAsIDAuMDAwMDAwXSxcbiAgICBbLTAuOTk4NjMwLCAwLjg4Mjk0OCwgLTAuNTE1MDM4LCAtMC44NTcxNjcsIDAuNDY5NDcyLCAwLjA1MjMzNl0sXG4gICAgWy0wLjk5NDUyMiwgMC44OTg3OTQsIC0wLjUyOTkxOSwgLTAuODQ4MDQ4LCAwLjQzODM3MSwgMC4xMDQ1MjhdLFxuICAgIFstMC45ODc2ODgsIDAuOTEzNTQ1LCAtMC41NDQ2MzksIC0wLjgzODY3MSwgMC40MDY3MzcsIDAuMTU2NDM0XSxcbiAgICBbLTAuOTc4MTQ4LCAwLjkyNzE4NCwgLTAuNTU5MTkzLCAtMC44MjkwMzgsIDAuMzc0NjA3LCAwLjIwNzkxMl0sXG4gICAgWy0wLjk2NTkyNiwgMC45Mzk2OTMsIC0wLjU3MzU3NiwgLTAuODE5MTUyLCAwLjM0MjAyMCwgMC4yNTg4MTldLFxuICAgIFstMC45NTEwNTcsIDAuOTUxMDU3LCAtMC41ODc3ODUsIC0wLjgwOTAxNywgMC4zMDkwMTcsIDAuMzA5MDE3XSxcbiAgICBbLTAuOTMzNTgwLCAwLjk2MTI2MiwgLTAuNjAxODE1LCAtMC43OTg2MzYsIDAuMjc1NjM3LCAwLjM1ODM2OF0sXG4gICAgWy0wLjkxMzU0NSwgMC45NzAyOTYsIC0wLjYxNTY2MSwgLTAuNzg4MDExLCAwLjI0MTkyMiwgMC40MDY3MzddLFxuICAgIFstMC44OTEwMDcsIDAuOTc4MTQ4LCAtMC42MjkzMjAsIC0wLjc3NzE0NiwgMC4yMDc5MTIsIDAuNDUzOTkwXSxcbiAgICBbLTAuODY2MDI1LCAwLjk4NDgwOCwgLTAuNjQyNzg4LCAtMC43NjYwNDQsIDAuMTczNjQ4LCAwLjUwMDAwMF0sXG4gICAgWy0wLjgzODY3MSwgMC45OTAyNjgsIC0wLjY1NjA1OSwgLTAuNzU0NzEwLCAwLjEzOTE3MywgMC41NDQ2MzldLFxuICAgIFstMC44MDkwMTcsIDAuOTk0NTIyLCAtMC42NjkxMzEsIC0wLjc0MzE0NSwgMC4xMDQ1MjgsIDAuNTg3Nzg1XSxcbiAgICBbLTAuNzc3MTQ2LCAwLjk5NzU2NCwgLTAuNjgxOTk4LCAtMC43MzEzNTQsIDAuMDY5NzU2LCAwLjYyOTMyMF0sXG4gICAgWy0wLjc0MzE0NSwgMC45OTkzOTEsIC0wLjY5NDY1OCwgLTAuNzE5MzQwLCAwLjAzNDg5OSwgMC42NjkxMzFdLFxuICAgIFstMC43MDcxMDcsIDEuMDAwMDAwLCAtMC43MDcxMDcsIC0wLjcwNzEwNywgMC4wMDAwMDAsIDAuNzA3MTA3XSxcbiAgICBbLTAuNjY5MTMxLCAwLjk5OTM5MSwgLTAuNzE5MzQwLCAtMC42OTQ2NTgsIC0wLjAzNDg5OSwgMC43NDMxNDVdLFxuICAgIFstMC42MjkzMjAsIDAuOTk3NTY0LCAtMC43MzEzNTQsIC0wLjY4MTk5OCwgLTAuMDY5NzU2LCAwLjc3NzE0Nl0sXG4gICAgWy0wLjU4Nzc4NSwgMC45OTQ1MjIsIC0wLjc0MzE0NSwgLTAuNjY5MTMxLCAtMC4xMDQ1MjgsIDAuODA5MDE3XSxcbiAgICBbLTAuNTQ0NjM5LCAwLjk5MDI2OCwgLTAuNzU0NzEwLCAtMC42NTYwNTksIC0wLjEzOTE3MywgMC44Mzg2NzFdLFxuICAgIFstMC41MDAwMDAsIDAuOTg0ODA4LCAtMC43NjYwNDQsIC0wLjY0Mjc4OCwgLTAuMTczNjQ4LCAwLjg2NjAyNV0sXG4gICAgWy0wLjQ1Mzk5MCwgMC45NzgxNDgsIC0wLjc3NzE0NiwgLTAuNjI5MzIwLCAtMC4yMDc5MTIsIDAuODkxMDA3XSxcbiAgICBbLTAuNDA2NzM3LCAwLjk3MDI5NiwgLTAuNzg4MDExLCAtMC42MTU2NjEsIC0wLjI0MTkyMiwgMC45MTM1NDVdLFxuICAgIFstMC4zNTgzNjgsIDAuOTYxMjYyLCAtMC43OTg2MzYsIC0wLjYwMTgxNSwgLTAuMjc1NjM3LCAwLjkzMzU4MF0sXG4gICAgWy0wLjMwOTAxNywgMC45NTEwNTcsIC0wLjgwOTAxNywgLTAuNTg3Nzg1LCAtMC4zMDkwMTcsIDAuOTUxMDU3XSxcbiAgICBbLTAuMjU4ODE5LCAwLjkzOTY5MywgLTAuODE5MTUyLCAtMC41NzM1NzYsIC0wLjM0MjAyMCwgMC45NjU5MjZdLFxuICAgIFstMC4yMDc5MTIsIDAuOTI3MTg0LCAtMC44MjkwMzgsIC0wLjU1OTE5MywgLTAuMzc0NjA3LCAwLjk3ODE0OF0sXG4gICAgWy0wLjE1NjQzNCwgMC45MTM1NDUsIC0wLjgzODY3MSwgLTAuNTQ0NjM5LCAtMC40MDY3MzcsIDAuOTg3Njg4XSxcbiAgICBbLTAuMTA0NTI4LCAwLjg5ODc5NCwgLTAuODQ4MDQ4LCAtMC41Mjk5MTksIC0wLjQzODM3MSwgMC45OTQ1MjJdLFxuICAgIFstMC4wNTIzMzYsIDAuODgyOTQ4LCAtMC44NTcxNjcsIC0wLjUxNTAzOCwgLTAuNDY5NDcyLCAwLjk5ODYzMF0sXG4gICAgWy0wLjAwMDAwMCwgMC44NjYwMjUsIC0wLjg2NjAyNSwgLTAuNTAwMDAwLCAtMC41MDAwMDAsIDEuMDAwMDAwXSxcbiAgICBbMC4wNTIzMzYsIDAuODQ4MDQ4LCAtMC44NzQ2MjAsIC0wLjQ4NDgxMCwgLTAuNTI5OTE5LCAwLjk5ODYzMF0sXG4gICAgWzAuMTA0NTI4LCAwLjgyOTAzOCwgLTAuODgyOTQ4LCAtMC40Njk0NzIsIC0wLjU1OTE5MywgMC45OTQ1MjJdLFxuICAgIFswLjE1NjQzNCwgMC44MDkwMTcsIC0wLjg5MTAwNywgLTAuNDUzOTkwLCAtMC41ODc3ODUsIDAuOTg3Njg4XSxcbiAgICBbMC4yMDc5MTIsIDAuNzg4MDExLCAtMC44OTg3OTQsIC0wLjQzODM3MSwgLTAuNjE1NjYxLCAwLjk3ODE0OF0sXG4gICAgWzAuMjU4ODE5LCAwLjc2NjA0NCwgLTAuOTA2MzA4LCAtMC40MjI2MTgsIC0wLjY0Mjc4OCwgMC45NjU5MjZdLFxuICAgIFswLjMwOTAxNywgMC43NDMxNDUsIC0wLjkxMzU0NSwgLTAuNDA2NzM3LCAtMC42NjkxMzEsIDAuOTUxMDU3XSxcbiAgICBbMC4zNTgzNjgsIDAuNzE5MzQwLCAtMC45MjA1MDUsIC0wLjM5MDczMSwgLTAuNjk0NjU4LCAwLjkzMzU4MF0sXG4gICAgWzAuNDA2NzM3LCAwLjY5NDY1OCwgLTAuOTI3MTg0LCAtMC4zNzQ2MDcsIC0wLjcxOTM0MCwgMC45MTM1NDVdLFxuICAgIFswLjQ1Mzk5MCwgMC42NjkxMzEsIC0wLjkzMzU4MCwgLTAuMzU4MzY4LCAtMC43NDMxNDUsIDAuODkxMDA3XSxcbiAgICBbMC41MDAwMDAsIDAuNjQyNzg4LCAtMC45Mzk2OTMsIC0wLjM0MjAyMCwgLTAuNzY2MDQ0LCAwLjg2NjAyNV0sXG4gICAgWzAuNTQ0NjM5LCAwLjYxNTY2MSwgLTAuOTQ1NTE5LCAtMC4zMjU1NjgsIC0wLjc4ODAxMSwgMC44Mzg2NzFdLFxuICAgIFswLjU4Nzc4NSwgMC41ODc3ODUsIC0wLjk1MTA1NywgLTAuMzA5MDE3LCAtMC44MDkwMTcsIDAuODA5MDE3XSxcbiAgICBbMC42MjkzMjAsIDAuNTU5MTkzLCAtMC45NTYzMDUsIC0wLjI5MjM3MiwgLTAuODI5MDM4LCAwLjc3NzE0Nl0sXG4gICAgWzAuNjY5MTMxLCAwLjUyOTkxOSwgLTAuOTYxMjYyLCAtMC4yNzU2MzcsIC0wLjg0ODA0OCwgMC43NDMxNDVdLFxuICAgIFswLjcwNzEwNywgMC41MDAwMDAsIC0wLjk2NTkyNiwgLTAuMjU4ODE5LCAtMC44NjYwMjUsIDAuNzA3MTA3XSxcbiAgICBbMC43NDMxNDUsIDAuNDY5NDcyLCAtMC45NzAyOTYsIC0wLjI0MTkyMiwgLTAuODgyOTQ4LCAwLjY2OTEzMV0sXG4gICAgWzAuNzc3MTQ2LCAwLjQzODM3MSwgLTAuOTc0MzcwLCAtMC4yMjQ5NTEsIC0wLjg5ODc5NCwgMC42MjkzMjBdLFxuICAgIFswLjgwOTAxNywgMC40MDY3MzcsIC0wLjk3ODE0OCwgLTAuMjA3OTEyLCAtMC45MTM1NDUsIDAuNTg3Nzg1XSxcbiAgICBbMC44Mzg2NzEsIDAuMzc0NjA3LCAtMC45ODE2MjcsIC0wLjE5MDgwOSwgLTAuOTI3MTg0LCAwLjU0NDYzOV0sXG4gICAgWzAuODY2MDI1LCAwLjM0MjAyMCwgLTAuOTg0ODA4LCAtMC4xNzM2NDgsIC0wLjkzOTY5MywgMC41MDAwMDBdLFxuICAgIFswLjg5MTAwNywgMC4zMDkwMTcsIC0wLjk4NzY4OCwgLTAuMTU2NDM0LCAtMC45NTEwNTcsIDAuNDUzOTkwXSxcbiAgICBbMC45MTM1NDUsIDAuMjc1NjM3LCAtMC45OTAyNjgsIC0wLjEzOTE3MywgLTAuOTYxMjYyLCAwLjQwNjczN10sXG4gICAgWzAuOTMzNTgwLCAwLjI0MTkyMiwgLTAuOTkyNTQ2LCAtMC4xMjE4NjksIC0wLjk3MDI5NiwgMC4zNTgzNjhdLFxuICAgIFswLjk1MTA1NywgMC4yMDc5MTIsIC0wLjk5NDUyMiwgLTAuMTA0NTI4LCAtMC45NzgxNDgsIDAuMzA5MDE3XSxcbiAgICBbMC45NjU5MjYsIDAuMTczNjQ4LCAtMC45OTYxOTUsIC0wLjA4NzE1NiwgLTAuOTg0ODA4LCAwLjI1ODgxOV0sXG4gICAgWzAuOTc4MTQ4LCAwLjEzOTE3MywgLTAuOTk3NTY0LCAtMC4wNjk3NTYsIC0wLjk5MDI2OCwgMC4yMDc5MTJdLFxuICAgIFswLjk4NzY4OCwgMC4xMDQ1MjgsIC0wLjk5ODYzMCwgLTAuMDUyMzM2LCAtMC45OTQ1MjIsIDAuMTU2NDM0XSxcbiAgICBbMC45OTQ1MjIsIDAuMDY5NzU2LCAtMC45OTkzOTEsIC0wLjAzNDg5OSwgLTAuOTk3NTY0LCAwLjEwNDUyOF0sXG4gICAgWzAuOTk4NjMwLCAwLjAzNDg5OSwgLTAuOTk5ODQ4LCAtMC4wMTc0NTIsIC0wLjk5OTM5MSwgMC4wNTIzMzZdLFxuICAgIFsxLjAwMDAwMCwgMC4wMDAwMDAsIC0xLjAwMDAwMCwgLTAuMDAwMDAwLCAtMS4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgICBbMC45OTg2MzAsIC0wLjAzNDg5OSwgLTAuOTk5ODQ4LCAwLjAxNzQ1MiwgLTAuOTk5MzkxLCAtMC4wNTIzMzZdLFxuICAgIFswLjk5NDUyMiwgLTAuMDY5NzU2LCAtMC45OTkzOTEsIDAuMDM0ODk5LCAtMC45OTc1NjQsIC0wLjEwNDUyOF0sXG4gICAgWzAuOTg3Njg4LCAtMC4xMDQ1MjgsIC0wLjk5ODYzMCwgMC4wNTIzMzYsIC0wLjk5NDUyMiwgLTAuMTU2NDM0XSxcbiAgICBbMC45NzgxNDgsIC0wLjEzOTE3MywgLTAuOTk3NTY0LCAwLjA2OTc1NiwgLTAuOTkwMjY4LCAtMC4yMDc5MTJdLFxuICAgIFswLjk2NTkyNiwgLTAuMTczNjQ4LCAtMC45OTYxOTUsIDAuMDg3MTU2LCAtMC45ODQ4MDgsIC0wLjI1ODgxOV0sXG4gICAgWzAuOTUxMDU3LCAtMC4yMDc5MTIsIC0wLjk5NDUyMiwgMC4xMDQ1MjgsIC0wLjk3ODE0OCwgLTAuMzA5MDE3XSxcbiAgICBbMC45MzM1ODAsIC0wLjI0MTkyMiwgLTAuOTkyNTQ2LCAwLjEyMTg2OSwgLTAuOTcwMjk2LCAtMC4zNTgzNjhdLFxuICAgIFswLjkxMzU0NSwgLTAuMjc1NjM3LCAtMC45OTAyNjgsIDAuMTM5MTczLCAtMC45NjEyNjIsIC0wLjQwNjczN10sXG4gICAgWzAuODkxMDA3LCAtMC4zMDkwMTcsIC0wLjk4NzY4OCwgMC4xNTY0MzQsIC0wLjk1MTA1NywgLTAuNDUzOTkwXSxcbiAgICBbMC44NjYwMjUsIC0wLjM0MjAyMCwgLTAuOTg0ODA4LCAwLjE3MzY0OCwgLTAuOTM5NjkzLCAtMC41MDAwMDBdLFxuICAgIFswLjgzODY3MSwgLTAuMzc0NjA3LCAtMC45ODE2MjcsIDAuMTkwODA5LCAtMC45MjcxODQsIC0wLjU0NDYzOV0sXG4gICAgWzAuODA5MDE3LCAtMC40MDY3MzcsIC0wLjk3ODE0OCwgMC4yMDc5MTIsIC0wLjkxMzU0NSwgLTAuNTg3Nzg1XSxcbiAgICBbMC43NzcxNDYsIC0wLjQzODM3MSwgLTAuOTc0MzcwLCAwLjIyNDk1MSwgLTAuODk4Nzk0LCAtMC42MjkzMjBdLFxuICAgIFswLjc0MzE0NSwgLTAuNDY5NDcyLCAtMC45NzAyOTYsIDAuMjQxOTIyLCAtMC44ODI5NDgsIC0wLjY2OTEzMV0sXG4gICAgWzAuNzA3MTA3LCAtMC41MDAwMDAsIC0wLjk2NTkyNiwgMC4yNTg4MTksIC0wLjg2NjAyNSwgLTAuNzA3MTA3XSxcbiAgICBbMC42NjkxMzEsIC0wLjUyOTkxOSwgLTAuOTYxMjYyLCAwLjI3NTYzNywgLTAuODQ4MDQ4LCAtMC43NDMxNDVdLFxuICAgIFswLjYyOTMyMCwgLTAuNTU5MTkzLCAtMC45NTYzMDUsIDAuMjkyMzcyLCAtMC44MjkwMzgsIC0wLjc3NzE0Nl0sXG4gICAgWzAuNTg3Nzg1LCAtMC41ODc3ODUsIC0wLjk1MTA1NywgMC4zMDkwMTcsIC0wLjgwOTAxNywgLTAuODA5MDE3XSxcbiAgICBbMC41NDQ2MzksIC0wLjYxNTY2MSwgLTAuOTQ1NTE5LCAwLjMyNTU2OCwgLTAuNzg4MDExLCAtMC44Mzg2NzFdLFxuICAgIFswLjUwMDAwMCwgLTAuNjQyNzg4LCAtMC45Mzk2OTMsIDAuMzQyMDIwLCAtMC43NjYwNDQsIC0wLjg2NjAyNV0sXG4gICAgWzAuNDUzOTkwLCAtMC42NjkxMzEsIC0wLjkzMzU4MCwgMC4zNTgzNjgsIC0wLjc0MzE0NSwgLTAuODkxMDA3XSxcbiAgICBbMC40MDY3MzcsIC0wLjY5NDY1OCwgLTAuOTI3MTg0LCAwLjM3NDYwNywgLTAuNzE5MzQwLCAtMC45MTM1NDVdLFxuICAgIFswLjM1ODM2OCwgLTAuNzE5MzQwLCAtMC45MjA1MDUsIDAuMzkwNzMxLCAtMC42OTQ2NTgsIC0wLjkzMzU4MF0sXG4gICAgWzAuMzA5MDE3LCAtMC43NDMxNDUsIC0wLjkxMzU0NSwgMC40MDY3MzcsIC0wLjY2OTEzMSwgLTAuOTUxMDU3XSxcbiAgICBbMC4yNTg4MTksIC0wLjc2NjA0NCwgLTAuOTA2MzA4LCAwLjQyMjYxOCwgLTAuNjQyNzg4LCAtMC45NjU5MjZdLFxuICAgIFswLjIwNzkxMiwgLTAuNzg4MDExLCAtMC44OTg3OTQsIDAuNDM4MzcxLCAtMC42MTU2NjEsIC0wLjk3ODE0OF0sXG4gICAgWzAuMTU2NDM0LCAtMC44MDkwMTcsIC0wLjg5MTAwNywgMC40NTM5OTAsIC0wLjU4Nzc4NSwgLTAuOTg3Njg4XSxcbiAgICBbMC4xMDQ1MjgsIC0wLjgyOTAzOCwgLTAuODgyOTQ4LCAwLjQ2OTQ3MiwgLTAuNTU5MTkzLCAtMC45OTQ1MjJdLFxuICAgIFswLjA1MjMzNiwgLTAuODQ4MDQ4LCAtMC44NzQ2MjAsIDAuNDg0ODEwLCAtMC41Mjk5MTksIC0wLjk5ODYzMF0sXG4gICAgWzAuMDAwMDAwLCAtMC44NjYwMjUsIC0wLjg2NjAyNSwgMC41MDAwMDAsIC0wLjUwMDAwMCwgLTEuMDAwMDAwXSxcbiAgICBbLTAuMDUyMzM2LCAtMC44ODI5NDgsIC0wLjg1NzE2NywgMC41MTUwMzgsIC0wLjQ2OTQ3MiwgLTAuOTk4NjMwXSxcbiAgICBbLTAuMTA0NTI4LCAtMC44OTg3OTQsIC0wLjg0ODA0OCwgMC41Mjk5MTksIC0wLjQzODM3MSwgLTAuOTk0NTIyXSxcbiAgICBbLTAuMTU2NDM0LCAtMC45MTM1NDUsIC0wLjgzODY3MSwgMC41NDQ2MzksIC0wLjQwNjczNywgLTAuOTg3Njg4XSxcbiAgICBbLTAuMjA3OTEyLCAtMC45MjcxODQsIC0wLjgyOTAzOCwgMC41NTkxOTMsIC0wLjM3NDYwNywgLTAuOTc4MTQ4XSxcbiAgICBbLTAuMjU4ODE5LCAtMC45Mzk2OTMsIC0wLjgxOTE1MiwgMC41NzM1NzYsIC0wLjM0MjAyMCwgLTAuOTY1OTI2XSxcbiAgICBbLTAuMzA5MDE3LCAtMC45NTEwNTcsIC0wLjgwOTAxNywgMC41ODc3ODUsIC0wLjMwOTAxNywgLTAuOTUxMDU3XSxcbiAgICBbLTAuMzU4MzY4LCAtMC45NjEyNjIsIC0wLjc5ODYzNiwgMC42MDE4MTUsIC0wLjI3NTYzNywgLTAuOTMzNTgwXSxcbiAgICBbLTAuNDA2NzM3LCAtMC45NzAyOTYsIC0wLjc4ODAxMSwgMC42MTU2NjEsIC0wLjI0MTkyMiwgLTAuOTEzNTQ1XSxcbiAgICBbLTAuNDUzOTkwLCAtMC45NzgxNDgsIC0wLjc3NzE0NiwgMC42MjkzMjAsIC0wLjIwNzkxMiwgLTAuODkxMDA3XSxcbiAgICBbLTAuNTAwMDAwLCAtMC45ODQ4MDgsIC0wLjc2NjA0NCwgMC42NDI3ODgsIC0wLjE3MzY0OCwgLTAuODY2MDI1XSxcbiAgICBbLTAuNTQ0NjM5LCAtMC45OTAyNjgsIC0wLjc1NDcxMCwgMC42NTYwNTksIC0wLjEzOTE3MywgLTAuODM4NjcxXSxcbiAgICBbLTAuNTg3Nzg1LCAtMC45OTQ1MjIsIC0wLjc0MzE0NSwgMC42NjkxMzEsIC0wLjEwNDUyOCwgLTAuODA5MDE3XSxcbiAgICBbLTAuNjI5MzIwLCAtMC45OTc1NjQsIC0wLjczMTM1NCwgMC42ODE5OTgsIC0wLjA2OTc1NiwgLTAuNzc3MTQ2XSxcbiAgICBbLTAuNjY5MTMxLCAtMC45OTkzOTEsIC0wLjcxOTM0MCwgMC42OTQ2NTgsIC0wLjAzNDg5OSwgLTAuNzQzMTQ1XSxcbiAgICBbLTAuNzA3MTA3LCAtMS4wMDAwMDAsIC0wLjcwNzEwNywgMC43MDcxMDcsIC0wLjAwMDAwMCwgLTAuNzA3MTA3XSxcbiAgICBbLTAuNzQzMTQ1LCAtMC45OTkzOTEsIC0wLjY5NDY1OCwgMC43MTkzNDAsIDAuMDM0ODk5LCAtMC42NjkxMzFdLFxuICAgIFstMC43NzcxNDYsIC0wLjk5NzU2NCwgLTAuNjgxOTk4LCAwLjczMTM1NCwgMC4wNjk3NTYsIC0wLjYyOTMyMF0sXG4gICAgWy0wLjgwOTAxNywgLTAuOTk0NTIyLCAtMC42NjkxMzEsIDAuNzQzMTQ1LCAwLjEwNDUyOCwgLTAuNTg3Nzg1XSxcbiAgICBbLTAuODM4NjcxLCAtMC45OTAyNjgsIC0wLjY1NjA1OSwgMC43NTQ3MTAsIDAuMTM5MTczLCAtMC41NDQ2MzldLFxuICAgIFstMC44NjYwMjUsIC0wLjk4NDgwOCwgLTAuNjQyNzg4LCAwLjc2NjA0NCwgMC4xNzM2NDgsIC0wLjUwMDAwMF0sXG4gICAgWy0wLjg5MTAwNywgLTAuOTc4MTQ4LCAtMC42MjkzMjAsIDAuNzc3MTQ2LCAwLjIwNzkxMiwgLTAuNDUzOTkwXSxcbiAgICBbLTAuOTEzNTQ1LCAtMC45NzAyOTYsIC0wLjYxNTY2MSwgMC43ODgwMTEsIDAuMjQxOTIyLCAtMC40MDY3MzddLFxuICAgIFstMC45MzM1ODAsIC0wLjk2MTI2MiwgLTAuNjAxODE1LCAwLjc5ODYzNiwgMC4yNzU2MzcsIC0wLjM1ODM2OF0sXG4gICAgWy0wLjk1MTA1NywgLTAuOTUxMDU3LCAtMC41ODc3ODUsIDAuODA5MDE3LCAwLjMwOTAxNywgLTAuMzA5MDE3XSxcbiAgICBbLTAuOTY1OTI2LCAtMC45Mzk2OTMsIC0wLjU3MzU3NiwgMC44MTkxNTIsIDAuMzQyMDIwLCAtMC4yNTg4MTldLFxuICAgIFstMC45NzgxNDgsIC0wLjkyNzE4NCwgLTAuNTU5MTkzLCAwLjgyOTAzOCwgMC4zNzQ2MDcsIC0wLjIwNzkxMl0sXG4gICAgWy0wLjk4NzY4OCwgLTAuOTEzNTQ1LCAtMC41NDQ2MzksIDAuODM4NjcxLCAwLjQwNjczNywgLTAuMTU2NDM0XSxcbiAgICBbLTAuOTk0NTIyLCAtMC44OTg3OTQsIC0wLjUyOTkxOSwgMC44NDgwNDgsIDAuNDM4MzcxLCAtMC4xMDQ1MjhdLFxuICAgIFstMC45OTg2MzAsIC0wLjg4Mjk0OCwgLTAuNTE1MDM4LCAwLjg1NzE2NywgMC40Njk0NzIsIC0wLjA1MjMzNl0sXG4gICAgWy0xLjAwMDAwMCwgLTAuODY2MDI1LCAtMC41MDAwMDAsIDAuODY2MDI1LCAwLjUwMDAwMCwgLTAuMDAwMDAwXSxcbiAgICBbLTAuOTk4NjMwLCAtMC44NDgwNDgsIC0wLjQ4NDgxMCwgMC44NzQ2MjAsIDAuNTI5OTE5LCAwLjA1MjMzNl0sXG4gICAgWy0wLjk5NDUyMiwgLTAuODI5MDM4LCAtMC40Njk0NzIsIDAuODgyOTQ4LCAwLjU1OTE5MywgMC4xMDQ1MjhdLFxuICAgIFstMC45ODc2ODgsIC0wLjgwOTAxNywgLTAuNDUzOTkwLCAwLjg5MTAwNywgMC41ODc3ODUsIDAuMTU2NDM0XSxcbiAgICBbLTAuOTc4MTQ4LCAtMC43ODgwMTEsIC0wLjQzODM3MSwgMC44OTg3OTQsIDAuNjE1NjYxLCAwLjIwNzkxMl0sXG4gICAgWy0wLjk2NTkyNiwgLTAuNzY2MDQ0LCAtMC40MjI2MTgsIDAuOTA2MzA4LCAwLjY0Mjc4OCwgMC4yNTg4MTldLFxuICAgIFstMC45NTEwNTcsIC0wLjc0MzE0NSwgLTAuNDA2NzM3LCAwLjkxMzU0NSwgMC42NjkxMzEsIDAuMzA5MDE3XSxcbiAgICBbLTAuOTMzNTgwLCAtMC43MTkzNDAsIC0wLjM5MDczMSwgMC45MjA1MDUsIDAuNjk0NjU4LCAwLjM1ODM2OF0sXG4gICAgWy0wLjkxMzU0NSwgLTAuNjk0NjU4LCAtMC4zNzQ2MDcsIDAuOTI3MTg0LCAwLjcxOTM0MCwgMC40MDY3MzddLFxuICAgIFstMC44OTEwMDcsIC0wLjY2OTEzMSwgLTAuMzU4MzY4LCAwLjkzMzU4MCwgMC43NDMxNDUsIDAuNDUzOTkwXSxcbiAgICBbLTAuODY2MDI1LCAtMC42NDI3ODgsIC0wLjM0MjAyMCwgMC45Mzk2OTMsIDAuNzY2MDQ0LCAwLjUwMDAwMF0sXG4gICAgWy0wLjgzODY3MSwgLTAuNjE1NjYxLCAtMC4zMjU1NjgsIDAuOTQ1NTE5LCAwLjc4ODAxMSwgMC41NDQ2MzldLFxuICAgIFstMC44MDkwMTcsIC0wLjU4Nzc4NSwgLTAuMzA5MDE3LCAwLjk1MTA1NywgMC44MDkwMTcsIDAuNTg3Nzg1XSxcbiAgICBbLTAuNzc3MTQ2LCAtMC41NTkxOTMsIC0wLjI5MjM3MiwgMC45NTYzMDUsIDAuODI5MDM4LCAwLjYyOTMyMF0sXG4gICAgWy0wLjc0MzE0NSwgLTAuNTI5OTE5LCAtMC4yNzU2MzcsIDAuOTYxMjYyLCAwLjg0ODA0OCwgMC42NjkxMzFdLFxuICAgIFstMC43MDcxMDcsIC0wLjUwMDAwMCwgLTAuMjU4ODE5LCAwLjk2NTkyNiwgMC44NjYwMjUsIDAuNzA3MTA3XSxcbiAgICBbLTAuNjY5MTMxLCAtMC40Njk0NzIsIC0wLjI0MTkyMiwgMC45NzAyOTYsIDAuODgyOTQ4LCAwLjc0MzE0NV0sXG4gICAgWy0wLjYyOTMyMCwgLTAuNDM4MzcxLCAtMC4yMjQ5NTEsIDAuOTc0MzcwLCAwLjg5ODc5NCwgMC43NzcxNDZdLFxuICAgIFstMC41ODc3ODUsIC0wLjQwNjczNywgLTAuMjA3OTEyLCAwLjk3ODE0OCwgMC45MTM1NDUsIDAuODA5MDE3XSxcbiAgICBbLTAuNTQ0NjM5LCAtMC4zNzQ2MDcsIC0wLjE5MDgwOSwgMC45ODE2MjcsIDAuOTI3MTg0LCAwLjgzODY3MV0sXG4gICAgWy0wLjUwMDAwMCwgLTAuMzQyMDIwLCAtMC4xNzM2NDgsIDAuOTg0ODA4LCAwLjkzOTY5MywgMC44NjYwMjVdLFxuICAgIFstMC40NTM5OTAsIC0wLjMwOTAxNywgLTAuMTU2NDM0LCAwLjk4NzY4OCwgMC45NTEwNTcsIDAuODkxMDA3XSxcbiAgICBbLTAuNDA2NzM3LCAtMC4yNzU2MzcsIC0wLjEzOTE3MywgMC45OTAyNjgsIDAuOTYxMjYyLCAwLjkxMzU0NV0sXG4gICAgWy0wLjM1ODM2OCwgLTAuMjQxOTIyLCAtMC4xMjE4NjksIDAuOTkyNTQ2LCAwLjk3MDI5NiwgMC45MzM1ODBdLFxuICAgIFstMC4zMDkwMTcsIC0wLjIwNzkxMiwgLTAuMTA0NTI4LCAwLjk5NDUyMiwgMC45NzgxNDgsIDAuOTUxMDU3XSxcbiAgICBbLTAuMjU4ODE5LCAtMC4xNzM2NDgsIC0wLjA4NzE1NiwgMC45OTYxOTUsIDAuOTg0ODA4LCAwLjk2NTkyNl0sXG4gICAgWy0wLjIwNzkxMiwgLTAuMTM5MTczLCAtMC4wNjk3NTYsIDAuOTk3NTY0LCAwLjk5MDI2OCwgMC45NzgxNDhdLFxuICAgIFstMC4xNTY0MzQsIC0wLjEwNDUyOCwgLTAuMDUyMzM2LCAwLjk5ODYzMCwgMC45OTQ1MjIsIDAuOTg3Njg4XSxcbiAgICBbLTAuMTA0NTI4LCAtMC4wNjk3NTYsIC0wLjAzNDg5OSwgMC45OTkzOTEsIDAuOTk3NTY0LCAwLjk5NDUyMl0sXG4gICAgWy0wLjA1MjMzNiwgLTAuMDM0ODk5LCAtMC4wMTc0NTIsIDAuOTk5ODQ4LCAwLjk5OTM5MSwgMC45OTg2MzBdLFxuICBdLFxuICBbXG4gICAgWy0xLjAwMDAwMCwgLTAuMDAwMDAwLCAxLjAwMDAwMCwgLTAuMDAwMDAwLCAwLjAwMDAwMCxcbiAgICAgLTEuMDAwMDAwLCAtMC4wMDAwMDAsIDAuMDAwMDAwLCAtMC4wMDAwMDBdLFxuICAgIFstMC45OTk4NDgsIDAuMDE3NDUyLCAwLjk5OTU0MywgLTAuMDMwMjI0LCAwLjAwMDI2NCxcbiAgICAgLTAuOTk5MDg2LCAwLjA0MjczMywgLTAuMDAwNTkwLCAwLjAwMDAwNF0sXG4gICAgWy0wLjk5OTM5MSwgMC4wMzQ4OTksIDAuOTk4MTczLCAtMC4wNjA0MTEsIDAuMDAxMDU1LFxuICAgICAtMC45OTYzNDgsIDAuMDg1MzU2LCAtMC4wMDIzNTcsIDAuMDAwMDM0XSxcbiAgICBbLTAuOTk4NjMwLCAwLjA1MjMzNiwgMC45OTU4OTEsIC0wLjA5MDUyNCwgMC4wMDIzNzIsXG4gICAgIC0wLjk5MTc5MSwgMC4xMjc3NTcsIC0wLjAwNTI5NywgMC4wMDAxMTNdLFxuICAgIFstMC45OTc1NjQsIDAuMDY5NzU2LCAwLjk5MjcwMSwgLTAuMTIwNTI3LCAwLjAwNDIxNCxcbiAgICAgLTAuOTg1NDI5LCAwLjE2OTgyOCwgLTAuMDA5NDAwLCAwLjAwMDI2OF0sXG4gICAgWy0wLjk5NjE5NSwgMC4wODcxNTYsIDAuOTg4NjA2LCAtMC4xNTAzODQsIDAuMDA2NTc4LFxuICAgICAtMC45NzcyNzcsIDAuMjExNDYwLCAtMC4wMTQ2NTQsIDAuMDAwNTIzXSxcbiAgICBbLTAuOTk0NTIyLCAwLjEwNDUyOCwgMC45ODM2MTEsIC0wLjE4MDA1NywgMC4wMDk0NjIsXG4gICAgIC0wLjk2NzM1NiwgMC4yNTI1NDQsIC0wLjAyMTA0MywgMC4wMDA5MDNdLFxuICAgIFstMC45OTI1NDYsIDAuMTIxODY5LCAwLjk3NzcyMiwgLTAuMjA5NTExLCAwLjAxMjg2MixcbiAgICAgLTAuOTU1NjkzLCAwLjI5Mjk3NiwgLTAuMDI4NTQ3LCAwLjAwMTQzMV0sXG4gICAgWy0wLjk5MDI2OCwgMC4xMzkxNzMsIDAuOTcwOTQ2LCAtMC4yMzg3MDksIDAuMDE2Nzc0LFxuICAgICAtMC45NDIzMTYsIDAuMzMyNjQ5LCAtMC4wMzcxNDMsIDAuMDAyMTMxXSxcbiAgICBbLTAuOTg3Njg4LCAwLjE1NjQzNCwgMC45NjMyOTIsIC0wLjI2NzYxNywgMC4wMjExOTMsXG4gICAgIC0wLjkyNzI2MiwgMC4zNzE0NjMsIC0wLjA0NjgwNiwgMC4wMDMwMjZdLFxuICAgIFstMC45ODQ4MDgsIDAuMTczNjQ4LCAwLjk1NDc2OSwgLTAuMjk2MTk4LCAwLjAyNjExNCxcbiAgICAgLTAuOTEwNTY5LCAwLjQwOTMxNywgLTAuMDU3NTA1LCAwLjAwNDE0MF0sXG4gICAgWy0wLjk4MTYyNywgMC4xOTA4MDksIDAuOTQ1Mzg4LCAtMC4zMjQ0MTksIDAuMDMxNTMwLFxuICAgICAtMC44OTIyNzksIDAuNDQ2MTE0LCAtMC4wNjkyMDksIDAuMDA1NDkyXSxcbiAgICBbLTAuOTc4MTQ4LCAwLjIwNzkxMiwgMC45MzUxNTksIC0wLjM1MjI0NCwgMC4wMzc0MzYsXG4gICAgIC0wLjg3MjQ0MSwgMC40ODE3NTksIC0wLjA4MTg4MCwgMC4wMDcxMDVdLFxuICAgIFstMC45NzQzNzAsIDAuMjI0OTUxLCAwLjkyNDA5NiwgLTAuMzc5NjQxLCAwLjA0MzgyMyxcbiAgICAgLTAuODUxMTA1LCAwLjUxNjE2MiwgLTAuMDk1NDgxLCAwLjAwODk5OV0sXG4gICAgWy0wLjk3MDI5NiwgMC4yNDE5MjIsIDAuOTEyMjExLCAtMC40MDY1NzQsIDAuMDUwNjg1LFxuICAgICAtMC44MjgzMjYsIDAuNTQ5MjMzLCAtMC4xMDk5NjksIDAuMDExMTkzXSxcbiAgICBbLTAuOTY1OTI2LCAwLjI1ODgxOSwgMC44OTk1MTksIC0wLjQzMzAxMywgMC4wNTgwMTMsXG4gICAgIC0wLjgwNDE2NCwgMC41ODA4ODksIC0wLjEyNTMwMCwgMC4wMTM3MDddLFxuICAgIFstMC45NjEyNjIsIDAuMjc1NjM3LCAwLjg4NjAzNiwgLTAuNDU4OTI0LCAwLjA2NTc5NyxcbiAgICAgLTAuNzc4NjgwLCAwLjYxMTA1MCwgLTAuMTQxNDI3LCAwLjAxNjU1Nl0sXG4gICAgWy0wLjk1NjMwNSwgMC4yOTIzNzIsIDAuODcxNzc4LCAtMC40ODQyNzUsIDAuMDc0MDI5LFxuICAgICAtMC43NTE5NDAsIDAuNjM5NjM5LCAtMC4xNTgzMDEsIDAuMDE5NzU4XSxcbiAgICBbLTAuOTUxMDU3LCAwLjMwOTAxNywgMC44NTY3NjMsIC0wLjUwOTAzNywgMC4wODI2OTgsXG4gICAgIC0wLjcyNDAxMiwgMC42NjY1ODMsIC0wLjE3NTg2OCwgMC4wMjMzMjldLFxuICAgIFstMC45NDU1MTksIDAuMzI1NTY4LCAwLjg0MTAwOCwgLTAuNTMzMTc4LCAwLjA5MTc5NCxcbiAgICAgLTAuNjk0OTY5LCAwLjY5MTgxNiwgLTAuMTk0MDc1LCAwLjAyNzI4MV0sXG4gICAgWy0wLjkzOTY5MywgMC4zNDIwMjAsIDAuODI0NTMzLCAtMC41NTY2NzAsIDAuMTAxMzA2LFxuICAgICAtMC42NjQ4ODUsIDAuNzE1Mjc0LCAtMC4yMTI4NjUsIDAuMDMxNjMwXSxcbiAgICBbLTAuOTMzNTgwLCAwLjM1ODM2OCwgMC44MDczNTksIC0wLjU3OTQ4NCwgMC4xMTEyMjIsXG4gICAgIC0wLjYzMzgzNywgMC43MzY4OTgsIC0wLjIzMjE4MCwgMC4wMzYzODVdLFxuICAgIFstMC45MjcxODQsIDAuMzc0NjA3LCAwLjc4OTUwNSwgLTAuNjAxNTkyLCAwLjEyMTUyOSxcbiAgICAgLTAuNjAxOTA0LCAwLjc1NjYzNywgLTAuMjUxOTYwLCAwLjA0MTU1OV0sXG4gICAgWy0wLjkyMDUwNSwgMC4zOTA3MzEsIDAuNzcwOTk0LCAtMC42MjI5NjcsIDAuMTMyMjE3LFxuICAgICAtMC41NjkxNjksIDAuNzc0NDQyLCAtMC4yNzIxNDMsIDAuMDQ3MTYwXSxcbiAgICBbLTAuOTEzNTQ1LCAwLjQwNjczNywgMC43NTE4NDgsIC0wLjY0MzU4MiwgMC4xNDMyNzEsXG4gICAgIC0wLjUzNTcxNSwgMC43OTAyNzAsIC0wLjI5MjY2NiwgMC4wNTMxOTZdLFxuICAgIFstMC45MDYzMDgsIDAuNDIyNjE4LCAwLjczMjA5MSwgLTAuNjYzNDE0LCAwLjE1NDY3OCxcbiAgICAgLTAuNTAxNjI3LCAwLjgwNDA4MywgLTAuMzEzNDY0LCAwLjA1OTY3NF0sXG4gICAgWy0wLjg5ODc5NCwgMC40MzgzNzEsIDAuNzExNzQ2LCAtMC42ODI0MzcsIDAuMTY2NDIzLFxuICAgICAtMC40NjY5OTMsIDAuODE1ODUwLCAtMC4zMzQ0NzIsIDAuMDY2NTk5XSxcbiAgICBbLTAuODkxMDA3LCAwLjQ1Mzk5MCwgMC42OTA4MzksIC0wLjcwMDYyOSwgMC4xNzg0OTQsXG4gICAgIC0wLjQzMTg5OSwgMC44MjU1NDQsIC0wLjM1NTYyMywgMC4wNzM5NzRdLFxuICAgIFstMC44ODI5NDgsIDAuNDY5NDcyLCAwLjY2OTM5NSwgLTAuNzE3OTY4LCAwLjE5MDg3NSxcbiAgICAgLTAuMzk2NDM2LCAwLjgzMzE0NSwgLTAuMzc2ODUxLCAwLjA4MTgwM10sXG4gICAgWy0wLjg3NDYyMCwgMC40ODQ4MTAsIDAuNjQ3NDM5LCAtMC43MzQ0MzEsIDAuMjAzNTUxLFxuICAgICAtMC4zNjA2OTIsIDAuODM4NjM4LCAtMC4zOTgwODYsIDAuMDkwMDg1XSxcbiAgICBbLTAuODY2MDI1LCAwLjUwMDAwMCwgMC42MjUwMDAsIC0wLjc1MDAwMCwgMC4yMTY1MDYsXG4gICAgIC0wLjMyNDc2MCwgMC44NDIwMTIsIC0wLjQxOTI2MywgMC4wOTg4MjFdLFxuICAgIFstMC44NTcxNjcsIDAuNTE1MDM4LCAwLjYwMjEwNCwgLTAuNzY0NjU1LCAwLjIyOTcyNixcbiAgICAgLTAuMjg4NzI4LCAwLjg0MzI2NSwgLTAuNDQwMzExLCAwLjEwODAwOV0sXG4gICAgWy0wLjg0ODA0OCwgMC41Mjk5MTksIDAuNTc4Nzc4LCAtMC43NzgzNzgsIDAuMjQzMTkyLFxuICAgICAtMC4yNTI2ODgsIDAuODQyMzk5LCAtMC40NjExNjQsIDAuMTE3NjQ0XSxcbiAgICBbLTAuODM4NjcxLCAwLjU0NDYzOSwgMC41NTUwNTIsIC0wLjc5MTE1NCwgMC4yNTY4OTEsXG4gICAgIC0wLjIxNjczMCwgMC44Mzk0MjIsIC0wLjQ4MTc1MywgMC4xMjc3MjJdLFxuICAgIFstMC44MjkwMzgsIDAuNTU5MTkzLCAwLjUzMDk1NSwgLTAuODAyOTY1LCAwLjI3MDgwMyxcbiAgICAgLTAuMTgwOTQ0LCAwLjgzNDM0NywgLTAuNTAyMDExLCAwLjEzODIzN10sXG4gICAgWy0wLjgxOTE1MiwgMC41NzM1NzYsIDAuNTA2NTE1LCAtMC44MTM3OTgsIDAuMjg0OTE0LFxuICAgICAtMC4xNDU0MjAsIDAuODI3MTk0LCAtMC41MjE4NzEsIDAuMTQ5MTgxXSxcbiAgICBbLTAuODA5MDE3LCAwLjU4Nzc4NSwgMC40ODE3NjMsIC0wLjgyMzYzOSwgMC4yOTkyMDQsXG4gICAgIC0wLjExMDI0NiwgMC44MTc5ODcsIC0wLjU0MTI2NiwgMC4xNjA1NDVdLFxuICAgIFstMC43OTg2MzYsIDAuNjAxODE1LCAwLjQ1NjcyOCwgLTAuODMyNDc3LCAwLjMxMzY1OCxcbiAgICAgLTAuMDc1NTA4LCAwLjgwNjc1NywgLTAuNTYwMTMyLCAwLjE3MjMxN10sXG4gICAgWy0wLjc4ODAxMSwgMC42MTU2NjEsIDAuNDMxNDQxLCAtMC44NDAzMDEsIDAuMzI4MjU3LFxuICAgICAtMC4wNDEyOTQsIDAuNzkzNTQxLCAtMC41Nzg0MDUsIDAuMTg0NDg3XSxcbiAgICBbLTAuNzc3MTQ2LCAwLjYyOTMyMCwgMC40MDU5MzQsIC0wLjg0NzEwMSwgMC4zNDI5ODQsXG4gICAgIC0wLjAwNzY4NiwgMC43NzgzNzksIC0wLjU5NjAyMSwgMC4xOTcwNDBdLFxuICAgIFstMC43NjYwNDQsIDAuNjQyNzg4LCAwLjM4MDIzNiwgLTAuODUyODY5LCAwLjM1NzgyMSxcbiAgICAgMC4wMjUyMzMsIDAuNzYxMzE5LCAtMC42MTI5MjEsIDAuMjA5OTYzXSxcbiAgICBbLTAuNzU0NzEwLCAwLjY1NjA1OSwgMC4zNTQzODAsIC0wLjg1NzU5NywgMC4zNzI3NDksXG4gICAgIDAuMDU3MzgzLCAwLjc0MjQxMiwgLTAuNjI5MDQ0LCAwLjIyMzIzOF0sXG4gICAgWy0wLjc0MzE0NSwgMC42NjkxMzEsIDAuMzI4Mzk2LCAtMC44NjEyODEsIDAuMzg3NzUxLFxuICAgICAwLjA4ODY4NiwgMC43MjE3MTQsIC0wLjY0NDMzNCwgMC4yMzY4NTBdLFxuICAgIFstMC43MzEzNTQsIDAuNjgxOTk4LCAwLjMwMjMxNywgLTAuODYzOTE2LCAwLjQwMjgwNyxcbiAgICAgMC4xMTkwNjgsIDAuNjk5Mjg4LCAtMC42NTg3MzQsIDAuMjUwNzc4XSxcbiAgICBbLTAuNzE5MzQwLCAwLjY5NDY1OCwgMC4yNzYxNzUsIC0wLjg2NTQ5OCwgMC40MTc5MDEsXG4gICAgIDAuMTQ4NDU0LCAwLjY3NTE5OSwgLTAuNjcyMTkwLCAwLjI2NTAwNV0sXG4gICAgWy0wLjcwNzEwNywgMC43MDcxMDcsIDAuMjUwMDAwLCAtMC44NjYwMjUsIDAuNDMzMDEzLFxuICAgICAwLjE3Njc3NywgMC42NDk1MTksIC0wLjY4NDY1MywgMC4yNzk1MDhdLFxuICAgIFstMC42OTQ2NTgsIDAuNzE5MzQwLCAwLjIyMzgyNSwgLTAuODY1NDk4LCAwLjQ0ODEyNSxcbiAgICAgMC4yMDM5NjksIDAuNjIyMzIyLCAtMC42OTYwNzMsIDAuMjk0MjY3XSxcbiAgICBbLTAuNjgxOTk4LCAwLjczMTM1NCwgMC4xOTc2ODMsIC0wLjg2MzkxNiwgMC40NjMyMTgsXG4gICAgIDAuMjI5OTY3LCAwLjU5MzY4OCwgLTAuNzA2NDA1LCAwLjMwOTI1OV0sXG4gICAgWy0wLjY2OTEzMSwgMC43NDMxNDUsIDAuMTcxNjA0LCAtMC44NjEyODEsIDAuNDc4Mjc1LFxuICAgICAwLjI1NDcxMiwgMC41NjM3MDAsIC0wLjcxNTYwNSwgMC4zMjQ0NTldLFxuICAgIFstMC42NTYwNTksIDAuNzU0NzEwLCAwLjE0NTYyMCwgLTAuODU3NTk3LCAwLjQ5MzI3NixcbiAgICAgMC4yNzgxNDcsIDAuNTMyNDQzLCAtMC43MjM2MzMsIDAuMzM5ODQ0XSxcbiAgICBbLTAuNjQyNzg4LCAwLjc2NjA0NCwgMC4xMTk3NjQsIC0wLjg1Mjg2OSwgMC41MDgyMDUsXG4gICAgIDAuMzAwMjIxLCAwLjUwMDAwOSwgLTAuNzMwNDUxLCAwLjM1NTM4N10sXG4gICAgWy0wLjYyOTMyMCwgMC43NzcxNDYsIDAuMDk0MDY2LCAtMC44NDcxMDEsIDAuNTIzMDQxLFxuICAgICAwLjMyMDg4NCwgMC40NjY0OTAsIC0wLjczNjAyNSwgMC4zNzEwNjNdLFxuICAgIFstMC42MTU2NjEsIDAuNzg4MDExLCAwLjA2ODU1OSwgLTAuODQwMzAxLCAwLjUzNzc2OCxcbiAgICAgMC4zNDAwOTMsIDAuNDMxOTgyLCAtMC43NDAzMjQsIDAuMzg2ODQ1XSxcbiAgICBbLTAuNjAxODE1LCAwLjc5ODYzNiwgMC4wNDMyNzIsIC0wLjgzMjQ3NywgMC41NTIzNjcsXG4gICAgIDAuMzU3ODA3LCAwLjM5NjU4NCwgLTAuNzQzMzIwLCAwLjQwMjcwNF0sXG4gICAgWy0wLjU4Nzc4NSwgMC44MDkwMTcsIDAuMDE4MjM3LCAtMC44MjM2MzksIDAuNTY2ODIxLFxuICAgICAwLjM3Mzk5MSwgMC4zNjAzOTcsIC0wLjc0NDk4OSwgMC40MTg2MTNdLFxuICAgIFstMC41NzM1NzYsIDAuODE5MTUyLCAtMC4wMDY1MTUsIC0wLjgxMzc5OCwgMC41ODExMTIsXG4gICAgIDAuMzg4NjEyLCAwLjMyMzUyNCwgLTAuNzQ1MzA4LCAwLjQzNDU0NF0sXG4gICAgWy0wLjU1OTE5MywgMC44MjkwMzgsIC0wLjAzMDk1NSwgLTAuODAyOTY1LCAwLjU5NTIyMixcbiAgICAgMC40MDE2NDUsIDAuMjg2MDY5LCAtMC43NDQyNjIsIDAuNDUwNDY3XSxcbiAgICBbLTAuNTQ0NjM5LCAwLjgzODY3MSwgLTAuMDU1MDUyLCAtMC43OTExNTQsIDAuNjA5MTM1LFxuICAgICAwLjQxMzA2NiwgMC4yNDgxNDAsIC0wLjc0MTgzNSwgMC40NjYzNTJdLFxuICAgIFstMC41Mjk5MTksIDAuODQ4MDQ4LCAtMC4wNzg3NzgsIC0wLjc3ODM3OCwgMC42MjI4MzMsXG4gICAgIDAuNDIyODU2LCAwLjIwOTg0MywgLTAuNzM4MDE3LCAwLjQ4MjE3MV0sXG4gICAgWy0wLjUxNTAzOCwgMC44NTcxNjcsIC0wLjEwMjEwNCwgLTAuNzY0NjU1LCAwLjYzNjMwMCxcbiAgICAgMC40MzEwMDQsIDAuMTcxMjg4LCAtMC43MzI4MDEsIDAuNDk3ODk0XSxcbiAgICBbLTAuNTAwMDAwLCAwLjg2NjAyNSwgLTAuMTI1MDAwLCAtMC43NTAwMDAsIDAuNjQ5NTE5LFxuICAgICAwLjQzNzUwMCwgMC4xMzI1ODMsIC0wLjcyNjE4NCwgMC41MTM0OTBdLFxuICAgIFstMC40ODQ4MTAsIDAuODc0NjIwLCAtMC4xNDc0MzksIC0wLjczNDQzMSwgMC42NjI0NzQsXG4gICAgIDAuNDQyMzQwLCAwLjA5MzgzNywgLTAuNzE4MTY3LCAwLjUyODkyOV0sXG4gICAgWy0wLjQ2OTQ3MiwgMC44ODI5NDgsIC0wLjE2OTM5NSwgLTAuNzE3OTY4LCAwLjY3NTE1MCxcbiAgICAgMC40NDU1MjQsIDAuMDU1MTYwLCAtMC43MDg3NTMsIDAuNTQ0MTgzXSxcbiAgICBbLTAuNDUzOTkwLCAwLjg5MTAwNywgLTAuMTkwODM5LCAtMC43MDA2MjksIDAuNjg3NTMxLFxuICAgICAwLjQ0NzA1OSwgMC4wMTY2NjIsIC0wLjY5Nzk1MCwgMC41NTkyMjBdLFxuICAgIFstMC40MzgzNzEsIDAuODk4Nzk0LCAtMC4yMTE3NDYsIC0wLjY4MjQzNywgMC42OTk2MDIsXG4gICAgIDAuNDQ2OTUzLCAtMC4wMjE1NTAsIC0wLjY4NTc2OSwgMC41NzQwMTFdLFxuICAgIFstMC40MjI2MTgsIDAuOTA2MzA4LCAtMC4yMzIwOTEsIC0wLjY2MzQxNCwgMC43MTEzNDgsXG4gICAgIDAuNDQ1MjIyLCAtMC4wNTkzNjgsIC0wLjY3MjIyNiwgMC41ODg1MjhdLFxuICAgIFstMC40MDY3MzcsIDAuOTEzNTQ1LCAtMC4yNTE4NDgsIC0wLjY0MzU4MiwgMC43MjI3NTUsXG4gICAgIDAuNDQxODg0LCAtMC4wOTY2ODQsIC0wLjY1NzMzOSwgMC42MDI3NDFdLFxuICAgIFstMC4zOTA3MzEsIDAuOTIwNTA1LCAtMC4yNzA5OTQsIC0wLjYyMjk2NywgMC43MzM4MDksXG4gICAgIDAuNDM2OTY0LCAtMC4xMzMzOTUsIC0wLjY0MTEzMCwgMC42MTY2MjFdLFxuICAgIFstMC4zNzQ2MDcsIDAuOTI3MTg0LCAtMC4yODk1MDUsIC0wLjYwMTU5MiwgMC43NDQ0OTYsXG4gICAgIDAuNDMwNDg4LCAtMC4xNjkzOTcsIC0wLjYyMzYyNCwgMC42MzAxNDFdLFxuICAgIFstMC4zNTgzNjgsIDAuOTMzNTgwLCAtMC4zMDczNTksIC0wLjU3OTQ4NCwgMC43NTQ4MDQsXG4gICAgIDAuNDIyNDkxLCAtMC4yMDQ1ODksIC0wLjYwNDg1MSwgMC42NDMyNzNdLFxuICAgIFstMC4zNDIwMjAsIDAuOTM5NjkzLCAtMC4zMjQ1MzMsIC0wLjU1NjY3MCwgMC43NjQ3MjAsXG4gICAgIDAuNDEzMDA4LCAtMC4yMzg4NzIsIC0wLjU4NDg0MywgMC42NTU5OTBdLFxuICAgIFstMC4zMjU1NjgsIDAuOTQ1NTE5LCAtMC4zNDEwMDgsIC0wLjUzMzE3OCwgMC43NzQyMzEsXG4gICAgIDAuNDAyMDgxLCAtMC4yNzIxNTAsIC0wLjU2MzYzNSwgMC42NjgyNjddLFxuICAgIFstMC4zMDkwMTcsIDAuOTUxMDU3LCAtMC4zNTY3NjMsIC0wLjUwOTAzNywgMC43ODMzMjcsXG4gICAgIDAuMzg5NzU0LCAtMC4zMDQzMjksIC0wLjU0MTI2NiwgMC42ODAwNzhdLFxuICAgIFstMC4yOTIzNzIsIDAuOTU2MzA1LCAtMC4zNzE3NzgsIC0wLjQ4NDI3NSwgMC43OTE5OTcsXG4gICAgIDAuMzc2MDc3LCAtMC4zMzUzMTksIC0wLjUxNzc3OCwgMC42OTEzOTldLFxuICAgIFstMC4yNzU2MzcsIDAuOTYxMjYyLCAtMC4zODYwMzYsIC0wLjQ1ODkyNCwgMC44MDAyMjgsXG4gICAgIDAuMzYxMTAyLCAtMC4zNjUwMzQsIC0wLjQ5MzIxNiwgMC43MDIyMDddLFxuICAgIFstMC4yNTg4MTksIDAuOTY1OTI2LCAtMC4zOTk1MTksIC0wLjQzMzAxMywgMC44MDgwMTMsXG4gICAgIDAuMzQ0ODg1LCAtMC4zOTMzODksIC0wLjQ2NzYyNywgMC43MTI0NzhdLFxuICAgIFstMC4yNDE5MjIsIDAuOTcwMjk2LCAtMC40MTIyMTEsIC0wLjQwNjU3NCwgMC44MTUzNDAsXG4gICAgIDAuMzI3NDg2LCAtMC40MjAzMDYsIC0wLjQ0MTA2MSwgMC43MjIxOTFdLFxuICAgIFstMC4yMjQ5NTEsIDAuOTc0MzcwLCAtMC40MjQwOTYsIC0wLjM3OTY0MSwgMC44MjIyMDIsXG4gICAgIDAuMzA4OTY5LCAtMC40NDU3MDksIC0wLjQxMzU3MiwgMC43MzEzMjddLFxuICAgIFstMC4yMDc5MTIsIDAuOTc4MTQ4LCAtMC40MzUxNTksIC0wLjM1MjI0NCwgMC44Mjg1ODksXG4gICAgIDAuMjg5Mzk5LCAtMC40Njk1MjcsIC0wLjM4NTIxNSwgMC43Mzk4NjZdLFxuICAgIFstMC4xOTA4MDksIDAuOTgxNjI3LCAtMC40NDUzODgsIC0wLjMyNDQxOSwgMC44MzQ0OTUsXG4gICAgIDAuMjY4ODQ2LCAtMC40OTE2OTMsIC0wLjM1NjA0NywgMC43NDc3OTBdLFxuICAgIFstMC4xNzM2NDgsIDAuOTg0ODA4LCAtMC40NTQ3NjksIC0wLjI5NjE5OCwgMC44Mzk5MTIsXG4gICAgIDAuMjQ3MzgyLCAtMC41MTIxNDUsIC0wLjMyNjEyOSwgMC43NTUwODJdLFxuICAgIFstMC4xNTY0MzQsIDAuOTg3Njg4LCAtMC40NjMyOTIsIC0wLjI2NzYxNywgMC44NDQ4MzIsXG4gICAgIDAuMjI1MDgxLCAtMC41MzA4MjcsIC0wLjI5NTUyMSwgMC43NjE3MjhdLFxuICAgIFstMC4xMzkxNzMsIDAuOTkwMjY4LCAtMC40NzA5NDYsIC0wLjIzODcwOSwgMC44NDkyNTEsXG4gICAgIDAuMjAyMDIwLCAtMC41NDc2ODQsIC0wLjI2NDI4NywgMC43Njc3MTJdLFxuICAgIFstMC4xMjE4NjksIDAuOTkyNTQ2LCAtMC40Nzc3MjIsIC0wLjIwOTUxMSwgMC44NTMxNjMsXG4gICAgIDAuMTc4Mjc5LCAtMC41NjI2NzIsIC0wLjIzMjQ5NCwgMC43NzMwMjNdLFxuICAgIFstMC4xMDQ1MjgsIDAuOTk0NTIyLCAtMC40ODM2MTEsIC0wLjE4MDA1NywgMC44NTY1NjMsXG4gICAgIDAuMTUzOTM3LCAtMC41NzU3NDcsIC0wLjIwMDIwNywgMC43Nzc2NDhdLFxuICAgIFstMC4wODcxNTYsIDAuOTk2MTk1LCAtMC40ODg2MDYsIC0wLjE1MDM4NCwgMC44NTk0NDcsXG4gICAgIDAuMTI5MDc4LCAtMC41ODY4NzIsIC0wLjE2NzQ5NCwgMC43ODE1NzldLFxuICAgIFstMC4wNjk3NTYsIDAuOTk3NTY0LCAtMC40OTI3MDEsIC0wLjEyMDUyNywgMC44NjE4MTEsXG4gICAgIDAuMTAzNzg2LCAtMC41OTYwMTgsIC0wLjEzNDQyNiwgMC43ODQ4MDZdLFxuICAgIFstMC4wNTIzMzYsIDAuOTk4NjMwLCAtMC40OTU4OTEsIC0wLjA5MDUyNCwgMC44NjM2NTMsXG4gICAgIDAuMDc4MTQ2LCAtMC42MDMxNTgsIC0wLjEwMTA3MSwgMC43ODczMjRdLFxuICAgIFstMC4wMzQ4OTksIDAuOTk5MzkxLCAtMC40OTgxNzMsIC0wLjA2MDQxMSwgMC44NjQ5NzEsXG4gICAgIDAuMDUyMjQzLCAtMC42MDgyNzIsIC0wLjA2NzUwMCwgMC43ODkxMjZdLFxuICAgIFstMC4wMTc0NTIsIDAuOTk5ODQ4LCAtMC40OTk1NDMsIC0wLjAzMDIyNCwgMC44NjU3NjIsXG4gICAgIDAuMDI2MTY1LCAtMC42MTEzNDcsIC0wLjAzMzc4NiwgMC43OTAyMDhdLFxuICAgIFswLjAwMDAwMCwgMS4wMDAwMDAsIC0wLjUwMDAwMCwgMC4wMDAwMDAsIDAuODY2MDI1LFxuICAgICAtMC4wMDAwMDAsIC0wLjYxMjM3MiwgMC4wMDAwMDAsIDAuNzkwNTY5XSxcbiAgICBbMC4wMTc0NTIsIDAuOTk5ODQ4LCAtMC40OTk1NDMsIDAuMDMwMjI0LCAwLjg2NTc2MixcbiAgICAgLTAuMDI2MTY1LCAtMC42MTEzNDcsIDAuMDMzNzg2LCAwLjc5MDIwOF0sXG4gICAgWzAuMDM0ODk5LCAwLjk5OTM5MSwgLTAuNDk4MTczLCAwLjA2MDQxMSwgMC44NjQ5NzEsXG4gICAgIC0wLjA1MjI0MywgLTAuNjA4MjcyLCAwLjA2NzUwMCwgMC43ODkxMjZdLFxuICAgIFswLjA1MjMzNiwgMC45OTg2MzAsIC0wLjQ5NTg5MSwgMC4wOTA1MjQsIDAuODYzNjUzLFxuICAgICAtMC4wNzgxNDYsIC0wLjYwMzE1OCwgMC4xMDEwNzEsIDAuNzg3MzI0XSxcbiAgICBbMC4wNjk3NTYsIDAuOTk3NTY0LCAtMC40OTI3MDEsIDAuMTIwNTI3LCAwLjg2MTgxMSxcbiAgICAgLTAuMTAzNzg2LCAtMC41OTYwMTgsIDAuMTM0NDI2LCAwLjc4NDgwNl0sXG4gICAgWzAuMDg3MTU2LCAwLjk5NjE5NSwgLTAuNDg4NjA2LCAwLjE1MDM4NCwgMC44NTk0NDcsXG4gICAgIC0wLjEyOTA3OCwgLTAuNTg2ODcyLCAwLjE2NzQ5NCwgMC43ODE1NzldLFxuICAgIFswLjEwNDUyOCwgMC45OTQ1MjIsIC0wLjQ4MzYxMSwgMC4xODAwNTcsIDAuODU2NTYzLFxuICAgICAtMC4xNTM5MzcsIC0wLjU3NTc0NywgMC4yMDAyMDcsIDAuNzc3NjQ4XSxcbiAgICBbMC4xMjE4NjksIDAuOTkyNTQ2LCAtMC40Nzc3MjIsIDAuMjA5NTExLCAwLjg1MzE2MyxcbiAgICAgLTAuMTc4Mjc5LCAtMC41NjI2NzIsIDAuMjMyNDk0LCAwLjc3MzAyM10sXG4gICAgWzAuMTM5MTczLCAwLjk5MDI2OCwgLTAuNDcwOTQ2LCAwLjIzODcwOSwgMC44NDkyNTEsXG4gICAgIC0wLjIwMjAyMCwgLTAuNTQ3Njg0LCAwLjI2NDI4NywgMC43Njc3MTJdLFxuICAgIFswLjE1NjQzNCwgMC45ODc2ODgsIC0wLjQ2MzI5MiwgMC4yNjc2MTcsIDAuODQ0ODMyLFxuICAgICAtMC4yMjUwODEsIC0wLjUzMDgyNywgMC4yOTU1MjEsIDAuNzYxNzI4XSxcbiAgICBbMC4xNzM2NDgsIDAuOTg0ODA4LCAtMC40NTQ3NjksIDAuMjk2MTk4LCAwLjgzOTkxMixcbiAgICAgLTAuMjQ3MzgyLCAtMC41MTIxNDUsIDAuMzI2MTI5LCAwLjc1NTA4Ml0sXG4gICAgWzAuMTkwODA5LCAwLjk4MTYyNywgLTAuNDQ1Mzg4LCAwLjMyNDQxOSwgMC44MzQ0OTUsXG4gICAgIC0wLjI2ODg0NiwgLTAuNDkxNjkzLCAwLjM1NjA0NywgMC43NDc3OTBdLFxuICAgIFswLjIwNzkxMiwgMC45NzgxNDgsIC0wLjQzNTE1OSwgMC4zNTIyNDQsIDAuODI4NTg5LFxuICAgICAtMC4yODkzOTksIC0wLjQ2OTUyNywgMC4zODUyMTUsIDAuNzM5ODY2XSxcbiAgICBbMC4yMjQ5NTEsIDAuOTc0MzcwLCAtMC40MjQwOTYsIDAuMzc5NjQxLCAwLjgyMjIwMixcbiAgICAgLTAuMzA4OTY5LCAtMC40NDU3MDksIDAuNDEzNTcyLCAwLjczMTMyN10sXG4gICAgWzAuMjQxOTIyLCAwLjk3MDI5NiwgLTAuNDEyMjExLCAwLjQwNjU3NCwgMC44MTUzNDAsXG4gICAgIC0wLjMyNzQ4NiwgLTAuNDIwMzA2LCAwLjQ0MTA2MSwgMC43MjIxOTFdLFxuICAgIFswLjI1ODgxOSwgMC45NjU5MjYsIC0wLjM5OTUxOSwgMC40MzMwMTMsIDAuODA4MDEzLFxuICAgICAtMC4zNDQ4ODUsIC0wLjM5MzM4OSwgMC40Njc2MjcsIDAuNzEyNDc4XSxcbiAgICBbMC4yNzU2MzcsIDAuOTYxMjYyLCAtMC4zODYwMzYsIDAuNDU4OTI0LCAwLjgwMDIyOCxcbiAgICAgLTAuMzYxMTAyLCAtMC4zNjUwMzQsIDAuNDkzMjE2LCAwLjcwMjIwN10sXG4gICAgWzAuMjkyMzcyLCAwLjk1NjMwNSwgLTAuMzcxNzc4LCAwLjQ4NDI3NSwgMC43OTE5OTcsXG4gICAgIC0wLjM3NjA3NywgLTAuMzM1MzE5LCAwLjUxNzc3OCwgMC42OTEzOTldLFxuICAgIFswLjMwOTAxNywgMC45NTEwNTcsIC0wLjM1Njc2MywgMC41MDkwMzcsIDAuNzgzMzI3LFxuICAgICAtMC4zODk3NTQsIC0wLjMwNDMyOSwgMC41NDEyNjYsIDAuNjgwMDc4XSxcbiAgICBbMC4zMjU1NjgsIDAuOTQ1NTE5LCAtMC4zNDEwMDgsIDAuNTMzMTc4LCAwLjc3NDIzMSxcbiAgICAgLTAuNDAyMDgxLCAtMC4yNzIxNTAsIDAuNTYzNjM1LCAwLjY2ODI2N10sXG4gICAgWzAuMzQyMDIwLCAwLjkzOTY5MywgLTAuMzI0NTMzLCAwLjU1NjY3MCwgMC43NjQ3MjAsXG4gICAgIC0wLjQxMzAwOCwgLTAuMjM4ODcyLCAwLjU4NDg0MywgMC42NTU5OTBdLFxuICAgIFswLjM1ODM2OCwgMC45MzM1ODAsIC0wLjMwNzM1OSwgMC41Nzk0ODQsIDAuNzU0ODA0LFxuICAgICAtMC40MjI0OTEsIC0wLjIwNDU4OSwgMC42MDQ4NTEsIDAuNjQzMjczXSxcbiAgICBbMC4zNzQ2MDcsIDAuOTI3MTg0LCAtMC4yODk1MDUsIDAuNjAxNTkyLCAwLjc0NDQ5NixcbiAgICAgLTAuNDMwNDg4LCAtMC4xNjkzOTcsIDAuNjIzNjI0LCAwLjYzMDE0MV0sXG4gICAgWzAuMzkwNzMxLCAwLjkyMDUwNSwgLTAuMjcwOTk0LCAwLjYyMjk2NywgMC43MzM4MDksXG4gICAgIC0wLjQzNjk2NCwgLTAuMTMzMzk1LCAwLjY0MTEzMCwgMC42MTY2MjFdLFxuICAgIFswLjQwNjczNywgMC45MTM1NDUsIC0wLjI1MTg0OCwgMC42NDM1ODIsIDAuNzIyNzU1LFxuICAgICAtMC40NDE4ODQsIC0wLjA5NjY4NCwgMC42NTczMzksIDAuNjAyNzQxXSxcbiAgICBbMC40MjI2MTgsIDAuOTA2MzA4LCAtMC4yMzIwOTEsIDAuNjYzNDE0LCAwLjcxMTM0OCxcbiAgICAgLTAuNDQ1MjIyLCAtMC4wNTkzNjgsIDAuNjcyMjI2LCAwLjU4ODUyOF0sXG4gICAgWzAuNDM4MzcxLCAwLjg5ODc5NCwgLTAuMjExNzQ2LCAwLjY4MjQzNywgMC42OTk2MDIsXG4gICAgIC0wLjQ0Njk1MywgLTAuMDIxNTUwLCAwLjY4NTc2OSwgMC41NzQwMTFdLFxuICAgIFswLjQ1Mzk5MCwgMC44OTEwMDcsIC0wLjE5MDgzOSwgMC43MDA2MjksIDAuNjg3NTMxLFxuICAgICAtMC40NDcwNTksIDAuMDE2NjYyLCAwLjY5Nzk1MCwgMC41NTkyMjBdLFxuICAgIFswLjQ2OTQ3MiwgMC44ODI5NDgsIC0wLjE2OTM5NSwgMC43MTc5NjgsIDAuNjc1MTUwLFxuICAgICAtMC40NDU1MjQsIDAuMDU1MTYwLCAwLjcwODc1MywgMC41NDQxODNdLFxuICAgIFswLjQ4NDgxMCwgMC44NzQ2MjAsIC0wLjE0NzQzOSwgMC43MzQ0MzEsIDAuNjYyNDc0LFxuICAgICAtMC40NDIzNDAsIDAuMDkzODM3LCAwLjcxODE2NywgMC41Mjg5MjldLFxuICAgIFswLjUwMDAwMCwgMC44NjYwMjUsIC0wLjEyNTAwMCwgMC43NTAwMDAsIDAuNjQ5NTE5LFxuICAgICAtMC40Mzc1MDAsIDAuMTMyNTgzLCAwLjcyNjE4NCwgMC41MTM0OTBdLFxuICAgIFswLjUxNTAzOCwgMC44NTcxNjcsIC0wLjEwMjEwNCwgMC43NjQ2NTUsIDAuNjM2MzAwLFxuICAgICAtMC40MzEwMDQsIDAuMTcxMjg4LCAwLjczMjgwMSwgMC40OTc4OTRdLFxuICAgIFswLjUyOTkxOSwgMC44NDgwNDgsIC0wLjA3ODc3OCwgMC43NzgzNzgsIDAuNjIyODMzLFxuICAgICAtMC40MjI4NTYsIDAuMjA5ODQzLCAwLjczODAxNywgMC40ODIxNzFdLFxuICAgIFswLjU0NDYzOSwgMC44Mzg2NzEsIC0wLjA1NTA1MiwgMC43OTExNTQsIDAuNjA5MTM1LFxuICAgICAtMC40MTMwNjYsIDAuMjQ4MTQwLCAwLjc0MTgzNSwgMC40NjYzNTJdLFxuICAgIFswLjU1OTE5MywgMC44MjkwMzgsIC0wLjAzMDk1NSwgMC44MDI5NjUsIDAuNTk1MjIyLFxuICAgICAtMC40MDE2NDUsIDAuMjg2MDY5LCAwLjc0NDI2MiwgMC40NTA0NjddLFxuICAgIFswLjU3MzU3NiwgMC44MTkxNTIsIC0wLjAwNjUxNSwgMC44MTM3OTgsIDAuNTgxMTEyLFxuICAgICAtMC4zODg2MTIsIDAuMzIzNTI0LCAwLjc0NTMwOCwgMC40MzQ1NDRdLFxuICAgIFswLjU4Nzc4NSwgMC44MDkwMTcsIDAuMDE4MjM3LCAwLjgyMzYzOSwgMC41NjY4MjEsXG4gICAgIC0wLjM3Mzk5MSwgMC4zNjAzOTcsIDAuNzQ0OTg5LCAwLjQxODYxM10sXG4gICAgWzAuNjAxODE1LCAwLjc5ODYzNiwgMC4wNDMyNzIsIDAuODMyNDc3LCAwLjU1MjM2NyxcbiAgICAgLTAuMzU3ODA3LCAwLjM5NjU4NCwgMC43NDMzMjAsIDAuNDAyNzA0XSxcbiAgICBbMC42MTU2NjEsIDAuNzg4MDExLCAwLjA2ODU1OSwgMC44NDAzMDEsIDAuNTM3NzY4LFxuICAgICAtMC4zNDAwOTMsIDAuNDMxOTgyLCAwLjc0MDMyNCwgMC4zODY4NDVdLFxuICAgIFswLjYyOTMyMCwgMC43NzcxNDYsIDAuMDk0MDY2LCAwLjg0NzEwMSwgMC41MjMwNDEsXG4gICAgIC0wLjMyMDg4NCwgMC40NjY0OTAsIDAuNzM2MDI1LCAwLjM3MTA2M10sXG4gICAgWzAuNjQyNzg4LCAwLjc2NjA0NCwgMC4xMTk3NjQsIDAuODUyODY5LCAwLjUwODIwNSxcbiAgICAgLTAuMzAwMjIxLCAwLjUwMDAwOSwgMC43MzA0NTEsIDAuMzU1Mzg3XSxcbiAgICBbMC42NTYwNTksIDAuNzU0NzEwLCAwLjE0NTYyMCwgMC44NTc1OTcsIDAuNDkzMjc2LFxuICAgICAtMC4yNzgxNDcsIDAuNTMyNDQzLCAwLjcyMzYzMywgMC4zMzk4NDRdLFxuICAgIFswLjY2OTEzMSwgMC43NDMxNDUsIDAuMTcxNjA0LCAwLjg2MTI4MSwgMC40NzgyNzUsXG4gICAgIC0wLjI1NDcxMiwgMC41NjM3MDAsIDAuNzE1NjA1LCAwLjMyNDQ1OV0sXG4gICAgWzAuNjgxOTk4LCAwLjczMTM1NCwgMC4xOTc2ODMsIDAuODYzOTE2LCAwLjQ2MzIxOCxcbiAgICAgLTAuMjI5OTY3LCAwLjU5MzY4OCwgMC43MDY0MDUsIDAuMzA5MjU5XSxcbiAgICBbMC42OTQ2NTgsIDAuNzE5MzQwLCAwLjIyMzgyNSwgMC44NjU0OTgsIDAuNDQ4MTI1LFxuICAgICAtMC4yMDM5NjksIDAuNjIyMzIyLCAwLjY5NjA3MywgMC4yOTQyNjddLFxuICAgIFswLjcwNzEwNywgMC43MDcxMDcsIDAuMjUwMDAwLCAwLjg2NjAyNSwgMC40MzMwMTMsXG4gICAgIC0wLjE3Njc3NywgMC42NDk1MTksIDAuNjg0NjUzLCAwLjI3OTUwOF0sXG4gICAgWzAuNzE5MzQwLCAwLjY5NDY1OCwgMC4yNzYxNzUsIDAuODY1NDk4LCAwLjQxNzkwMSxcbiAgICAgLTAuMTQ4NDU0LCAwLjY3NTE5OSwgMC42NzIxOTAsIDAuMjY1MDA1XSxcbiAgICBbMC43MzEzNTQsIDAuNjgxOTk4LCAwLjMwMjMxNywgMC44NjM5MTYsIDAuNDAyODA3LFxuICAgICAtMC4xMTkwNjgsIDAuNjk5Mjg4LCAwLjY1ODczNCwgMC4yNTA3NzhdLFxuICAgIFswLjc0MzE0NSwgMC42NjkxMzEsIDAuMzI4Mzk2LCAwLjg2MTI4MSwgMC4zODc3NTEsXG4gICAgIC0wLjA4ODY4NiwgMC43MjE3MTQsIDAuNjQ0MzM0LCAwLjIzNjg1MF0sXG4gICAgWzAuNzU0NzEwLCAwLjY1NjA1OSwgMC4zNTQzODAsIDAuODU3NTk3LCAwLjM3Mjc0OSxcbiAgICAgLTAuMDU3MzgzLCAwLjc0MjQxMiwgMC42MjkwNDQsIDAuMjIzMjM4XSxcbiAgICBbMC43NjYwNDQsIDAuNjQyNzg4LCAwLjM4MDIzNiwgMC44NTI4NjksIDAuMzU3ODIxLFxuICAgICAtMC4wMjUyMzMsIDAuNzYxMzE5LCAwLjYxMjkyMSwgMC4yMDk5NjNdLFxuICAgIFswLjc3NzE0NiwgMC42MjkzMjAsIDAuNDA1OTM0LCAwLjg0NzEwMSwgMC4zNDI5ODQsXG4gICAgIDAuMDA3Njg2LCAwLjc3ODM3OSwgMC41OTYwMjEsIDAuMTk3MDQwXSxcbiAgICBbMC43ODgwMTEsIDAuNjE1NjYxLCAwLjQzMTQ0MSwgMC44NDAzMDEsIDAuMzI4MjU3LFxuICAgICAwLjA0MTI5NCwgMC43OTM1NDEsIDAuNTc4NDA1LCAwLjE4NDQ4N10sXG4gICAgWzAuNzk4NjM2LCAwLjYwMTgxNSwgMC40NTY3MjgsIDAuODMyNDc3LCAwLjMxMzY1OCxcbiAgICAgMC4wNzU1MDgsIDAuODA2NzU3LCAwLjU2MDEzMiwgMC4xNzIzMTddLFxuICAgIFswLjgwOTAxNywgMC41ODc3ODUsIDAuNDgxNzYzLCAwLjgyMzYzOSwgMC4yOTkyMDQsXG4gICAgIDAuMTEwMjQ2LCAwLjgxNzk4NywgMC41NDEyNjYsIDAuMTYwNTQ1XSxcbiAgICBbMC44MTkxNTIsIDAuNTczNTc2LCAwLjUwNjUxNSwgMC44MTM3OTgsIDAuMjg0OTE0LFxuICAgICAwLjE0NTQyMCwgMC44MjcxOTQsIDAuNTIxODcxLCAwLjE0OTE4MV0sXG4gICAgWzAuODI5MDM4LCAwLjU1OTE5MywgMC41MzA5NTUsIDAuODAyOTY1LCAwLjI3MDgwMyxcbiAgICAgMC4xODA5NDQsIDAuODM0MzQ3LCAwLjUwMjAxMSwgMC4xMzgyMzddLFxuICAgIFswLjgzODY3MSwgMC41NDQ2MzksIDAuNTU1MDUyLCAwLjc5MTE1NCwgMC4yNTY4OTEsXG4gICAgIDAuMjE2NzMwLCAwLjgzOTQyMiwgMC40ODE3NTMsIDAuMTI3NzIyXSxcbiAgICBbMC44NDgwNDgsIDAuNTI5OTE5LCAwLjU3ODc3OCwgMC43NzgzNzgsIDAuMjQzMTkyLFxuICAgICAwLjI1MjY4OCwgMC44NDIzOTksIDAuNDYxMTY0LCAwLjExNzY0NF0sXG4gICAgWzAuODU3MTY3LCAwLjUxNTAzOCwgMC42MDIxMDQsIDAuNzY0NjU1LCAwLjIyOTcyNixcbiAgICAgMC4yODg3MjgsIDAuODQzMjY1LCAwLjQ0MDMxMSwgMC4xMDgwMDldLFxuICAgIFswLjg2NjAyNSwgMC41MDAwMDAsIDAuNjI1MDAwLCAwLjc1MDAwMCwgMC4yMTY1MDYsXG4gICAgIDAuMzI0NzYwLCAwLjg0MjAxMiwgMC40MTkyNjMsIDAuMDk4ODIxXSxcbiAgICBbMC44NzQ2MjAsIDAuNDg0ODEwLCAwLjY0NzQzOSwgMC43MzQ0MzEsIDAuMjAzNTUxLFxuICAgICAwLjM2MDY5MiwgMC44Mzg2MzgsIDAuMzk4MDg2LCAwLjA5MDA4NV0sXG4gICAgWzAuODgyOTQ4LCAwLjQ2OTQ3MiwgMC42NjkzOTUsIDAuNzE3OTY4LCAwLjE5MDg3NSxcbiAgICAgMC4zOTY0MzYsIDAuODMzMTQ1LCAwLjM3Njg1MSwgMC4wODE4MDNdLFxuICAgIFswLjg5MTAwNywgMC40NTM5OTAsIDAuNjkwODM5LCAwLjcwMDYyOSwgMC4xNzg0OTQsXG4gICAgIDAuNDMxODk5LCAwLjgyNTU0NCwgMC4zNTU2MjMsIDAuMDczOTc0XSxcbiAgICBbMC44OTg3OTQsIDAuNDM4MzcxLCAwLjcxMTc0NiwgMC42ODI0MzcsIDAuMTY2NDIzLFxuICAgICAwLjQ2Njk5MywgMC44MTU4NTAsIDAuMzM0NDcyLCAwLjA2NjU5OV0sXG4gICAgWzAuOTA2MzA4LCAwLjQyMjYxOCwgMC43MzIwOTEsIDAuNjYzNDE0LCAwLjE1NDY3OCxcbiAgICAgMC41MDE2MjcsIDAuODA0MDgzLCAwLjMxMzQ2NCwgMC4wNTk2NzRdLFxuICAgIFswLjkxMzU0NSwgMC40MDY3MzcsIDAuNzUxODQ4LCAwLjY0MzU4MiwgMC4xNDMyNzEsXG4gICAgIDAuNTM1NzE1LCAwLjc5MDI3MCwgMC4yOTI2NjYsIDAuMDUzMTk2XSxcbiAgICBbMC45MjA1MDUsIDAuMzkwNzMxLCAwLjc3MDk5NCwgMC42MjI5NjcsIDAuMTMyMjE3LFxuICAgICAwLjU2OTE2OSwgMC43NzQ0NDIsIDAuMjcyMTQzLCAwLjA0NzE2MF0sXG4gICAgWzAuOTI3MTg0LCAwLjM3NDYwNywgMC43ODk1MDUsIDAuNjAxNTkyLCAwLjEyMTUyOSxcbiAgICAgMC42MDE5MDQsIDAuNzU2NjM3LCAwLjI1MTk2MCwgMC4wNDE1NTldLFxuICAgIFswLjkzMzU4MCwgMC4zNTgzNjgsIDAuODA3MzU5LCAwLjU3OTQ4NCwgMC4xMTEyMjIsXG4gICAgIDAuNjMzODM3LCAwLjczNjg5OCwgMC4yMzIxODAsIDAuMDM2Mzg1XSxcbiAgICBbMC45Mzk2OTMsIDAuMzQyMDIwLCAwLjgyNDUzMywgMC41NTY2NzAsIDAuMTAxMzA2LFxuICAgICAwLjY2NDg4NSwgMC43MTUyNzQsIDAuMjEyODY1LCAwLjAzMTYzMF0sXG4gICAgWzAuOTQ1NTE5LCAwLjMyNTU2OCwgMC44NDEwMDgsIDAuNTMzMTc4LCAwLjA5MTc5NCxcbiAgICAgMC42OTQ5NjksIDAuNjkxODE2LCAwLjE5NDA3NSwgMC4wMjcyODFdLFxuICAgIFswLjk1MTA1NywgMC4zMDkwMTcsIDAuODU2NzYzLCAwLjUwOTAzNywgMC4wODI2OTgsXG4gICAgIDAuNzI0MDEyLCAwLjY2NjU4MywgMC4xNzU4NjgsIDAuMDIzMzI5XSxcbiAgICBbMC45NTYzMDUsIDAuMjkyMzcyLCAwLjg3MTc3OCwgMC40ODQyNzUsIDAuMDc0MDI5LFxuICAgICAwLjc1MTk0MCwgMC42Mzk2MzksIDAuMTU4MzAxLCAwLjAxOTc1OF0sXG4gICAgWzAuOTYxMjYyLCAwLjI3NTYzNywgMC44ODYwMzYsIDAuNDU4OTI0LCAwLjA2NTc5NyxcbiAgICAgMC43Nzg2ODAsIDAuNjExMDUwLCAwLjE0MTQyNywgMC4wMTY1NTZdLFxuICAgIFswLjk2NTkyNiwgMC4yNTg4MTksIDAuODk5NTE5LCAwLjQzMzAxMywgMC4wNTgwMTMsXG4gICAgIDAuODA0MTY0LCAwLjU4MDg4OSwgMC4xMjUzMDAsIDAuMDEzNzA3XSxcbiAgICBbMC45NzAyOTYsIDAuMjQxOTIyLCAwLjkxMjIxMSwgMC40MDY1NzQsIDAuMDUwNjg1LFxuICAgICAwLjgyODMyNiwgMC41NDkyMzMsIDAuMTA5OTY5LCAwLjAxMTE5M10sXG4gICAgWzAuOTc0MzcwLCAwLjIyNDk1MSwgMC45MjQwOTYsIDAuMzc5NjQxLCAwLjA0MzgyMyxcbiAgICAgMC44NTExMDUsIDAuNTE2MTYyLCAwLjA5NTQ4MSwgMC4wMDg5OTldLFxuICAgIFswLjk3ODE0OCwgMC4yMDc5MTIsIDAuOTM1MTU5LCAwLjM1MjI0NCwgMC4wMzc0MzYsXG4gICAgIDAuODcyNDQxLCAwLjQ4MTc1OSwgMC4wODE4ODAsIDAuMDA3MTA1XSxcbiAgICBbMC45ODE2MjcsIDAuMTkwODA5LCAwLjk0NTM4OCwgMC4zMjQ0MTksIDAuMDMxNTMwLFxuICAgICAwLjg5MjI3OSwgMC40NDYxMTQsIDAuMDY5MjA5LCAwLjAwNTQ5Ml0sXG4gICAgWzAuOTg0ODA4LCAwLjE3MzY0OCwgMC45NTQ3NjksIDAuMjk2MTk4LCAwLjAyNjExNCxcbiAgICAgMC45MTA1NjksIDAuNDA5MzE3LCAwLjA1NzUwNSwgMC4wMDQxNDBdLFxuICAgIFswLjk4NzY4OCwgMC4xNTY0MzQsIDAuOTYzMjkyLCAwLjI2NzYxNywgMC4wMjExOTMsXG4gICAgIDAuOTI3MjYyLCAwLjM3MTQ2MywgMC4wNDY4MDYsIDAuMDAzMDI2XSxcbiAgICBbMC45OTAyNjgsIDAuMTM5MTczLCAwLjk3MDk0NiwgMC4yMzg3MDksIDAuMDE2Nzc0LFxuICAgICAwLjk0MjMxNiwgMC4zMzI2NDksIDAuMDM3MTQzLCAwLjAwMjEzMV0sXG4gICAgWzAuOTkyNTQ2LCAwLjEyMTg2OSwgMC45Nzc3MjIsIDAuMjA5NTExLCAwLjAxMjg2MixcbiAgICAgMC45NTU2OTMsIDAuMjkyOTc2LCAwLjAyODU0NywgMC4wMDE0MzFdLFxuICAgIFswLjk5NDUyMiwgMC4xMDQ1MjgsIDAuOTgzNjExLCAwLjE4MDA1NywgMC4wMDk0NjIsXG4gICAgIDAuOTY3MzU2LCAwLjI1MjU0NCwgMC4wMjEwNDMsIDAuMDAwOTAzXSxcbiAgICBbMC45OTYxOTUsIDAuMDg3MTU2LCAwLjk4ODYwNiwgMC4xNTAzODQsIDAuMDA2NTc4LFxuICAgICAwLjk3NzI3NywgMC4yMTE0NjAsIDAuMDE0NjU0LCAwLjAwMDUyM10sXG4gICAgWzAuOTk3NTY0LCAwLjA2OTc1NiwgMC45OTI3MDEsIDAuMTIwNTI3LCAwLjAwNDIxNCxcbiAgICAgMC45ODU0MjksIDAuMTY5ODI4LCAwLjAwOTQwMCwgMC4wMDAyNjhdLFxuICAgIFswLjk5ODYzMCwgMC4wNTIzMzYsIDAuOTk1ODkxLCAwLjA5MDUyNCwgMC4wMDIzNzIsXG4gICAgIDAuOTkxNzkxLCAwLjEyNzc1NywgMC4wMDUyOTcsIDAuMDAwMTEzXSxcbiAgICBbMC45OTkzOTEsIDAuMDM0ODk5LCAwLjk5ODE3MywgMC4wNjA0MTEsIDAuMDAxMDU1LFxuICAgICAwLjk5NjM0OCwgMC4wODUzNTYsIDAuMDAyMzU3LCAwLjAwMDAzNF0sXG4gICAgWzAuOTk5ODQ4LCAwLjAxNzQ1MiwgMC45OTk1NDMsIDAuMDMwMjI0LCAwLjAwMDI2NCxcbiAgICAgMC45OTkwODYsIDAuMDQyNzMzLCAwLjAwMDU5MCwgMC4wMDAwMDRdLFxuICAgIFsxLjAwMDAwMCwgLTAuMDAwMDAwLCAxLjAwMDAwMCwgLTAuMDAwMDAwLCAwLjAwMDAwMCxcbiAgICAgMS4wMDAwMDAsIC0wLjAwMDAwMCwgMC4wMDAwMDAsIC0wLjAwMDAwMF0sXG4gIF0sXG5dO1xuXG5cbi8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTX0FaSU1VVEhfUkVTT0xVVElPTiA9XG4gIGV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU1swXS5sZW5ndGg7XG5cblxuLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG5leHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NfRUxFVkFUSU9OX1JFU09MVVRJT04gPVxuICBleHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NbMV0ubGVuZ3RoO1xuXG5cbi8qKlxuICogVGhlIG1heGltdW0gYWxsb3dlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5leHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSID1cbiAgZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTWzBdWzBdLmxlbmd0aCAvIDI7XG5cblxuLyoqXG4gKiBQcmUtY29tcHV0ZWQgcGVyLWJhbmQgd2VpZ2h0aW5nIGNvZWZmaWNpZW50cyBmb3IgcHJvZHVjaW5nIGVuZXJneS1wcmVzZXJ2aW5nXG4gKiBNYXgtUmUgc291cmNlcy5cbiAqL1xuZXhwb3J0cy5NQVhfUkVfV0VJR0hUUyA9XG5bXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMF0sXG4gIFsxLjAwMzIzNiwgMS4wMDIxNTYsIDAuOTk5MTUyLCAwLjk5MDAzOF0sXG4gIFsxLjAzMjM3MCwgMS4wMjExOTQsIDAuOTkwNDMzLCAwLjg5ODU3Ml0sXG4gIFsxLjA2MjY5NCwgMS4wNDAyMzEsIDAuOTc5MTYxLCAwLjc5OTgwNl0sXG4gIFsxLjA5Mzk5OSwgMS4wNTg5NTQsIDAuOTY0OTc2LCAwLjY5MzYwM10sXG4gIFsxLjEyNjAwMywgMS4wNzcwMDYsIDAuOTQ3NTI2LCAwLjU3OTg5MF0sXG4gIFsxLjE1ODM0NSwgMS4wOTM5ODIsIDAuOTI2NDc0LCAwLjQ1ODY5MF0sXG4gIFsxLjE5MDU5MCwgMS4xMDk0MzcsIDAuOTAxNTEyLCAwLjMzMDE1OF0sXG4gIFsxLjIyMjIyOCwgMS4xMjI4OTAsIDAuODcyMzcwLCAwLjE5NDYyMV0sXG4gIFsxLjI1MjY4NCwgMS4xMzM4MzcsIDAuODM4ODM5LCAwLjA1MjYxNF0sXG4gIFsxLjI4MTk4NywgMS4xNDIzNTgsIDAuODAxMTk5LCAwLjAwMDAwMF0sXG4gIFsxLjMxMjA3MywgMS4xNTAyMDcsIDAuNzYwODM5LCAwLjAwMDAwMF0sXG4gIFsxLjM0MzAxMSwgMS4xNTc0MjQsIDAuNzE3Nzk5LCAwLjAwMDAwMF0sXG4gIFsxLjM3NDY0OSwgMS4xNjM4NTksIDAuNjcxOTk5LCAwLjAwMDAwMF0sXG4gIFsxLjQwNjgwOSwgMS4xNjkzNTQsIDAuNjIzMzcxLCAwLjAwMDAwMF0sXG4gIFsxLjQzOTI4NiwgMS4xNzM3MzksIDAuNTcxODY4LCAwLjAwMDAwMF0sXG4gIFsxLjQ3MTg0NiwgMS4xNzY4MzcsIDAuNTE3NDY1LCAwLjAwMDAwMF0sXG4gIFsxLjUwNDIyNiwgMS4xNzg0NjUsIDAuNDYwMTc0LCAwLjAwMDAwMF0sXG4gIFsxLjUzNjEzMywgMS4xNzg0MzgsIDAuNDAwMDQzLCAwLjAwMDAwMF0sXG4gIFsxLjU2NzI1MywgMS4xNzY1NzMsIDAuMzM3MTY1LCAwLjAwMDAwMF0sXG4gIFsxLjU5NzI0NywgMS4xNzI2OTUsIDAuMjcxNjg4LCAwLjAwMDAwMF0sXG4gIFsxLjYyNTc2NiwgMS4xNjY2NDUsIDAuMjAzODE1LCAwLjAwMDAwMF0sXG4gIFsxLjY1MjQ1NSwgMS4xNTgyODUsIDAuMTMzODA2LCAwLjAwMDAwMF0sXG4gIFsxLjY3Njk2NiwgMS4xNDc1MDYsIDAuMDYxOTgzLCAwLjAwMDAwMF0sXG4gIFsxLjY5OTAwNiwgMS4xMzQyNjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjcyMDIyNCwgMS4xMTk3ODksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjc0MTYzMSwgMS4xMDQ4MTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjc2MzE4MywgMS4wODkzMzAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjc4NDgzNywgMS4wNzMzNTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjgwNjU0OCwgMS4wNTY4OTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjgyODI2OSwgMS4wMzk5NjgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjg0OTk1MiwgMS4wMjI1ODAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjg3MTU1MiwgMS4wMDQ3NTIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjg5MzAxOCwgMC45ODY1MDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjkxNDMwNSwgMC45Njc4NTcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjkzNTM2NiwgMC45NDg4MzcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjk1NjE1NCwgMC45Mjk0NzEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjk3NjYyNSwgMC45MDk3OTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsxLjk5NjczNiwgMC44ODk4MjMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjAxNjQ0OCwgMC44Njk2MDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjAzNTcyMSwgMC44NDkxNzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjA1NDUyMiwgMC44Mjg1NjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjA3MjgxOCwgMC44MDc4MTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjA5MDU4MSwgMC43ODY5NjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjEwNzc4NSwgMC43NjYwNTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjEyNDQxMSwgMC43NDUxMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjE0MDQzOSwgMC43MjQxOTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjE1NTg1NiwgMC43MDMzMzIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjE3MDY1MywgMC42ODI1NjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjE4NDgyMywgMC42NjE5MjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjE5ODM2NCwgMC42NDE0NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjIxMTI3NSwgMC42MjExNjksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjIyMzU2MiwgMC42MDExMjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjIzNTIzMCwgMC41ODEzNDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI0NjI4OSwgMC41NjE4NDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI1Njc1MSwgMC41NDI2NjcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI2NjYzMSwgMC41MjM4MjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI3NTk0MywgMC41MDUzNDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI4NDcwNywgMC40ODcyMzksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjI5MjkzOSwgMC40Njk1MjgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMwMDY2MSwgMC40NTIyMjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMwNzg5MiwgMC40MzUzNDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMxNDY1NCwgMC40MTg4ODgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMyMDk2OSwgMC40MDI4NzAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMyNjg1OCwgMC4zODcyOTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMzMjM0MywgMC4zNzIxNjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjMzNzQ0NSwgMC4zNTc0ODEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM0MjE4NiwgMC4zNDMyNDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM0NjU4NSwgMC4zMjk0NTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM1MDY2NCwgMC4zMTYxMTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM1NDQ0MiwgMC4zMDMyMDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM1NzkzNywgMC4yOTA3MzgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM2MTE2OCwgMC4yNzg2OTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM2NDE1MiwgMC4yNjcwODAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM2NjkwNiwgMC4yNTU4NzgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM2OTQ0NiwgMC4yNDUwODIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM3MTc4NiwgMC4yMzQ2ODUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM3Mzk0MCwgMC4yMjQ2NzcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM3NTkyMywgMC4yMTUwNDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM3Nzc0NSwgMC4yMDU3OTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM3OTQyMSwgMC4xOTY4OTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4MDk1OSwgMC4xODgzNDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4MjM3MiwgMC4xODAxMzIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4MzY2NywgMC4xNzIyNTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4NDg1NiwgMC4xNjQ2ODksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4NTk0NSwgMC4xNTc0MzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4Njk0MywgMC4xNTA0NzksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4Nzg1NywgMC4xNDM4MTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4ODY5NCwgMC4xMzc0MjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM4OTQ2MCwgMC4xMzEyOTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MDE2MCwgMC4xMjU0MzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MDgwMSwgMC4xMTk4MjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MTM4NiwgMC4xMTQ0NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MTkyMSwgMC4xMDkzMDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MjQxMCwgMC4xMDQzNzYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5Mjg1NywgMC4wOTk2NjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MzI2NSwgMC4wOTUxNjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5MzYzNywgMC4wOTA4NTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5Mzk3NywgMC4wODY3MzEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NDI4OCwgMC4wODI3OTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NDU3MSwgMC4wNzkwMjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NDgyOSwgMC4wNzU0MjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTA2NCwgMC4wNzE5ODYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTI3OSwgMC4wNjg2OTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTQ3NSwgMC4wNjU1NTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTY1MywgMC4wNjI1NTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTgxNiwgMC4wNTk2OTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NTk2NCwgMC4wNTY5NTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjA5OSwgMC4wNTQzNDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjIyMiwgMC4wNTE4NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjMzNCwgMC4wNDk0NjIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjQzNiwgMC4wNDcxODYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjUyOSwgMC4wNDUwMTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjYxMywgMC4wNDI5MzksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjY5MSwgMC4wNDA5NTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5Njc2MSwgMC4wMzkwNjksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjgyNSwgMC4wMzcyNjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5Njg4MywgMC4wMzU1NDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NjkzNiwgMC4wMzM5MDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5Njk4NCwgMC4wMzIzMzQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzAyOCwgMC4wMzA4MzgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzA2OCwgMC4wMjk0MTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzEwNCwgMC4wMjgwNDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzEzNywgMC4wMjY3NDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzE2NywgMC4wMjU1MDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzE5NCwgMC4wMjQzMjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzIxOSwgMC4wMjMxOTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzI0MiwgMC4wMjIxMjIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzI2MiwgMC4wMjEwOTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzI4MSwgMC4wMjAxMTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzI5OCwgMC4wMTkxODEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzMxNCwgMC4wMTgyOTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzMyOCwgMC4wMTc0NDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM0MSwgMC4wMTY2MzAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM1MiwgMC4wMTU4NTcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM2MywgMC4wMTUxMTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM3MiwgMC4wMTQ0MTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM4MSwgMC4wMTM3NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM4OSwgMC4wMTMxMDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzM5NiwgMC4wMTI0OTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQwMywgMC4wMTE5MTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQwOSwgMC4wMTEzNjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQxNCwgMC4wMTA4MzEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQxOSwgMC4wMTAzMjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQyNCwgMC4wMDk4NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQyOCwgMC4wMDkzODcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQzMiwgMC4wMDg5NDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQzNSwgMC4wMDg1MzIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQzOCwgMC4wMDgxMzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ0MSwgMC4wMDc3NTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ0MywgMC4wMDczOTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ0NiwgMC4wMDcwNDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ0OCwgMC4wMDY3MjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1MCwgMC4wMDY0MDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1MSwgMC4wMDYxMDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1MywgMC4wMDU4MjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1NCwgMC4wMDU1NTIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1NiwgMC4wMDUyOTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1NywgMC4wMDUwNDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1OCwgMC4wMDQ4MTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ1OSwgMC4wMDQ1ODYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MCwgMC4wMDQzNzIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MSwgMC4wMDQxNjgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MSwgMC4wMDM5NzQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MiwgMC4wMDM3ODgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MywgMC4wMDM2MTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2MywgMC4wMDM0NDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NCwgMC4wMDMyODIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NCwgMC4wMDMxMjksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NSwgMC4wMDI5ODMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NSwgMC4wMDI4NDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NSwgMC4wMDI3MTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NiwgMC4wMDI1ODQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NiwgMC4wMDI0NjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NiwgMC4wMDIzNDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NiwgMC4wMDIyMzksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDIxMzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDIwMzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDE5NDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDE4NDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDE3NjMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2NywgMC4wMDE2ODEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDE2MDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDE1MjcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDE0NTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEzODgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEzMjMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEyNjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEyMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDExNDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEwOTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDEwNDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDA5OTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDA5NDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDA5MDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDA4NjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OCwgMC4wMDA4MjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA3ODIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA3NDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA3MTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA2NzcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA2NDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA2MTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA1ODcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA1NTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA1MzMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA1MDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA0ODUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA0NjIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA0NDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA0MjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDA0MDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzODEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzNjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzNDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzMzAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAzMDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyODYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyNzMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyNjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyNDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyMzYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyMjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAyMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxOTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxODYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNzcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNjksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxNDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMzMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMjcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAxMDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwOTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwOTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwODcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwODMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNzksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNzEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNjgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNjIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwNDAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMzAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMjAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMTAsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDksIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDgsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDcsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDYsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDUsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDQsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDMsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDIsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG4gIFsyLjM5NzQ2OSwgMC4wMDAwMDEsIDAuMDAwMDAwLCAwLjAwMDAwMF0sXG5dO1xuXG5cbi8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuZXhwb3J0cy5NQVhfUkVfV0VJR0hUU19SRVNPTFVUSU9OID0gZXhwb3J0cy5NQVhfUkVfV0VJR0hUUy5sZW5ndGg7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFNvdXJjZSBtb2RlbCB0byBzcGF0aWFsaXplIGFuIGF1ZGlvIGJ1ZmZlci5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IERpcmVjdGl2aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmNvbnN0IEF0dGVudWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmNvbnN0IEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIFNvdXJjZVxuICogQGRlc2NyaXB0aW9uIFNvdXJjZSBtb2RlbCB0byBzcGF0aWFsaXplIGFuIGF1ZGlvIGJ1ZmZlci5cbiAqIEBwYXJhbSB7UmVzb25hbmNlQXVkaW99IHNjZW5lIEFzc29jaWF0ZWQge0BsaW5rIFJlc29uYW5jZUF1ZGlvXG4gKiBSZXNvbmFuY2VBdWRpb30gaW5zdGFuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMucG9zaXRpb25cbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmZvcndhcmRcbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIGZvcndhcmQgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0ZPUldBUkQgREVGQVVMVF9GT1JXQVJEfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnVwXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCB1cCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfVVAgREVGQVVMVF9VUH0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5taW5EaXN0YW5jZVxuICogTWluLiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0UgREVGQVVMVF9NSU5fRElTVEFOQ0V9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4RGlzdGFuY2VcbiAqIE1heC4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFIERFRkFVTFRfTUFYX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJvbGxvZmZcbiAqIFJvbGxvZmYgbW9kZWwgdG8gdXNlLCBjaG9zZW4gZnJvbSBvcHRpb25zIGluXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTIEFUVEVOVUFUSU9OX1JPTExPRkZTfS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGIERFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5nYWluIElucHV0IGdhaW4gKGxpbmVhcikuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU09VUkNFX0dBSU4gREVGQVVMVF9TT1VSQ0VfR0FJTn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbHBoYSBEaXJlY3Rpdml0eSBhbHBoYS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQSBERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNoYXJwbmVzcyBEaXJlY3Rpdml0eSBzaGFycG5lc3MuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTXG4gKiBERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICogU291cmNlIHdpZHRoIChpbiBkZWdyZWVzKS4gV2hlcmUgMCBkZWdyZWVzIGlzIGEgcG9pbnQgc291cmNlIGFuZCAzNjAgZGVncmVlc1xuICogaXMgYW4gb21uaWRpcmVjdGlvbmFsIHNvdXJjZS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEggREVGQVVMVF9TT1VSQ0VfV0lEVEh9LlxuICovXG5mdW5jdGlvbiBTb3VyY2Uoc2NlbmUsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgU291cmNlXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLnBvc2l0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMucG9zaXRpb24gPSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yd2FyZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmZvcndhcmQgPSBVdGlscy5ERUZBVUxUX0ZPUldBUkQuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy51cCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnVwID0gVXRpbHMuREVGQVVMVF9VUC5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLm1pbkRpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWluRGlzdGFuY2UgPSBVdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhEaXN0YW5jZSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1heERpc3RhbmNlID0gVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0U7XG4gIH1cbiAgaWYgKG9wdGlvbnMucm9sbG9mZiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnJvbGxvZmYgPSBVdGlscy5ERUZBVUxUX1JPTExPRkY7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZ2FpbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmdhaW4gPSBVdGlscy5ERUZBVUxUX1NPVVJDRV9HQUlOO1xuICB9XG4gIGlmIChvcHRpb25zLmFscGhhID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYWxwaGEgPSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBO1xuICB9XG4gIGlmIChvcHRpb25zLnNoYXJwbmVzcyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNoYXJwbmVzcyA9IFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTO1xuICB9XG4gIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc291cmNlV2lkdGggPSBVdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSDtcbiAgfVxuXG4gIC8vIE1lbWJlciB2YXJpYWJsZXMuXG4gIHRoaXMuX3NjZW5lID0gc2NlbmU7XG4gIHRoaXMuX3Bvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgdGhpcy5fZm9yd2FyZCA9IG9wdGlvbnMuZm9yd2FyZDtcbiAgdGhpcy5fdXAgPSBvcHRpb25zLnVwO1xuICB0aGlzLl9keCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gIHRoaXMuX3JpZ2h0ID0gVXRpbHMuY3Jvc3NQcm9kdWN0KHRoaXMuX2ZvcndhcmQsIHRoaXMuX3VwKTtcblxuICAvLyBDcmVhdGUgYXVkaW8gbm9kZXMuXG4gIGxldCBjb250ZXh0ID0gc2NlbmUuX2NvbnRleHQ7XG4gIHRoaXMuaW5wdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fZGlyZWN0aXZpdHkgPSBuZXcgRGlyZWN0aXZpdHkoY29udGV4dCwge1xuICAgIGFscGhhOiBvcHRpb25zLmFscGhhLFxuICAgIHNoYXJwbmVzczogb3B0aW9ucy5zaGFycG5lc3MsXG4gIH0pO1xuICB0aGlzLl90b0Vhcmx5ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX3RvTGF0ZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9hdHRlbnVhdGlvbiA9IG5ldyBBdHRlbnVhdGlvbihjb250ZXh0LCB7XG4gICAgbWluRGlzdGFuY2U6IG9wdGlvbnMubWluRGlzdGFuY2UsXG4gICAgbWF4RGlzdGFuY2U6IG9wdGlvbnMubWF4RGlzdGFuY2UsXG4gICAgcm9sbG9mZjogb3B0aW9ucy5yb2xsb2ZmLFxuICB9KTtcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKGNvbnRleHQsIHtcbiAgICBhbWJpc29uaWNPcmRlcjogc2NlbmUuX2FtYmlzb25pY09yZGVyLFxuICAgIHNvdXJjZVdpZHRoOiBvcHRpb25zLnNvdXJjZVdpZHRoLFxuICB9KTtcblxuICAvLyBDb25uZWN0IG5vZGVzLlxuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fdG9MYXRlKTtcbiAgdGhpcy5fdG9MYXRlLmNvbm5lY3Qoc2NlbmUuX3Jvb20ubGF0ZS5pbnB1dCk7XG5cbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2F0dGVudWF0aW9uLmlucHV0KTtcbiAgdGhpcy5fYXR0ZW51YXRpb24ub3V0cHV0LmNvbm5lY3QodGhpcy5fdG9FYXJseSk7XG4gIHRoaXMuX3RvRWFybHkuY29ubmVjdChzY2VuZS5fcm9vbS5lYXJseS5pbnB1dCk7XG5cbiAgdGhpcy5fYXR0ZW51YXRpb24ub3V0cHV0LmNvbm5lY3QodGhpcy5fZGlyZWN0aXZpdHkuaW5wdXQpO1xuICB0aGlzLl9kaXJlY3Rpdml0eS5vdXRwdXQuY29ubmVjdCh0aGlzLl9lbmNvZGVyLmlucHV0KTtcblxuICB0aGlzLl9lbmNvZGVyLm91dHB1dC5jb25uZWN0KHNjZW5lLl9saXN0ZW5lci5pbnB1dCk7XG5cbiAgLy8gQXNzaWduIGluaXRpYWwgY29uZGl0aW9ucy5cbiAgdGhpcy5zZXRQb3NpdGlvbihcbiAgICBvcHRpb25zLnBvc2l0aW9uWzBdLCBvcHRpb25zLnBvc2l0aW9uWzFdLCBvcHRpb25zLnBvc2l0aW9uWzJdKTtcbiAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gb3B0aW9ucy5nYWluO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAvLyBBc3NpZ24gbmV3IHBvc2l0aW9uLlxuICB0aGlzLl9wb3NpdGlvblswXSA9IHg7XG4gIHRoaXMuX3Bvc2l0aW9uWzFdID0geTtcbiAgdGhpcy5fcG9zaXRpb25bMl0gPSB6O1xuXG4gIC8vIEhhbmRsZSBmYXItZmllbGQgZWZmZWN0LlxuICBsZXQgZGlzdGFuY2UgPSB0aGlzLl9zY2VuZS5fcm9vbS5nZXREaXN0YW5jZU91dHNpZGVSb29tKFxuICAgIHRoaXMuX3Bvc2l0aW9uWzBdLCB0aGlzLl9wb3NpdGlvblsxXSwgdGhpcy5fcG9zaXRpb25bMl0pO1xuICAgIGxldCBnYWluID0gX2NvbXB1dGVEaXN0YW5jZU91dHNpZGVSb29tKGRpc3RhbmNlKTtcbiAgdGhpcy5fdG9MYXRlLmdhaW4udmFsdWUgPSBnYWluO1xuICB0aGlzLl90b0Vhcmx5LmdhaW4udmFsdWUgPSBnYWluO1xuXG4gIHRoaXMuX3VwZGF0ZSgpO1xufTtcblxuXG4vLyBVcGRhdGUgdGhlIHNvdXJjZSB3aGVuIGNoYW5naW5nIHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uLlxuU291cmNlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIENvbXB1dGUgZGlzdGFuY2UgdG8gbGlzdGVuZXIuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgdGhpcy5fZHhbaV0gPSB0aGlzLl9wb3NpdGlvbltpXSAtIHRoaXMuX3NjZW5lLl9saXN0ZW5lci5wb3NpdGlvbltpXTtcbiAgfVxuICBsZXQgZGlzdGFuY2UgPSBNYXRoLnNxcnQodGhpcy5fZHhbMF0gKiB0aGlzLl9keFswXSArXG4gICAgdGhpcy5fZHhbMV0gKiB0aGlzLl9keFsxXSArIHRoaXMuX2R4WzJdICogdGhpcy5fZHhbMl0pO1xuICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgLy8gTm9ybWFsaXplIGRpcmVjdGlvbiB2ZWN0b3IuXG4gICAgdGhpcy5fZHhbMF0gLz0gZGlzdGFuY2U7XG4gICAgdGhpcy5fZHhbMV0gLz0gZGlzdGFuY2U7XG4gICAgdGhpcy5fZHhbMl0gLz0gZGlzdGFuY2U7XG4gIH1cblxuICAvLyBDb21wdWV0ZSBhbmdsZSBvZiBkaXJlY3Rpb24gdmVjdG9yLlxuICBsZXQgYXppbXV0aCA9IE1hdGguYXRhbjIoLXRoaXMuX2R4WzBdLCB0aGlzLl9keFsyXSkgKlxuICAgIFV0aWxzLlJBRElBTlNfVE9fREVHUkVFUztcbiAgbGV0IGVsZXZhdGlvbiA9IE1hdGguYXRhbjIodGhpcy5fZHhbMV0sIE1hdGguc3FydCh0aGlzLl9keFswXSAqIHRoaXMuX2R4WzBdICtcbiAgICB0aGlzLl9keFsyXSAqIHRoaXMuX2R4WzJdKSkgKiBVdGlscy5SQURJQU5TX1RPX0RFR1JFRVM7XG5cbiAgLy8gU2V0IGRpc3RhbmNlL2RpcmVjdGl2aXR5L2RpcmVjdGlvbiB2YWx1ZXMuXG4gIHRoaXMuX2F0dGVudWF0aW9uLnNldERpc3RhbmNlKGRpc3RhbmNlKTtcbiAgdGhpcy5fZGlyZWN0aXZpdHkuY29tcHV0ZUFuZ2xlKHRoaXMuX2ZvcndhcmQsIHRoaXMuX2R4KTtcbiAgdGhpcy5fZW5jb2Rlci5zZXREaXJlY3Rpb24oYXppbXV0aCwgZWxldmF0aW9uKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3Mgcm9sbG9mZi5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb2xsb2ZmXG4gKiBSb2xsb2ZmIG1vZGVsIHRvIHVzZSwgY2hvc2VuIGZyb20gb3B0aW9ucyBpblxuICoge0BsaW5rY29kZSBVdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyBBVFRFTlVBVElPTl9ST0xMT0ZGU30uXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0Um9sbG9mZiA9IGZ1bmN0aW9uKHJvbGxvZmYpIHtcbiAgdGhpcy5fYXR0ZW51YXRpb24uc2V0Um9sbG9mZihyb2xsb2ZmKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgbWluaW11bSBkaXN0YW5jZSAoaW4gbWV0ZXJzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0YW5jZVxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldE1pbkRpc3RhbmNlID0gZnVuY3Rpb24obWluRGlzdGFuY2UpIHtcbiAgdGhpcy5fYXR0ZW51YXRpb24ubWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgbWF4aW11bSBkaXN0YW5jZSAoaW4gbWV0ZXJzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEaXN0YW5jZVxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldE1heERpc3RhbmNlID0gZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcbiAgdGhpcy5fYXR0ZW51YXRpb24ubWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgZ2FpbiAobGluZWFyKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBnYWluXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0R2FpbiA9IGZ1bmN0aW9uKGdhaW4pIHtcbiAgdGhpcy5pbnB1dC5nYWluLnZhbHVlID0gZ2Fpbjtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSdzIG9yaWVudGF0aW9uIHVzaW5nIGZvcndhcmQgYW5kIHVwIHZlY3RvcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFhcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWVxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRaXG4gKiBAcGFyYW0ge051bWJlcn0gdXBYXG4gKiBAcGFyYW0ge051bWJlcn0gdXBZXG4gKiBAcGFyYW0ge051bWJlcn0gdXBaXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbihmb3J3YXJkWCwgZm9yd2FyZFksIGZvcndhcmRaLFxuICAgIHVwWCwgdXBZLCB1cFopIHtcbiAgdGhpcy5fZm9yd2FyZFswXSA9IGZvcndhcmRYO1xuICB0aGlzLl9mb3J3YXJkWzFdID0gZm9yd2FyZFk7XG4gIHRoaXMuX2ZvcndhcmRbMl0gPSBmb3J3YXJkWjtcbiAgdGhpcy5fdXBbMF0gPSB1cFg7XG4gIHRoaXMuX3VwWzFdID0gdXBZO1xuICB0aGlzLl91cFsyXSA9IHVwWjtcbiAgdGhpcy5fcmlnaHQgPSBVdGlscy5jcm9zc1Byb2R1Y3QodGhpcy5fZm9yd2FyZCwgdGhpcy5fdXApO1xufTtcblxuXG4vLyBUT0RPKGJpdGxsYW1hKTogTWFrZSBzdXJlIHRoaXMgd29ya3Mgd2l0aCBUaHJlZS5qcyBhcyBpbnRlbmRlZC5cbi8qKlxuICogU2V0IHNvdXJjZSdzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiB1c2luZyBhXG4gKiBUaHJlZS5qcyBtb2RlbFZpZXdNYXRyaXggb2JqZWN0LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG1hdHJpeDRcbiAqIFRoZSBNYXRyaXg0IHJlcHJlc2VudGluZyB0aGUgb2JqZWN0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBpbiB3b3JsZCBzcGFjZS5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4ID0gZnVuY3Rpb24obWF0cml4NCkge1xuICB0aGlzLl9yaWdodFswXSA9IG1hdHJpeDQuZWxlbWVudHNbMF07XG4gIHRoaXMuX3JpZ2h0WzFdID0gbWF0cml4NC5lbGVtZW50c1sxXTtcbiAgdGhpcy5fcmlnaHRbMl0gPSBtYXRyaXg0LmVsZW1lbnRzWzJdO1xuICB0aGlzLl91cFswXSA9IG1hdHJpeDQuZWxlbWVudHNbNF07XG4gIHRoaXMuX3VwWzFdID0gbWF0cml4NC5lbGVtZW50c1s1XTtcbiAgdGhpcy5fdXBbMl0gPSBtYXRyaXg0LmVsZW1lbnRzWzZdO1xuICB0aGlzLl9mb3J3YXJkWzBdID0gbWF0cml4NC5lbGVtZW50c1s4XTtcbiAgdGhpcy5fZm9yd2FyZFsxXSA9IG1hdHJpeDQuZWxlbWVudHNbOV07XG4gIHRoaXMuX2ZvcndhcmRbMl0gPSBtYXRyaXg0LmVsZW1lbnRzWzEwXTtcblxuICAvLyBOb3JtYWxpemUgdG8gcmVtb3ZlIHNjYWxpbmcuXG4gIHRoaXMuX3JpZ2h0ID0gVXRpbHMubm9ybWFsaXplVmVjdG9yKHRoaXMuX3JpZ2h0KTtcbiAgdGhpcy5fdXAgPSBVdGlscy5ub3JtYWxpemVWZWN0b3IodGhpcy5fdXApO1xuICB0aGlzLl9mb3J3YXJkID0gVXRpbHMubm9ybWFsaXplVmVjdG9yKHRoaXMuX2ZvcndhcmQpO1xuXG4gIC8vIFVwZGF0ZSBwb3NpdGlvbi5cbiAgdGhpcy5zZXRQb3NpdGlvbihcbiAgICBtYXRyaXg0LmVsZW1lbnRzWzEyXSwgbWF0cml4NC5lbGVtZW50c1sxM10sIG1hdHJpeDQuZWxlbWVudHNbMTRdKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSB3aWR0aCAoaW4gZGVncmVlcykuIFdoZXJlIDAgZGVncmVlcyBpcyBhIHBvaW50IHNvdXJjZSBhbmQgMzYwXG4gKiBkZWdyZWVzIGlzIGFuIG9tbmlkaXJlY3Rpb25hbCBzb3VyY2UuXG4gKiBAcGFyYW0ge051bWJlcn0gc291cmNlV2lkdGggKGluIGRlZ3JlZXMpLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldFNvdXJjZVdpZHRoID0gZnVuY3Rpb24oc291cmNlV2lkdGgpIHtcbiAgdGhpcy5fZW5jb2Rlci5zZXRTb3VyY2VXaWR0aChzb3VyY2VXaWR0aCk7XG4gIHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcG9zaXRpb25bMF0sIHRoaXMuX3Bvc2l0aW9uWzFdLCB0aGlzLl9wb3NpdGlvblsyXSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIGRpcmVjdGl2aXR5IHBhdHRlcm4gKGRlZmluZWQgYnkgYWxwaGEpLCB3aGVyZSAwIGlzIGFuXG4gKiBvbW5pZGlyZWN0aW9uYWwgcGF0dGVybiwgMSBpcyBhIGJpZGlyZWN0aW9uYWwgcGF0dGVybiwgMC41IGlzIGEgY2FyZGlvZFxuICogcGF0dGVybi4gVGhlIHNoYXJwbmVzcyBvZiB0aGUgcGF0dGVybiBpcyBpbmNyZWFzZWQgZXhwb25lbnRpYWxseS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuICogRGV0ZXJtaW5lcyBkaXJlY3Rpdml0eSBwYXR0ZXJuICgwIHRvIDEpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNoYXJwbmVzc1xuICogRGV0ZXJtaW5lcyB0aGUgc2hhcnBuZXNzIG9mIHRoZSBkaXJlY3Rpdml0eSBwYXR0ZXJuICgxIHRvIEluZikuXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0RGlyZWN0aXZpdHlQYXR0ZXJuID0gZnVuY3Rpb24oYWxwaGEsIHNoYXJwbmVzcykge1xuICB0aGlzLl9kaXJlY3Rpdml0eS5zZXRQYXR0ZXJuKGFscGhhLCBzaGFycG5lc3MpO1xuICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uWzBdLCB0aGlzLl9wb3NpdGlvblsxXSwgdGhpcy5fcG9zaXRpb25bMl0pO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZSB0aGUgZGlzdGFuY2UgYSBzb3VyY2UgaXMgb3V0c2lkZSBvZiBhIHJvb20uIEF0dGVudWF0ZSBnYWluIGdvaW5nXG4gKiB0byB0aGUgcmVmbGVjdGlvbnMgYW5kIHJldmVyYiB3aGVuIHRoZSBzb3VyY2UgaXMgb3V0c2lkZSBvZiB0aGUgcm9vbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBEaXN0YW5jZSBpbiBtZXRlcnMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEdhaW4gKGxpbmVhcikgb2Ygc291cmNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVEaXN0YW5jZU91dHNpZGVSb29tKGRpc3RhbmNlKSB7XG4gIC8vIFdlIGFwcGx5IGEgbGluZWFyIHJhbXAgZnJvbSAxIHRvIDAgYXMgdGhlIHNvdXJjZSBpcyB1cCB0byAxbSBvdXRzaWRlLlxuICBsZXQgZ2FpbiA9IDE7XG4gIGlmIChkaXN0YW5jZSA+IFV0aWxzLkVQU0lMT05fRkxPQVQpIHtcbiAgICBnYWluID0gMSAtIGRpc3RhbmNlIC8gVXRpbHMuU09VUkNFX01BWF9PVVRTSURFX1JPT01fRElTVEFOQ0U7XG5cbiAgICAvLyBDbGFtcCBnYWluIGJldHdlZW4gMCBhbmQgMS5cbiAgICBnYWluID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZ2FpbikpO1xuICB9XG4gIHJldHVybiBnYWluO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gU291cmNlO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBEaXJlY3Rpdml0eS9vY2NsdXNpb24gZmlsdGVyLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBEaXJlY3Rpdml0eVxuICogQGRlc2NyaXB0aW9uIERpcmVjdGl2aXR5L29jY2x1c2lvbiBmaWx0ZXIuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbHBoYVxuICogRGV0ZXJtaW5lcyBkaXJlY3Rpdml0eSBwYXR0ZXJuICgwIHRvIDEpLiBTZWVcbiAqIHtAbGluayBEaXJlY3Rpdml0eSNzZXRQYXR0ZXJuIHNldFBhdHRlcm59IGZvciBtb3JlIGRldGFpbHMuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEEgREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zaGFycG5lc3NcbiAqIERldGVybWluZXMgdGhlIHNoYXJwbmVzcyBvZiB0aGUgZGlyZWN0aXZpdHkgcGF0dGVybiAoMSB0byBJbmYpLiBTZWVcbiAqIHtAbGluayBEaXJlY3Rpdml0eSNzZXRQYXR0ZXJuIHNldFBhdHRlcm59IGZvciBtb3JlIGRldGFpbHMuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTXG4gKiBERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU30uXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGl2aXR5KGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgRGlyZWN0aXZpdHlcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIERpcmVjdGl2aXR5XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbHBoYSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmFscGhhID0gVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQTtcbiAgfVxuICBpZiAob3B0aW9ucy5zaGFycG5lc3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zaGFycG5lc3MgPSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTUztcbiAgfVxuXG4gIC8vIENyZWF0ZSBhdWRpbyBub2RlLlxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fbG93cGFzcyA9IGNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBmaWx0ZXIgY29lZmZpY2llbnRzLlxuICB0aGlzLl9sb3dwYXNzLnR5cGUgPSAnbG93cGFzcyc7XG4gIHRoaXMuX2xvd3Bhc3MuUS52YWx1ZSA9IDA7XG4gIHRoaXMuX2xvd3Bhc3MuZnJlcXVlbmN5LnZhbHVlID0gY29udGV4dC5zYW1wbGVSYXRlICogMC41O1xuXG4gIHRoaXMuX2Nvc1RoZXRhID0gMDtcbiAgdGhpcy5zZXRQYXR0ZXJuKG9wdGlvbnMuYWxwaGEsIG9wdGlvbnMuc2hhcnBuZXNzKTtcblxuICAvLyBJbnB1dC9PdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9sb3dwYXNzO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX2xvd3Bhc3M7XG59XG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaWx0ZXIgdXNpbmcgdGhlIHNvdXJjZSdzIGZvcndhcmQgb3JpZW50YXRpb24gYW5kIHRoZSBsaXN0ZW5lcidzXG4gKiBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBmb3J3YXJkIFRoZSBzb3VyY2UncyBmb3J3YXJkIHZlY3Rvci5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBzb3VyY2UgdG8gdGhlXG4gKiBsaXN0ZW5lci5cbiAqL1xuRGlyZWN0aXZpdHkucHJvdG90eXBlLmNvbXB1dGVBbmdsZSA9IGZ1bmN0aW9uKGZvcndhcmQsIGRpcmVjdGlvbikge1xuICBsZXQgZm9yd2FyZE5vcm0gPSBVdGlscy5ub3JtYWxpemVWZWN0b3IoZm9yd2FyZCk7XG4gIGxldCBkaXJlY3Rpb25Ob3JtID0gVXRpbHMubm9ybWFsaXplVmVjdG9yKGRpcmVjdGlvbik7XG4gIGxldCBjb2VmZiA9IDE7XG4gIGlmICh0aGlzLl9hbHBoYSA+IFV0aWxzLkVQU0lMT05fRkxPQVQpIHtcbiAgICBsZXQgY29zVGhldGEgPSBmb3J3YXJkTm9ybVswXSAqIGRpcmVjdGlvbk5vcm1bMF0gK1xuICAgICAgZm9yd2FyZE5vcm1bMV0gKiBkaXJlY3Rpb25Ob3JtWzFdICsgZm9yd2FyZE5vcm1bMl0gKiBkaXJlY3Rpb25Ob3JtWzJdO1xuICAgIGNvZWZmID0gKDEgLSB0aGlzLl9hbHBoYSkgKyB0aGlzLl9hbHBoYSAqIGNvc1RoZXRhO1xuICAgIGNvZWZmID0gTWF0aC5wb3coTWF0aC5hYnMoY29lZmYpLCB0aGlzLl9zaGFycG5lc3MpO1xuICB9XG4gIHRoaXMuX2xvd3Bhc3MuZnJlcXVlbmN5LnZhbHVlID0gdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlICogMC41ICogY29lZmY7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIGRpcmVjdGl2aXR5IHBhdHRlcm4gKGRlZmluZWQgYnkgYWxwaGEpLCB3aGVyZSAwIGlzIGFuXG4gKiBvbW5pZGlyZWN0aW9uYWwgcGF0dGVybiwgMSBpcyBhIGJpZGlyZWN0aW9uYWwgcGF0dGVybiwgMC41IGlzIGEgY2FyZGlvZFxuICogcGF0dGVybi4gVGhlIHNoYXJwbmVzcyBvZiB0aGUgcGF0dGVybiBpcyBpbmNyZWFzZWQgZXhwb25lbmVudGlhbGx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG4gKiBEZXRlcm1pbmVzIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDAgdG8gMSkuXG4gKiBAcGFyYW0ge051bWJlcn0gc2hhcnBuZXNzXG4gKiBEZXRlcm1pbmVzIHRoZSBzaGFycG5lc3Mgb2YgdGhlIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDEgdG8gSW5mKS5cbiAqIERFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTfS5cbiAqL1xuRGlyZWN0aXZpdHkucHJvdG90eXBlLnNldFBhdHRlcm4gPSBmdW5jdGlvbihhbHBoYSwgc2hhcnBuZXNzKSB7XG4gIC8vIENsYW1wIGFuZCBzZXQgdmFsdWVzLlxuICB0aGlzLl9hbHBoYSA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGFscGhhKSk7XG4gIHRoaXMuX3NoYXJwbmVzcyA9IE1hdGgubWF4KDEsIHNoYXJwbmVzcyk7XG5cbiAgLy8gVXBkYXRlIGFuZ2xlIGNhbGN1bGF0aW9uIHVzaW5nIG5ldyB2YWx1ZXMuXG4gIHRoaXMuY29tcHV0ZUFuZ2xlKFt0aGlzLl9jb3NUaGV0YSAqIHRoaXMuX2Nvc1RoZXRhLCAwLCAwXSwgWzEsIDAsIDBdKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3Rpdml0eTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgRGlzdGFuY2UtYmFzZWQgYXR0ZW51YXRpb24gZmlsdGVyLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIEF0dGVudWF0aW9uXG4gKiBAZGVzY3JpcHRpb24gRGlzdGFuY2UtYmFzZWQgYXR0ZW51YXRpb24gZmlsdGVyLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWluRGlzdGFuY2VcbiAqIE1pbi4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFIERFRkFVTFRfTUlOX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heERpc3RhbmNlXG4gKiBNYXguIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRSBERUZBVUxUX01BWF9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yb2xsb2ZmXG4gKiBSb2xsb2ZmIG1vZGVsIHRvIHVzZSwgY2hvc2VuIGZyb20gb3B0aW9ucyBpblxuICoge0BsaW5rY29kZSBVdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyBBVFRFTlVBVElPTl9ST0xMT0ZGU30uIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRiBERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkZ9LlxuICovXG5mdW5jdGlvbiBBdHRlbnVhdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBNaW4uIGRpc3RhbmNlIChpbiBtZXRlcnMpLlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1pbkRpc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBBdHRlbnVhdGlvblxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNYXguIGRpc3RhbmNlIChpbiBtZXRlcnMpLlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IG1heERpc3RhbmNlXG4gICAqIEBtZW1iZXJvZiBBdHRlbnVhdGlvblxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIEF0dGVudWF0aW9uXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBBdHRlbnVhdGlvblxuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMubWluRGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5taW5EaXN0YW5jZSA9IFV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFO1xuICB9XG4gIGlmIChvcHRpb25zLm1heERpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWF4RGlzdGFuY2UgPSBVdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRTtcbiAgfVxuICBpZiAob3B0aW9ucy5yb2xsb2ZmID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMucm9sbG9mZiA9IFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRjtcbiAgfVxuXG4gIC8vIEFzc2lnbiB2YWx1ZXMuXG4gIHRoaXMubWluRGlzdGFuY2UgPSBvcHRpb25zLm1pbkRpc3RhbmNlO1xuICB0aGlzLm1heERpc3RhbmNlID0gb3B0aW9ucy5tYXhEaXN0YW5jZTtcbiAgdGhpcy5zZXRSb2xsb2ZmKG9wdGlvbnMucm9sbG9mZik7XG5cbiAgLy8gQ3JlYXRlIG5vZGUuXG4gIHRoaXMuX2dhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSB0byBtYXggZGlzdGFuY2UuXG4gIHRoaXMuc2V0RGlzdGFuY2Uob3B0aW9ucy5tYXhEaXN0YW5jZSk7XG5cbiAgLy8gSW5wdXQvT3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fZ2Fpbk5vZGU7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fZ2Fpbk5vZGU7XG59XG5cblxuLyoqXG4gKiBTZXQgZGlzdGFuY2UgZnJvbSB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgKGluIG1ldGVycykuXG4gKi9cbkF0dGVudWF0aW9uLnByb3RvdHlwZS5zZXREaXN0YW5jZSA9IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG4gIGxldCBnYWluID0gMTtcbiAgaWYgKHRoaXMuX3JvbGxvZmYgPT0gJ2xvZ2FyaXRobWljJykge1xuICAgIGlmIChkaXN0YW5jZSA+IHRoaXMubWF4RGlzdGFuY2UpIHtcbiAgICAgIGdhaW4gPSAwO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPiB0aGlzLm1pbkRpc3RhbmNlKSB7XG4gICAgICBsZXQgcmFuZ2UgPSB0aGlzLm1heERpc3RhbmNlIC0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgIGlmIChyYW5nZSA+IFV0aWxzLkVQU0lMT05fRkxPQVQpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgYXR0ZW51YXRpb24gdmFsdWUgYnkgdGhlIGxvZ2FyaXRobWljIGN1cnZlXG4gICAgICAgIC8vIFwiMSAvIChkICsgMSlcIiB3aXRoIGFuIG9mZnNldCBvZiB8bWluRGlzdGFuY2V8LlxuICAgICAgICBsZXQgcmVsYXRpdmVEaXN0YW5jZSA9IGRpc3RhbmNlIC0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgICAgbGV0IGF0dGVudWF0aW9uID0gMSAvIChyZWxhdGl2ZURpc3RhbmNlICsgMSk7XG4gICAgICAgIGxldCBhdHRlbnVhdGlvbk1heCA9IDEgLyAocmFuZ2UgKyAxKTtcbiAgICAgICAgZ2FpbiA9IChhdHRlbnVhdGlvbiAtIGF0dGVudWF0aW9uTWF4KSAvICgxIC0gYXR0ZW51YXRpb25NYXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9yb2xsb2ZmID09ICdsaW5lYXInKSB7XG4gICAgaWYgKGRpc3RhbmNlID4gdGhpcy5tYXhEaXN0YW5jZSkge1xuICAgICAgZ2FpbiA9IDA7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA+IHRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IHRoaXMubWF4RGlzdGFuY2UgLSB0aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgaWYgKHJhbmdlID4gVXRpbHMuRVBTSUxPTl9GTE9BVCkge1xuICAgICAgICBnYWluID0gKHRoaXMubWF4RGlzdGFuY2UgLSBkaXN0YW5jZSkgLyByYW5nZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IGdhaW47XG59O1xuXG5cbi8qKlxuICogU2V0IHJvbGxvZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sbG9mZlxuICogUm9sbG9mZiBtb2RlbCB0byB1c2UsIGNob3NlbiBmcm9tIG9wdGlvbnMgaW5cbiAqIHtAbGlua2NvZGUgVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgQVRURU5VQVRJT05fUk9MTE9GRlN9LlxuICovXG5BdHRlbnVhdGlvbi5wcm90b3R5cGUuc2V0Um9sbG9mZiA9IGZ1bmN0aW9uKHJvbGxvZmYpIHtcbiAgbGV0IGlzVmFsaWRNb2RlbCA9IH5VdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUy5pbmRleE9mKHJvbGxvZmYpO1xuICBpZiAocm9sbG9mZiA9PSB1bmRlZmluZWQgfHwgIWlzVmFsaWRNb2RlbCkge1xuICAgIGlmICghaXNWYWxpZE1vZGVsKSB7XG4gICAgICBVdGlscy5sb2coJ0ludmFsaWQgcm9sbG9mZiBtb2RlbCAoXFxcIicgKyByb2xsb2ZmICtcbiAgICAgICAgJ1xcXCIpLiBVc2luZyBkZWZhdWx0OiBcXFwiJyArIFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRiArICdcXFwiLicpO1xuICAgIH1cbiAgICByb2xsb2ZmID0gVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGO1xuICB9IGVsc2Uge1xuICAgIHJvbGxvZmYgPSByb2xsb2ZmLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICB0aGlzLl9yb2xsb2ZmID0gcm9sbG9mZjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBdHRlbnVhdGlvbjtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgQ29tcGxldGUgcm9vbSBtb2RlbCB3aXRoIGVhcmx5IGFuZCBsYXRlIHJlZmxlY3Rpb25zLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgTGF0ZVJlZmxlY3Rpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmNvbnN0IEVhcmx5UmVmbGVjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogR2VuZXJhdGUgYWJzb3JwdGlvbiBjb2VmZmljaWVudHMgZnJvbSBtYXRlcmlhbCBuYW1lcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2dldENvZWZmaWNpZW50c0Zyb21NYXRlcmlhbHMobWF0ZXJpYWxzKSB7XG4gIC8vIEluaXRpYWxpemUgY29lZmZpY2llbnRzIHRvIHVzZSBkZWZhdWx0cy5cbiAgbGV0IGNvZWZmaWNpZW50cyA9IHt9O1xuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICBjb2VmZmljaWVudHNbcHJvcGVydHldID0gVXRpbHMuUk9PTV9NQVRFUklBTF9DT0VGRklDSUVOVFNbXG4gICAgICAgIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFNbcHJvcGVydHldXTtcbiAgICB9XG4gIH1cblxuICAvLyBTYW5pdGl6ZSBtYXRlcmlhbHMuXG4gIGlmIChtYXRlcmlhbHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgbWF0ZXJpYWxzID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihtYXRlcmlhbHMsIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpO1xuICB9XG5cbiAgLy8gQXNzaWduIGNvZWZmaWNpZW50cyB1c2luZyBwcm92aWRlZCBtYXRlcmlhbHMuXG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiZcbiAgICAgICAgbWF0ZXJpYWxzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgaWYgKG1hdGVyaWFsc1twcm9wZXJ0eV0gaW4gVXRpbHMuUk9PTV9NQVRFUklBTF9DT0VGRklDSUVOVFMpIHtcbiAgICAgICAgY29lZmZpY2llbnRzW3Byb3BlcnR5XSA9XG4gICAgICAgICAgVXRpbHMuUk9PTV9NQVRFUklBTF9DT0VGRklDSUVOVFNbbWF0ZXJpYWxzW3Byb3BlcnR5XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlscy5sb2coJ01hdGVyaWFsIFxcXCInICsgbWF0ZXJpYWxzW3Byb3BlcnR5XSArICdcXFwiIG9uIHdhbGwgXFxcIicgK1xuICAgICAgICAgIHByb3BlcnR5ICsgJ1xcXCIgbm90IGZvdW5kLiBVc2luZyBcXFwiJyArXG4gICAgICAgICAgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMU1twcm9wZXJ0eV0gKyAnXFxcIi4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMubG9nKCdXYWxsIFxcXCInICsgcHJvcGVydHkgKyAnXFxcIiBpcyBub3QgZGVmaW5lZC4gRGVmYXVsdCB1c2VkLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29lZmZpY2llbnRzO1xufVxuXG4vKipcbiAqIFNhbml0aXplIGNvZWZmaWNpZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2VmZmljaWVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplQ29lZmZpY2llbnRzKGNvZWZmaWNpZW50cykge1xuICBpZiAoY29lZmZpY2llbnRzID09IHVuZGVmaW5lZCkge1xuICAgIGNvZWZmaWNpZW50cyA9IHt9O1xuICB9XG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpIHtcbiAgICBpZiAoIShjb2VmZmljaWVudHMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSkge1xuICAgICAgLy8gSWYgZWxlbWVudCBpcyBub3QgcHJlc2VudCwgdXNlIGRlZmF1bHQgY29lZmZpY2llbnRzLlxuICAgICAgY29lZmZpY2llbnRzW3Byb3BlcnR5XSA9IFV0aWxzLlJPT01fTUFURVJJQUxfQ09FRkZJQ0lFTlRTW1xuICAgICAgICBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTW3Byb3BlcnR5XV07XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2VmZmljaWVudHM7XG59XG5cbi8qKlxuICogU2FuaXRpemUgZGltZW5zaW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9zYW5pdGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICBpZiAoZGltZW5zaW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBkaW1lbnNpb25zID0ge307XG4gIH1cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMpIHtcbiAgICBpZiAoIShkaW1lbnNpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkpIHtcbiAgICAgIGRpbWVuc2lvbnNbcHJvcGVydHldID0gVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlNbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGltZW5zaW9ucztcbn1cblxuLyoqXG4gKiBDb21wdXRlIGZyZXF1ZW5jeS1kZXBlbmRlbnQgcmV2ZXJiIGR1cmF0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29lZmZpY2llbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gc3BlZWRPZlNvdW5kXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gX2dldER1cmF0aW9uc0Zyb21Qcm9wZXJ0aWVzKGRpbWVuc2lvbnMsIGNvZWZmaWNpZW50cywgc3BlZWRPZlNvdW5kKSB7XG4gIGxldCBkdXJhdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTKTtcblxuICAvLyBTYW5pdGl6ZSBpbnB1dHMuXG4gIGRpbWVuc2lvbnMgPSBfc2FuaXRpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpO1xuICBjb2VmZmljaWVudHMgPSBfc2FuaXRpemVDb2VmZmljaWVudHMoY29lZmZpY2llbnRzKTtcbiAgaWYgKHNwZWVkT2ZTb3VuZCA9PSB1bmRlZmluZWQpIHtcbiAgICBzcGVlZE9mU291bmQgPSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EO1xuICB9XG5cbiAgLy8gQWNvdXN0aWMgY29uc3RhbnQuXG4gIGxldCBrID0gVXRpbHMuVFdFTlRZX0ZPVVJfTE9HMTAgLyBzcGVlZE9mU291bmQ7XG5cbiAgLy8gQ29tcHV0ZSB2b2x1bWUsIHNraXAgaWYgcm9vbSBpcyBub3QgcHJlc2VudC5cbiAgbGV0IHZvbHVtZSA9IGRpbWVuc2lvbnMud2lkdGggKiBkaW1lbnNpb25zLmhlaWdodCAqIGRpbWVuc2lvbnMuZGVwdGg7XG4gIGlmICh2b2x1bWUgPCBVdGlscy5ST09NX01JTl9WT0xVTUUpIHtcbiAgICByZXR1cm4gZHVyYXRpb25zO1xuICB9XG5cbiAgLy8gUm9vbSBzdXJmYWNlIGFyZWEuXG4gIGxldCBsZWZ0UmlnaHRBcmVhID0gZGltZW5zaW9ucy53aWR0aCAqIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICBsZXQgZmxvb3JDZWlsaW5nQXJlYSA9IGRpbWVuc2lvbnMud2lkdGggKiBkaW1lbnNpb25zLmRlcHRoO1xuICBsZXQgZnJvbnRCYWNrQXJlYSA9IGRpbWVuc2lvbnMuZGVwdGggKiBkaW1lbnNpb25zLmhlaWdodDtcbiAgbGV0IHRvdGFsQXJlYSA9IDIgKiAobGVmdFJpZ2h0QXJlYSArIGZsb29yQ2VpbGluZ0FyZWEgKyBmcm9udEJhY2tBcmVhKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUzsgaSsrKSB7XG4gICAgLy8gRWZmZWN0aXZlIGFic29ycHRpdmUgYXJlYS5cbiAgICBsZXQgYWJzb3JidGlvbkFyZWEgPVxuICAgICAgKGNvZWZmaWNpZW50cy5sZWZ0W2ldICsgY29lZmZpY2llbnRzLnJpZ2h0W2ldKSAqIGxlZnRSaWdodEFyZWEgK1xuICAgICAgKGNvZWZmaWNpZW50cy5kb3duW2ldICsgY29lZmZpY2llbnRzLnVwW2ldKSAqIGZsb29yQ2VpbGluZ0FyZWEgK1xuICAgICAgKGNvZWZmaWNpZW50cy5mcm9udFtpXSArIGNvZWZmaWNpZW50cy5iYWNrW2ldKSAqIGZyb250QmFja0FyZWE7XG4gICAgbGV0IG1lYW5BYnNvcmJ0aW9uQXJlYSA9IGFic29yYnRpb25BcmVhIC8gdG90YWxBcmVhO1xuXG4gICAgLy8gQ29tcHV0ZSByZXZlcmJlcmF0aW9uIHVzaW5nIEV5cmluZyBlcXVhdGlvbiBbMV0uXG4gICAgLy8gWzFdIEJlcmFuZWssIExlbyBMLiBcIkFuYWx5c2lzIG9mIFNhYmluZSBhbmQgRXlyaW5nIGVxdWF0aW9ucyBhbmQgdGhlaXJcbiAgICAvLyAgICAgYXBwbGljYXRpb24gdG8gY29uY2VydCBoYWxsIGF1ZGllbmNlIGFuZCBjaGFpciBhYnNvcnB0aW9uLlwiIFRoZVxuICAgIC8vICAgICBKb3VybmFsIG9mIHRoZSBBY291c3RpY2FsIFNvY2lldHkgb2YgQW1lcmljYSwgVm9sLiAxMjAsIE5vLiAzLlxuICAgIC8vICAgICAoMjAwNiksIHBwLiAxMzk5LTEzOTkuXG4gICAgZHVyYXRpb25zW2ldID0gVXRpbHMuUk9PTV9FWVJJTkdfQ09SUkVDVElPTl9DT0VGRklDSUVOVCAqIGsgKiB2b2x1bWUgL1xuICAgICAgKC10b3RhbEFyZWEgKiBNYXRoLmxvZygxIC0gbWVhbkFic29yYnRpb25BcmVhKSArIDQgKlxuICAgICAgVXRpbHMuUk9PTV9BSVJfQUJTT1JQVElPTl9DT0VGRklDSUVOVFNbaV0gKiB2b2x1bWUpO1xuICB9XG4gIHJldHVybiBkdXJhdGlvbnM7XG59XG5cblxuLyoqXG4gKiBDb21wdXRlIHJlZmxlY3Rpb24gY29lZmZpY2llbnRzIGZyb20gYWJzb3JwdGlvbiBjb2VmZmljaWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gYWJzb3JwdGlvbkNvZWZmaWNpZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfY29tcHV0ZVJlZmxlY3Rpb25Db2VmZmljaWVudHMoYWJzb3JwdGlvbkNvZWZmaWNpZW50cykge1xuICBsZXQgcmVmbGVjdGlvbkNvZWZmaWNpZW50cyA9IFtdO1xuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAgICAgICAgLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgLy8gQ29tcHV0ZSBhdmVyYWdlIGFic29ycHRpb24gY29lZmZpY2llbnQgKHBlciB3YWxsKS5cbiAgICAgIHJlZmxlY3Rpb25Db2VmZmljaWVudHNbcHJvcGVydHldID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgVXRpbHMuTlVNQkVSX1JFRkxFQ1RJT05fQVZFUkFHSU5HX0JBTkRTOyBqKyspIHtcbiAgICAgICAgbGV0IGJhbmRJbmRleCA9IGogKyBVdGlscy5ST09NX1NUQVJUSU5HX0FWRVJBR0lOR19CQU5EO1xuICAgICAgICByZWZsZWN0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XSArPVxuICAgICAgICAgIGFic29ycHRpb25Db2VmZmljaWVudHNbcHJvcGVydHldW2JhbmRJbmRleF07XG4gICAgICB9XG4gICAgICByZWZsZWN0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XSAvPVxuICAgICAgICBVdGlscy5OVU1CRVJfUkVGTEVDVElPTl9BVkVSQUdJTkdfQkFORFM7XG5cbiAgICAgIC8vIENvbnZlcnQgYWJzb3JwdGlvbiBjb2VmZmljaWVudCB0byByZWZsZWN0aW9uIGNvZWZmaWNpZW50LlxuICAgICAgcmVmbGVjdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV0gPVxuICAgICAgICBNYXRoLnNxcnQoMSAtIHJlZmxlY3Rpb25Db2VmZmljaWVudHNbcHJvcGVydHldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmxlY3Rpb25Db2VmZmljaWVudHM7XG59XG5cblxuLyoqXG4gKiBAY2xhc3MgUm9vbVxuICogQGRlc2NyaXB0aW9uIE1vZGVsIHRoYXQgbWFuYWdlcyBlYXJseSBhbmQgbGF0ZSByZWZsZWN0aW9ucyB1c2luZyBhY291c3RpY1xuICogcHJvcGVydGllcyBhbmQgbGlzdGVuZXIgcG9zaXRpb24gcmVsYXRpdmUgdG8gYSByZWN0YW5ndWxhciByb29tLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvblxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kaW1lbnNpb25zIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgREVGQVVMVF9ST09NX0RJTUVOU0lPTlN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMubWF0ZXJpYWxzIE5hbWVkIGFjb3VzdGljIG1hdGVyaWFscyBwZXIgd2FsbC5cbiAqIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyBERUZBVUxUX1JPT01fTUFURVJJQUxTfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkT2ZTb3VuZFxuICogKGluIG1ldGVycy9zZWNvbmQpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EIERFRkFVTFRfU1BFRURfT0ZfU09VTkR9LlxuICovXG5mdW5jdGlvbiBSb29tKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIEVhcmx5UmVmbGVjdGlvbnMge0BsaW5rIEVhcmx5UmVmbGVjdGlvbnMgRWFybHlSZWZsZWN0aW9uc30gc3VibW9kdWxlLlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGVhcmx5XG4gICAqIEBtZW1iZXJvZiBSb29tXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIExhdGVSZWZsZWN0aW9ucyB7QGxpbmsgTGF0ZVJlZmxlY3Rpb25zIExhdGVSZWZsZWN0aW9uc30gc3VibW9kdWxlLlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGxhdGVcbiAgICogQG1lbWJlcm9mIFJvb21cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgUm9vbVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZGltZW5zaW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmRpbWVuc2lvbnMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuZGltZW5zaW9ucywgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMpO1xuICB9XG4gIGlmIChvcHRpb25zLm1hdGVyaWFscyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1hdGVyaWFscyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5tYXRlcmlhbHMsIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpO1xuICB9XG4gIGlmIChvcHRpb25zLnNwZWVkT2ZTb3VuZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNwZWVkT2ZTb3VuZCA9IFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQ7XG4gIH1cblxuICAvLyBTYW5pdGl6ZSByb29tLXByb3BlcnRpZXMtcmVsYXRlZCBhcmd1bWVudHMuXG4gIG9wdGlvbnMuZGltZW5zaW9ucyA9IF9zYW5pdGl6ZURpbWVuc2lvbnMob3B0aW9ucy5kaW1lbnNpb25zKTtcbiAgbGV0IGFic29ycHRpb25Db2VmZmljaWVudHMgPSBfZ2V0Q29lZmZpY2llbnRzRnJvbU1hdGVyaWFscyhvcHRpb25zLm1hdGVyaWFscyk7XG4gIGxldCByZWZsZWN0aW9uQ29lZmZpY2llbnRzID1cbiAgICBfY29tcHV0ZVJlZmxlY3Rpb25Db2VmZmljaWVudHMoYWJzb3JwdGlvbkNvZWZmaWNpZW50cyk7XG4gIGxldCBkdXJhdGlvbnMgPSBfZ2V0RHVyYXRpb25zRnJvbVByb3BlcnRpZXMob3B0aW9ucy5kaW1lbnNpb25zLFxuICAgIGFic29ycHRpb25Db2VmZmljaWVudHMsIG9wdGlvbnMuc3BlZWRPZlNvdW5kKTtcblxuICAvLyBDb25zdHJ1Y3Qgc3VibW9kdWxlcyBmb3IgZWFybHkgYW5kIGxhdGUgcmVmbGVjdGlvbnMuXG4gIHRoaXMuZWFybHkgPSBuZXcgRWFybHlSZWZsZWN0aW9ucyhjb250ZXh0LCB7XG4gICAgZGltZW5zaW9uczogb3B0aW9ucy5kaW1lbnNpb25zLFxuICAgIGNvZWZmaWNpZW50czogcmVmbGVjdGlvbkNvZWZmaWNpZW50cyxcbiAgICBzcGVlZE9mU291bmQ6IG9wdGlvbnMuc3BlZWRPZlNvdW5kLFxuICAgIGxpc3RlbmVyUG9zaXRpb246IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbixcbiAgfSk7XG4gIHRoaXMubGF0ZSA9IG5ldyBMYXRlUmVmbGVjdGlvbnMoY29udGV4dCwge1xuICAgIGR1cmF0aW9uczogZHVyYXRpb25zLFxuICB9KTtcblxuICB0aGlzLnNwZWVkT2ZTb3VuZCA9IG9wdGlvbnMuc3BlZWRPZlNvdW5kO1xuXG4gIC8vIENvbnN0cnVjdCBhdXhpbGxhcnkgYXVkaW8gbm9kZXMuXG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuZWFybHkub3V0cHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICB0aGlzLl9tZXJnZXIgPSBjb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoNCk7XG5cbiAgdGhpcy5sYXRlLm91dHB1dC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG4gIHRoaXMuX21lcmdlci5jb25uZWN0KHRoaXMub3V0cHV0KTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgcm9vbSdzIGRpbWVuc2lvbnMgYW5kIHdhbGwgbWF0ZXJpYWxzLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMgUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyBERUZBVUxUX1JPT01fRElNRU5TSU9OU30uXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxzIE5hbWVkIGFjb3VzdGljIG1hdGVyaWFscyBwZXIgd2FsbC4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyBERUZBVUxUX1JPT01fTUFURVJJQUxTfS5cbiAqL1xuUm9vbS5wcm90b3R5cGUuc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uKGRpbWVuc2lvbnMsIG1hdGVyaWFscykge1xuICAvLyBDb21wdXRlIGxhdGUgcmVzcG9uc2UuXG4gIGxldCBhYnNvcnB0aW9uQ29lZmZpY2llbnRzID0gX2dldENvZWZmaWNpZW50c0Zyb21NYXRlcmlhbHMobWF0ZXJpYWxzKTtcbiAgbGV0IGR1cmF0aW9ucyA9IF9nZXREdXJhdGlvbnNGcm9tUHJvcGVydGllcyhkaW1lbnNpb25zLFxuICAgIGFic29ycHRpb25Db2VmZmljaWVudHMsIHRoaXMuc3BlZWRPZlNvdW5kKTtcbiAgdGhpcy5sYXRlLnNldER1cmF0aW9ucyhkdXJhdGlvbnMpO1xuXG4gIC8vIENvbXB1dGUgZWFybHkgcmVzcG9uc2UuXG4gIHRoaXMuZWFybHkuc3BlZWRPZlNvdW5kID0gdGhpcy5zcGVlZE9mU291bmQ7XG4gIGxldCByZWZsZWN0aW9uQ29lZmZpY2llbnRzID1cbiAgICBfY29tcHV0ZVJlZmxlY3Rpb25Db2VmZmljaWVudHMoYWJzb3JwdGlvbkNvZWZmaWNpZW50cyk7XG4gIHRoaXMuZWFybHkuc2V0Um9vbVByb3BlcnRpZXMoZGltZW5zaW9ucywgcmVmbGVjdGlvbkNvZWZmaWNpZW50cyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cblJvb20ucHJvdG90eXBlLnNldExpc3RlbmVyUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHRoaXMuZWFybHkuc3BlZWRPZlNvdW5kID0gdGhpcy5zcGVlZE9mU291bmQ7XG4gIHRoaXMuZWFybHkuc2V0TGlzdGVuZXJQb3NpdGlvbih4LCB5LCB6KTtcblxuICAvLyBEaXNhYmxlIHJvb20gZWZmZWN0cyBpZiB0aGUgbGlzdGVuZXIgaXMgb3V0c2lkZSB0aGUgcm9vbSBib3VuZGFyaWVzLlxuICBsZXQgZGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlT3V0c2lkZVJvb20oeCwgeSwgeik7XG4gIGxldCBnYWluID0gMTtcbiAgaWYgKGRpc3RhbmNlID4gVXRpbHMuRVBTSUxPTl9GTE9BVCkge1xuICAgIGdhaW4gPSAxIC0gZGlzdGFuY2UgLyBVdGlscy5MSVNURU5FUl9NQVhfT1VUU0lERV9ST09NX0RJU1RBTkNFO1xuXG4gICAgLy8gQ2xhbXAgZ2FpbiBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgZ2FpbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGdhaW4pKTtcbiAgfVxuICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gZ2Fpbjtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlIGRpc3RhbmNlIG91dHNpZGUgcm9vbSBvZiBwcm92aWRlZCBwb3NpdGlvbiAoaW4gbWV0ZXJzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIERpc3RhbmNlIG91dHNpZGUgcm9vbSAoaW4gbWV0ZXJzKS4gUmV0dXJucyAwIGlmIGluc2lkZSByb29tLlxuICovXG5Sb29tLnByb3RvdHlwZS5nZXREaXN0YW5jZU91dHNpZGVSb29tID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICBsZXQgZHggPSBNYXRoLm1heCgwLCAtdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMud2lkdGggLSB4LFxuICAgIHggLSB0aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy53aWR0aCk7XG4gICAgbGV0IGR5ID0gTWF0aC5tYXgoMCwgLXRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLmhlaWdodCAtIHksXG4gICAgeSAtIHRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLmhlaWdodCk7XG4gICAgbGV0IGR6ID0gTWF0aC5tYXgoMCwgLXRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLmRlcHRoIC0geixcbiAgICB6IC0gdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMuZGVwdGgpO1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUm9vbTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgTGF0ZSByZXZlcmJlcmF0aW9uIGZpbHRlciBmb3IgQW1iaXNvbmljIGNvbnRlbnQuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIExhdGVSZWZsZWN0aW9uc1xuICogQGRlc2NyaXB0aW9uIExhdGUtcmVmbGVjdGlvbnMgcmV2ZXJiZXJhdGlvbiBmaWx0ZXIgZm9yIEFtYmlzb25pYyBjb250ZW50LlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5kdXJhdGlvbnNcbiAqIE11bHRpYmFuZCBSVDYwIGR1cmF0aW9ucyAoaW4gc2Vjb25kcykgZm9yIGVhY2ggZnJlcXVlbmN5IGJhbmQsIGxpc3RlZCBhc1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFNcbiAqIEZSRVFVREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTRU5DWV9CQU5EU30uIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0RVUkFUSU9OUyBERUZBVUxUX1JFVkVSQl9EVVJBVElPTlN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucHJlZGVsYXkgUHJlLWRlbGF5IChpbiBtaWxsaXNlY29uZHMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9QUkVERUxBWSBERUZBVUxUX1JFVkVSQl9QUkVERUxBWX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5nYWluIE91dHB1dCBnYWluIChsaW5lYXIpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9HQUlOIERFRkFVTFRfUkVWRVJCX0dBSU59LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYmFuZHdpZHRoIEJhbmR3aWR0aCAoaW4gb2N0YXZlcykgZm9yIGVhY2ggZnJlcXVlbmN5XG4gKiBiYW5kLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9CQU5EV0lEVEggREVGQVVMVF9SRVZFUkJfQkFORFdJRFRIfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnRhaWxvbnNldCBMZW5ndGggKGluIG1pbGxpc2Vjb25kcykgb2YgaW1wdWxzZVxuICogcmVzcG9uc2UgdG8gYXBwbHkgYSBoYWxmLUhhbm4gd2luZG93LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9UQUlMX09OU0VUIERFRkFVTFRfUkVWRVJCX1RBSUxfT05TRVR9LlxuICovXG5mdW5jdGlvbiBMYXRlUmVmbGVjdGlvbnMoY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBMYXRlUmVmbGVjdGlvbnNcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIExhdGVSZWZsZWN0aW9uc1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuZHVyYXRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZHVyYXRpb25zID0gVXRpbHMuREVGQVVMVF9SRVZFUkJfRFVSQVRJT05TLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlZGVsYXkgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5wcmVkZWxheSA9IFV0aWxzLkRFRkFVTFRfUkVWRVJCX1BSRURFTEFZO1xuICB9XG4gIGlmIChvcHRpb25zLmdhaW4gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5nYWluID0gVXRpbHMuREVGQVVMVF9SRVZFUkJfR0FJTjtcbiAgfVxuICBpZiAob3B0aW9ucy5iYW5kd2lkdGggPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5iYW5kd2lkdGggPSBVdGlscy5ERUZBVUxUX1JFVkVSQl9CQU5EV0lEVEg7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGFpbG9uc2V0ID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMudGFpbG9uc2V0ID0gVXRpbHMuREVGQVVMVF9SRVZFUkJfVEFJTF9PTlNFVDtcbiAgfVxuXG4gIC8vIEFzc2lnbiBwcmUtY29tcHV0ZWQgdmFyaWFibGVzLlxuICBsZXQgZGVsYXlTZWNzID0gb3B0aW9ucy5wcmVkZWxheSAvIDEwMDA7XG4gIHRoaXMuX2JhbmR3aWR0aENvZWZmID0gb3B0aW9ucy5iYW5kd2lkdGggKiBVdGlscy5MT0cyX0RJVjI7XG4gIHRoaXMuX3RhaWxvbnNldFNhbXBsZXMgPSBvcHRpb25zLnRhaWxvbnNldCAvIDEwMDA7XG5cbiAgLy8gQ3JlYXRlIG5vZGVzLlxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5pbnB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9wcmVkZWxheSA9IGNvbnRleHQuY3JlYXRlRGVsYXkoZGVsYXlTZWNzKTtcbiAgdGhpcy5fY29udm9sdmVyID0gY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBTZXQgcmV2ZXJiIGF0dGVudWF0aW9uLlxuICB0aGlzLm91dHB1dC5nYWluLnZhbHVlID0gb3B0aW9ucy5nYWluO1xuXG4gIC8vIERpc2FibGUgbm9ybWFsaXphdGlvbi5cbiAgdGhpcy5fY29udm9sdmVyLm5vcm1hbGl6ZSA9IGZhbHNlO1xuXG4gIC8vIENvbm5lY3Qgbm9kZXMuXG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9wcmVkZWxheSk7XG4gIHRoaXMuX3ByZWRlbGF5LmNvbm5lY3QodGhpcy5fY29udm9sdmVyKTtcbiAgdGhpcy5fY29udm9sdmVyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gIC8vIENvbXB1dGUgSVIgdXNpbmcgUlQ2MCB2YWx1ZXMuXG4gIHRoaXMuc2V0RHVyYXRpb25zKG9wdGlvbnMuZHVyYXRpb25zKTtcbn1cblxuXG4vKipcbiAqIFJlLWNvbXB1dGUgYSBuZXcgaW1wdWxzZSByZXNwb25zZSBieSBwcm92aWRpbmcgTXVsdGliYW5kIFJUNjAgZHVyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheX0gZHVyYXRpb25zXG4gKiBNdWx0aWJhbmQgUlQ2MCBkdXJhdGlvbnMgKGluIHNlY29uZHMpIGZvciBlYWNoIGZyZXF1ZW5jeSBiYW5kLCBsaXN0ZWQgYXNcbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTXG4gKiBERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFN9LlxuICovXG5MYXRlUmVmbGVjdGlvbnMucHJvdG90eXBlLnNldER1cmF0aW9ucyA9IGZ1bmN0aW9uKGR1cmF0aW9ucykge1xuICBpZiAoZHVyYXRpb25zLmxlbmd0aCAhPT0gVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMpIHtcbiAgICBVdGlscy5sb2coJ1dhcm5pbmc6IGludmFsaWQgbnVtYmVyIG9mIFJUNjAgdmFsdWVzIHByb3ZpZGVkIHRvIHJldmVyYi4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDb21wdXRlIGltcHVsc2UgcmVzcG9uc2UuXG4gIGxldCBkdXJhdGlvbnNTYW1wbGVzID1cbiAgICBuZXcgRmxvYXQzMkFycmF5KFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTKTtcbiAgICBsZXQgc2FtcGxlUmF0ZSA9IHRoaXMuX2NvbnRleHQuc2FtcGxlUmF0ZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIENsYW1wIHdpdGhpbiBzdWl0YWJsZSByYW5nZS5cbiAgICBkdXJhdGlvbnNbaV0gPVxuICAgICAgTWF0aC5tYXgoMCwgTWF0aC5taW4oVXRpbHMuREVGQVVMVF9SRVZFUkJfTUFYX0RVUkFUSU9OLCBkdXJhdGlvbnNbaV0pKTtcblxuICAgIC8vIENvbnZlcnQgc2Vjb25kcyB0byBzYW1wbGVzLlxuICAgIGR1cmF0aW9uc1NhbXBsZXNbaV0gPSBNYXRoLnJvdW5kKGR1cmF0aW9uc1tpXSAqIHNhbXBsZVJhdGUgKlxuICAgICAgVXRpbHMuREVGQVVMVF9SRVZFUkJfRFVSQVRJT05fTVVMVElQTElFUik7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIG1heCBSVDYwIGxlbmd0aCBpbiBzYW1wbGVzLlxuICBsZXQgZHVyYXRpb25zU2FtcGxlc01heCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHVyYXRpb25zU2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkdXJhdGlvbnNTYW1wbGVzW2ldID4gZHVyYXRpb25zU2FtcGxlc01heCkge1xuICAgICAgZHVyYXRpb25zU2FtcGxlc01heCA9IGR1cmF0aW9uc1NhbXBsZXNbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gU2tpcCB0aGlzIHN0ZXAgaWYgdGhlcmUgaXMgbm8gcmV2ZXJiZXJhdGlvbiB0byBjb21wdXRlLlxuICBpZiAoZHVyYXRpb25zU2FtcGxlc01heCA8IDEpIHtcbiAgICBkdXJhdGlvbnNTYW1wbGVzTWF4ID0gMTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBpbXB1bHNlIHJlc3BvbnNlIGJ1ZmZlci5cbiAgbGV0IGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIGR1cmF0aW9uc1NhbXBsZXNNYXgsIHNhbXBsZVJhdGUpO1xuICBsZXQgYnVmZmVyRGF0YSA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblxuICAvLyBDcmVhdGUgbm9pc2Ugc2lnbmFsIChjb21wdXRlZCBvbmNlLCByZWZlcmVuY2VkIGluIGVhY2ggYmFuZCdzIHJvdXRpbmUpLlxuICBsZXQgbm9pc2VTaWduYWwgPSBuZXcgRmxvYXQzMkFycmF5KGR1cmF0aW9uc1NhbXBsZXNNYXgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9uc1NhbXBsZXNNYXg7IGkrKykge1xuICAgIG5vaXNlU2lnbmFsW2ldID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVjYXkgcmF0ZSBwZXItYmFuZCBhbmQgZmlsdGVyIHRoZSBkZWNheWluZyBub2lzZSBzaWduYWwuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFM7IGkrKykge1xuICAgIC8vIENvbXB1dGUgZGVjYXkgcmF0ZS5cbiAgICBsZXQgZGVjYXlSYXRlID0gLVV0aWxzLkxPRzEwMDAgLyBkdXJhdGlvbnNTYW1wbGVzW2ldO1xuXG4gICAgLy8gQ29uc3RydWN0IGEgc3RhbmRhcmQgb25lLXplcm8sIHR3by1wb2xlIGJhbmRwYXNzIGZpbHRlcjpcbiAgICAvLyBIKHopID0gKGIwICogel4wICsgYjEgKiB6Xi0xICsgYjIgKiB6Xi0yKSAvICgxICsgYTEgKiB6Xi0xICsgYTIgKiB6Xi0yKVxuICAgIGxldCBvbWVnYSA9IFV0aWxzLlRXT19QSSAqXG4gICAgICBVdGlscy5ERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFNbaV0gLyBzYW1wbGVSYXRlO1xuICAgIGxldCBzaW5PbWVnYSA9IE1hdGguc2luKG9tZWdhKTtcbiAgICBsZXQgYWxwaGEgPSBzaW5PbWVnYSAqIE1hdGguc2luaCh0aGlzLl9iYW5kd2lkdGhDb2VmZiAqIG9tZWdhIC8gc2luT21lZ2EpO1xuICAgIGxldCBhMENvZWZmUmVjaXByb2NhbCA9IDEgLyAoMSArIGFscGhhKTtcbiAgICBsZXQgYjBDb2VmZiA9IGFscGhhICogYTBDb2VmZlJlY2lwcm9jYWw7XG4gICAgbGV0IGExQ29lZmYgPSAtMiAqIE1hdGguY29zKG9tZWdhKSAqIGEwQ29lZmZSZWNpcHJvY2FsO1xuICAgIGxldCBhMkNvZWZmID0gKDEgLSBhbHBoYSkgKiBhMENvZWZmUmVjaXByb2NhbDtcblxuICAgIC8vIFdlIG9wdGltaXplIHNpbmNlIGIyID0gLWIwLCBiMSA9IDAuXG4gICAgLy8gVXBkYXRlIGVxdWF0aW9uIGZvciB0d28tcG9sZSBiYW5kcGFzcyBmaWx0ZXI6XG4gICAgLy8gICB1W25dID0geFtuXSAtIGExICogeFtuLTFdIC0gYTIgKiB4W24tMl1cbiAgICAvLyAgIHlbbl0gPSBiMCAqICh1W25dIC0gdVtuLTJdKVxuICAgIGxldCB1bTEgPSAwO1xuICAgIGxldCB1bTIgPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZHVyYXRpb25zU2FtcGxlc1tpXTsgaisrKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5LWRlY2F5aW5nIHdoaXRlIG5vaXNlLlxuICAgICAgbGV0IHggPSBub2lzZVNpZ25hbFtqXSAqIE1hdGguZXhwKGRlY2F5UmF0ZSAqIGopO1xuXG4gICAgICAvLyBGaWx0ZXIgc2lnbmFsIHdpdGggYmFuZHBhc3MgZmlsdGVyIGFuZCBhZGQgdG8gb3V0cHV0LlxuICAgICAgbGV0IHUgPSB4IC0gYTFDb2VmZiAqIHVtMSAtIGEyQ29lZmYgKiB1bTI7XG4gICAgICBidWZmZXJEYXRhW2pdICs9IGIwQ29lZmYgKiAodSAtIHVtMik7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2VmZmljaWVudHMuXG4gICAgICB1bTIgPSB1bTE7XG4gICAgICB1bTEgPSB1O1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhbmQgYXBwbHkgaGFsZiBvZiBhIEhhbm4gd2luZG93IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gIC8vIGltcHVsc2UgcmVzcG9uc2UuXG4gIGxldCBoYWxmSGFubkxlbmd0aCA9XG4gICAgTWF0aC5yb3VuZCh0aGlzLl90YWlsb25zZXRTYW1wbGVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXJEYXRhLmxlbmd0aCwgaGFsZkhhbm5MZW5ndGgpOyBpKyspIHtcbiAgICBsZXQgaGFsZkhhbm4gPVxuICAgICAgMC41ICogKDEgLSBNYXRoLmNvcyhVdGlscy5UV09fUEkgKiBpIC8gKDIgKiBoYWxmSGFubkxlbmd0aCAtIDEpKSk7XG4gICAgICBidWZmZXJEYXRhW2ldICo9IGhhbGZIYW5uO1xuICB9XG4gIHRoaXMuX2NvbnZvbHZlci5idWZmZXIgPSBidWZmZXI7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGF0ZVJlZmxlY3Rpb25zO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBSYXktdHJhY2luZy1iYXNlZCBlYXJseSByZWZsZWN0aW9ucyBtb2RlbC5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgRWFybHlSZWZsZWN0aW9uc1xuICogQGRlc2NyaXB0aW9uIFJheS10cmFjaW5nLWJhc2VkIGVhcmx5IHJlZmxlY3Rpb25zIG1vZGVsLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGltZW5zaW9uc1xuICogUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyBERUZBVUxUX1JPT01fRElNRU5TSU9OU30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5jb2VmZmljaWVudHNcbiAqIEZyZXF1ZW5jeS1pbmRlcGVuZGVudCByZWZsZWN0aW9uIGNvZWZmcyBwZXIgd2FsbC4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICogREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zcGVlZE9mU291bmRcbiAqIChpbiBtZXRlcnMgLyBzZWNvbmQpLiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkRcbiAqIERFRkFVTFRfU1BFRURfT0ZfU09VTkR9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvblxuICogKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKi9cbmZ1bmN0aW9uIEVhcmx5UmVmbGVjdGlvbnMoY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogVGhlIHJvb20ncyBzcGVlZCBvZiBzb3VuZCAoaW4gbWV0ZXJzL3NlY29uZCkuXG4gICAqIEBtZW1iZXIge051bWJlcn0gc3BlZWRPZlNvdW5kXG4gICAqIEBtZW1iZXJvZiBFYXJseVJlZmxlY3Rpb25zXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgRWFybHlSZWZsZWN0aW9uc1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBGaXJzdC1vcmRlciBhbWJpc29uaWMgKDQtY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBFYXJseVJlZmxlY3Rpb25zXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5zcGVlZE9mU291bmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zcGVlZE9mU291bmQgPSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EO1xuICB9XG4gIGlmIChvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID0gVXRpbHMuREVGQVVMVF9QT1NJVElPTi5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmNvZWZmaWNpZW50cyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmNvZWZmaWNpZW50cyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5jb2VmZmljaWVudHMsIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpO1xuICB9XG5cbiAgLy8gQXNzaWduIHJvb20ncyBzcGVlZCBvZiBzb3VuZC5cbiAgdGhpcy5zcGVlZE9mU291bmQgPSBvcHRpb25zLnNwZWVkT2ZTb3VuZDtcblxuICAvLyBDcmVhdGUgbm9kZXMuXG4gIHRoaXMuaW5wdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbG93cGFzcyA9IGNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gIHRoaXMuX2RlbGF5cyA9IHt9O1xuICB0aGlzLl9nYWlucyA9IHt9OyAvLyBnYWluUGVyV2FsbCA9IChSZWZsZWN0aW9uQ29lZmYgLyBBdHRlbnVhdGlvbilcbiAgdGhpcy5faW52ZXJ0ZXJzID0ge307IC8vIDMgb2YgdGhlc2UgYXJlIG5lZWRlZCBmb3IgcmlnaHQvYmFjay9kb3duIHdhbGxzLlxuICB0aGlzLl9tZXJnZXIgPSBjb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoNCk7IC8vIEZpcnN0LW9yZGVyIGVuY29kaW5nIG9ubHkuXG5cbiAgLy8gQ29ubmVjdCBhdWRpbyBncmFwaCBmb3IgZWFjaCB3YWxsIHJlZmxlY3Rpb24uXG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICAgICAgICAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICB0aGlzLl9kZWxheXNbcHJvcGVydHldID1cbiAgICAgICAgY29udGV4dC5jcmVhdGVEZWxheShVdGlscy5NQVhfRFVSQVRJT04pO1xuICAgICAgdGhpcy5fZ2FpbnNbcHJvcGVydHldID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX2ludmVydGVycy5yaWdodCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9pbnZlcnRlcnMuZG93biA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9pbnZlcnRlcnMuYmFjayA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIEluaXRpYWxpemUgbG93cGFzcyBmaWx0ZXIuXG4gIHRoaXMuX2xvd3Bhc3MudHlwZSA9ICdsb3dwYXNzJztcbiAgdGhpcy5fbG93cGFzcy5mcmVxdWVuY3kudmFsdWUgPSBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ1VUT0ZGX0ZSRVFVRU5DWTtcbiAgdGhpcy5fbG93cGFzcy5RLnZhbHVlID0gMDtcblxuICAvLyBJbml0aWFsaXplIGVuY29kZXIgZGlyZWN0aW9ucywgc2V0IGRlbGF5IHRpbWVzIGFuZCBnYWlucyB0byAwLlxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAgICAgICAgLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgdGhpcy5fZGVsYXlzW3Byb3BlcnR5XS5kZWxheVRpbWUudmFsdWUgPSAwO1xuICAgICAgdGhpcy5fZ2FpbnNbcHJvcGVydHldLmdhaW4udmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgaW52ZXJ0ZXJzIGZvciBvcHBvc2l0ZSB3YWxscyAoJ3JpZ2h0JywgJ2Rvd24nLCAnYmFjaycgb25seSkuXG4gIHRoaXMuX2ludmVydGVycy5yaWdodC5nYWluLnZhbHVlID0gLTE7XG4gIHRoaXMuX2ludmVydGVycy5kb3duLmdhaW4udmFsdWUgPSAtMTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmJhY2suZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gIC8vIENvbm5lY3Qgbm9kZXMuXG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9sb3dwYXNzKTtcbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gICAgICAgIC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIHRoaXMuX2xvd3Bhc3MuY29ubmVjdCh0aGlzLl9kZWxheXNbcHJvcGVydHldKTtcbiAgICAgIHRoaXMuX2RlbGF5c1twcm9wZXJ0eV0uY29ubmVjdCh0aGlzLl9nYWluc1twcm9wZXJ0eV0pO1xuICAgICAgdGhpcy5fZ2FpbnNbcHJvcGVydHldLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb25uZWN0IGdhaW5zIHRvIGFtYmlzb25pYyBjaGFubmVsIG91dHB1dC5cbiAgLy8gTGVmdDogWzEgMSAwIDBdXG4gIC8vIFJpZ2h0OiBbMSAtMSAwIDBdXG4gIC8vIFVwOiBbMSAwIDEgMF1cbiAgLy8gRG93bjogWzEgMCAtMSAwXVxuICAvLyBGcm9udDogWzEgMCAwIDFdXG4gIC8vIEJhY2s6IFsxIDAgMCAtMV1cbiAgdGhpcy5fZ2FpbnMubGVmdC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMSk7XG5cbiAgdGhpcy5fZ2FpbnMucmlnaHQuY29ubmVjdCh0aGlzLl9pbnZlcnRlcnMucmlnaHQpO1xuICB0aGlzLl9pbnZlcnRlcnMucmlnaHQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuXG4gIHRoaXMuX2dhaW5zLnVwLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAyKTtcblxuICB0aGlzLl9nYWlucy5kb3duLmNvbm5lY3QodGhpcy5faW52ZXJ0ZXJzLmRvd24pO1xuICB0aGlzLl9pbnZlcnRlcnMuZG93bi5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMik7XG5cbiAgdGhpcy5fZ2FpbnMuZnJvbnQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDMpO1xuXG4gIHRoaXMuX2dhaW5zLmJhY2suY29ubmVjdCh0aGlzLl9pbnZlcnRlcnMuYmFjayk7XG4gIHRoaXMuX2ludmVydGVycy5iYWNrLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAzKTtcbiAgdGhpcy5fbWVyZ2VyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gIC8vIEluaXRpYWxpemUuXG4gIHRoaXMuX2xpc3RlbmVyUG9zaXRpb24gPSBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb247XG4gIHRoaXMuc2V0Um9vbVByb3BlcnRpZXMob3B0aW9ucy5kaW1lbnNpb25zLCBvcHRpb25zLmNvZWZmaWNpZW50cyk7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24gKGluIG1ldGVycyksXG4gKiB3aGVyZSBbMCwwLDBdIGlzIHRoZSBjZW50ZXIgb2YgdGhlIHJvb20uXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cbkVhcmx5UmVmbGVjdGlvbnMucHJvdG90eXBlLnNldExpc3RlbmVyUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIC8vIEFzc2lnbiBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgdGhpcy5fbGlzdGVuZXJQb3NpdGlvbiA9IFt4LCB5LCB6XTtcblxuICAvLyBEZXRlcm1pbmUgZGlzdGFuY2VzIHRvIGVhY2ggd2FsbC5cbiAgbGV0IGRpc3RhbmNlcyA9IHtcbiAgICBsZWZ0OiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy53aWR0aCArIHgpICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgICByaWdodDogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMud2lkdGggLSB4KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gICAgZnJvbnQ6IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLmRlcHRoICsgeikgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICAgIGJhY2s6IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLmRlcHRoIC0geikgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICAgIGRvd246IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLmhlaWdodCArIHkpICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgICB1cDogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMuaGVpZ2h0IC0geSkgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICB9O1xuXG4gIC8vIEFzc2lnbiBkZWxheSAmIGF0dGVudWF0aW9uIHZhbHVlcyB1c2luZyBkaXN0YW5jZXMuXG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICAgICAgICAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAvLyBDb21wdXRlIGFuZCBhc3NpZ24gZGVsYXkgKGluIHNlY29uZHMpLlxuICAgICAgbGV0IGRlbGF5SW5TZWNzID0gZGlzdGFuY2VzW3Byb3BlcnR5XSAvIHRoaXMuc3BlZWRPZlNvdW5kO1xuICAgICAgdGhpcy5fZGVsYXlzW3Byb3BlcnR5XS5kZWxheVRpbWUudmFsdWUgPSBkZWxheUluU2VjcztcblxuICAgICAgLy8gQ29tcHV0ZSBhbmQgYXNzaWduIGdhaW4sIHVzZXMgbG9nYXJpdGhtaWMgcm9sbG9mZjogXCJnID0gUiAvIChkICsgMSlcIlxuICAgICAgbGV0IGF0dGVudWF0aW9uID0gdGhpcy5fY29lZmZpY2llbnRzW3Byb3BlcnR5XSAvIGRpc3RhbmNlc1twcm9wZXJ0eV07XG4gICAgICB0aGlzLl9nYWluc1twcm9wZXJ0eV0uZ2Fpbi52YWx1ZSA9IGF0dGVudWF0aW9uO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm9vbSdzIHByb3BlcnRpZXMgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mXG4gKiByZWZsZWN0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zXG4gKiBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TIERFRkFVTFRfUk9PTV9ESU1FTlNJT05TfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2VmZmljaWVudHNcbiAqIEZyZXF1ZW5jeS1pbmRlcGVuZGVudCByZWZsZWN0aW9uIGNvZWZmcyBwZXIgd2FsbC4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICogREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU30uXG4gKi9cbkVhcmx5UmVmbGVjdGlvbnMucHJvdG90eXBlLnNldFJvb21Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnRzKSB7XG4gIGlmIChkaW1lbnNpb25zID09IHVuZGVmaW5lZCkge1xuICAgIGRpbWVuc2lvbnMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKGRpbWVuc2lvbnMsIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TKTtcbiAgfVxuICBpZiAoY29lZmZpY2llbnRzID09IHVuZGVmaW5lZCkge1xuICAgIGNvZWZmaWNpZW50cyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24oY29lZmZpY2llbnRzLCBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKTtcbiAgfVxuICB0aGlzLl9jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7XG5cbiAgLy8gU2FuaXRpemUgZGltZW5zaW9ucyBhbmQgc3RvcmUgaGFsZi1kaW1lbnNpb25zLlxuICB0aGlzLl9oYWxmRGltZW5zaW9ucyA9IHt9O1xuICB0aGlzLl9oYWxmRGltZW5zaW9ucy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKiAwLjU7XG4gIHRoaXMuX2hhbGZEaW1lbnNpb25zLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogMC41O1xuICB0aGlzLl9oYWxmRGltZW5zaW9ucy5kZXB0aCA9IGRpbWVuc2lvbnMuZGVwdGggKiAwLjU7XG5cbiAgLy8gVXBkYXRlIGxpc3RlbmVyIHBvc2l0aW9uIHdpdGggbmV3IHJvb20gcHJvcGVydGllcy5cbiAgdGhpcy5zZXRMaXN0ZW5lclBvc2l0aW9uKHRoaXMuX2xpc3RlbmVyUG9zaXRpb25bMF0sXG4gICAgdGhpcy5fbGlzdGVuZXJQb3NpdGlvblsxXSwgdGhpcy5fbGlzdGVuZXJQb3NpdGlvblsyXSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRWFybHlSZWZsZWN0aW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFByaW1hcnkgbmFtZXNwYWNlIGZvciBSZXNvbmFuY2VBdWRpbyBsaWJyYXJ5LlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuIFxuXG5cbi8vIE1haW4gbW9kdWxlLlxuZXhwb3J0cy5SZXNvbmFuY2VBdWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cbi8vIFRlc3RhYmxlIFN1Ym1vZHVsZXMuXG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkF0dGVudWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uRGlyZWN0aXZpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5FYXJseVJlZmxlY3Rpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uRW5jb2RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkxhdGVSZWZsZWN0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkxpc3RlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uUm9vbSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLlNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLlRhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLlV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uVmVyc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUmVzb25hbmNlQXVkaW8gbGlicmFyeSBuYW1lIHNwYWNlIGFuZCBjb21tb24gdXRpbGl0aWVzLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgTGlzdGVuZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29uc3QgU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmNvbnN0IFJvb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuY29uc3QgRW5jb2RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgUmVzb25hbmNlQXVkaW9cbiAqIEBkZXNjcmlwdGlvbiBNYWluIGNsYXNzIGZvciBtYW5hZ2luZyBzb3VyY2VzLCByb29tIGFuZCBsaXN0ZW5lciBtb2RlbHMuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbWJpc29uaWNPcmRlclxuICogRGVzaXJlZCBhbWJpc29uaWMgT3JkZXIuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSIERFRkFVTFRfQU1CSVNPTklDX09SREVSfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb25cbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS4gRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMubGlzdGVuZXJGb3J3YXJkXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIGZvcndhcmQgdmVjdG9yLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0ZPUldBUkQgREVGQVVMVF9GT1JXQVJEfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmxpc3RlbmVyVXBcbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgdXAgdmVjdG9yLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1VQIERFRkFVTFRfVVB9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGltZW5zaW9ucyBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TIERFRkFVTFRfUk9PTV9ESU1FTlNJT05TfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLm1hdGVyaWFscyBOYW1lZCBhY291c3RpYyBtYXRlcmlhbHMgcGVyIHdhbGwuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMgREVGQVVMVF9ST09NX01BVEVSSUFMU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zcGVlZE9mU291bmRcbiAqIChpbiBtZXRlcnMvc2Vjb25kKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORCBERUZBVUxUX1NQRUVEX09GX1NPVU5EfS5cbiAqL1xuZnVuY3Rpb24gUmVzb25hbmNlQXVkaW8oY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogQmluYXVyYWxseS1yZW5kZXJlZCBzdGVyZW8gKDItY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBSZXNvbmFuY2VBdWRpb1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfVxuICAgKiAoRm9yIHJlbmRlcmluZyBpbnB1dCBzb3VuZGZpZWxkcykuXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gYW1iaXNvbmljSW5wdXRcbiAgICogQG1lbWJlcm9mIFJlc29uYW5jZUF1ZGlvXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfVxuICAgKiAoRm9yIGFsbG93aW5nIGV4dGVybmFsIHJlbmRlcmluZyAvIHBvc3QtcHJvY2Vzc2luZykuXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gYW1iaXNvbmljT3V0cHV0XG4gICAqIEBtZW1iZXJvZiBSZXNvbmFuY2VBdWRpb1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciA9IFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSO1xuICB9XG4gIGlmIChvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID0gVXRpbHMuREVGQVVMVF9QT1NJVElPTi5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmxpc3RlbmVyRm9yd2FyZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmxpc3RlbmVyRm9yd2FyZCA9IFV0aWxzLkRFRkFVTFRfRk9SV0FSRC5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmxpc3RlbmVyVXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5saXN0ZW5lclVwID0gVXRpbHMuREVGQVVMVF9VUC5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmRpbWVuc2lvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5kaW1lbnNpb25zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmRpbWVuc2lvbnMsIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXRlcmlhbHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5tYXRlcmlhbHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMubWF0ZXJpYWxzLCBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zcGVlZE9mU291bmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zcGVlZE9mU291bmQgPSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG1lbWJlciBzdWJtb2R1bGVzLlxuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9IEVuY29kZXIudmFsaWRhdGVBbWJpc29uaWNPcmRlcihvcHRpb25zLmFtYmlzb25pY09yZGVyKTtcbiAgdGhpcy5fc291cmNlcyA9IFtdO1xuICB0aGlzLl9yb29tID0gbmV3IFJvb20oY29udGV4dCwge1xuICAgIGxpc3RlbmVyUG9zaXRpb246IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbixcbiAgICBkaW1lbnNpb25zOiBvcHRpb25zLmRpbWVuc2lvbnMsXG4gICAgbWF0ZXJpYWxzOiBvcHRpb25zLm1hdGVyaWFscyxcbiAgICBzcGVlZE9mU291bmQ6IG9wdGlvbnMuc3BlZWRPZlNvdW5kLFxuICB9KTtcbiAgdGhpcy5fbGlzdGVuZXIgPSBuZXcgTGlzdGVuZXIoY29udGV4dCwge1xuICAgIGFtYmlzb25pY09yZGVyOiBvcHRpb25zLmFtYmlzb25pY09yZGVyLFxuICAgIHBvc2l0aW9uOiBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24sXG4gICAgZm9yd2FyZDogb3B0aW9ucy5saXN0ZW5lckZvcndhcmQsXG4gICAgdXA6IG9wdGlvbnMubGlzdGVuZXJVcCxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIGF1eGlsbGFyeSBhdWRpbyBub2Rlcy5cbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuYW1iaXNvbmljT3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuYW1iaXNvbmljSW5wdXQgPSB0aGlzLl9saXN0ZW5lci5pbnB1dDtcblxuICAvLyBDb25uZWN0IGF1ZGlvIGdyYXBoLlxuICB0aGlzLl9yb29tLm91dHB1dC5jb25uZWN0KHRoaXMuX2xpc3RlbmVyLmlucHV0KTtcbiAgdGhpcy5fbGlzdGVuZXIub3V0cHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICB0aGlzLl9saXN0ZW5lci5hbWJpc29uaWNPdXRwdXQuY29ubmVjdCh0aGlzLmFtYmlzb25pY091dHB1dCk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc291cmNlIGZvciB0aGUgc2NlbmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMucG9zaXRpb25cbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmZvcndhcmRcbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIGZvcndhcmQgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0ZPUldBUkQgREVGQVVMVF9GT1JXQVJEfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnVwXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCB1cCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfVVAgREVGQVVMVF9VUH0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5taW5EaXN0YW5jZVxuICogTWluLiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0UgREVGQVVMVF9NSU5fRElTVEFOQ0V9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4RGlzdGFuY2VcbiAqIE1heC4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFIERFRkFVTFRfTUFYX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJvbGxvZmZcbiAqIFJvbGxvZmYgbW9kZWwgdG8gdXNlLCBjaG9zZW4gZnJvbSBvcHRpb25zIGluXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTIEFUVEVOVUFUSU9OX1JPTExPRkZTfS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGIERFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5nYWluIElucHV0IGdhaW4gKGxpbmVhcikuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU09VUkNFX0dBSU4gREVGQVVMVF9TT1VSQ0VfR0FJTn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbHBoYSBEaXJlY3Rpdml0eSBhbHBoYS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQSBERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNoYXJwbmVzcyBEaXJlY3Rpdml0eSBzaGFycG5lc3MuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTXG4gKiBERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zb3VyY2VXaWR0aFxuICogU291cmNlIHdpZHRoIChpbiBkZWdyZWVzKS4gV2hlcmUgMCBkZWdyZWVzIGlzIGEgcG9pbnQgc291cmNlIGFuZCAzNjAgZGVncmVlc1xuICogaXMgYW4gb21uaWRpcmVjdGlvbmFsIHNvdXJjZS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEggREVGQVVMVF9TT1VSQ0VfV0lEVEh9LlxuICogQHJldHVybiB7U291cmNlfVxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuY3JlYXRlU291cmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzb3VyY2UgYW5kIHB1c2ggaXQgdG8gdGhlIGludGVybmFsIHNvdXJjZXMgYXJyYXksIHJldHVybmluZ1xuICAvLyB0aGUgb2JqZWN0J3MgcmVmZXJlbmNlIHRvIHRoZSB1c2VyLlxuICBsZXQgc291cmNlID0gbmV3IFNvdXJjZSh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fc291cmNlc1t0aGlzLl9zb3VyY2VzLmxlbmd0aF0gPSBzb3VyY2U7XG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzY2VuZSdzIGRlc2lyZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIERlc2lyZWQgYW1iaXNvbmljIG9yZGVyLlxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0QW1iaXNvbmljT3JkZXIgPSBmdW5jdGlvbihhbWJpc29uaWNPcmRlcikge1xuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9IEVuY29kZXIudmFsaWRhdGVBbWJpc29uaWNPcmRlcihhbWJpc29uaWNPcmRlcik7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSByb29tJ3MgZGltZW5zaW9ucyBhbmQgd2FsbCBtYXRlcmlhbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9ucyBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxzIE5hbWVkIGFjb3VzdGljIG1hdGVyaWFscyBwZXIgd2FsbC5cbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldFJvb21Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oZGltZW5zaW9ucywgbWF0ZXJpYWxzKSB7XG4gIHRoaXMuX3Jvb20uc2V0UHJvcGVydGllcyhkaW1lbnNpb25zLCBtYXRlcmlhbHMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0TGlzdGVuZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgLy8gVXBkYXRlIGxpc3RlbmVyIHBvc2l0aW9uLlxuICB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblswXSA9IHg7XG4gIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzFdID0geTtcbiAgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMl0gPSB6O1xuICB0aGlzLl9yb29tLnNldExpc3RlbmVyUG9zaXRpb24oeCwgeSwgeik7XG5cbiAgLy8gVXBkYXRlIHNvdXJjZXMgd2l0aCBuZXcgbGlzdGVuZXIgcG9zaXRpb24uXG4gIHRoaXMuX3NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgIGVsZW1lbnQuX3VwZGF0ZSgpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSdzIG9yaWVudGF0aW9uIHVzaW5nIGZvcndhcmQgYW5kIHVwIHZlY3RvcnMuXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFhcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWVxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRaXG4gKiBAcGFyYW0ge051bWJlcn0gdXBYXG4gKiBAcGFyYW0ge051bWJlcn0gdXBZXG4gKiBAcGFyYW0ge051bWJlcn0gdXBaXG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRMaXN0ZW5lck9yaWVudGF0aW9uID0gZnVuY3Rpb24oZm9yd2FyZFgsIGZvcndhcmRZLFxuICBmb3J3YXJkWiwgdXBYLCB1cFksIHVwWikge1xuICB0aGlzLl9saXN0ZW5lci5zZXRPcmllbnRhdGlvbihmb3J3YXJkWCwgZm9yd2FyZFksIGZvcndhcmRaLCB1cFgsIHVwWSwgdXBaKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIHVzaW5nIGEgVGhyZWUuanMgTWF0cml4NCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0cml4XG4gKiBUaGUgVGhyZWUuanMgTWF0cml4NCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBsaXN0ZW5lcidzIHdvcmxkIHRyYW5zZm9ybS5cbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldExpc3RlbmVyRnJvbU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICB0aGlzLl9saXN0ZW5lci5zZXRGcm9tTWF0cml4KG1hdHJpeCk7XG5cbiAgLy8gVXBkYXRlIHRoZSByZXN0IG9mIHRoZSBzY2VuZSB1c2luZyBuZXcgbGlzdGVuZXIgcG9zaXRpb24uXG4gIHRoaXMuc2V0TGlzdGVuZXJQb3NpdGlvbih0aGlzLl9saXN0ZW5lci5wb3NpdGlvblswXSxcbiAgICB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblsxXSwgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMl0pO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc3BlZWQgb2Ygc291bmQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3BlZWRPZlNvdW5kXG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRTcGVlZE9mU291bmQgPSBmdW5jdGlvbihzcGVlZE9mU291bmQpIHtcbiAgdGhpcy5fcm9vbS5zcGVlZE9mU291bmQgPSBzcGVlZE9mU291bmQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb25hbmNlQXVkaW87XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0cnVlKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIGxpYnJhcnkgY29tbW9uIHV0aWxpdGllcy5cbiAqL1xuXG5cbi8qKlxuICogT21uaXRvbmUgbGlicmFyeSBsb2dnaW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHthbnl9IE1lc3NhZ2UgdG8gYmUgcHJpbnRlZCBvdXQuXG4gKi9cbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSh3aW5kb3cuY29uc29sZSwgW1xuICAgICclY1tPbW5pdG9uZV0lYyAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJykgK1xuICAgICAgICAnICVjKEAnICsgcGVyZm9ybWFuY2Uubm93KCkudG9GaXhlZCgyKSArICdtcyknLFxuICAgICdiYWNrZ3JvdW5kOiAjQkJERUZCOyBjb2xvcjogI0ZGNTcyMjsgZm9udC13ZWlnaHQ6IDUwMCcsICdmb250LXdlaWdodDogMzAwJyxcbiAgICAnY29sb3I6ICNBQUEnLFxuICBdKTtcbn07XG5cblxuLyoqXG4gKiBPbW5pdG9uZSBsaWJyYXJ5IGVycm9yLXRocm93aW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHthbnl9IE1lc3NhZ2UgdG8gYmUgcHJpbnRlZCBvdXQuXG4gKi9cbmV4cG9ydHMudGhyb3cgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LmNvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIFtcbiAgICAnJWNbT21uaXRvbmVdJWMgJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpICtcbiAgICAgICAgJyAlYyhAJyArIHBlcmZvcm1hbmNlLm5vdygpLnRvRml4ZWQoMikgKyAnbXMpJyxcbiAgICAnYmFja2dyb3VuZDogI0M2MjgyODsgY29sb3I6ICNGRkVCRUU7IGZvbnQtd2VpZ2h0OiA4MDAnLCAnZm9udC13ZWlnaHQ6IDQwMCcsXG4gICAgJ2NvbG9yOiAjQUFBJyxcbiAgXSk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKGZhbHNlKTtcbn07XG5cblxuLy8gU3RhdGljIHRlbXAgc3RvcmFnZSBmb3IgbWF0cml4IGludmVyc2lvbi5cbmxldCBhMDA7XG5sZXQgYTAxO1xubGV0IGEwMjtcbmxldCBhMDM7XG5sZXQgYTEwO1xubGV0IGExMTtcbmxldCBhMTI7XG5sZXQgYTEzO1xubGV0IGEyMDtcbmxldCBhMjE7XG5sZXQgYTIyO1xubGV0IGEyMztcbmxldCBhMzA7XG5sZXQgYTMxO1xubGV0IGEzMjtcbmxldCBhMzM7XG5sZXQgYjAwO1xubGV0IGIwMTtcbmxldCBiMDI7XG5sZXQgYjAzO1xubGV0IGIwNDtcbmxldCBiMDU7XG5sZXQgYjA2O1xubGV0IGIwNztcbmxldCBiMDg7XG5sZXQgYjA5O1xubGV0IGIxMDtcbmxldCBiMTE7XG5sZXQgZGV0O1xuXG5cbi8qKlxuICogQSA0eDQgbWF0cml4IGludmVyc2lvbiB1dGlsaXR5LiBUaGlzIGRvZXMgbm90IGhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZVxuICogYXJndW1lbnRzIGFyZSBub3QgcHJvcGVyIDR4NCBtYXRyaWNlcy5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvdXQgICBUaGUgaW52ZXJ0ZWQgcmVzdWx0LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGEgICAgIFRoZSBzb3VyY2UgbWF0cml4LlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBvdXRcbiAqL1xuZXhwb3J0cy5pbnZlcnRNYXRyaXg0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTtcbiAgYTMwID0gYVsxMl07XG4gIGEzMSA9IGFbMTNdO1xuICBhMzIgPSBhWzE0XTtcbiAgYTMzID0gYVsxNV07XG4gIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG4gIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICByZXR1cm4gb3V0O1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZGVmaW5lZCBpbiB0aGUgRU5VTSBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IGVudW1EaWN0aW9uYXJ5IC0gRU5VTSBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBlbnRyeVZhbHVlIC0gYSB2YWx1ZSB0byBwcm9iZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNEZWZpbmVkRU5VTUVudHJ5ID0gZnVuY3Rpb24oZW51bURpY3Rpb25hcnksIGVudHJ5VmFsdWUpIHtcbiAgZm9yIChsZXQgZW51bUtleSBpbiBlbnVtRGljdGlvbmFyeSkge1xuICAgIGlmIChlbnRyeVZhbHVlID09PSBlbnVtRGljdGlvbmFyeVtlbnVtS2V5XSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEEgY29udGV4dCBvYmplY3QgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBdWRpb0NvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIC8vIFRPRE8oaG9jaCk6IFVwZGF0ZSB0aGlzIHdoZW4gQmFzZUF1ZGlvQ29udGV4dCBpcyBhdmFpbGFibGUgZm9yIGFsbFxuICAvLyBicm93c2Vycy5cbiAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBBdWRpb0NvbnRleHQgfHxcbiAgICBjb250ZXh0IGluc3RhbmNlb2YgT2ZmbGluZUF1ZGlvQ29udGV4dDtcbn07XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsaWQgQXVkaW9CdWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gYXVkaW9CdWZmZXIgQW4gQXVkaW9CdWZmZXIgb2JqZWN0IHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzQXVkaW9CdWZmZXIgPSBmdW5jdGlvbihhdWRpb0J1ZmZlcikge1xuICByZXR1cm4gYXVkaW9CdWZmZXIgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlcjtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtIGNoYW5uZWwtd2lzZSBtZXJnZSBvbiBtdWx0aXBsZSBBdWRpb0J1ZmZlcnMuIFRoZSBzYW1wbGUgcmF0ZSBhbmRcbiAqIHRoZSBsZW5ndGggb2YgYnVmZmVycyB0byBiZSBtZXJnZWQgbXVzdCBiZSBpZGVudGljYWwuXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IGJ1ZmZlckxpc3QgLSBBbiBhcnJheSBvZiBBdWRpb0J1ZmZlcnMgdG8gYmUgbWVyZ2VkXG4gKiBjaGFubmVsLXdpc2UuXG4gKiBAcmV0dXJuIHtBdWRpb0J1ZmZlcn0gLSBBIHNpbmdsZSBtZXJnZWQgQXVkaW9CdWZmZXIuXG4gKi9cbmV4cG9ydHMubWVyZ2VCdWZmZXJMaXN0QnlDaGFubmVsID0gZnVuY3Rpb24oY29udGV4dCwgYnVmZmVyTGlzdCkge1xuICBjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXJMaXN0WzBdLmxlbmd0aDtcbiAgY29uc3QgYnVmZmVyU2FtcGxlUmF0ZSA9IGJ1ZmZlckxpc3RbMF0uc2FtcGxlUmF0ZTtcbiAgbGV0IGJ1ZmZlck51bWJlck9mQ2hhbm5lbCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJ1ZmZlck51bWJlck9mQ2hhbm5lbCA+IDMyKSB7XG4gICAgICBleHBvcnRzLnRocm93KCdVdGlscy5tZXJnZUJ1ZmZlcjogTnVtYmVyIG9mIGNoYW5uZWxzIGNhbm5vdCBleGNlZWQgMzIuJyArXG4gICAgICAgICAgJyhnb3QgJyArIGJ1ZmZlck51bWJlck9mQ2hhbm5lbCArICcpJyk7XG4gICAgfVxuICAgIGlmIChidWZmZXJMZW5ndGggIT09IGJ1ZmZlckxpc3RbaV0ubGVuZ3RoKSB7XG4gICAgICBleHBvcnRzLnRocm93KCdVdGlscy5tZXJnZUJ1ZmZlcjogQXVkaW9CdWZmZXIgbGVuZ3RocyBhcmUgJyArXG4gICAgICAgICAgJ2luY29uc2lzdGVudC4gKGV4cGVjdGVkICcgKyBidWZmZXJMZW5ndGggKyAnIGJ1dCBnb3QgJyArXG4gICAgICAgICAgYnVmZmVyTGlzdFtpXS5sZW5ndGggKyAnKScpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyU2FtcGxlUmF0ZSAhPT0gYnVmZmVyTGlzdFtpXS5zYW1wbGVSYXRlKSB7XG4gICAgICBleHBvcnRzLnRocm93KCdVdGlscy5tZXJnZUJ1ZmZlcjogQXVkaW9CdWZmZXIgc2FtcGxlIHJhdGVzIGFyZSAnICtcbiAgICAgICAgICAnaW5jb25zaXN0ZW50LiAoZXhwZWN0ZWQgJyArIGJ1ZmZlclNhbXBsZVJhdGUgKyAnIGJ1dCBnb3QgJyArXG4gICAgICAgICAgYnVmZmVyTGlzdFtpXS5zYW1wbGVSYXRlICsgJyknKTtcbiAgICB9XG4gICAgYnVmZmVyTnVtYmVyT2ZDaGFubmVsICs9IGJ1ZmZlckxpc3RbaV0ubnVtYmVyT2ZDaGFubmVscztcbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKGJ1ZmZlck51bWJlck9mQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJTYW1wbGVSYXRlKTtcbiAgbGV0IGRlc3RpbmF0aW9uQ2hhbm5lbEluZGV4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBidWZmZXJMaXN0W2ldLm51bWJlck9mQ2hhbm5lbHM7ICsraikge1xuICAgICAgYnVmZmVyLmdldENoYW5uZWxEYXRhKGRlc3RpbmF0aW9uQ2hhbm5lbEluZGV4KyspLnNldChcbiAgICAgICAgICBidWZmZXJMaXN0W2ldLmdldENoYW5uZWxEYXRhKGopKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuXG4vKipcbiAqIFBlcmZvcm0gY2hhbm5lbC13aXNlIHNwbGl0IGJ5IHRoZSBnaXZlbiBjaGFubmVsIGNvdW50LiBGb3IgZXhhbXBsZSxcbiAqIDEgeCBBdWRpb0J1ZmZlcig4KSAtPiBzcGxpdEJ1ZmZlcihjb250ZXh0LCBidWZmZXIsIDIpIC0+IDQgeCBBdWRpb0J1ZmZlcigyKS5cbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IGF1ZGlvQnVmZmVyIC0gQW4gQXVkaW9CdWZmZXIgdG8gYmUgc3BsaXR0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3BsaXRCeSAtIE51bWJlciBvZiBjaGFubmVscyB0byBiZSBzcGxpdHRlZC5cbiAqIEByZXR1cm4ge0F1ZGlvQnVmZmVyW119IC0gQW4gYXJyYXkgb2Ygc3BsaXR0ZWQgQXVkaW9CdWZmZXJzLlxuICovXG5leHBvcnRzLnNwbGl0QnVmZmVyYnlDaGFubmVsID0gZnVuY3Rpb24oY29udGV4dCwgYXVkaW9CdWZmZXIsIHNwbGl0QnkpIHtcbiAgaWYgKGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgPD0gc3BsaXRCeSkge1xuICAgIGV4cG9ydHMudGhyb3coJ1V0aWxzLnNwbGl0QnVmZmVyOiBJbnN1ZmZpY2llbnQgbnVtYmVyIG9mIGNoYW5uZWxzLiAoJyArXG4gICAgICAgIGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgKyAnIHNwbGl0dGVkIGJ5ICcgKyBzcGxpdEJ5ICsgJyknKTtcbiAgfVxuXG4gIGxldCBidWZmbGVyTGlzdCA9IFtdO1xuICBsZXQgc291cmNlQ2hhbm5lbEluZGV4ID0gMDtcbiAgY29uc3QgbnVtYmVyT2ZTcGxpdHRlZEJ1ZmZlciA9XG4gICAgICBNYXRoLmNlaWwoYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyAvIHNwbGl0QnkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3BsaXR0ZWRCdWZmZXI7ICsraSkge1xuICAgIGxldCBidWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcihzcGxpdEJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyLnNhbXBsZVJhdGUpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3BsaXRCeTsgKytqKSB7XG4gICAgICBpZiAoc291cmNlQ2hhbm5lbEluZGV4IDwgYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscykge1xuICAgICAgICBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoaikuc2V0KFxuICAgICAgICAgIGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKHNvdXJjZUNoYW5uZWxJbmRleCsrKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZmZsZXJMaXN0LnB1c2goYnVmZmVyKTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXJMaXN0O1xufTtcblxuXG4vKipcbiAqIENvbnZlcnRzIEJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBBcnJheUJ1ZmZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHJpbmcgLSBCYXNlNjQtZW5jZG9lZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtBcnJheUJ5dWZmZXJ9IENvbnZlcnRlZCBBcnJheUJ1ZmZlciBvYmplY3QuXG4gKi9cbmV4cG9ydHMuZ2V0QXJyYXlCdWZmZXJGcm9tQmFzZTY0U3RyaW5nID0gZnVuY3Rpb24oYmFzZTY0U3RyaW5nKSB7XG4gIGxldCBiaW5hcnlTdHJpbmcgPSB3aW5kb3cuYXRvYihiYXNlNjRTdHJpbmcpO1xuICBsZXQgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGJ5dGVBcnJheS5mb3JFYWNoKFxuICAgICh2YWx1ZSwgaW5kZXgpID0+IGJ5dGVBcnJheVtpbmRleF0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpbmRleCkpO1xuICByZXR1cm4gYnl0ZUFycmF5LmJ1ZmZlcjtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgU3RyZWFtbGluZWQgQXVkaW9CdWZmZXIgbG9hZGVyLlxuICovXG5cblxuXG5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBCdWZmZXJEYXRhVHlwZVxuICovXG5cbi8qKlxuICogQnVmZmVyIGRhdGEgdHlwZSBmb3IgRU5VTS5cbiAqIEBlbnVtIHtCdWZmZXJEYXRhVHlwZX1cbiAqL1xuY29uc3QgQnVmZmVyRGF0YVR5cGUgPSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBUaGUgZGF0YSBjb250YWlucyBCYXNlNjQtZW5jb2RlZCBzdHJpbmcuLiAqL1xuICBCQVNFNjQ6ICdiYXNlNjQnLFxuICAvKiogQHR5cGUge3N0cmluZ30gVGhlIGRhdGEgaXMgYSBVUkwgZm9yIGF1ZGlvIGZpbGUuICovXG4gIFVSTDogJ3VybCcsXG59O1xuXG5cbi8qKlxuICogQnVmZmVyTGlzdCBvYmplY3QgbWFuYW5nZXMgdGhlIGFzeW5jIGxvYWRpbmcvZGVjb2Rpbmcgb2YgbXVsdGlwbGVcbiAqIEF1ZGlvQnVmZmVycyBmcm9tIG11bHRpcGxlIFVSTHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGJ1ZmZlckRhdGEgLSBBbiBvcmRlcmVkIGxpc3Qgb2YgVVJMcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRhdGFUeXBlPSdiYXNlNjQnXSAtIEJ1ZmZlckRhdGFUeXBlIHNwZWNpZmllci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmVyYm9zZT1mYWxzZV0gLSBMb2cgdmVyYm9zaXR5LiB8dHJ1ZXwgcHJpbnRzIHRoZVxuICogaW5kaXZpZHVhbCBtZXNzYWdlIGZyb20gZWFjaCBVUkwgYW5kIEF1ZGlvQnVmZmVyLlxuICovXG5mdW5jdGlvbiBCdWZmZXJMaXN0KGNvbnRleHQsIGJ1ZmZlckRhdGEsIG9wdGlvbnMpIHtcbiAgdGhpcy5fY29udGV4dCA9IFV0aWxzLmlzQXVkaW9Db250ZXh0KGNvbnRleHQpID9cbiAgICAgIGNvbnRleHQgOlxuICAgICAgVXRpbHMudGhyb3coJ0J1ZmZlckxpc3Q6IEludmFsaWQgQmFzZUF1ZGlvQ29udGV4dC4nKTtcblxuICB0aGlzLl9vcHRpb25zID0ge1xuICAgIGRhdGFUeXBlOiBCdWZmZXJEYXRhVHlwZS5CQVNFNjQsXG4gICAgdmVyYm9zZTogZmFsc2UsXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kYXRhVHlwZSAmJlxuICAgICAgICBVdGlscy5pc0RlZmluZWRFTlVNRW50cnkoQnVmZmVyRGF0YVR5cGUsIG9wdGlvbnMuZGF0YVR5cGUpKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLmRhdGFUeXBlID0gb3B0aW9ucy5kYXRhVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy52ZXJib3NlID0gQm9vbGVhbihvcHRpb25zLnZlcmJvc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2J1ZmZlckxpc3QgPSBbXTtcbiAgdGhpcy5fYnVmZmVyRGF0YSA9IHRoaXMuX29wdGlvbnMuZGF0YVR5cGUgPT09IEJ1ZmZlckRhdGFUeXBlLkJBU0U2NFxuICAgICAgPyBidWZmZXJEYXRhXG4gICAgICA6IGJ1ZmZlckRhdGEuc2xpY2UoMCk7XG4gIHRoaXMuX251bWJlck9mVGFza3MgPSB0aGlzLl9idWZmZXJEYXRhLmxlbmd0aDtcblxuICB0aGlzLl9yZXNvbHZlSGFuZGxlciA9IG51bGw7XG4gIHRoaXMuX3JlamVjdEhhbmRsZXIgPSBuZXcgRnVuY3Rpb24oKTtcbn1cblxuXG4vKipcbiAqIFN0YXJ0cyBBdWRpb0J1ZmZlciBsb2FkaW5nIHRhc2tzLlxuICogQHJldHVybiB7UHJvbWlzZTxBdWRpb0J1ZmZlcltdPn0gVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZlxuICogQXVkaW9CdWZmZXIuXG4gKi9cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHRoaXMuX3Byb21pc2VHZW5lcmF0b3IuYmluZCh0aGlzKSk7XG59O1xuXG5cbi8qKlxuICogUHJvbWlzZSBhcmd1bWVudCBnZW5lcmF0b3IuIEludGVybmFsbHkgc3RhcnRzIG11bHRpcGxlIGFzeW5jIGxvYWRpbmcgdGFza3MuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZSBQcm9taXNlIHJlc29sdmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVqZWN0IFByb21pc2UgcmVqZWN0LlxuICovXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fcHJvbWlzZUdlbmVyYXRvciA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICBVdGlscy50aHJvdygnQnVmZmVyTGlzdDogSW52YWxpZCBQcm9taXNlIHJlc29sdmVyLicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3Jlc29sdmVIYW5kbGVyID0gcmVzb2x2ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcmVqZWN0SGFuZGxlciA9IHJlamVjdDtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVyRGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX29wdGlvbnMuZGF0YVR5cGUgPT09IEJ1ZmZlckRhdGFUeXBlLkJBU0U2NFxuICAgICAgICA/IHRoaXMuX2xhdW5jaEFzeW5jTG9hZFRhc2soaSlcbiAgICAgICAgOiB0aGlzLl9sYXVuY2hBc3luY0xvYWRUYXNrWEhSKGkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUnVuIGFzeW5jIGxvYWRpbmcgdGFzayBmb3IgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXNrSWQgVGFzayBJRCBudW1iZXIgZnJvbSB0aGUgb3JkZXJlZCBsaXN0IHxidWZmZXJEYXRhfC5cbiAqL1xuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2xhdW5jaEFzeW5jTG9hZFRhc2sgPSBmdW5jdGlvbih0YXNrSWQpIHtcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIHRoaXMuX2NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKFxuICAgICAgVXRpbHMuZ2V0QXJyYXlCdWZmZXJGcm9tQmFzZTY0U3RyaW5nKHRoaXMuX2J1ZmZlckRhdGFbdGFza0lkXSksXG4gICAgICBmdW5jdGlvbihhdWRpb0J1ZmZlcikge1xuICAgICAgICB0aGF0Ll91cGRhdGVQcm9ncmVzcyh0YXNrSWQsIGF1ZGlvQnVmZmVyKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGhhdC5fdXBkYXRlUHJvZ3Jlc3ModGFza0lkLCBudWxsKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdCdWZmZXJMaXN0OiBkZWNvZGluZyBBcnJheUJ5ZmZlcihcIicgKyB0YXNrSWQgK1xuICAgICAgICAgICAgJ1wiIGZyb20gQmFzZTY0LWVuY29kZWQgZGF0YSBmYWlsZWQuICgnICsgZXJyb3JNZXNzYWdlICsgJyknO1xuICAgICAgICBVdGlscy50aHJvdyhtZXNzYWdlKTtcbiAgICAgICAgdGhhdC5fcmVqZWN0SGFuZGxlcihtZXNzYWdlKTtcbiAgICAgIH0pO1xufTtcblxuXG4vKipcbiAqIFJ1biBhc3luYyBsb2FkaW5nIHRhc2sgdmlhIFhIUiBmb3IgYXVkaW8gZmlsZSBVUkxzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXNrSWQgVGFzayBJRCBudW1iZXIgZnJvbSB0aGUgb3JkZXJlZCBsaXN0IHxidWZmZXJEYXRhfC5cbiAqL1xuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2xhdW5jaEFzeW5jTG9hZFRhc2tYSFIgPSBmdW5jdGlvbih0YXNrSWQpIHtcbiAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhoci5vcGVuKCdHRVQnLCB0aGlzLl9idWZmZXJEYXRhW3Rhc2tJZF0pO1xuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHRoYXQuX2NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKFxuICAgICAgICAgIHhoci5yZXNwb25zZSxcbiAgICAgICAgICBmdW5jdGlvbihhdWRpb0J1ZmZlcikge1xuICAgICAgICAgICAgdGhhdC5fdXBkYXRlUHJvZ3Jlc3ModGFza0lkLCBhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoYXQuX3VwZGF0ZVByb2dyZXNzKHRhc2tJZCwgbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0J1ZmZlckxpc3Q6IGRlY29kaW5nIFwiJyArXG4gICAgICAgICAgICAgICAgdGhhdC5fYnVmZmVyRGF0YVt0YXNrSWRdICsgJ1wiIGZhaWxlZC4gKCcgKyBlcnJvck1lc3NhZ2UgKyAnKSc7XG4gICAgICAgICAgICBVdGlscy50aHJvdyhtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoYXQuX3JlamVjdEhhbmRsZXIobWVzc2FnZSk7XG4gICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQnVmZmVyTGlzdDogWEhSIGVycm9yIHdoaWxlIGxvYWRpbmcgXCInICtcbiAgICAgICAgICB0aGF0Ll9idWZmZXJEYXRhW3Rhc2tJZF0gKyAnKCcgKyB4aHIuc3RhdHVzVGV4dCArICcpJztcbiAgICAgIFV0aWxzLnRocm93KG1lc3NhZ2UpO1xuICAgICAgdGhhdC5fcmVqZWN0SGFuZGxlcihtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgIFV0aWxzLnRocm93KFxuICAgICAgICAnQnVmZmVyTGlzdDogWEhSIG5ldHdvcmsgZmFpbGVkIG9uIGxvYWRpbmcgXCInICtcbiAgICAgICAgdGhhdC5fYnVmZmVyRGF0YVt0YXNrSWRdICsgJ1wiLicpO1xuICAgIHRoYXQuX3VwZGF0ZVByb2dyZXNzKHRhc2tJZCwgbnVsbCk7XG4gICAgdGhhdC5fcmVqZWN0SGFuZGxlcigpO1xuICB9O1xuXG4gIHhoci5zZW5kKCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgb3ZlcmFsbCBwcm9ncmVzcyBvbiBsb2FkaW5nIHRhc2tzLlxuICogQHBhcmFtIHtOdW1iZXJ9IHRhc2tJZCBUYXNrIElEIG51bWJlci5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IGF1ZGlvQnVmZmVyIERlY29kZWQgQXVkaW9CdWZmZXIgb2JqZWN0LlxuICovXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbih0YXNrSWQsIGF1ZGlvQnVmZmVyKSB7XG4gIHRoaXMuX2J1ZmZlckxpc3RbdGFza0lkXSA9IGF1ZGlvQnVmZmVyO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnZlcmJvc2UpIHtcbiAgICBsZXQgbWVzc2FnZVN0cmluZyA9IHRoaXMuX29wdGlvbnMuZGF0YVR5cGUgPT09IEJ1ZmZlckRhdGFUeXBlLkJBU0U2NFxuICAgICAgICA/ICdBcnJheUJ1ZmZlcignICsgdGFza0lkICsgJykgZnJvbSBCYXNlNjQtZW5jb2RlZCBIUklSJ1xuICAgICAgICA6ICdcIicgKyB0aGlzLl9idWZmZXJEYXRhW3Rhc2tJZF0gKyAnXCInO1xuICAgIFV0aWxzLmxvZygnQnVmZmVyTGlzdDogJyArIG1lc3NhZ2VTdHJpbmcgKyAnIHN1Y2Nlc3NmdWxseSBsb2FkZWQuJyk7XG4gIH1cblxuICBpZiAoLS10aGlzLl9udW1iZXJPZlRhc2tzID09PSAwKSB7XG4gICAgbGV0IG1lc3NhZ2VTdHJpbmcgPSB0aGlzLl9vcHRpb25zLmRhdGFUeXBlID09PSBCdWZmZXJEYXRhVHlwZS5CQVNFNjRcbiAgICAgICAgPyB0aGlzLl9idWZmZXJEYXRhLmxlbmd0aCArICcgQXVkaW9CdWZmZXJzIGZyb20gQmFzZTY0LWVuY29kZWQgSFJJUnMnXG4gICAgICAgIDogdGhpcy5fYnVmZmVyRGF0YS5sZW5ndGggKyAnIGZpbGVzIHZpYSBYSFInO1xuICAgIFV0aWxzLmxvZygnQnVmZmVyTGlzdDogJyArIG1lc3NhZ2VTdHJpbmcgKyAnIGxvYWRlZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgdGhpcy5fcmVzb2x2ZUhhbmRsZXIodGhpcy5fYnVmZmVyTGlzdCk7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0O1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIEFuIGF1ZGlvIGNoYW5uZWwgcm91dGVyIHRvIHJlc29sdmUgZGlmZmVyZW50IGNoYW5uZWwgbGF5b3V0cyBiZXR3ZWVuXG4gKiBicm93c2Vycy5cbiAqL1xuXG5cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtOdW1iZXJbXX0gQ2hhbm5lbE1hcFxuICovXG5cbi8qKlxuICogQ2hhbm5lbCBtYXAgZGljdGlvbmFyeSBFTlVNLlxuICogQGVudW0ge0NoYW5uZWxNYXB9XG4gKi9cbmNvbnN0IENoYW5uZWxNYXAgPSB7XG4gIC8qKiBAdHlwZSB7TnVtYmVyW119IC0gQUNOIGNoYW5uZWwgbWFwIGZvciBDaHJvbWUgYW5kIEZpcmVGb3guIChGRk1QRUcpICovXG4gIERFRkFVTFQ6IFswLCAxLCAyLCAzXSxcbiAgLyoqIEB0eXBlIHtOdW1iZXJbXX0gLSBTYWZhcmkncyA0LWNoYW5uZWwgbWFwIGZvciBBQUMgY29kZWMuICovXG4gIFNBRkFSSTogWzIsIDAsIDEsIDNdLFxuICAvKiogQHR5cGUge051bWJlcltdfSAtIEFDTiA+IEZ1TWEgY29udmVyc2lvbiBtYXAuICovXG4gIEZVTUE6IFswLCAzLCAxLCAyXSxcbn07XG5cblxuLyoqXG4gKiBDaGFubmVsIHJvdXRlciBmb3IgRk9BIHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGNoYW5uZWxNYXAgLSBSb3V0aW5nIGRlc3RpbmF0aW9uIGFycmF5LlxuICovXG5mdW5jdGlvbiBGT0FSb3V0ZXIoY29udGV4dCwgY2hhbm5lbE1hcCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9zcGxpdHRlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9tZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoNCk7XG5cbiAgLy8gaW5wdXQvb3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fc3BsaXR0ZXI7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fbWVyZ2VyO1xuXG4gIHRoaXMuc2V0Q2hhbm5lbE1hcChjaGFubmVsTWFwIHx8IENoYW5uZWxNYXAuREVGQVVMVCk7XG59XG5cblxuLyoqXG4gKiBTZXRzIGNoYW5uZWwgbWFwLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY2hhbm5lbE1hcCAtIEEgbmV3IGNoYW5uZWwgbWFwIGZvciBGT0Egc3RyZWFtLlxuICovXG5GT0FSb3V0ZXIucHJvdG90eXBlLnNldENoYW5uZWxNYXAgPSBmdW5jdGlvbihjaGFubmVsTWFwKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFubmVsTWFwKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2NoYW5uZWxNYXAgPSBjaGFubmVsTWFwO1xuICB0aGlzLl9zcGxpdHRlci5kaXNjb25uZWN0KCk7XG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCB0aGlzLl9jaGFubmVsTWFwWzBdKTtcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDEsIHRoaXMuX2NoYW5uZWxNYXBbMV0pO1xuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMiwgdGhpcy5fY2hhbm5lbE1hcFsyXSk7XG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAzLCB0aGlzLl9jaGFubmVsTWFwWzNdKTtcbn07XG5cblxuLyoqXG4gKiBTdGF0aWMgY2hhbm5lbCBtYXAgRU5VTS5cbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtDaGFubmVsTWFwfVxuICovXG5GT0FSb3V0ZXIuQ2hhbm5lbE1hcCA9IENoYW5uZWxNYXA7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FSb3V0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgU291bmQgZmllbGQgcm90YXRvciBmb3IgZmlyc3Qtb3JkZXItYW1iaXNvbmljcyBkZWNvZGluZy5cbiAqL1xuXG5cblxuXG4vKipcbiAqIEZpcnN0LW9yZGVyLWFtYmlzb25pYyBkZWNvZGVyIGJhc2VkIG9uIGdhaW4gbm9kZSBuZXR3b3JrLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICovXG5mdW5jdGlvbiBGT0FSb3RhdG9yKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5faW5ZID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2luWiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9pblggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTAgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTEgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTMgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTUgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTYgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTcgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbTggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fb3V0WSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9vdXRaID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX291dFggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDQpO1xuXG4gIC8vIEFDTiBjaGFubmVsIG9yZGVyaW5nOiBbMSwgMiwgM10gPT4gWy1ZLCBaLCAtWF1cbiAgLy8gWSAoZnJvbSBjaGFubmVsIDEpXG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5faW5ZLCAxKTtcbiAgLy8gWiAoZnJvbSBjaGFubmVsIDIpXG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5faW5aLCAyKTtcbiAgLy8gWCAoZnJvbSBjaGFubmVsIDMpXG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5faW5YLCAzKTtcbiAgdGhpcy5faW5ZLmdhaW4udmFsdWUgPSAtMTtcbiAgdGhpcy5faW5YLmdhaW4udmFsdWUgPSAtMTtcblxuICAvLyBBcHBseSB0aGUgcm90YXRpb24gaW4gdGhlIHdvcmxkIHNwYWNlLlxuICAvLyB8WXwgICB8IG0wICBtMyAgbTYgfCAgIHwgWSAqIG0wICsgWiAqIG0zICsgWCAqIG02IHwgICB8IFlyIHxcbiAgLy8gfFp8ICogfCBtMSAgbTQgIG03IHwgPSB8IFkgKiBtMSArIFogKiBtNCArIFggKiBtNyB8ID0gfCBaciB8XG4gIC8vIHxYfCAgIHwgbTIgIG01ICBtOCB8ICAgfCBZICogbTIgKyBaICogbTUgKyBYICogbTggfCAgIHwgWHIgfFxuICB0aGlzLl9pblkuY29ubmVjdCh0aGlzLl9tMCk7XG4gIHRoaXMuX2luWS5jb25uZWN0KHRoaXMuX20xKTtcbiAgdGhpcy5faW5ZLmNvbm5lY3QodGhpcy5fbTIpO1xuICB0aGlzLl9pblouY29ubmVjdCh0aGlzLl9tMyk7XG4gIHRoaXMuX2luWi5jb25uZWN0KHRoaXMuX200KTtcbiAgdGhpcy5faW5aLmNvbm5lY3QodGhpcy5fbTUpO1xuICB0aGlzLl9pblguY29ubmVjdCh0aGlzLl9tNik7XG4gIHRoaXMuX2luWC5jb25uZWN0KHRoaXMuX203KTtcbiAgdGhpcy5faW5YLmNvbm5lY3QodGhpcy5fbTgpO1xuICB0aGlzLl9tMC5jb25uZWN0KHRoaXMuX291dFkpO1xuICB0aGlzLl9tMS5jb25uZWN0KHRoaXMuX291dFopO1xuICB0aGlzLl9tMi5jb25uZWN0KHRoaXMuX291dFgpO1xuICB0aGlzLl9tMy5jb25uZWN0KHRoaXMuX291dFkpO1xuICB0aGlzLl9tNC5jb25uZWN0KHRoaXMuX291dFopO1xuICB0aGlzLl9tNS5jb25uZWN0KHRoaXMuX291dFgpO1xuICB0aGlzLl9tNi5jb25uZWN0KHRoaXMuX291dFkpO1xuICB0aGlzLl9tNy5jb25uZWN0KHRoaXMuX291dFopO1xuICB0aGlzLl9tOC5jb25uZWN0KHRoaXMuX291dFgpO1xuXG4gIC8vIFRyYW5zZm9ybSAzOiB3b3JsZCBzcGFjZSB0byBhdWRpbyBzcGFjZS5cbiAgLy8gVyAtPiBXICh0byBjaGFubmVsIDApXG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcbiAgLy8gWSAodG8gY2hhbm5lbCAxKVxuICB0aGlzLl9vdXRZLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcbiAgLy8gWiAodG8gY2hhbm5lbCAyKVxuICB0aGlzLl9vdXRaLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAyKTtcbiAgLy8gWCAodG8gY2hhbm5lbCAzKVxuICB0aGlzLl9vdXRYLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAzKTtcbiAgdGhpcy5fb3V0WS5nYWluLnZhbHVlID0gLTE7XG4gIHRoaXMuX291dFguZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gIHRoaXMuc2V0Um90YXRpb25NYXRyaXgzKG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKSk7XG5cbiAgLy8gaW5wdXQvb3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fc3BsaXR0ZXI7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fbWVyZ2VyO1xufVxuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggM3gzIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4MyAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUm90YXRvci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXgzKSB7XG4gIHRoaXMuX20wLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbMF07XG4gIHRoaXMuX20xLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbMV07XG4gIHRoaXMuX20yLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbMl07XG4gIHRoaXMuX20zLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbM107XG4gIHRoaXMuX200LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbNF07XG4gIHRoaXMuX201LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbNV07XG4gIHRoaXMuX202LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbNl07XG4gIHRoaXMuX203LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbN107XG4gIHRoaXMuX204LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbOF07XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggNHg0IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4NCAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUm90YXRvci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXg0KSB7XG4gIHRoaXMuX20wLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMF07XG4gIHRoaXMuX20xLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMV07XG4gIHRoaXMuX20yLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMl07XG4gIHRoaXMuX20zLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNF07XG4gIHRoaXMuX200LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNV07XG4gIHRoaXMuX201LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNl07XG4gIHRoaXMuX202LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbOF07XG4gIHRoaXMuX203LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbOV07XG4gIHRoaXMuX204LmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMTBdO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEByZXR1cm4ge051bWJlcltdfSAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUm90YXRvci5wcm90b3R5cGUuZ2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAgdGhpcy5fbTAuZ2Fpbi52YWx1ZSwgdGhpcy5fbTEuZ2Fpbi52YWx1ZSwgdGhpcy5fbTIuZ2Fpbi52YWx1ZSxcbiAgICB0aGlzLl9tMy5nYWluLnZhbHVlLCB0aGlzLl9tNC5nYWluLnZhbHVlLCB0aGlzLl9tNS5nYWluLnZhbHVlLFxuICAgIHRoaXMuX202LmdhaW4udmFsdWUsIHRoaXMuX203LmdhaW4udmFsdWUsIHRoaXMuX204LmdhaW4udmFsdWUsXG4gIF07XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCA0eDQgcm90YXRpb24gbWF0cml4LlxuICogQHJldHVybiB7TnVtYmVyW119IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSb3RhdG9yLnByb3RvdHlwZS5nZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJvdGF0aW9uTWF0cml4NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICByb3RhdGlvbk1hdHJpeDRbMF0gPSB0aGlzLl9tMC5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMV0gPSB0aGlzLl9tMS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMl0gPSB0aGlzLl9tMi5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNF0gPSB0aGlzLl9tMy5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNV0gPSB0aGlzLl9tNC5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNl0gPSB0aGlzLl9tNS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbOF0gPSB0aGlzLl9tNi5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbOV0gPSB0aGlzLl9tNy5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMTBdID0gdGhpcy5fbTguZ2Fpbi52YWx1ZTtcbiAgcmV0dXJuIHJvdGF0aW9uTWF0cml4NDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FSb3RhdG9yO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgQSBjb2xsZWN0aW9uIG9mIGNvbnZvbHZlcnMuIENhbiBiZSB1c2VkIGZvciB0aGUgb3B0aW1pemVkIEZPQSBiaW5hdXJhbFxuICogcmVuZGVyaW5nLiAoZS5nLiBTSC1NYXhSZSBIUlRGcylcbiAqL1xuXG5cblxuXG4vKipcbiAqIEZPQUNvbnZvbHZlci4gQSBjb2xsZWN0aW9uIG9mIDIgc3RlcmVvIGNvbnZvbHZlcnMgZm9yIDQtY2hhbm5lbCBGT0Egc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgVGhlIGFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBbaHJpckJ1ZmZlckxpc3RdIC0gQW4gb3JkZXJlZC1saXN0IG9mIHN0ZXJlb1xuICogQXVkaW9CdWZmZXJzIGZvciBjb252b2x1dGlvbi4gKGkuZS4gMiBzdGVyZW8gQXVkaW9CdWZmZXJzIGZvciBGT0EpXG4gKi9cbmZ1bmN0aW9uIEZPQUNvbnZvbHZlcihjb250ZXh0LCBocmlyQnVmZmVyTGlzdCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5faXNCdWZmZXJMb2FkZWQgPSBmYWxzZTtcblxuICB0aGlzLl9idWlsZEF1ZGlvR3JhcGgoKTtcblxuICBpZiAoaHJpckJ1ZmZlckxpc3QpIHtcbiAgICB0aGlzLnNldEhSSVJCdWZmZXJMaXN0KGhyaXJCdWZmZXJMaXN0KTtcbiAgfVxuXG4gIHRoaXMuZW5hYmxlKCk7XG59XG5cblxuLyoqXG4gKiBCdWlsZCB0aGUgaW50ZXJuYWwgYXVkaW8gZ3JhcGguXG4gKlxuICogQHByaXZhdGVcbiAqL1xuRk9BQ29udm9sdmVyLnByb3RvdHlwZS5fYnVpbGRBdWRpb0dyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3NwbGl0dGVyV1laWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9tZXJnZXJXWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiAgdGhpcy5fbWVyZ2VyWlggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gIHRoaXMuX2NvbnZvbHZlcldZID0gdGhpcy5fY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgdGhpcy5fY29udm9sdmVyWlggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICB0aGlzLl9zcGxpdHRlcldZID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG4gIHRoaXMuX3NwbGl0dGVyWlggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiAgdGhpcy5faW52ZXJ0ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbWVyZ2VyQmluYXVyYWwgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gIHRoaXMuX3N1bW1pbmdCdXMgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBHcm91cCBXIGFuZCBZLCB0aGVuIFogYW5kIFguXG4gIHRoaXMuX3NwbGl0dGVyV1laWC5jb25uZWN0KHRoaXMuX21lcmdlcldZLCAwLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWVpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyV1ksIDEsIDEpO1xuICB0aGlzLl9zcGxpdHRlcldZWlguY29ubmVjdCh0aGlzLl9tZXJnZXJaWCwgMiwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyV1laWC5jb25uZWN0KHRoaXMuX21lcmdlclpYLCAzLCAxKTtcblxuICAvLyBDcmVhdGUgYSBuZXR3b3JrIG9mIGNvbnZvbHZlcnMgdXNpbmcgc3BsaXR0ZXIvbWVyZ2VyLlxuICB0aGlzLl9tZXJnZXJXWS5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcldZKTtcbiAgdGhpcy5fbWVyZ2VyWlguY29ubmVjdCh0aGlzLl9jb252b2x2ZXJaWCk7XG4gIHRoaXMuX2NvbnZvbHZlcldZLmNvbm5lY3QodGhpcy5fc3BsaXR0ZXJXWSk7XG4gIHRoaXMuX2NvbnZvbHZlclpYLmNvbm5lY3QodGhpcy5fc3BsaXR0ZXJaWCk7XG4gIHRoaXMuX3NwbGl0dGVyV1kuY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMCwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyV1kuY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMCwgMSk7XG4gIHRoaXMuX3NwbGl0dGVyV1kuY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMSwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyV1kuY29ubmVjdCh0aGlzLl9pbnZlcnRlciwgMSwgMCk7XG4gIHRoaXMuX2ludmVydGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDAsIDEpO1xuICB0aGlzLl9zcGxpdHRlclpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDAsIDApO1xuICB0aGlzLl9zcGxpdHRlclpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDAsIDEpO1xuICB0aGlzLl9zcGxpdHRlclpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDEsIDApO1xuICB0aGlzLl9zcGxpdHRlclpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDEsIDEpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFdlYkF1ZGlvJ3MgY29udm9sdmVyIGRvZXMgdGhlIG5vcm1hbGl6YXRpb24gYmFzZWQgb24gSVInc1xuICAvLyBlbmVyZ3kuIEZvciB0aGUgcHJlY2lzZSBjb252b2x1dGlvbiwgaXQgbXVzdCBiZSBkaXNhYmxlZCBiZWZvcmUgdGhlIGJ1ZmZlclxuICAvLyBhc3NpZ25tZW50LlxuICB0aGlzLl9jb252b2x2ZXJXWS5ub3JtYWxpemUgPSBmYWxzZTtcbiAgdGhpcy5fY29udm9sdmVyWlgubm9ybWFsaXplID0gZmFsc2U7XG5cbiAgLy8gRm9yIGFzeW1tZXRyaWMgZGVncmVlLlxuICB0aGlzLl9pbnZlcnRlci5nYWluLnZhbHVlID0gLTE7XG5cbiAgLy8gSW5wdXQvb3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fc3BsaXR0ZXJXWVpYO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX3N1bW1pbmdCdXM7XG59O1xuXG5cbi8qKlxuICogQXNzaWducyAyIEhSSVIgQXVkaW9CdWZmZXJzIHRvIDIgY29udm9sdmVyczogTm90ZSB0aGF0IHdlIHVzZSAyIHN0ZXJlb1xuICogY29udm9sdXRpb25zIGZvciA0LWNoYW5uZWwgZGlyZWN0IGNvbnZvbHV0aW9uLiBVc2luZyBtb25vIGNvbnZvbHZlciBvclxuICogNC1jaGFubmVsIGNvbnZvbHZlciBpcyBub3QgdmlhYmxlIGJlY2F1c2UgbW9ubyBjb252b2x1dGlvbiB3YXN0ZWZ1bGx5XG4gKiBwcm9kdWNlcyB0aGUgc3RlcmVvIG91dHB1dHMsIGFuZCB0aGUgNC1jaCBjb252b2x2ZXIgZG9lcyBjcm9zcy1jaGFubmVsXG4gKiBjb252b2x1dGlvbi4gKFNlZSBXZWIgQXVkaW8gQVBJIHNwZWMpXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IGhyaXJCdWZmZXJMaXN0IC0gQW4gYXJyYXkgb2Ygc3RlcmVvIEF1ZGlvQnVmZmVycyBmb3JcbiAqIGNvbnZvbHZlcnMuXG4gKi9cbkZPQUNvbnZvbHZlci5wcm90b3R5cGUuc2V0SFJJUkJ1ZmZlckxpc3QgPSBmdW5jdGlvbihocmlyQnVmZmVyTGlzdCkge1xuICAvLyBBZnRlciB0aGVzZSBhc3NpZ25tZW50cywgdGhlIGNoYW5uZWwgZGF0YSBpbiB0aGUgYnVmZmVyIGlzIGltbXV0YWJsZSBpblxuICAvLyBGaXJlRm94LiAoaS5lLiBuZXV0ZXJlZCkgU28gd2Ugc2hvdWxkIGF2b2lkIHJlLWFzc2lnbmluZyBidWZmZXJzLCBvdGhlcndpc2VcbiAgLy8gYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICBpZiAodGhpcy5faXNCdWZmZXJMb2FkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jb252b2x2ZXJXWS5idWZmZXIgPSBocmlyQnVmZmVyTGlzdFswXTtcbiAgdGhpcy5fY29udm9sdmVyWlguYnVmZmVyID0gaHJpckJ1ZmZlckxpc3RbMV07XG4gIHRoaXMuX2lzQnVmZmVyTG9hZGVkID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBFbmFibGUgRk9BQ29udm9sdmVyIGluc3RhbmNlLiBUaGUgYXVkaW8gZ3JhcGggd2lsbCBiZSBhY3RpdmF0ZWQgYW5kIHB1bGxlZCBieVxuICogdGhlIFdlYkF1ZGlvIGVuZ2luZS4gKGkuZS4gY29uc3VtZSBDUFUgY3ljbGUpXG4gKi9cbkZPQUNvbnZvbHZlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX21lcmdlckJpbmF1cmFsLmNvbm5lY3QodGhpcy5fc3VtbWluZ0J1cyk7XG4gIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogRGlzYWJsZSBGT0FDb252b2x2ZXIgaW5zdGFuY2UuIFRoZSBpbm5lciBncmFwaCB3aWxsIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZVxuICogYXVkaW8gZGVzdGluYXRpb24sIHRodXMgbm8gQ1BVIGN5Y2xlIHdpbGwgYmUgY29uc3VtZWQuXG4gKi9cbkZPQUNvbnZvbHZlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tZXJnZXJCaW5hdXJhbC5kaXNjb25uZWN0KCk7XG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQUNvbnZvbHZlcjtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IERFUFJFQ0FURUQgYXQgVjEuIEF1ZGlvIGJ1ZmZlciBsb2FkaW5nIHV0aWxpdHkuXG4gKi9cblxuXG5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLyoqXG4gKiBTdHJlYW1saW5lZCBhdWRpbyBmaWxlIGxvYWRlciBzdXBwb3J0cyBQcm9taXNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgICAgICAgICAgQXVkaW9Db250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gYXVkaW9GaWxlRGF0YSAgICBBdWRpbyBmaWxlIGluZm8gYXMgW3tuYW1lLCB1cmx9XVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSAgICAgICAgUmVzb2x1dGlvbiBoYW5kbGVyIGZvciBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ICAgICAgICAgUmVqZWN0aW9uIGhhbmRsZXIgZm9yIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzcyAgICAgICBQcm9ncmVzcyBldmVudCBoYW5kbGVyLlxuICovXG5mdW5jdGlvbiBBdWRpb0J1ZmZlck1hbmFnZXIoY29udGV4dCwgYXVkaW9GaWxlRGF0YSwgcmVzb2x2ZSwgcmVqZWN0LCBwcm9ncmVzcykge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9idWZmZXJzID0gbmV3IE1hcCgpO1xuICB0aGlzLl9sb2FkaW5nVGFza3MgPSB7fTtcblxuICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICB0aGlzLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuXG4gIC8vIEl0ZXJhdGluZyBmaWxlIGxvYWRpbmcuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9GaWxlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZpbGVJbmZvID0gYXVkaW9GaWxlRGF0YVtpXTtcblxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVzIGZpbGVuYW1lIGFuZCBxdWl0IGlmIGl0IGhhcHBlbnMuXG4gICAgaWYgKHRoaXMuX2xvYWRpbmdUYXNrcy5oYXNPd25Qcm9wZXJ0eShmaWxlSW5mby5uYW1lKSkge1xuICAgICAgVXRpbHMubG9nKCdEdXBsaWNhdGVkIGZpbGVuYW1lIHdoZW4gbG9hZGluZzogJyArIGZpbGVJbmZvLm5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1hcmsgaXQgYXMgcGVuZGluZyAoMClcbiAgICB0aGlzLl9sb2FkaW5nVGFza3NbZmlsZUluZm8ubmFtZV0gPSAwO1xuICAgIHRoaXMuX2xvYWRBdWRpb0ZpbGUoZmlsZUluZm8pO1xuICB9XG59XG5cbkF1ZGlvQnVmZmVyTWFuYWdlci5wcm90b3R5cGUuX2xvYWRBdWRpb0ZpbGUgPSBmdW5jdGlvbihmaWxlSW5mbykge1xuICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgeGhyLm9wZW4oJ0dFVCcsIGZpbGVJbmZvLnVybCk7XG4gIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgdGhhdC5fY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoeGhyLnJlc3BvbnNlLFxuICAgICAgICBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICAvLyBVdGlscy5sb2coJ0ZpbGUgbG9hZGVkOiAnICsgZmlsZUluZm8udXJsKTtcbiAgICAgICAgICB0aGF0Ll9kb25lKGZpbGVJbmZvLm5hbWUsIGJ1ZmZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICBVdGlscy5sb2coJ0RlY29kaW5nIGZhaWx1cmU6ICdcbiAgICAgICAgICAgICsgZmlsZUluZm8udXJsICsgJyAoJyArIG1lc3NhZ2UgKyAnKScpO1xuICAgICAgICAgIHRoYXQuX2RvbmUoZmlsZUluZm8ubmFtZSwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy5sb2coJ1hIUiBFcnJvcjogJyArIGZpbGVJbmZvLnVybCArICcgKCcgKyB4aHIuc3RhdHVzVGV4dFxuICAgICAgICArICcpJyk7XG4gICAgICB0aGF0Ll9kb25lKGZpbGVJbmZvLm5hbWUsIG51bGwpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiBmZXRjaCBsb2NhbCByZXNvdXJjZXMgaWYgWEhSIGZhaWxzLlxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgVXRpbHMubG9nKCdYSFIgTmV0d29yayBmYWlsdXJlOiAnICsgZmlsZUluZm8udXJsKTtcbiAgICB0aGF0Ll9kb25lKGZpbGVJbmZvLm5hbWUsIG51bGwpO1xuICB9O1xuXG4gIHhoci5zZW5kKCk7XG59O1xuXG5BdWRpb0J1ZmZlck1hbmFnZXIucHJvdG90eXBlLl9kb25lID0gZnVuY3Rpb24oZmlsZW5hbWUsIGJ1ZmZlcikge1xuICAvLyBMYWJlbCB0aGUgbG9hZGluZyB0YXNrLlxuICB0aGlzLl9sb2FkaW5nVGFza3NbZmlsZW5hbWVdID0gYnVmZmVyICE9PSBudWxsID8gJ2xvYWRlZCcgOiAnZmFpbGVkJztcblxuICAvLyBBIGZhaWxlZCB0YXNrIHdpbGwgYmUgYSBudWxsIGJ1ZmZlci5cbiAgdGhpcy5fYnVmZmVycy5zZXQoZmlsZW5hbWUsIGJ1ZmZlcik7XG5cbiAgdGhpcy5fdXBkYXRlUHJvZ3Jlc3MoZmlsZW5hbWUpO1xufTtcblxuQXVkaW9CdWZmZXJNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICBsZXQgbnVtYmVyT2ZGaW5pc2hlZFRhc2tzID0gMDtcbiAgbGV0IG51bWJlck9mRmFpbGVkVGFzayA9IDA7XG4gIGxldCBudW1iZXJPZlRhc2tzID0gMDtcblxuICBmb3IgKGNvbnN0IHRhc2sgaW4gdGhpcy5fbG9hZGluZ1Rhc2tzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9sb2FkaW5nVGFza3MsIHRhc2spKSB7XG4gICAgICBudW1iZXJPZlRhc2tzKys7XG4gICAgICBpZiAodGhpcy5fbG9hZGluZ1Rhc2tzW3Rhc2tdID09PSAnbG9hZGVkJykge1xuICAgICAgICBudW1iZXJPZkZpbmlzaGVkVGFza3MrKztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9hZGluZ1Rhc2tzW3Rhc2tdID09PSAnZmFpbGVkJykge1xuICAgICAgICBudW1iZXJPZkZhaWxlZFRhc2srKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHRoaXMuX3Byb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3MoZmlsZW5hbWUsIG51bWJlck9mRmluaXNoZWRUYXNrcywgbnVtYmVyT2ZUYXNrcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG51bWJlck9mRmluaXNoZWRUYXNrcyA9PT0gbnVtYmVyT2ZUYXNrcykge1xuICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fYnVmZmVycyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG51bWJlck9mRmluaXNoZWRUYXNrcyArIG51bWJlck9mRmFpbGVkVGFzayA9PT0gbnVtYmVyT2ZUYXNrcykge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9idWZmZXJzKTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXVkaW9CdWZmZXJNYW5hZ2VyO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgUGhhc2UgbWF0Y2hlZCBmaWx0ZXIgZm9yIGZpcnN0LW9yZGVyLWFtYmlzb25pY3MgZGVjb2RpbmcuXG4gKi9cblxuXG5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vLyBTdGF0aWMgcGFyYW1ldGVycy5cbmNvbnN0IENST1NTT1ZFUl9GUkVRVUVOQ1kgPSA2OTA7XG5jb25zdCBHQUlOX0NPRUZGSUNJRU5UUyA9IFsxLjQxNDIsIDAuODE2NiwgMC44MTY2LCAwLjgxNjZdO1xuXG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIGNvZWZmaWNpZW50cyBmb3IgZHVhbCBiYW5kIGZpbHRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjcm9zc292ZXJGcmVxdWVuY3lcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlXG4gKiBAcmV0dXJuIHtPYmplY3R9IEZpbHRlciBjb2VmZmljaWVudHMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRHVhbEJhbmRDb2VmZmljaWVudHMoY3Jvc3NvdmVyRnJlcXVlbmN5LCBzYW1wbGVSYXRlKSB7XG4gIGNvbnN0IGsgPSBNYXRoLnRhbihNYXRoLlBJICogY3Jvc3NvdmVyRnJlcXVlbmN5IC8gc2FtcGxlUmF0ZSk7XG4gIGNvbnN0IGsyID0gayAqIGs7XG4gIGNvbnN0IGRlbm9taW5hdG9yID0gazIgKyAyICogayArIDE7XG5cbiAgcmV0dXJuIHtcbiAgICBsb3dwYXNzQTogWzEsIDIgKiAoazIgLSAxKSAvIGRlbm9taW5hdG9yLCAoazIgLSAyICogayArIDEpIC8gZGVub21pbmF0b3JdLFxuICAgIGxvd3Bhc3NCOiBbazIgLyBkZW5vbWluYXRvciwgMiAqIGsyIC8gZGVub21pbmF0b3IsIGsyIC8gZGVub21pbmF0b3JdLFxuICAgIGhpcGFzc0E6IFsxLCAyICogKGsyIC0gMSkgLyBkZW5vbWluYXRvciwgKGsyIC0gMiAqIGsgKyAxKSAvIGRlbm9taW5hdG9yXSxcbiAgICBoaXBhc3NCOiBbMSAvIGRlbm9taW5hdG9yLCAtMiAqIDEgLyBkZW5vbWluYXRvciwgMSAvIGRlbm9taW5hdG9yXSxcbiAgfTtcbn1cblxuXG4vKipcbiAqIEZPQVBoYXNlTWF0Y2hlZEZpbHRlcjogQSBzZXQgb2YgZmlsdGVycyAoTFAvSFApIHdpdGggYSBjcm9zc292ZXIgZnJlcXVlbmN5IHRvXG4gKiBjb21wZW5zYXRlIHRoZSBnYWluIG9mIGhpZ2ggZnJlcXVlbmN5IGNvbnRlbnRzIHdpdGhvdXQgYSBwaGFzZSBkaWZmZXJlbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICovXG5mdW5jdGlvbiBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9pbnB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIGlmICghdGhpcy5fY29udGV4dC5jcmVhdGVJSVJGaWx0ZXIpIHtcbiAgICBVdGlscy5sb2coJ0lJUiBmaWx0ZXIgaXMgbWlzc2luZy4gVXNpbmcgQmlxdWFkIGZpbHRlciBpbnN0ZWFkLicpO1xuICAgIHRoaXMuX2xwZiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgdGhpcy5faHBmID0gdGhpcy5fY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICB0aGlzLl9scGYuZnJlcXVlbmN5LnZhbHVlID0gQ1JPU1NPVkVSX0ZSRVFVRU5DWTtcbiAgICB0aGlzLl9ocGYuZnJlcXVlbmN5LnZhbHVlID0gQ1JPU1NPVkVSX0ZSRVFVRU5DWTtcbiAgICB0aGlzLl9ocGYudHlwZSA9ICdoaWdocGFzcyc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29lZiA9IGdlbmVyYXRlRHVhbEJhbmRDb2VmZmljaWVudHMoQ1JPU1NPVkVSX0ZSRVFVRU5DWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNhbXBsZVJhdGUpO1xuICAgIHRoaXMuX2xwZiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlSUlSRmlsdGVyKGNvZWYubG93cGFzc0IsIGNvZWYubG93cGFzc0EpO1xuICAgIHRoaXMuX2hwZiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlSUlSRmlsdGVyKGNvZWYuaGlwYXNzQiwgY29lZi5oaXBhc3NBKTtcbiAgfVxuXG4gIHRoaXMuX3NwbGl0dGVyTG93ID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX3NwbGl0dGVySGlnaCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9nYWluSGlnaFcgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fZ2FpbkhpZ2hZID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2dhaW5IaWdoWiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9nYWluSGlnaFggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDQpO1xuXG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5faHBmKTtcbiAgdGhpcy5faHBmLmNvbm5lY3QodGhpcy5fc3BsaXR0ZXJIaWdoKTtcbiAgdGhpcy5fc3BsaXR0ZXJIaWdoLmNvbm5lY3QodGhpcy5fZ2FpbkhpZ2hXLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJIaWdoLmNvbm5lY3QodGhpcy5fZ2FpbkhpZ2hZLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJIaWdoLmNvbm5lY3QodGhpcy5fZ2FpbkhpZ2haLCAyKTtcbiAgdGhpcy5fc3BsaXR0ZXJIaWdoLmNvbm5lY3QodGhpcy5fZ2FpbkhpZ2hYLCAzKTtcbiAgdGhpcy5fZ2FpbkhpZ2hXLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcbiAgdGhpcy5fZ2FpbkhpZ2hZLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcbiAgdGhpcy5fZ2FpbkhpZ2haLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAyKTtcbiAgdGhpcy5fZ2FpbkhpZ2hYLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAzKTtcblxuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2xwZik7XG4gIHRoaXMuX2xwZi5jb25uZWN0KHRoaXMuX3NwbGl0dGVyTG93KTtcbiAgdGhpcy5fc3BsaXR0ZXJMb3cuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuICB0aGlzLl9zcGxpdHRlckxvdy5jb25uZWN0KHRoaXMuX21lcmdlciwgMSwgMSk7XG4gIHRoaXMuX3NwbGl0dGVyTG93LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAyLCAyKTtcbiAgdGhpcy5fc3BsaXR0ZXJMb3cuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDMsIDMpO1xuXG4gIC8vIEFwcGx5IGdhaW4gY29ycmVjdGlvbiB0byBoaS1wYXNzZWQgcHJlc3N1cmUgYW5kIHZlbG9jaXR5IGNvbXBvbmVudHM6XG4gIC8vIEludmVydGluZyBzaWduIGlzIG5lY2Vzc2FyeSBhcyB0aGUgbG93LXBhc3NlZCBhbmQgaGlnaC1wYXNzZWQgcG9ydGlvbiBhcmVcbiAgLy8gb3V0LW9mLXBoYXNlIGFmdGVyIHRoZSBmaWx0ZXJpbmcuXG4gIGNvbnN0IG5vdyA9IHRoaXMuX2NvbnRleHQuY3VycmVudFRpbWU7XG4gIHRoaXMuX2dhaW5IaWdoVy5nYWluLnNldFZhbHVlQXRUaW1lKC0xICogR0FJTl9DT0VGRklDSUVOVFNbMF0sIG5vdyk7XG4gIHRoaXMuX2dhaW5IaWdoWS5nYWluLnNldFZhbHVlQXRUaW1lKC0xICogR0FJTl9DT0VGRklDSUVOVFNbMV0sIG5vdyk7XG4gIHRoaXMuX2dhaW5IaWdoWi5nYWluLnNldFZhbHVlQXRUaW1lKC0xICogR0FJTl9DT0VGRklDSUVOVFNbMl0sIG5vdyk7XG4gIHRoaXMuX2dhaW5IaWdoWC5nYWluLnNldFZhbHVlQXRUaW1lKC0xICogR0FJTl9DT0VGRklDSUVOVFNbM10sIG5vdyk7XG5cbiAgLy8gSW5wdXQvb3V0cHV0IFByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5faW5wdXQ7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fbWVyZ2VyO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BUGhhc2VNYXRjaGVkRmlsdGVyO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgVmlydHVhbCBzcGVha2VyIGFic3RyYWN0aW9uIGZvciBmaXJzdC1vcmRlci1hbWJpc29uaWNzIGRlY29kaW5nLlxuICovXG5cblxuXG5cbi8qKlxuICogREVQUkVDQVRFRCBhdCBWMTogQSB2aXJ0dWFsIHNwZWFrZXIgd2l0aCBhbWJpc29uaWMgZGVjb2RpbmcgZ2FpbiBjb2VmZmljaWVudHNcbiAqIGFuZCBIUlRGIGNvbnZvbHV0aW9uIGZvciBmaXJzdC1vcmRlci1hbWJpc29uaWNzIHN0cmVhbS4gTm90ZSB0aGF0IHRoZVxuICogc3ViZ3JhcGggZGlyZWN0bHkgY29ubmVjdHMgdG8gY29udGV4dCdzIGRlc3RpbmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBzcGVha2VyLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3B0aW9ucy5jb2VmZmljaWVudHMgLSBEZWNvZGluZyBjb2VmZmljaWVudHMgZm9yIChXLFksWixYKS5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IG9wdGlvbnMuSVIgLSBTdGVyZW8gSVIgYnVmZmVyIGZvciBIUlRGIGNvbnZvbHV0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZ2FpbiAtIFBvc3QtZ2FpbiBmb3IgdGhlIHNwZWFrZXIuXG4gKi9cbmZ1bmN0aW9uIEZPQVZpcnR1YWxTcGVha2VyKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuSVIubnVtYmVyT2ZDaGFubmVscyAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSVIgZG9lcyBub3QgaGF2ZSAyIGNoYW5uZWxzLiBjYW5ub3QgcHJvY2VlZC4nKTtcbiAgfVxuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9pbnB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9jVyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9jWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9jWiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9jWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9jb252b2x2ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICB0aGlzLl9nYWluID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9jVywgMCk7XG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5fY1ksIDEpO1xuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2NaLCAyKTtcbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9jWCwgMyk7XG4gIHRoaXMuX2NXLmNvbm5lY3QodGhpcy5fY29udm9sdmVyKTtcbiAgdGhpcy5fY1kuY29ubmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuICB0aGlzLl9jWi5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcik7XG4gIHRoaXMuX2NYLmNvbm5lY3QodGhpcy5fY29udm9sdmVyKTtcbiAgdGhpcy5fY29udm9sdmVyLmNvbm5lY3QodGhpcy5fZ2Fpbik7XG4gIHRoaXMuX2dhaW4uY29ubmVjdCh0aGlzLl9jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICB0aGlzLmVuYWJsZSgpO1xuXG4gIHRoaXMuX2NvbnZvbHZlci5ub3JtYWxpemUgPSBmYWxzZTtcbiAgdGhpcy5fY29udm9sdmVyLmJ1ZmZlciA9IG9wdGlvbnMuSVI7XG4gIHRoaXMuX2dhaW4uZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuZ2FpbjtcblxuICAvLyBTZXQgZ2FpbiBjb2VmZmljaWVudHMgZm9yIEZPQSBhbWJpc29uaWMgc3RyZWFtcy5cbiAgdGhpcy5fY1cuZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuY29lZmZpY2llbnRzWzBdO1xuICB0aGlzLl9jWS5nYWluLnZhbHVlID0gb3B0aW9ucy5jb2VmZmljaWVudHNbMV07XG4gIHRoaXMuX2NaLmdhaW4udmFsdWUgPSBvcHRpb25zLmNvZWZmaWNpZW50c1syXTtcbiAgdGhpcy5fY1guZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuY29lZmZpY2llbnRzWzNdO1xuXG4gIC8vIElucHV0IHByb3h5LiBPdXRwdXQgZGlyZWN0bHkgY29ubmVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uLlxuICB0aGlzLmlucHV0ID0gdGhpcy5faW5wdXQ7XG59XG5cblxuRk9BVmlydHVhbFNwZWFrZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9nYWluLmNvbm5lY3QodGhpcy5fY29udGV4dC5kZXN0aW5hdGlvbik7XG4gIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG59O1xuXG5cbkZPQVZpcnR1YWxTcGVha2VyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dhaW4uZGlzY29ubmVjdCgpO1xuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FWaXJ0dWFsU3BlYWtlcjtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIEEgY29sbGVjdGlvbiBvZiBjb252b2x2ZXJzLiBDYW4gYmUgdXNlZCBmb3IgdGhlIG9wdGltaXplZCBIT0EgYmluYXVyYWxcbiAqIHJlbmRlcmluZy4gKGUuZy4gU0gtTWF4UmUgSFJURnMpXG4gKi9cblxuXG5cblxuLyoqXG4gKiBBIGNvbnZvbHZlciBuZXR3b3JrIGZvciBOLWNoYW5uZWwgSE9BIHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciAtIEFtYmlzb25pYyBvcmRlci4gKDIgb3IgMylcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gW2hyaXJCdWZmZXJMaXN0XSAtIEFuIG9yZGVyZWQtbGlzdCBvZiBzdGVyZW9cbiAqIEF1ZGlvQnVmZmVycyBmb3IgY29udm9sdXRpb24uIChTT0E6IDUgQXVkaW9CdWZmZXJzLCBUT0E6IDggQXVkaW9CdWZmZXJzKVxuICovXG5mdW5jdGlvbiBIT0FDb252b2x2ZXIoY29udGV4dCwgYW1iaXNvbmljT3JkZXIsIGhyaXJCdWZmZXJMaXN0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9pc0J1ZmZlckxvYWRlZCA9IGZhbHNlO1xuXG4gIC8vIFRoZSBudW1iZXIgb2YgY2hhbm5lbHMgSyBiYXNlZCBvbiB0aGUgYW1iaXNvbmljIG9yZGVyIE4gd2hlcmUgSyA9IChOKzEpXjIuXG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID0gYW1iaXNvbmljT3JkZXI7XG4gIHRoaXMuX251bWJlck9mQ2hhbm5lbHMgPVxuICAgICAgKHRoaXMuX2FtYmlzb25pY09yZGVyICsgMSkgKiAodGhpcy5fYW1iaXNvbmljT3JkZXIgKyAxKTtcblxuICB0aGlzLl9idWlsZEF1ZGlvR3JhcGgoKTtcbiAgaWYgKGhyaXJCdWZmZXJMaXN0KSB7XG4gICAgdGhpcy5zZXRIUklSQnVmZmVyTGlzdChocmlyQnVmZmVyTGlzdCk7XG4gIH1cblxuICB0aGlzLmVuYWJsZSgpO1xufVxuXG5cbi8qKlxuICogQnVpbGQgdGhlIGludGVybmFsIGF1ZGlvIGdyYXBoLlxuICogRm9yIFRPQSBjb252b2x1dGlvbjpcbiAqICAgaW5wdXQgLT4gc3BsaXR0ZXIoMTYpIC1bMCwxXS0+IG1lcmdlcigyKSAtPiBjb252b2x2ZXIoMikgLT4gc3BsaXR0ZXIoMilcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIC1bMiwzXS0+IG1lcmdlcigyKSAtPiBjb252b2x2ZXIoMikgLT4gc3BsaXR0ZXIoMilcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIC1bNCw1XS0+IC4uLiAoNiBtb3JlLCA4IGJyYW5jaGVzIHRvdGFsKVxuICogQHByaXZhdGVcbiAqL1xuSE9BQ29udm9sdmVyLnByb3RvdHlwZS5fYnVpbGRBdWRpb0dyYXBoID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG51bWJlck9mU3RlcmVvQ2hhbm5lbHMgPSBNYXRoLmNlaWwodGhpcy5fbnVtYmVyT2ZDaGFubmVscyAvIDIpO1xuXG4gIHRoaXMuX2lucHV0U3BsaXR0ZXIgPVxuICAgICAgdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIodGhpcy5fbnVtYmVyT2ZDaGFubmVscyk7XG4gIHRoaXMuX3N0ZXJlb01lcmdlcnMgPSBbXTtcbiAgdGhpcy5fY29udm9sdmVycyA9IFtdO1xuICB0aGlzLl9zdGVyZW9TcGxpdHRlcnMgPSBbXTtcbiAgdGhpcy5fcG9zaXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9uZWdhdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2ludmVydGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2JpbmF1cmFsTWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICB0aGlzLl9vdXRwdXRHYWluID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0ZXJlb0NoYW5uZWxzOyArK2kpIHtcbiAgICB0aGlzLl9zdGVyZW9NZXJnZXJzW2ldID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICAgIHRoaXMuX2NvbnZvbHZlcnNbaV0gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICAgIHRoaXMuX3N0ZXJlb1NwbGl0dGVyc1tpXSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICAgIHRoaXMuX2NvbnZvbHZlcnNbaV0ubm9ybWFsaXplID0gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBsID0gMDsgbCA8PSB0aGlzLl9hbWJpc29uaWNPcmRlcjsgKytsKSB7XG4gICAgZm9yIChsZXQgbSA9IC1sOyBtIDw9IGw7IG0rKykge1xuICAgICAgLy8gV2UgY29tcHV0ZSB0aGUgQUNOIGluZGV4IChrKSBvZiBhbWJpc29uaWNzIGNoYW5uZWwgdXNpbmcgdGhlIGRlZ3JlZSAobClcbiAgICAgIC8vIGFuZCBpbmRleCAobSk6IGsgPSBsXjIgKyBsICsgbVxuICAgICAgY29uc3QgYWNuSW5kZXggPSBsICogbCArIGwgKyBtO1xuICAgICAgY29uc3Qgc3RlcmVvSW5kZXggPSBNYXRoLmZsb29yKGFjbkluZGV4IC8gMik7XG5cbiAgICAgIC8vIFNwbGl0IGNoYW5uZWxzIGZyb20gaW5wdXQgaW50byBhcnJheSBvZiBzdGVyZW8gY29udm9sdmVycy5cbiAgICAgIC8vIFRoZW4gY3JlYXRlIGEgbmV0d29yayBvZiBtZXJnZXJzIHRoYXQgcHJvZHVjZXMgdGhlIHN0ZXJlbyBvdXRwdXQuXG4gICAgICB0aGlzLl9pbnB1dFNwbGl0dGVyLmNvbm5lY3QoXG4gICAgICAgICAgdGhpcy5fc3RlcmVvTWVyZ2Vyc1tzdGVyZW9JbmRleF0sIGFjbkluZGV4LCBhY25JbmRleCAlIDIpO1xuICAgICAgdGhpcy5fc3RlcmVvTWVyZ2Vyc1tzdGVyZW9JbmRleF0uY29ubmVjdCh0aGlzLl9jb252b2x2ZXJzW3N0ZXJlb0luZGV4XSk7XG4gICAgICB0aGlzLl9jb252b2x2ZXJzW3N0ZXJlb0luZGV4XS5jb25uZWN0KHRoaXMuX3N0ZXJlb1NwbGl0dGVyc1tzdGVyZW9JbmRleF0pO1xuXG4gICAgICAvLyBQb3NpdGl2ZSBpbmRleCAobSA+PSAwKSBzcGhlcmljYWwgaGFybW9uaWNzIGFyZSBzeW1tZXRyaWNhbCBhcm91bmQgdGhlXG4gICAgICAvLyBmcm9udCBheGlzLCB3aGlsZSBuZWdhdGl2ZSBpbmRleCAobSA8IDApIHNwaGVyaWNhbCBoYXJtb25pY3MgYXJlXG4gICAgICAvLyBhbnRpLXN5bW1ldHJpY2FsIGFyb3VuZCB0aGUgZnJvbnQgYXhpcy4gV2Ugd2lsbCBleHBsb2l0IHRoaXMgc3ltbWV0cnlcbiAgICAgIC8vIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGNvbnZvbHV0aW9ucyByZXF1aXJlZCB3aGVuIHJlbmRlcmluZyB0byBhXG4gICAgICAvLyBzeW1tZXRyaWNhbCBiaW5hdXJhbCByZW5kZXJlci5cbiAgICAgIGlmIChtID49IDApIHtcbiAgICAgICAgdGhpcy5fc3RlcmVvU3BsaXR0ZXJzW3N0ZXJlb0luZGV4XS5jb25uZWN0KFxuICAgICAgICAgICAgdGhpcy5fcG9zaXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcywgYWNuSW5kZXggJSAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0ZXJlb1NwbGl0dGVyc1tzdGVyZW9JbmRleF0uY29ubmVjdChcbiAgICAgICAgICAgIHRoaXMuX25lZ2F0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MsIGFjbkluZGV4ICUgMik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fcG9zaXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcy5jb25uZWN0KHRoaXMuX2JpbmF1cmFsTWVyZ2VyLCAwLCAwKTtcbiAgdGhpcy5fcG9zaXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcy5jb25uZWN0KHRoaXMuX2JpbmF1cmFsTWVyZ2VyLCAwLCAxKTtcbiAgdGhpcy5fbmVnYXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcy5jb25uZWN0KHRoaXMuX2JpbmF1cmFsTWVyZ2VyLCAwLCAwKTtcbiAgdGhpcy5fbmVnYXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcy5jb25uZWN0KHRoaXMuX2ludmVydGVyKTtcbiAgdGhpcy5faW52ZXJ0ZXIuY29ubmVjdCh0aGlzLl9iaW5hdXJhbE1lcmdlciwgMCwgMSk7XG5cbiAgLy8gRm9yIGFzeW1tZXRyaWMgaW5kZXguXG4gIHRoaXMuX2ludmVydGVyLmdhaW4udmFsdWUgPSAtMTtcblxuICAvLyBJbnB1dC9PdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9pbnB1dFNwbGl0dGVyO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX291dHB1dEdhaW47XG59O1xuXG5cbi8qKlxuICogQXNzaWducyBOIEhSSVIgQXVkaW9CdWZmZXJzIHRvIE4gY29udm9sdmVyczogTm90ZSB0aGF0IHdlIHVzZSAyIHN0ZXJlb1xuICogY29udm9sdXRpb25zIGZvciA0LWNoYW5uZWwgZGlyZWN0IGNvbnZvbHV0aW9uLiBVc2luZyBtb25vIGNvbnZvbHZlciBvclxuICogNC1jaGFubmVsIGNvbnZvbHZlciBpcyBub3QgdmlhYmxlIGJlY2F1c2UgbW9ubyBjb252b2x1dGlvbiB3YXN0ZWZ1bGx5XG4gKiBwcm9kdWNlcyB0aGUgc3RlcmVvIG91dHB1dHMsIGFuZCB0aGUgNC1jaCBjb252b2x2ZXIgZG9lcyBjcm9zcy1jaGFubmVsXG4gKiBjb252b2x1dGlvbi4gKFNlZSBXZWIgQXVkaW8gQVBJIHNwZWMpXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IGhyaXJCdWZmZXJMaXN0IC0gQW4gYXJyYXkgb2Ygc3RlcmVvIEF1ZGlvQnVmZmVycyBmb3JcbiAqIGNvbnZvbHZlcnMuXG4gKi9cbkhPQUNvbnZvbHZlci5wcm90b3R5cGUuc2V0SFJJUkJ1ZmZlckxpc3QgPSBmdW5jdGlvbihocmlyQnVmZmVyTGlzdCkge1xuICAvLyBBZnRlciB0aGVzZSBhc3NpZ25tZW50cywgdGhlIGNoYW5uZWwgZGF0YSBpbiB0aGUgYnVmZmVyIGlzIGltbXV0YWJsZSBpblxuICAvLyBGaXJlRm94LiAoaS5lLiBuZXV0ZXJlZCkgU28gd2Ugc2hvdWxkIGF2b2lkIHJlLWFzc2lnbmluZyBidWZmZXJzLCBvdGhlcndpc2VcbiAgLy8gYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICBpZiAodGhpcy5faXNCdWZmZXJMb2FkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhyaXJCdWZmZXJMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fY29udm9sdmVyc1tpXS5idWZmZXIgPSBocmlyQnVmZmVyTGlzdFtpXTtcbiAgfVxuXG4gIHRoaXMuX2lzQnVmZmVyTG9hZGVkID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBFbmFibGUgSE9BQ29udm9sdmVyIGluc3RhbmNlLiBUaGUgYXVkaW8gZ3JhcGggd2lsbCBiZSBhY3RpdmF0ZWQgYW5kIHB1bGxlZCBieVxuICogdGhlIFdlYkF1ZGlvIGVuZ2luZS4gKGkuZS4gY29uc3VtZSBDUFUgY3ljbGUpXG4gKi9cbkhPQUNvbnZvbHZlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2JpbmF1cmFsTWVyZ2VyLmNvbm5lY3QodGhpcy5fb3V0cHV0R2Fpbik7XG4gIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogRGlzYWJsZSBIT0FDb252b2x2ZXIgaW5zdGFuY2UuIFRoZSBpbm5lciBncmFwaCB3aWxsIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZVxuICogYXVkaW8gZGVzdGluYXRpb24sIHRodXMgbm8gQ1BVIGN5Y2xlIHdpbGwgYmUgY29uc3VtZWQuXG4gKi9cbkhPQUNvbnZvbHZlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5hdXJhbE1lcmdlci5kaXNjb25uZWN0KCk7XG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhPQUNvbnZvbHZlcjtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBTb3VuZCBmaWVsZCByb3RhdG9yIGZvciBoaWdoZXItb3JkZXItYW1iaXNvbmljcyBkZWNvZGluZy5cbiAqL1xuXG5cblxuXG4vKipcbiAqIEtyb25lY2tlciBEZWx0YSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcGFyYW0ge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRLcm9uZWNrZXJEZWx0YShpLCBqKSB7XG4gIHJldHVybiBpID09PSBqID8gMSA6IDA7XG59XG5cblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB1cyB0byBhY2Nlc3MgYSBtYXRyaXggYXJyYXkgaW4gdGhlIHNhbWVcbiAqIG1hbm5lciwgYXNzdW1pbmcgaXQgaXMgYSAoMmwrMSl4KDJsKzEpIG1hdHJpeC4gWzJdIHVzZXMgYW4gb2RkIGNvbnZlbnRpb24gb2ZcbiAqIHJlZmVycmluZyB0byB0aGUgcm93cyBhbmQgY29sdW1ucyB1c2luZyBjZW50ZXJlZCBpbmRpY2VzLCBzbyB0aGUgbWlkZGxlIHJvd1xuICogYW5kIGNvbHVtbiBhcmUgKDAsIDApIGFuZCB0aGUgdXBwZXIgbGVmdCB3b3VsZCBoYXZlIG5lZ2F0aXZlIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSBnYWluVmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCwgaSwgaiwgZ2FpblZhbHVlKSB7XG4gIGNvbnN0IGluZGV4ID0gKGogKyBsKSAqICgyICogbCArIDEpICsgKGkgKyBsKTtcbiAgLy8gUm93LXdpc2UgaW5kZXhpbmcuXG4gIG1hdHJpeFtsIC0gMV1baW5kZXhdLmdhaW4udmFsdWUgPSBnYWluVmFsdWU7XG59XG5cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzIHRvIGFjY2VzcyBhIG1hdHJpeCBhcnJheSBpbiB0aGUgc2FtZVxuICogbWFubmVyLCBhc3N1bWluZyBpdCBpcyBhICgybCsxKSB4ICgybCsxKSBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcGFyYW0ge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsLCBpLCBqKSB7XG4gIC8vIFJvdy13aXNlIGluZGV4aW5nLlxuICBjb25zdCBpbmRleCA9IChqICsgbCkgKiAoMiAqIGwgKyAxKSArIChpICsgbCk7XG4gIHJldHVybiBtYXRyaXhbbCAtIDFdW2luZGV4XS5nYWluLnZhbHVlO1xufVxuXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGRlZmluZWQgaW4gWzJdIHRoYXQgaXMgdXNlZCBieSB0aGUgZnVuY3Rpb25zIFUsIFYsIFcuXG4gKiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIG9uIGl0cyBvd24sIGFzIFUsIFYsIGFuZCBXIChhbmQgdGhlaXIgY29lZmZpY2llbnRzKVxuICogc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBtYXRyaXggZWxlbWVudHMgdG8gYWNjZXNzIGFyZ3VtZW50cyB8YXwgYW5kIHxifC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRQKG1hdHJpeCwgaSwgYSwgYiwgbCkge1xuICBpZiAoYiA9PT0gbCkge1xuICAgIHJldHVybiBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCAxLCBpLCAxKSAqXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwgLSAxLCBhLCBsIC0gMSkgLVxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCAxLCBpLCAtMSkgKlxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsIC0gMSwgYSwgLWwgKyAxKTtcbiAgfSBlbHNlIGlmIChiID09PSAtbCkge1xuICAgIHJldHVybiBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCAxLCBpLCAxKSAqXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwgLSAxLCBhLCAtbCArIDEpICtcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgMSwgaSwgLTEpICpcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCAtIDEsIGEsIGwgLSAxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgMSwgaSwgMCkgKlxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsIC0gMSwgYSwgYik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbnMgVSwgViwgYW5kIFcgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBjb3JyZXNwb25kaW5nbHlcbiAqIG5hbWVkIGNvZWZmaWNpZW50IHUsIHYsIHcgZnJvbSB0aGUgZnVuY3Rpb24gQ29tcHV0ZVVWV0NvZWZmKCkgaXMgbm9uLXplcm8uXG4gKiBXaGVuIHRoZSBjb2VmZmljaWVudCBpcyAwLCB0aGVzZSB3b3VsZCBhdHRlbXB0IHRvIGFjY2VzcyBtYXRyaXggZWxlbWVudHMgdGhhdFxuICogYXJlIG91dCBvZiBib3VuZHMuIFRoZSB2ZWN0b3Igb2Ygcm90YXRpb25zLCB8cnwsIG11c3QgaGF2ZSB0aGUgfGwgLSAxfFxuICogcHJldmlvdXNseSBjb21wbGV0ZWQgYmFuZCByb3RhdGlvbnMuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdmFsaWQgZm9yIHxsID49IDJ8LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0VShtYXRyaXgsIG0sIG4sIGwpIHtcbiAgLy8gQWx0aG91Z2ggWzEsIDJdIHNwbGl0IFUgaW50byB0aHJlZSBjYXNlcyBmb3IgbSA9PSAwLCBtIDwgMCwgbSA+IDBcbiAgLy8gdGhlIGFjdHVhbCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGZvciBhbGwgdGhyZWUgY2FzZXMuXG4gIHJldHVybiBnZXRQKG1hdHJpeCwgMCwgbSwgbiwgbCk7XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIFUsIFYsIGFuZCBXIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgY29ycmVzcG9uZGluZ2x5XG4gKiBuYW1lZCBjb2VmZmljaWVudCB1LCB2LCB3IGZyb20gdGhlIGZ1bmN0aW9uIENvbXB1dGVVVldDb2VmZigpIGlzIG5vbi16ZXJvLlxuICogV2hlbiB0aGUgY29lZmZpY2llbnQgaXMgMCwgdGhlc2Ugd291bGQgYXR0ZW1wdCB0byBhY2Nlc3MgbWF0cml4IGVsZW1lbnRzIHRoYXRcbiAqIGFyZSBvdXQgb2YgYm91bmRzLiBUaGUgdmVjdG9yIG9mIHJvdGF0aW9ucywgfHJ8LCBtdXN0IGhhdmUgdGhlIHxsIC0gMXxcbiAqIHByZXZpb3VzbHkgY29tcGxldGVkIGJhbmQgcm90YXRpb25zLiBUaGVzZSBmdW5jdGlvbnMgYXJlIHZhbGlkIGZvciB8bCA+PSAyfC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFYobWF0cml4LCBtLCBuLCBsKSB7XG4gIGlmIChtID09PSAwKSB7XG4gICAgcmV0dXJuIGdldFAobWF0cml4LCAxLCAxLCBuLCBsKSArIGdldFAobWF0cml4LCAtMSwgLTEsIG4sIGwpO1xuICB9IGVsc2UgaWYgKG0gPiAwKSB7XG4gICAgY29uc3QgZCA9IGdldEtyb25lY2tlckRlbHRhKG0sIDEpO1xuICAgIHJldHVybiBnZXRQKG1hdHJpeCwgMSwgbSAtIDEsIG4sIGwpICogTWF0aC5zcXJ0KDEgKyBkKSAtXG4gICAgICAgIGdldFAobWF0cml4LCAtMSwgLW0gKyAxLCBuLCBsKSAqICgxIC0gZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm90ZSB0aGVyZSBpcyBhcHBhcmVudCBlcnJhdGEgaW4gWzEsMiwyYl0gZGVhbGluZyB3aXRoIHRoaXMgcGFydGljdWxhclxuICAgIC8vIGNhc2UuIFsyYl0gd3JpdGVzIGl0IHNob3VsZCBiZSBQKigxLWQpK1AqKDEtZCleMC41XG4gICAgLy8gWzFdIHdyaXRlcyBpdCBhcyBQKigxK2QpK1AqKDEtZCleMC41LCBidXQgZ29pbmcgdGhyb3VnaCB0aGUgbWF0aCBieSBoYW5kLFxuICAgIC8vIHlvdSBtdXN0IGhhdmUgaXQgYXMgUCooMS1kKStQKigxK2QpXjAuNSB0byBmb3JtIGEgMl4uNSB0ZXJtLCB3aGljaFxuICAgIC8vIHBhcmFsbGVscyB0aGUgY2FzZSB3aGVyZSBtID4gMC5cbiAgICBjb25zdCBkID0gZ2V0S3JvbmVja2VyRGVsdGEobSwgLTEpO1xuICAgIHJldHVybiBnZXRQKG1hdHJpeCwgMSwgbSArIDEsIG4sIGwpICogKDEgLSBkKSArXG4gICAgICAgIGdldFAobWF0cml4LCAtMSwgLW0gLSAxLCBuLCBsKSAqIE1hdGguc3FydCgxICsgZCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbnMgVSwgViwgYW5kIFcgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBjb3JyZXNwb25kaW5nbHlcbiAqIG5hbWVkIGNvZWZmaWNpZW50IHUsIHYsIHcgZnJvbSB0aGUgZnVuY3Rpb24gQ29tcHV0ZVVWV0NvZWZmKCkgaXMgbm9uLXplcm8uXG4gKiBXaGVuIHRoZSBjb2VmZmljaWVudCBpcyAwLCB0aGVzZSB3b3VsZCBhdHRlbXB0IHRvIGFjY2VzcyBtYXRyaXggZWxlbWVudHMgdGhhdFxuICogYXJlIG91dCBvZiBib3VuZHMuIFRoZSB2ZWN0b3Igb2Ygcm90YXRpb25zLCB8cnwsIG11c3QgaGF2ZSB0aGUgfGwgLSAxfFxuICogcHJldmlvdXNseSBjb21wbGV0ZWQgYmFuZCByb3RhdGlvbnMuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdmFsaWQgZm9yIHxsID49IDJ8LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFcobWF0cml4LCBtLCBuLCBsKSB7XG4gIC8vIFdoZW5ldmVyIHRoaXMgaGFwcGVucywgdyBpcyBhbHNvIDAgc28gVyBjYW4gYmUgYW55dGhpbmcuXG4gIGlmIChtID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gbSA+IDAgPyBnZXRQKG1hdHJpeCwgMSwgbSArIDEsIG4sIGwpICsgZ2V0UChtYXRyaXgsIC0xLCAtbSAtIDEsIG4sIGwpIDpcbiAgICAgICAgICAgICAgICAgZ2V0UChtYXRyaXgsIDEsIG0gLSAxLCBuLCBsKSAtIGdldFAobWF0cml4LCAtMSwgLW0gKyAxLCBuLCBsKTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvZWZmaWNpZW50cyBhcHBsaWVkIHRvIHRoZSBVLCBWLCBhbmQgVyBmdW5jdGlvbnMuIEJlY2F1c2VcbiAqIHRoZWlyIGVxdWF0aW9ucyBzaGFyZSBtYW55IGNvbW1vbiB0ZXJtcyB0aGV5IGFyZSBjb21wdXRlZCBzaW11bHRhbmVvdXNseS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEByZXR1cm4ge0FycmF5fSAzIGNvZWZmaWNpZW50cyBmb3IgVSwgViBhbmQgVyBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVVVldDb2VmZihtLCBuLCBsKSB7XG4gIGNvbnN0IGQgPSBnZXRLcm9uZWNrZXJEZWx0YShtLCAwKTtcbiAgY29uc3QgcmVjaXByb2NhbERlbm9taW5hdG9yID1cbiAgICAgIE1hdGguYWJzKG4pID09PSBsID8gMSAvICgyICogbCAqICgyICogbCAtIDEpKSA6IDEgLyAoKGwgKyBuKSAqIChsIC0gbikpO1xuXG4gIHJldHVybiBbXG4gICAgTWF0aC5zcXJ0KChsICsgbSkgKiAobCAtIG0pICogcmVjaXByb2NhbERlbm9taW5hdG9yKSxcbiAgICAwLjUgKiAoMSAtIDIgKiBkKSAqIE1hdGguc3FydCgoMSArIGQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobCArIE1hdGguYWJzKG0pIC0gMSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsICsgTWF0aC5hYnMobSkpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNpcHJvY2FsRGVub21pbmF0b3IpLFxuICAgIC0wLjUgKiAoMSAtIGQpICogTWF0aC5zcXJ0KChsIC0gTWF0aC5hYnMobSkgLSAxKSAqIChsIC0gTWF0aC5hYnMobSkpKSAqXG4gICAgICAgIHJlY2lwcm9jYWxEZW5vbWluYXRvcixcbiAgXTtcbn1cblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlICgybCsxKSB4ICgybCsxKSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBiYW5kIGwuXG4gKiBUaGlzIHVzZXMgdGhlIG1hdHJpY2VzIGNvbXB1dGVkIGZvciBiYW5kIDEgYW5kIGJhbmQgbC0xIHRvIGNvbXB1dGUgdGhlXG4gKiBtYXRyaXggZm9yIGJhbmQgbC4gfHJvdGF0aW9uc3wgbXVzdCBjb250YWluIHRoZSBwcmV2aW91c2x5IGNvbXB1dGVkIGwtMVxuICogcm90YXRpb24gbWF0cmljZXMuXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGNvbWVzIGZyb20gcC4gNSAoNjM0NiksIFRhYmxlIDEgYW5kIDIgaW4gWzJdIHRha2luZ1xuICogaW50byBhY2NvdW50IHRoZSBjb3JyZWN0aW9ucyBmcm9tIFsyYl0uXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoIHdoZXJlXG4gKiBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVCYW5kUm90YXRpb24obWF0cml4LCBsKSB7XG4gIC8vIFRoZSBsdGggYmFuZCByb3RhdGlvbiBtYXRyaXggaGFzIHJvd3MgYW5kIGNvbHVtbnMgZXF1YWwgdG8gdGhlIG51bWJlciBvZlxuICAvLyBjb2VmZmljaWVudHMgd2l0aGluIHRoYXQgYmFuZCAoLWwgPD0gbSA8PSBsIGltcGxpZXMgMmwgKyAxIGNvZWZmaWNpZW50cykuXG4gIGZvciAobGV0IG0gPSAtbDsgbSA8PSBsOyBtKyspIHtcbiAgICBmb3IgKGxldCBuID0gLWw7IG4gPD0gbDsgbisrKSB7XG4gICAgICBjb25zdCB1dndDb2VmZmljaWVudHMgPSBjb21wdXRlVVZXQ29lZmYobSwgbiwgbCk7XG5cbiAgICAgIC8vIFRoZSBmdW5jdGlvbnMgVSwgViwgVyBhcmUgb25seSBzYWZlIHRvIGNhbGwgaWYgdGhlIGNvZWZmaWNpZW50c1xuICAgICAgLy8gdSwgdiwgdyBhcmUgbm90IHplcm8uXG4gICAgICBpZiAoTWF0aC5hYnModXZ3Q29lZmZpY2llbnRzWzBdKSA+IDApIHtcbiAgICAgICAgdXZ3Q29lZmZpY2llbnRzWzBdICo9IGdldFUobWF0cml4LCBtLCBuLCBsKTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyh1dndDb2VmZmljaWVudHNbMV0pID4gMCkge1xuICAgICAgICB1dndDb2VmZmljaWVudHNbMV0gKj0gZ2V0VihtYXRyaXgsIG0sIG4sIGwpO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHV2d0NvZWZmaWNpZW50c1syXSkgPiAwKSB7XG4gICAgICAgIHV2d0NvZWZmaWNpZW50c1syXSAqPSBnZXRXKG1hdHJpeCwgbSwgbiwgbCk7XG4gICAgICB9XG5cbiAgICAgIHNldENlbnRlcmVkRWxlbWVudChcbiAgICAgICAgICBtYXRyaXgsIGwsIG0sIG4sXG4gICAgICAgICAgdXZ3Q29lZmZpY2llbnRzWzBdICsgdXZ3Q29lZmZpY2llbnRzWzFdICsgdXZ3Q29lZmZpY2llbnRzWzJdKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIEhPQSByb3RhdGlvbiBtYXRyaXggYWZ0ZXIgc2V0dGluZyB0aGUgdHJhbnNmb3JtIG1hdHJpeC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVIT0FNYXRyaWNlcyhtYXRyaXgpIHtcbiAgLy8gV2Ugc3RhcnQgYnkgY29tcHV0aW5nIHRoZSAybmQtb3JkZXIgbWF0cml4IGZyb20gdGhlIDFzdC1vcmRlciBtYXRyaXguXG4gIGZvciAobGV0IGkgPSAyOyBpIDw9IG1hdHJpeC5sZW5ndGg7IGkrKykge1xuICAgIGNvbXB1dGVCYW5kUm90YXRpb24obWF0cml4LCBpKTtcbiAgfVxufVxuXG5cbi8qKlxuICogSGlnaGVyLW9yZGVyLWFtYmlzb25pYyBkZWNvZGVyIGJhc2VkIG9uIGdhaW4gbm9kZSBuZXR3b3JrLiBXZSBleHBlY3RcbiAqIHRoZSBvcmRlciBvZiB0aGUgY2hhbm5lbHMgdG8gY29uZm9ybSB0byBBQ04gb3JkZXJpbmcuIEJlbG93IGFyZSB0aGUgaGVscGVyXG4gKiBtZXRob2RzIHRvIGNvbXB1dGUgU0ggcm90YXRpb24gdXNpbmcgcmVjdXJzaW9uLiBUaGUgY29kZSB1c2VzIG1hdGhzIGRlc2NyaWJlZFxuICogaW4gdGhlIGZvbGxvd2luZyBwYXBlcnM6XG4gKiAgWzFdIFIuIEdyZWVuLCBcIlNwaGVyaWNhbCBIYXJtb25pYyBMaWdodGluZzogVGhlIEdyaXR0eSBEZXRhaWxzXCIsIEdEQyAyMDAzLFxuICogICAgICBodHRwOi8vd3d3LnJlc2VhcmNoLnNjZWEuY29tL2dkYzIwMDMvc3BoZXJpY2FsLWhhcm1vbmljLWxpZ2h0aW5nLnBkZlxuICogIFsyXSBKLiBJdmFuaWMgYW5kIEsuIFJ1ZWRlbmJlcmcsIFwiUm90YXRpb24gTWF0cmljZXMgZm9yIFJlYWxcbiAqICAgICAgU3BoZXJpY2FsIEhhcm1vbmljcy4gRGlyZWN0IERldGVybWluYXRpb24gYnkgUmVjdXJzaW9uXCIsIEouIFBoeXMuXG4gKiAgICAgIENoZW0uLCB2b2wuIDEwMCwgbm8uIDE1LCBwcC4gNjM0Mi02MzQ3LCAxOTk2LlxuICogICAgICBodHRwOi8vcHVicy5hY3Mub3JnL2RvaS9wZGYvMTAuMTAyMS9qcDk1MzM1MHVcbiAqICBbMmJdIENvcnJlY3Rpb25zIHRvIGluaXRpYWwgcHVibGljYXRpb246XG4gKiAgICAgICBodHRwOi8vcHVicy5hY3Mub3JnL2RvaS9wZGYvMTAuMTAyMS9qcDk4MzMzNTBcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciAtIEFtYmlzb25pYyBvcmRlci5cbiAqL1xuZnVuY3Rpb24gSE9BUm90YXRvcihjb250ZXh0LCBhbWJpc29uaWNPcmRlcikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPSBhbWJpc29uaWNPcmRlcjtcblxuICAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIEsgYmFzZWQgb24gdGhlIGFtYmlzb25pYyBvcmRlclxuICAvLyBOIHdoZXJlIEsgPSAoTiArIDEpXjIuXG4gIGNvbnN0IG51bWJlck9mQ2hhbm5lbHMgPSAoYW1iaXNvbmljT3JkZXIgKyAxKSAqIChhbWJpc29uaWNPcmRlciArIDEpO1xuXG4gIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIobnVtYmVyT2ZDaGFubmVscyk7XG4gIHRoaXMuX21lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcihudW1iZXJPZkNoYW5uZWxzKTtcblxuICAvLyBDcmVhdGUgYSBzZXQgb2YgcGVyLW9yZGVyIHJvdGF0aW9uIG1hdHJpY2VzIHVzaW5nIGdhaW4gbm9kZXMuXG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4ID0gW107XG4gIGxldCBvcmRlck9mZnNldDtcbiAgbGV0IHJvd3M7XG4gIGxldCBpbnB1dEluZGV4O1xuICBsZXQgb3V0cHV0SW5kZXg7XG4gIGxldCBtYXRyaXhJbmRleDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gYW1iaXNvbmljT3JkZXI7IGkrKykge1xuICAgIC8vIEVhY2ggYW1iaXNvbmljIG9yZGVyIHJlcXVpcmVzIGEgc2VwYXJhdGUgKDJsICsgMSkgeCAoMmwgKyAxKSByb3RhdGlvblxuICAgIC8vIG1hdHJpeC4gV2UgY29tcHV0ZSB0aGUgb2Zmc2V0IHZhbHVlIGFzIHRoZSBmaXJzdCBjaGFubmVsIGluZGV4IG9mIHRoZVxuICAgIC8vIGN1cnJlbnQgb3JkZXIgd2hlcmVcbiAgICAvLyAgIGtfbGFzdCA9IGxeMiArIGwgKyBtLFxuICAgIC8vIGFuZCBtID0gLWxcbiAgICAvLyAgIGtfbGFzdCA9IGxeMlxuICAgIG9yZGVyT2Zmc2V0ID0gaSAqIGk7XG5cbiAgICAvLyBVc2VzIHJvdy1tYWpvciBpbmRleGluZy5cbiAgICByb3dzID0gKDIgKiBpICsgMSk7XG5cbiAgICB0aGlzLl9nYWluTm9kZU1hdHJpeFtpIC0gMV0gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd3M7IGorKykge1xuICAgICAgaW5wdXRJbmRleCA9IG9yZGVyT2Zmc2V0ICsgajtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93czsgaysrKSB7XG4gICAgICAgIG91dHB1dEluZGV4ID0gb3JkZXJPZmZzZXQgKyBrO1xuICAgICAgICBtYXRyaXhJbmRleCA9IGogKiByb3dzICsgaztcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbaSAtIDFdW21hdHJpeEluZGV4XSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KFxuICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbaSAtIDFdW21hdHJpeEluZGV4XSwgaW5wdXRJbmRleCk7XG4gICAgICAgIHRoaXMuX2dhaW5Ob2RlTWF0cml4W2kgLSAxXVttYXRyaXhJbmRleF0uY29ubmVjdChcbiAgICAgICAgICAgIHRoaXMuX21lcmdlciwgMCwgb3V0cHV0SW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFctY2hhbm5lbCBpcyBub3QgaW52b2x2ZWQgaW4gcm90YXRpb24sIHNraXAgc3RyYWlnaHQgdG8gb3VwdXQuXG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcblxuICAvLyBEZWZhdWx0IElkZW50aXR5IG1hdHJpeC5cbiAgdGhpcy5zZXRSb3RhdGlvbk1hdHJpeDMobmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pKTtcblxuICAvLyBJbnB1dC9PdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9zcGxpdHRlcjtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9tZXJnZXI7XG59XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCAzeDMgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXgzIC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSb3RhdG9yLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyArK2kpIHtcbiAgICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVtpXS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzW2ldO1xuICB9XG4gIGNvbXB1dGVIT0FNYXRyaWNlcyh0aGlzLl9nYWluTm9kZU1hdHJpeCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggNHg0IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4NCAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUm90YXRvci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXg0KSB7XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzBdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMF07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzFdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMV07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzJdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMl07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzNdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNF07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzRdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNV07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzVdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbNl07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzZdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbOF07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzddLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbOV07XG4gIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzhdLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDRbMTBdO1xuICBjb21wdXRlSE9BTWF0cmljZXModGhpcy5fZ2Fpbk5vZGVNYXRyaXgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqIEByZXR1cm4ge051bWJlcltdfSAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUm90YXRvci5wcm90b3R5cGUuZ2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24oKSB7XG4gIGxldCByb3RhdGlvbk1hdHJpeDMgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDk7ICsraSkge1xuICAgIHJvdGF0aW9uTWF0cml4M1tpXSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdW2ldLmdhaW4udmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJvdGF0aW9uTWF0cml4Mztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IDR4NCByb3RhdGlvbiBtYXRyaXguXG4gKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJvdGF0b3IucHJvdG90eXBlLmdldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcm90YXRpb25NYXRyaXg0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gIHJvdGF0aW9uTWF0cml4NFswXSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzBdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsxXSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzFdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsyXSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzJdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs0XSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzNdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs1XSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzRdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs2XSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzVdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs4XSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzZdLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs5XSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzddLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsxMF0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs4XS5nYWluLnZhbHVlO1xuICByZXR1cm4gcm90YXRpb25NYXRyaXg0O1xufTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkhPQVJvdGF0b3IucHJvdG90eXBlLmdldEFtYmlzb25pY09yZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hbWJpc29uaWNPcmRlcjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIT0FSb3RhdG9yO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgTmFtZXNwYWNlIGZvciBPbW5pdG9uZSBsaWJyYXJ5LlxuICovXG5cblxuXG5cbmV4cG9ydHMuT21uaXRvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgbGlicmFyeSBuYW1lIHNwYWNlIGFuZCB1c2VyLWZhY2luZyBBUElzLlxuICovXG5cblxuXG5cbmNvbnN0IEJ1ZmZlckxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgRk9BQ29udm9sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmNvbnN0IEZPQURlY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmNvbnN0IEZPQVBoYXNlTWF0Y2hlZEZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb25zdCBGT0FSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuY29uc3QgRk9BUm90YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5jb25zdCBGT0FSb3V0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29uc3QgRk9BVmlydHVhbFNwZWFrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuY29uc3QgSE9BQ29udm9sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmNvbnN0IEhPQVJlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5jb25zdCBIT0FSb3RhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmNvbnN0IFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5jb25zdCBWZXJzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbi8vIERFUFJFQ0FURUQgaW4gVjEsIGluIGZhdm9yIG9mIEJ1ZmZlckxpc3QuXG5jb25zdCBBdWRpb0J1ZmZlck1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cbi8qKlxuICogT21uaXRvbmUgbmFtZXNwYWNlLlxuICogQG5hbWVzcGFjZVxuICovXG5sZXQgT21uaXRvbmUgPSB7fTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJyb3dzZXJJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIEJyb3dzZXIgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uIC0gQnJvd3NlciB2ZXJzaW9uLlxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBicm93c2VyIG5hbWUgYW5kIHZlcnNpb24uXG4gKiBAbWVtYmVyT2YgT21uaXRvbmVcbiAqIEBzdGF0aWMge0Jyb3dzZXJJbmZvfVxuICovXG5PbW5pdG9uZS5icm93c2VySW5mbyA9IFBvbHlmaWxsLmdldEJyb3dzZXJJbmZvKCk7XG5cblxuLy8gREVQUkVDQVRFRCBpbiBWMS4gRE8uIE5PVC4gVVNFLlxuT21uaXRvbmUubG9hZEF1ZGlvQnVmZmVycyA9IGZ1bmN0aW9uKGNvbnRleHQsIHNwZWFrZXJEYXRhKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBuZXcgQXVkaW9CdWZmZXJNYW5hZ2VyKGNvbnRleHQsIHNwZWFrZXJEYXRhLCBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgICByZXNvbHZlKGJ1ZmZlcnMpO1xuICAgIH0sIHJlamVjdCk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSBhc3luYyBsb2FkaW5nL2RlY29kaW5nIG9mIG11bHRpcGxlIEF1ZGlvQnVmZmVycyBmcm9tIG11bHRpcGxlXG4gKiBVUkxzLlxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYnVmZmVyRGF0YSAtIEFuIG9yZGVyZWQgbGlzdCBvZiBVUkxzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEJ1ZmZlckxpc3Qgb3B0aW9ucy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kYXRhVHlwZT0ndXJsJ10gLSBCdWZmZXJMaXN0IGRhdGEgdHlwZS5cbiAqIEByZXR1cm4ge1Byb21pc2U8QXVkaW9CdWZmZXJbXT59IC0gVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZlxuICogQXVkaW9CdWZmZXIuXG4gKi9cbk9tbml0b25lLmNyZWF0ZUJ1ZmZlckxpc3QgPSBmdW5jdGlvbihjb250ZXh0LCBidWZmZXJEYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IGJ1ZmZlckxpc3QgPVxuICAgICAgbmV3IEJ1ZmZlckxpc3QoY29udGV4dCwgYnVmZmVyRGF0YSwgb3B0aW9ucyB8fCB7ZGF0YVR5cGU6ICd1cmwnfSk7XG4gIHJldHVybiBidWZmZXJMaXN0LmxvYWQoKTtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtIGNoYW5uZWwtd2lzZSBtZXJnZSBvbiBtdWx0aXBsZSBBdWRpb0J1ZmZlcnMuIFRoZSBzYW1wbGUgcmF0ZSBhbmRcbiAqIHRoZSBsZW5ndGggb2YgYnVmZmVycyB0byBiZSBtZXJnZWQgbXVzdCBiZSBpZGVudGljYWwuXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gYnVmZmVyTGlzdCAtIEFuIGFycmF5IG9mIEF1ZGlvQnVmZmVycyB0byBiZSBtZXJnZWRcbiAqIGNoYW5uZWwtd2lzZS5cbiAqIEByZXR1cm4ge0F1ZGlvQnVmZmVyfSAtIEEgc2luZ2xlIG1lcmdlZCBBdWRpb0J1ZmZlci5cbiAqL1xuT21uaXRvbmUubWVyZ2VCdWZmZXJMaXN0QnlDaGFubmVsID0gVXRpbHMubWVyZ2VCdWZmZXJMaXN0QnlDaGFubmVsO1xuXG5cbi8qKlxuICogUGVyZm9ybSBjaGFubmVsLXdpc2Ugc3BsaXQgYnkgdGhlIGdpdmVuIGNoYW5uZWwgY291bnQuIEZvciBleGFtcGxlLFxuICogMSB4IEF1ZGlvQnVmZmVyKDgpIC0+IHNwbGl0QnVmZmVyKGNvbnRleHQsIGJ1ZmZlciwgMikgLT4gNCB4IEF1ZGlvQnVmZmVyKDIpLlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBhdWRpb0J1ZmZlciAtIEFuIEF1ZGlvQnVmZmVyIHRvIGJlIHNwbGl0dGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwbGl0QnkgLSBOdW1iZXIgb2YgY2hhbm5lbHMgdG8gYmUgc3BsaXR0ZWQuXG4gKiBAcmV0dXJuIHtBdWRpb0J1ZmZlcltdfSAtIEFuIGFycmF5IG9mIHNwbGl0dGVkIEF1ZGlvQnVmZmVycy5cbiAqL1xuT21uaXRvbmUuc3BsaXRCdWZmZXJieUNoYW5uZWwgPSBVdGlscy5zcGxpdEJ1ZmZlcmJ5Q2hhbm5lbDtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRk9BIENvbnZvbHZlci5cbiAqIEBzZWUgRk9BQ29udm9sdmVyXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgVGhlIGFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBbaHJpckJ1ZmZlckxpc3RdIC0gQW4gb3JkZXJlZC1saXN0IG9mIHN0ZXJlb1xuICogQHJldHVybiB7Rk9BQ29udm9sdmVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FDb252b2x2ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBocmlyQnVmZmVyTGlzdCkge1xuICByZXR1cm4gbmV3IEZPQUNvbnZvbHZlcihjb250ZXh0LCBocmlyQnVmZmVyTGlzdCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEZPQSBSb3V0ZXIuXG4gKiBAc2VlIEZPQVJvdXRlclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGNoYW5uZWxNYXAgLSBSb3V0aW5nIGRlc3RpbmF0aW9uIGFycmF5LlxuICogQHJldHVybiB7Rk9BUm91dGVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FSb3V0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBjaGFubmVsTWFwKSB7XG4gIHJldHVybiBuZXcgRk9BUm91dGVyKGNvbnRleHQsIGNoYW5uZWxNYXApO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBGT0EgUm90YXRvci5cbiAqIEBzZWUgRk9BUm90YXRvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEByZXR1cm4ge0ZPQVJvdGF0b3J9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQVJvdGF0b3IgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgRk9BUm90YXRvcihjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRk9BUGhhc2VNYXRjaGVkRmlsdGVyLlxuICogQGlnbm9yZVxuICogQHNlZSBGT0FQaGFzZU1hdGNoZWRGaWx0ZXJcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcmV0dXJuIHtGT0FQaGFzZU1hdGNoZWRGaWx0ZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQVBoYXNlTWF0Y2hlZEZpbHRlciA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIoY29udGV4dCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEZPQVZpcnR1YWxTcGVha2VyLiBGb3IgcGFyYW1ldGVycywgcmVmZXIgdGhlXG4gKiBkZWZpbml0aW9uIG9mIFZpcnR1YWxTcGVha2VyIGNsYXNzLlxuICogQGlnbm9yZVxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm4ge0ZPQVZpcnR1YWxTcGVha2VyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FWaXJ0dWFsU3BlYWtlciA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBGT0FWaXJ0dWFsU3BlYWtlcihjb250ZXh0LCBvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBERVBSRUNBVEVELiBVc2UgRk9BUmVuZGVyZXIgaW5zdGFuY2UuXG4gKiBAc2VlIEZPQVJlbmRlcmVyXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSB2aWRlb0VsZW1lbnQgLSBWaWRlbyBvciBBdWRpbyBET00gZWxlbWVudCB0byBiZSBzdHJlYW1lZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgRk9BIGRlY29kZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5iYXNlUmVzb3VyY2VVcmwgLSBCYXNlIFVSTCBmb3IgcmVzb3VyY2VzLlxuICogKGJhc2UgcGF0aCBmb3IgSFJJUiBmaWxlcylcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3N0R2Fpbj0yNi4wXSAtIFBvc3QtZGVjb2RpbmcgZ2FpbiBjb21wZW5zYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5yb3V0aW5nRGVzdGluYXRpb25dICBDdXN0b20gY2hhbm5lbCBsYXlvdXQuXG4gKiBAcmV0dXJuIHtGT0FEZWNvZGVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FEZWNvZGVyID0gZnVuY3Rpb24oY29udGV4dCwgdmlkZW9FbGVtZW50LCBvcHRpb25zKSB7XG4gIFV0aWxzLmxvZygnV0FSTklORzogRk9BRGVjb2RlciBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIEZPQVJlbmRlcmVyLicpO1xuICByZXR1cm4gbmV3IEZPQURlY29kZXIoY29udGV4dCwgdmlkZW9FbGVtZW50LCBvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBGT0FSZW5kZXJlciwgdGhlIGZpcnN0LW9yZGVyIGFtYmlzb25pYyBkZWNvZGVyIGFuZCB0aGUgb3B0aW1pemVkXG4gKiBiaW5hdXJhbCByZW5kZXJlci5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmNoYW5uZWxNYXBdIC0gQ3VzdG9tIGNoYW5uZWwgcm91dGluZyBtYXAuIFVzZWZ1bCBmb3JcbiAqIGhhbmRsaW5nIHRoZSBpbmNvbnNpc3RlbmN5IGluIGJyb3dzZXIncyBtdWx0aWNoYW5uZWwgYXVkaW8gZGVjb2RpbmcuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmhyaXJQYXRoTGlzdF0gLSBBIGxpc3Qgb2YgcGF0aHMgdG8gSFJJUiBmaWxlcy4gSXRcbiAqIG92ZXJyaWRlcyB0aGUgaW50ZXJuYWwgSFJJUiBsaXN0IGlmIGdpdmVuLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBbY29uZmlnLnJlbmRlcmluZ01vZGU9J2FtYmlzb25pYyddIC0gUmVuZGVyaW5nIG1vZGUuXG4gKiBAcmV0dXJuIHtGT0FSZW5kZXJlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BUmVuZGVyZXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBGT0FSZW5kZXJlcihjb250ZXh0LCBjb25maWcpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgSE9BUm90YXRvciBmb3IgaGlnaGVyLW9yZGVyIGFtYmlzb25pY3Mgcm90YXRpb24uXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIC0gQW1iaXNvbmljIG9yZGVyLlxuICogQHJldHVybiB7SE9BUm90YXRvcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlSE9BUm90YXRvciA9IGZ1bmN0aW9uKGNvbnRleHQsIGFtYmlzb25pY09yZGVyKSB7XG4gIHJldHVybiBuZXcgSE9BUm90YXRvcihjb250ZXh0LCBhbWJpc29uaWNPcmRlcik7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBIT0FDb252b2x2ZXIgcGVyZm9ybXMgdGhlIG11bHRpLWNoYW5uZWwgY29udm9sdXRpb24gZm9yIHRoZSBvcHRtaXplZFxuICogYmluYXVyYWwgcmVuZGVyaW5nLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciAtIEFtYmlzb25pYyBvcmRlci4gKDIgb3IgMylcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gW2hyaXJCdWZmZXJMaXN0XSAtIEFuIG9yZGVyZWQtbGlzdCBvZiBzdGVyZW9cbiAqIEF1ZGlvQnVmZmVycyBmb3IgY29udm9sdXRpb24uIChTT0E6IDUgQXVkaW9CdWZmZXJzLCBUT0E6IDggQXVkaW9CdWZmZXJzKVxuICogQHJldHVybiB7SE9BQ29udm92bGVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVIT0FDb252b2x2ZXIgPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCBhbWJpc29uaWNPcmRlciwgaHJpckJ1ZmZlckxpc3QpIHtcbiAgcmV0dXJuIG5ldyBIT0FDb252b2x2ZXIoY29udGV4dCwgYW1iaXNvbmljT3JkZXIsIGhyaXJCdWZmZXJMaXN0KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIEhPQVJlbmRlcmVyIGZvciBoaWdoZXItb3JkZXIgYW1iaXNvbmljIGRlY29kaW5nIGFuZCB0aGUgb3B0aW1pemVkXG4gKiBiaW5hdXJhbCByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuYW1iaXNvbmljT3JkZXI9M10gLSBBbWJpc29uaWMgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmhyaXJQYXRoTGlzdF0gLSBBIGxpc3Qgb2YgcGF0aHMgdG8gSFJJUiBmaWxlcy4gSXRcbiAqIG92ZXJyaWRlcyB0aGUgaW50ZXJuYWwgSFJJUiBsaXN0IGlmIGdpdmVuLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBbY29uZmlnLnJlbmRlcmluZ01vZGU9J2FtYmlzb25pYyddIC0gUmVuZGVyaW5nIG1vZGUuXG4gKiBAcmV0dXJuIHtIT0FSZW5kZXJlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlSE9BUmVuZGVyZXIgPSBmdW5jdGlvbihjb250ZXh0LCBjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBIT0FSZW5kZXJlcihjb250ZXh0LCBjb25maWcpO1xufTtcblxuXG4vLyBIYW5kbGVyIFByZWxvYWQgVGFza3MuXG4vLyAtIERldGVjdHMgdGhlIGJyb3dzZXIgaW5mb3JtYXRpb24uXG4vLyAtIFByaW50cyBvdXQgdGhlIHZlcnNpb24gbnVtYmVyLlxuKGZ1bmN0aW9uKCkge1xuICBVdGlscy5sb2coJ1ZlcnNpb24gJyArIFZlcnNpb24gKyAnIChydW5uaW5nICcgK1xuICAgICAgT21uaXRvbmUuYnJvd3NlckluZm8ubmFtZSArICcgJyArIE9tbml0b25lLmJyb3dzZXJJbmZvLnZlcnNpb24gK1xuICAgICAgJyBvbiAnICsgT21uaXRvbmUuYnJvd3NlckluZm8ucGxhdGZvcm0gKycpJyk7XG4gIGlmIChPbW5pdG9uZS5icm93c2VySW5mby5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzYWZhcmknKSB7XG4gICAgUG9seWZpbGwucGF0Y2hTYWZhcmkoKTtcbiAgICBVdGlscy5sb2coT21uaXRvbmUuYnJvd3NlckluZm8ubmFtZSArICcgZGV0ZWN0ZWQuIEFwcGxpeWluZyBwb2x5ZmlsbC4uLicpO1xuICB9XG59KSgpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gT21uaXRvbmU7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgRk9BIGRlY29kZXIsIERFUFJFQ0FURUQgaW4gZmF2b3Igb2YgRk9BUmVuZGVyZXIuXG4gKi9cblxuXG5cbmNvbnN0IEF1ZGlvQnVmZmVyTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5jb25zdCBGT0FSb3V0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29uc3QgRk9BUm90YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5jb25zdCBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuY29uc3QgRk9BVmlydHVhbFNwZWFrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuY29uc3QgRk9BU3BlYWtlckRhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQnkgZGVmYXVsdCwgT21uaXRvbmUgZmV0Y2hlcyBJUiBmcm9tIHRoZSBzcGF0aWFsIG1lZGlhIHJlcG9zaXRvcnkuXG5jb25zdCBIUlRGU0VUX1VSTCA9ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vR29vZ2xlQ2hyb21lL29tbml0b25lL21hc3Rlci9idWlsZC9yZXNvdXJjZXMvJztcblxuLy8gUG9zdCBnYWluIGNvbXBlbnNhdGlvbiB2YWx1ZS5cbmxldCBQT1NUX0dBSU5fREIgPSAwO1xuXG5cbi8qKlxuICogT21uaXRvbmUgRk9BIGRlY29kZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge1ZpZGVvRWxlbWVudH0gdmlkZW9FbGVtZW50IC0gVGFyZ2V0IHZpZGVvIChvciBhdWRpbykgZWxlbWVudCBmb3JcbiAqIHN0cmVhbWluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5IUlRGU2V0VXJsIC0gQmFzZSBVUkwgZm9yIHRoZSBjdWJlIEhSVEYgc2V0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBvc3RHYWluREIgLSBQb3N0LWRlY29kaW5nIGdhaW4gY29tcGVuc2F0aW9uIGluIGRCLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gb3B0aW9ucy5jaGFubmVsTWFwIC0gQ3VzdG9tIGNoYW5uZWwgbWFwLlxuICovXG5mdW5jdGlvbiBGT0FEZWNvZGVyKGNvbnRleHQsIHZpZGVvRWxlbWVudCwgb3B0aW9ucykge1xuICB0aGlzLl9pc0RlY29kZXJSZWFkeSA9IGZhbHNlO1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fdmlkZW9FbGVtZW50ID0gdmlkZW9FbGVtZW50O1xuICB0aGlzLl9kZWNvZGluZ01vZGUgPSAnYW1iaXNvbmljJztcblxuICB0aGlzLl9wb3N0R2FpbkRCID0gUE9TVF9HQUlOX0RCO1xuICB0aGlzLl9IUlRGU2V0VXJsID0gSFJURlNFVF9VUkw7XG4gIHRoaXMuX2NoYW5uZWxNYXAgPSBGT0FSb3V0ZXIuQ2hhbm5lbE1hcC5ERUZBVUxUOyAvLyBBQ05cblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBvc3RHYWluREIpIHtcbiAgICAgIHRoaXMuX3Bvc3RHYWluREIgPSBvcHRpb25zLnBvc3RHYWluREI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLkhSVEZTZXRVcmwpIHtcbiAgICAgIHRoaXMuX0hSVEZTZXRVcmwgPSBvcHRpb25zLkhSVEZTZXRVcmw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNoYW5uZWxNYXApIHtcbiAgICAgIHRoaXMuX2NoYW5uZWxNYXAgPSBvcHRpb25zLmNoYW5uZWxNYXA7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhcnJhbmdlIHNwZWFrZXIgZGF0YSBiYXNlZCBvbiB8b3B0aW9ucy5IUlRGU2V0VXJsfC5cbiAgdGhpcy5fc3BlYWtlckRhdGEgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBGT0FTcGVha2VyRGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX3NwZWFrZXJEYXRhLnB1c2goe1xuICAgICAgbmFtZTogRk9BU3BlYWtlckRhdGFbaV0ubmFtZSxcbiAgICAgIHVybDogdGhpcy5fSFJURlNldFVybCArICcvJyArIEZPQVNwZWFrZXJEYXRhW2ldLnVybCxcbiAgICAgIGNvZWY6IEZPQVNwZWFrZXJEYXRhW2ldLmNvZWYsXG4gICAgfSk7XG4gIH1cblxuICB0aGlzLl90ZW1wTWF0cml4NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xufVxuXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhbmQgbG9hZCB0aGUgcmVzb3VyY2VzIGZvciB0aGUgZGVjb2RlLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuRk9BRGVjb2Rlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICBVdGlscy5sb2coJ0luaXRpYWxpemluZy4uLiAobW9kZTogJyArIHRoaXMuX2RlY29kaW5nTW9kZSArICcpJyk7XG5cbiAgLy8gUmVyb3V0aW5nIGNoYW5uZWxzIGlmIG5lY2Vzc2FyeS5cbiAgbGV0IGNoYW5uZWxNYXBTdHJpbmcgPSB0aGlzLl9jaGFubmVsTWFwLnRvU3RyaW5nKCk7XG4gIGxldCBkZWZhdWx0Q2hhbm5lbE1hcFN0cmluZyA9IEZPQVJvdXRlci5DaGFubmVsTWFwLkRFRkFVTFQudG9TdHJpbmcoKTtcbiAgaWYgKGNoYW5uZWxNYXBTdHJpbmcgIT09IGRlZmF1bHRDaGFubmVsTWFwU3RyaW5nKSB7XG4gICAgVXRpbHMubG9nKCdSZW1hcHBpbmcgY2hhbm5lbHMgKFsnICsgZGVmYXVsdENoYW5uZWxNYXBTdHJpbmcgKyAnXSAtPiBbJ1xuICAgICAgKyBjaGFubmVsTWFwU3RyaW5nICsgJ10pJyk7XG4gIH1cblxuICB0aGlzLl9hdWRpb0VsZW1lbnRTb3VyY2UgPVxuICAgICAgdGhpcy5fY29udGV4dC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UodGhpcy5fdmlkZW9FbGVtZW50KTtcbiAgdGhpcy5fZm9hUm91dGVyID0gbmV3IEZPQVJvdXRlcih0aGlzLl9jb250ZXh0LCB0aGlzLl9jaGFubmVsTWFwKTtcbiAgdGhpcy5fZm9hUm90YXRvciA9IG5ldyBGT0FSb3RhdG9yKHRoaXMuX2NvbnRleHQpO1xuICB0aGlzLl9mb2FQaGFzZU1hdGNoZWRGaWx0ZXIgPSBuZXcgRk9BUGhhc2VNYXRjaGVkRmlsdGVyKHRoaXMuX2NvbnRleHQpO1xuXG4gIHRoaXMuX2F1ZGlvRWxlbWVudFNvdXJjZS5jb25uZWN0KHRoaXMuX2ZvYVJvdXRlci5pbnB1dCk7XG4gIHRoaXMuX2ZvYVJvdXRlci5vdXRwdXQuY29ubmVjdCh0aGlzLl9mb2FSb3RhdG9yLmlucHV0KTtcbiAgdGhpcy5fZm9hUm90YXRvci5vdXRwdXQuY29ubmVjdCh0aGlzLl9mb2FQaGFzZU1hdGNoZWRGaWx0ZXIuaW5wdXQpO1xuXG4gIHRoaXMuX2ZvYVZpcnR1YWxTcGVha2VycyA9IFtdO1xuXG4gIC8vIEJ5cGFzcyBzaWduYWwgcGF0aC5cbiAgdGhpcy5fYnlwYXNzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2F1ZGlvRWxlbWVudFNvdXJjZS5jb25uZWN0KHRoaXMuX2J5cGFzcyk7XG5cbiAgLy8gR2V0IHRoZSBsaW5lYXIgYW1wbGl0dWRlIGZyb20gdGhlIHBvc3QgZ2FpbiBvcHRpb24sIHdoaWNoIGlzIGluIGRlY2liZWwuXG4gIGNvbnN0IHBvc3RHYWluTGluZWFyID0gTWF0aC5wb3coMTAsIHRoaXMuX3Bvc3RHYWluREIvMjApO1xuICBVdGlscy5sb2coJ0dhaW4gY29tcGVuc2F0aW9uOiAnICsgcG9zdEdhaW5MaW5lYXIgKyAnICgnICsgdGhpcy5fcG9zdEdhaW5EQlxuICAgICsgJ2RCKScpO1xuXG4gIC8vIFRoaXMgcmV0dXJucyBhIHByb21pc2Ugc28gZGV2ZWxvcGVycyBjYW4gdXNlIHRoZSBkZWNvZGVyIHdoZW4gaXQgaXMgcmVhZHkuXG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbmV3IEF1ZGlvQnVmZmVyTWFuYWdlcih0aGF0Ll9jb250ZXh0LCB0aGF0Ll9zcGVha2VyRGF0YSxcbiAgICAgIGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGF0Ll9zcGVha2VyRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoYXQuX2ZvYVZpcnR1YWxTcGVha2Vyc1tpXSA9IG5ldyBGT0FWaXJ0dWFsU3BlYWtlcih0aGF0Ll9jb250ZXh0LCB7XG4gICAgICAgICAgICBjb2VmZmljaWVudHM6IHRoYXQuX3NwZWFrZXJEYXRhW2ldLmNvZWYsXG4gICAgICAgICAgICBJUjogYnVmZmVycy5nZXQodGhhdC5fc3BlYWtlckRhdGFbaV0ubmFtZSksXG4gICAgICAgICAgICBnYWluOiBwb3N0R2FpbkxpbmVhcixcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoYXQuX2ZvYVBoYXNlTWF0Y2hlZEZpbHRlci5vdXRwdXQuY29ubmVjdChcbiAgICAgICAgICAgIHRoYXQuX2ZvYVZpcnR1YWxTcGVha2Vyc1tpXS5pbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGRlY29kaW5nIG1vZGUuXG4gICAgICAgIHRoYXQuc2V0TW9kZSh0aGF0Ll9kZWNvZGluZ01vZGUpO1xuICAgICAgICB0aGF0Ll9pc0RlY29kZXJSZWFkeSA9IHRydWU7XG4gICAgICAgIFV0aWxzLmxvZygnSFJURiBJUnMgYXJlIGxvYWRlZCBzdWNjZXNzZnVsbHkuIFRoZSBkZWNvZGVyIGlzIHJlYWR5LicpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCByZWplY3QpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBzb3VuZCBmaWVsZCByb3RhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJvdGF0aW9uTWF0cml4ICAgICAgM3gzIHJvdGF0aW9uIG1hdHJpeCAocm93LW1ham9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcHJlc2VudGF0aW9uKVxuICovXG5GT0FEZWNvZGVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeCA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4KSB7XG4gIHRoaXMuX2ZvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXgocm90YXRpb25NYXRyaXgpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgcm90YXRpb24gbWF0cml4IGZyb20gYSBUaHJlZS5qcyBjYW1lcmEgb2JqZWN0LlxuICogQHBhcmFtICB7T2JqZWN0fSBjYW1lcmFNYXRyaXggICAgICBUaGUgTWF0cml4NCBvYmVqY3Qgb2YgVGhyZWUuanMgdGhlIGNhbWVyYS5cbiAqL1xuRk9BRGVjb2Rlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXhGcm9tQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhTWF0cml4KSB7XG4gIC8vIEV4dHJhY3QgdGhlIGlubmVyIGFycmF5IGVsZW1lbnRzIGFuZCBpbnZlcnNlLiAoVGhlIGFjdHVhbCB2aWV3IHJvdGF0aW9uIGlzXG4gIC8vIHRoZSBvcHBvc2l0ZSBvZiB0aGUgY2FtZXJhIG1vdmVtZW50LilcbiAgVXRpbHMuaW52ZXJ0TWF0cml4NCh0aGlzLl90ZW1wTWF0cml4NCwgY2FtZXJhTWF0cml4LmVsZW1lbnRzKTtcbiAgdGhpcy5fZm9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDQodGhpcy5fdGVtcE1hdHJpeDQpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlY29kaW5nIG1vZGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kZSAgICAgICAgICAgICAgIERlY29kaW5nIG1vZGUuIFdoZW4gdGhlIG1vZGUgaXMgJ2J5cGFzcydcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRlY29kZXIgaXMgZGlzYWJsZWQgYW5kIGJ5cGFzcyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgc3RyZWFtIHRvIHRoZSBvdXRwdXQuIFNldHRpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgdG8gJ2FtYmlzb25pYycgYWN0aXZhdGVzIHRoZSBkZWNvZGVyLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHRoZSBtb2RlIGlzICdvZmYnLCBhbGwgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgaXMgY29tcGxldGVseSB0dXJuZWQgb2ZmIHNhdmluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgQ1BVIHBvd2VyLlxuICovXG5GT0FEZWNvZGVyLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICBpZiAobW9kZSA9PT0gdGhpcy5fZGVjb2RpbmdNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnYnlwYXNzJzpcbiAgICAgIHRoaXMuX2RlY29kaW5nTW9kZSA9ICdieXBhc3MnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzW2ldLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2J5cGFzcy5jb25uZWN0KHRoaXMuX2NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhbWJpc29uaWMnOlxuICAgICAgdGhpcy5fZGVjb2RpbmdNb2RlID0gJ2FtYmlzb25pYyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnNbaV0uZW5hYmxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvZmYnOlxuICAgICAgdGhpcy5fZGVjb2RpbmdNb2RlID0gJ29mZic7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnNbaV0uZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgVXRpbHMubG9nKCdEZWNvZGluZyBtb2RlIGNoYW5nZWQuICgnICsgbW9kZSArICcpJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQURlY29kZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBkYXRhIGZvciBGT0FWaXJ0dWFsU3BlYWtlci4gRWFjaCBlbnRyeSBjb250YWlucyB0aGUgVVJMIGZvciBJUiBmaWxlcyBhbmRcbiAqIHRoZSBnYWluIGNvZWZmaWNpZW50cyBmb3IgdGhlIGFzc29jaWF0ZWQgSVIgZmlsZXMuIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2ZcbiAqIGNvZWZmaWNpZW50cyBmb2xsb3dzIHRoZSBBQ04gY2hhbm5lbCBvcmRlcmluZy4gKFcsWSxaLFgpXG4gKiBAdHlwZSB7T2JqZWN0W119XG4gKi9cbmNvbnN0IEZPQVNwZWFrZXJEYXRhID0gW3tcbiAgbmFtZTogJ0UzNV9BMTM1JyxcbiAgdXJsOiAnRTM1X0ExMzUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAwLjIxNjQ5NSwgMC4yMTY1MywgLTAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UzNV9BLTEzNScsXG4gIHVybDogJ0UzNV9BLTEzNS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIC0wLjIxNjQ5NSwgMC4yMTY1MywgLTAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UtMzVfQTEzNScsXG4gIHVybDogJ0UtMzVfQTEzNS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIDAuMjE2NDk1LCAtMC4yMTY1MywgLTAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UtMzVfQS0xMzUnLFxuICB1cmw6ICdFLTM1X0EtMTM1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgLTAuMjE2NDk1LCAtMC4yMTY1MywgLTAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UzNV9BNDUnLFxuICB1cmw6ICdFMzVfQTQ1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgMC4yMTY0OTUsIDAuMjE2NTMsIDAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UzNV9BLTQ1JyxcbiAgdXJsOiAnRTM1X0EtNDUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAtMC4yMTY0OTUsIDAuMjE2NTMsIDAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UtMzVfQTQ1JyxcbiAgdXJsOiAnRS0zNV9BNDUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAwLjIxNjQ5NSwgLTAuMjE2NTMsIDAuMjE2NDk1XSxcbn0sIHtcbiAgbmFtZTogJ0UtMzVfQS00NScsXG4gIHVybDogJ0UtMzVfQS00NS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIC0wLjIxNjQ5NSwgLTAuMjE2NTMsIDAuMjE2NDk1XSxcbn1dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BU3BlYWtlckRhdGE7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgRk9BUmVuZGVyZXIuIFRoaXMgaXMgdXNlci1mYWNpbmcgQVBJIGZvciB0aGUgZmlyc3Qtb3JkZXJcbiAqIGFtYmlzb25pYyBkZWNvZGVyIGFuZCB0aGUgb3B0aW1pemVkIGJpbmF1cmFsIHJlbmRlcmVyLlxuICovXG5cblxuXG5jb25zdCBCdWZmZXJMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IEZPQUNvbnZvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5jb25zdCBGT0FIcmlyQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5jb25zdCBGT0FSb3RhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvbnN0IEZPQVJvdXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBSZW5kZXJpbmdNb2RlXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJpbmcgbW9kZSBFTlVNLlxuICogQGVudW0ge1JlbmRlcmluZ01vZGV9XG4gKi9cbmNvbnN0IFJlbmRlcmluZ01vZGUgPSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBVc2UgYW1iaXNvbmljIHJlbmRlcmluZy4gKi9cbiAgQU1CSVNPTklDOiAnYW1iaXNvbmljJyxcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IEJ5cGFzcy4gTm8gYW1iaXNvbmljIHJlbmRlcmluZy4gKi9cbiAgQllQQVNTOiAnYnlwYXNzJyxcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IERpc2FibGUgYXVkaW8gb3V0cHV0LiAqL1xuICBPRkY6ICdvZmYnLFxufTtcblxuXG4vKipcbiAqIE9tbml0b25lIEZPQSByZW5kZXJlciBjbGFzcy4gVXNlcyB0aGUgb3B0aW1pemVkIGNvbnZvbHV0aW9uIHRlY2huaXF1ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuY2hhbm5lbE1hcF0gLSBDdXN0b20gY2hhbm5lbCByb3V0aW5nIG1hcC4gVXNlZnVsIGZvclxuICogaGFuZGxpbmcgdGhlIGluY29uc2lzdGVuY3kgaW4gYnJvd3NlcidzIG11bHRpY2hhbm5lbCBhdWRpbyBkZWNvZGluZy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuaHJpclBhdGhMaXN0XSAtIEEgbGlzdCBvZiBwYXRocyB0byBIUklSIGZpbGVzLiBJdFxuICogb3ZlcnJpZGVzIHRoZSBpbnRlcm5hbCBIUklSIGxpc3QgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IFtjb25maWcucmVuZGVyaW5nTW9kZT0nYW1iaXNvbmljJ10gLSBSZW5kZXJpbmcgbW9kZS5cbiAqL1xuZnVuY3Rpb24gRk9BUmVuZGVyZXIoY29udGV4dCwgY29uZmlnKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBVdGlscy5pc0F1ZGlvQ29udGV4dChjb250ZXh0KSA/XG4gICAgICBjb250ZXh0IDpcbiAgICAgIFV0aWxzLnRocm93KCdGT0FSZW5kZXJlcjogSW52YWxpZCBCYXNlQXVkaW9Db250ZXh0LicpO1xuXG4gIHRoaXMuX2NvbmZpZyA9IHtcbiAgICBjaGFubmVsTWFwOiBGT0FSb3V0ZXIuQ2hhbm5lbE1hcC5ERUZBVUxULFxuICAgIHJlbmRlcmluZ01vZGU6IFJlbmRlcmluZ01vZGUuQU1CSVNPTklDLFxuICB9O1xuXG4gIGlmIChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLmNoYW5uZWxNYXApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5jaGFubmVsTWFwKSAmJiBjb25maWcuY2hhbm5lbE1hcC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLmNoYW5uZWxNYXAgPSBjb25maWcuY2hhbm5lbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLnRocm93KFxuICAgICAgICAgICAgJ0ZPQVJlbmRlcmVyOiBJbnZhbGlkIGNoYW5uZWwgbWFwLiAoZ290ICcgKyBjb25maWcuY2hhbm5lbE1hcFxuICAgICAgICAgICAgKyAnKScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maWcuaHJpclBhdGhMaXN0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuaHJpclBhdGhMaXN0KSAmJlxuICAgICAgICAgIGNvbmZpZy5ocmlyUGF0aExpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXRoTGlzdCA9IGNvbmZpZy5ocmlyUGF0aExpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlscy50aHJvdyhcbiAgICAgICAgICAgICdGT0FSZW5kZXJlcjogSW52YWxpZCBIUklSIFVSTHMuIEl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAnICtcbiAgICAgICAgICAgICcyIFVSTHMgdG8gSFJJUiBmaWxlcy4gKGdvdCAnICsgY29uZmlnLmhyaXJQYXRoTGlzdCArICcpJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5yZW5kZXJpbmdNb2RlKSB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhSZW5kZXJpbmdNb2RlKS5pbmNsdWRlcyhjb25maWcucmVuZGVyaW5nTW9kZSkpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgPSBjb25maWcucmVuZGVyaW5nTW9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLmxvZyhcbiAgICAgICAgICAgICdGT0FSZW5kZXJlcjogSW52YWxpZCByZW5kZXJpbmcgbW9kZSBvcmRlci4gKGdvdCcgK1xuICAgICAgICAgICAgY29uZmlnLnJlbmRlcmluZ01vZGUgKyAnKSBGYWxsYmFja3MgdG8gdGhlIG1vZGUgXCJhbWJpc29uaWNcIi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9idWlsZEF1ZGlvR3JhcGgoKTtcblxuICB0aGlzLl90ZW1wTWF0cml4NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICB0aGlzLl9pc1JlbmRlcmVyUmVhZHkgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgaW50ZXJuYWwgYXVkaW8gZ3JhcGguXG4gKiBAcHJpdmF0ZVxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuX2J1aWxkQXVkaW9HcmFwaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlucHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2J5cGFzcyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9mb2FSb3V0ZXIgPSBuZXcgRk9BUm91dGVyKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwKTtcbiAgdGhpcy5fZm9hUm90YXRvciA9IG5ldyBGT0FSb3RhdG9yKHRoaXMuX2NvbnRleHQpO1xuICB0aGlzLl9mb2FDb252b2x2ZXIgPSBuZXcgRk9BQ29udm9sdmVyKHRoaXMuX2NvbnRleHQpO1xuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZm9hUm91dGVyLmlucHV0KTtcbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2J5cGFzcyk7XG4gIHRoaXMuX2ZvYVJvdXRlci5vdXRwdXQuY29ubmVjdCh0aGlzLl9mb2FSb3RhdG9yLmlucHV0KTtcbiAgdGhpcy5fZm9hUm90YXRvci5vdXRwdXQuY29ubmVjdCh0aGlzLl9mb2FDb252b2x2ZXIuaW5wdXQpO1xuICB0aGlzLl9mb2FDb252b2x2ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gIHRoaXMuaW5wdXQuY2hhbm5lbENvdW50ID0gNDtcbiAgdGhpcy5pbnB1dC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0JztcbiAgdGhpcy5pbnB1dC5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSAnZGlzY3JldGUnO1xufTtcblxuXG4vKipcbiAqIEludGVybmFsIGNhbGxiYWNrIGhhbmRsZXIgZm9yIHxpbml0aWFsaXplfCBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZSAtIFJlc29sdXRpb24gaGFuZGxlci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlamVjdCAtIFJlamVjdGlvbiBoYW5kbGVyLlxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuX2luaXRpYWxpemVDYWxsYmFjayA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICBjb25zdCBidWZmZXJMaXN0ID0gdGhpcy5fY29uZmlnLnBhdGhMaXN0XG4gICAgICA/IG5ldyBCdWZmZXJMaXN0KHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbmZpZy5wYXRoTGlzdCwge2RhdGFUeXBlOiAndXJsJ30pXG4gICAgICA6IG5ldyBCdWZmZXJMaXN0KHRoaXMuX2NvbnRleHQsIEZPQUhyaXJCYXNlNjQpO1xuICBidWZmZXJMaXN0LmxvYWQoKS50aGVuKFxuICAgICAgZnVuY3Rpb24oaHJpckJ1ZmZlckxpc3QpIHtcbiAgICAgICAgdGhpcy5fZm9hQ29udm9sdmVyLnNldEhSSVJCdWZmZXJMaXN0KGhyaXJCdWZmZXJMaXN0KTtcbiAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdNb2RlKHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlKTtcbiAgICAgICAgdGhpcy5faXNSZW5kZXJlclJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgVXRpbHMubG9nKCdGT0FSZW5kZXJlcjogSFJJUnMgbG9hZGVkIHN1Y2Nlc3NmdWxseS4gUmVhZHkuJyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRk9BUmVuZGVyZXI6IEhSSVIgbG9hZGluZy9kZWNvZGluZyBmYWlsZWQuJztcbiAgICAgICAgVXRpbHMudGhyb3coZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbmQgbG9hZHMgdGhlIHJlc291cmNlIGZvciB0aGUgcmVuZGVyZXIuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICBVdGlscy5sb2coXG4gICAgICAnRk9BUmVuZGVyZXI6IEluaXRpYWxpemluZy4uLiAobW9kZTogJyArIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlICtcbiAgICAgICcpJyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHRoaXMuX2luaXRpYWxpemVDYWxsYmFjay5iaW5kKHRoaXMpLCBmdW5jdGlvbihlcnJvcikge1xuICAgIFV0aWxzLnRocm93KCdGT0FSZW5kZXJlcjogSW5pdGlhbGl6YXRpb24gZmFpbGVkLiAoJyArIGVycm9yICsgJyknKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBjaGFubmVsIG1hcC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGNoYW5uZWxNYXAgLSBDdXN0b20gY2hhbm5lbCByb3V0aW5nIGZvciBGT0Egc3RyZWFtLlxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Q2hhbm5lbE1hcCA9IGZ1bmN0aW9uKGNoYW5uZWxNYXApIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hhbm5lbE1hcC50b1N0cmluZygpICE9PSB0aGlzLl9jb25maWcuY2hhbm5lbE1hcC50b1N0cmluZygpKSB7XG4gICAgVXRpbHMubG9nKFxuICAgICAgICAnUmVtYXBwaW5nIGNoYW5uZWxzIChbJyArIHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwLnRvU3RyaW5nKCkgK1xuICAgICAgICAnXSAtPiBbJyArIGNoYW5uZWxNYXAudG9TdHJpbmcoKSArICddKS4nKTtcbiAgICB0aGlzLl9jb25maWcuY2hhbm5lbE1hcCA9IGNoYW5uZWxNYXAuc2xpY2UoKTtcbiAgICB0aGlzLl9mb2FSb3V0ZXIuc2V0Q2hhbm5lbE1hcCh0aGlzLl9jb25maWcuY2hhbm5lbE1hcCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCAzeDMgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXgzIC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXgzKSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZm9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDMocm90YXRpb25NYXRyaXgzKTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCA0eDQgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXg0IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXg0KSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fZm9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDQocm90YXRpb25NYXRyaXg0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJvdGF0aW9uIG1hdHJpeCBmcm9tIGEgVGhyZWUuanMgY2FtZXJhIG9iamVjdC4gRGVwcmVhdGVkIGluIFYxLCBhbmRcbiAqIHRoaXMgZXhpc3RzIG9ubHkgZm9yIHRoZSBiYWNrd2FyZCBjb21wYXRpYmxpdHkuIEluc3RlYWQsIHVzZVxuICogfHNldFJvdGF0YXRpb25NYXRyaXg0KCl8IHdpdGggVGhyZWUuanMgfGNhbWVyYS53b3JsZE1hdHJpeC5lbGVtZW50c3wuXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGNhbWVyYU1hdHJpeCAtIE1hdHJpeDQgZnJvbSBUaHJlZS5qcyB8Y2FtZXJhLm1hdHJpeHwuXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeEZyb21DYW1lcmEgPSBmdW5jdGlvbihjYW1lcmFNYXRyaXgpIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBFeHRyYWN0IHRoZSBpbm5lciBhcnJheSBlbGVtZW50cyBhbmQgaW52ZXJzZS4gKFRoZSBhY3R1YWwgdmlldyByb3RhdGlvbiBpc1xuICAvLyB0aGUgb3Bwb3NpdGUgb2YgdGhlIGNhbWVyYSBtb3ZlbWVudC4pXG4gIFV0aWxzLmludmVydE1hdHJpeDQodGhpcy5fdGVtcE1hdHJpeDQsIGNhbWVyYU1hdHJpeC5lbGVtZW50cyk7XG4gIHRoaXMuX2ZvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXg0KHRoaXMuX3RlbXBNYXRyaXg0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJlbmRlcmluZyBtb2RlLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBtb2RlIC0gUmVuZGVyaW5nIG1vZGUuXG4gKiAgLSAnYW1iaXNvbmljJzogYWN0aXZhdGVzIHRoZSBhbWJpc29uaWMgZGVjb2RpbmcvYmluYXVybCByZW5kZXJpbmcuXG4gKiAgLSAnYnlwYXNzJzogYnlwYXNzZXMgdGhlIGlucHV0IHN0cmVhbSBkaXJlY3RseSB0byB0aGUgb3V0cHV0LiBObyBhbWJpc29uaWNcbiAqICAgIGRlY29kaW5nIG9yIGVuY29kaW5nLlxuICogIC0gJ29mZic6IGFsbCB0aGUgcHJvY2Vzc2luZyBvZmYgc2F2aW5nIHRoZSBDUFUgcG93ZXIuXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSZW5kZXJpbmdNb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICBpZiAobW9kZSA9PT0gdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuQU1CSVNPTklDOlxuICAgICAgdGhpcy5fZm9hQ29udm9sdmVyLmVuYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5CWVBBU1M6XG4gICAgICB0aGlzLl9mb2FDb252b2x2ZXIuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLk9GRjpcbiAgICAgIHRoaXMuX2ZvYUNvbnZvbHZlci5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIFV0aWxzLmxvZyhcbiAgICAgICAgICAnRk9BUmVuZGVyZXI6IFJlbmRlcmluZyBtb2RlIFwiJyArIG1vZGUgKyAnXCIgaXMgbm90ICcgK1xuICAgICAgICAgICdzdXBwb3J0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIFV0aWxzLmxvZygnRk9BUmVuZGVyZXI6IFJlbmRlcmluZyBtb2RlIGNoYW5nZWQuICgnICsgbW9kZSArICcpJyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BUmVuZGVyZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5jb25zdCBPbW5pdG9uZUZPQUhyaXJCYXNlNjQgPSBbXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFEKy93SUE5djhRQVB2L0N3RCsvd2NBL3Y4TUFQLy9BUUQ3L3dFQUNBQUVBUGovK3Y4WUFCQUE3di9uLy92LzlQL00vOEQvL2YzNC9SMzhFdnp4QWZFQnRBMmxEVGNCSlFGSjlUNzFGUDBEL2NEMXRmVm8vV3Y5dVBUTzlQUG1PdWZjL1UvK2FnTDNBaXNjL1J4dUdLRVpCdjNqL2lZTXpRMmdBenNFUVFVQUJpUUZyQVN6QTVjQjJRbXlDeTBBdGdSNEFlWUd0ZmdBQTJqNU9RSFArc2NBclBzTUJKZ0VnZ0lFQnR6NitRVnEvcGovYVBnOEJQUDNnUUVpK2pFQW9mMGZBMXY5Ky83Uys4SUJqdndkL3hENElBREwvUGY5enZzKy9sMyt3Z0I3LytMKzdmekZBREg5a2Y2QStuMytEUDYrL1RQOXhQNjgvcG4rdy8yNi9pMzlZZ0EwL3U3OTBQdDkva0QrN3Yxcy9XYis4ZjRDLzFQK3BmL3gvY1QrNi8zcC9YejlmZjVGLzBmOUcvNHIvNnYvNFA1TC9zTCtmZjdjL3BqK092N1gvVVQrOVA1Ry9veis2djZBLzJEKzkvNlAvOHIvYlA3bS9paitDLy9lL3RqL0dmNGUvOXYrRndEUC9sei9zUDdGLzJIK3J2L0cvczcvSGY3eS80UCtOQUQ5L2swQUsvNncvelAvaEFDaC9zWC9nZjQ0QU9QK2RnQ20vaVVBay81cUFPRCtQd0MrL2pFQVdQNENBQXIvYlFCdy92di96ZjVpQUNEL09nQ1MvdUQvQ3Y5b0FBYi9DZ0RLL2t3QS8vNXRBQ0gvVGdDZy9oNEFIUDlhQUJQL0pBRFAvaEVBWXY5Z0FBai8zZjhtL3lzQVl2OGdBQ1gvOC84ay95c0FYdjhiQUJILy92OGoveWdBYS84cUFBRC85ZjlnLzFZQVdmOEpBQ0gvQWdCMi96NEFYUC93L3ozL0ZnQjIveWtBWC8vOS96Ly9Fd0NWL3pVQVMvL24vMVQvR0FDSy94NEFUdi8wLzRQL1FRQjQvL3YvV1AvMi8zWC9IQUI4Ly9QL1YvLzMvMmYvQVFCaC85di9UZi94LzVQL0l3Q0kvd01BZi84aEFLUC9KQUNaL3hVQWl2OG5BSy8vSGdDci95TUFtLzh1QU16L09BQ2kveVFBcWY4N0FNVC9Nd0NZL3lVQXRQOUZBTUgvS2dDdS95Y0F5UDg1QU12L0l3Q3oveG9BMWY4cUFNbi9GZ0M4L3hRQTQvOG5BTVgvQ3dESi94UUE0ZjhaQU1IL0JnRE8veFFBNGY4V0FNUC9Cd0RVL3hRQTRQOFFBTUgvQVFEYi94UUEzUDhKQU1QL0FnRGgveElBMnY4RUFNai9BZ0RrL3cwQTFmLysvOHYvQXdEbS93d0Ewdi8rLzlIL0JnRGwvd2tBenYvOC85VC9Cd0RrL3djQXp2LzgvOXIvQ1FEaS93UUF6Zi84LzkvL0NBRGYvLy8vMFAvOS8rTC9Cd0RkLy83LzAvLy8vK1QvQmdEYi8vei8xZjhBQU9mL0JRRFovL3YvMnY4Q0FPYi9Bd0RZLy92LzN2OEVBT2IvQWdEWS8vMy80ZjhGQU9YL0FRRFovLzcvNVA4R0FPUC9BQURiL3dBQTUvOEdBT0gvLy8vZC93SUE1LzhGQU9ELy8vL2Yvd01BNlA4RkFPRC8vLy9oL3dRQTZQOEVBTjcvLy8vaC93VUE0djhEQU52L0FRRGQvd1FBM1A4Q0FObi9BZ0RiL3dNQTIvOENBTnYvQWdEZC93SUEzdjhDQU9IL0FRRGovd0VBXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFBQUFBQUEvZjhDQVAvL0FRRC8vd0VBLy84QkFQMy9BQUFDQVA3LytmOEFBQUlBL1A4RkFBUUE4LzhBQUJvQStmL1Yvd1FBSFFETy94b0FRUUJPL29jQTBQeDEvdWNIVy80VUNtOEhMTzZrQWp2OC9mQ1JEZEFBWWZQaUJJZ0ZYdmVVQ00wR0J2aDYvbno3cmYwSi9RY1FTUlZkQmdvQlNnRlI2MnI5TlA4bStMb0VBdnJpQlZBQWlBUG1BQkVHTWYybCtTd0JqdmE2L0c0QS8vOFAvQ1lETWdYbS9SMENLQUU2L2ZjQkJ3QXRBTkQra1FBMEE1VURod0ZzLzhJQjhmeWRBRVAvQS84di9lNy9tUDhqLzJZQkl3RTNBdjBBWXYrdUFPRDhsZ0FnL3d3QUlmL0wvbjBBZS8vT0FKTUIzUC9YQUYvL1h3Q00vMDhBQi84TkFFZi9yZjRqQVQzL2xnQUpBUDRBSGdEcEFPOEFVZjlMLzA3L1FmOEtBT0QveC8rRC8zc0FUUUNEQU1vQTBmNzkvK0wvRVFEdC83RUFxditTLzdJQXV2L28vd2dBYy8vWC8vSC9Td0NtLyszL1lmL0IveW9BQUFESS83WC9Bd0JnLzVFQVRnQ1gveFlBL1ArcS8wMEFWQUNZLzZ2L0JBREQvendBTFFDTi84ei9LUUR1L3lnQUVnQ1ovNmYvVlFEQy8vVC9LUUNzLzdQL1VnQWZBTzcvTmdDOC81Ny9hd0FaQVBQLytQL1YvOHovYlFCQkFMLy9EZ0QwLytUL1RBQkJBTXovQ3dBeEFQei9TUUJxQUxuL0JnQUxBUHovRUFBN0FJei8zLzhpQUFVQS8vOGtBTGYveS85VkFCUUErdjgxQU9qLzBQOWNBQjRBK2Y4V0FPci92djgzQUJnQXcvOEpBT2ovNGY4bkFDSUFzZi95L3c0QTN2OGdBQ1FBeFAvbi95Y0E3UDhXQUMwQXlmL1UveWNBOXYvNy95VUEwUC9QL3pVQUJBRGMveFVBNVAvSi96Y0FDd0RTL3hVQTlQL20vekFBQ1FEWC8rMy85di8yL3lRQUNnRFovK1AvQXdBS0FCWUEvLy9iLzlqL0VRQUxBQmtBRGdENi8rNy9Hd0Q0L3c0QThQL3cvL2ovRWdBRUFBVUE5Zi8xL3dRQUdnRDQvd0FBNS8vLy93QUFHUUQxLy8vLzdmOEZBQVVBRlFEdi93QUE2djhMQUFjQUZRRHMvd0VBOVA4U0FBWUFDd0RyLy83L0FRQVNBQVlBQlFEdi93SUFBd0FXQUFJQUFnRHYvd0FBQmdBVEFBRUEvZi91L3dRQUJnQVFBUHIvK1Avei93VUFDUUFMQVBqLzkvLzQvd2dBQndBS0FQVC8rZi81L3c0QUJ3QUlBUFQvKy8vOS93NEFBd0FEQVBILy9mLy8vdzhBLy84QkFQUC8vLzhCQUEwQS9mLysvL1gvQWdBQ0FBMEErLy84Ly9iL0JBQURBQW9BK2YvNy8vbi9CZ0FEQUFjQStQLzcvL3YvQndBQkFBUUErUC84Ly8zL0NRQUJBQUlBOS8vOS8vLy9DUUQvLy8vLytQLy8vd0FBQ0FEOS8vNy8rZjhBQUFBQUJ3RDgvLzMvK3Y4Q0FBQUFCZ0Q3Ly96Ly9QOEVBQUFBQkFENi8vMy8vUDhGQVAvL0FnRDYvLzcvL3Y4RkFQNy9BUUQ3Ly8vLy8vOEdBUDcvQUFENy93RUEvLzhFQVAzL0FBRDkvd0VBL3Y4REFQMy9BQUQ5L3dJQS92OENBUDMvQVFEOS93SUEvdjhDQVA3L0FRRCsvd0VBXCIsXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9tbml0b25lRk9BSHJpckJhc2U2NDtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSBIT0FSZW5kZXJlci4gVGhpcyBpcyB1c2VyLWZhY2luZyBBUEkgZm9yIHRoZSBoaWdoZXItb3JkZXJcbiAqIGFtYmlzb25pYyBkZWNvZGVyIGFuZCB0aGUgb3B0aW1pemVkIGJpbmF1cmFsIHJlbmRlcmVyLlxuICovXG5cblxuXG5jb25zdCBCdWZmZXJMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IEhPQUNvbnZvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5jb25zdCBIT0FSb3RhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmNvbnN0IFRPQUhyaXJCYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbmNvbnN0IFNPQUhyaXJCYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFJlbmRlcmluZ01vZGVcbiAqL1xuXG4vKipcbiAqIFJlbmRlcmluZyBtb2RlIEVOVU0uXG4gKiBAZW51bSB7UmVuZGVyaW5nTW9kZX1cbiAqL1xuY29uc3QgUmVuZGVyaW5nTW9kZSA9IHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IFVzZSBhbWJpc29uaWMgcmVuZGVyaW5nLiAqL1xuICBBTUJJU09OSUM6ICdhbWJpc29uaWMnLFxuICAvKiogQHR5cGUge3N0cmluZ30gQnlwYXNzLiBObyBhbWJpc29uaWMgcmVuZGVyaW5nLiAqL1xuICBCWVBBU1M6ICdieXBhc3MnLFxuICAvKiogQHR5cGUge3N0cmluZ30gRGlzYWJsZSBhdWRpbyBvdXRwdXQuICovXG4gIE9GRjogJ29mZicsXG59O1xuXG5cbi8vIEN1cnJlbnRseSBTT0EgYW5kIFRPQSBhcmUgb25seSBzdXBwb3J0ZWQuXG5jb25zdCBTdXBwb3J0ZWRBbWJpc29uaWNPcmRlciA9IFsyLCAzXTtcblxuXG4vKipcbiAqIE9tbml0b25lIEhPQSByZW5kZXJlciBjbGFzcy4gVXNlcyB0aGUgb3B0aW1pemVkIGNvbnZvbHV0aW9uIHRlY2huaXF1ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmFtYmlzb25pY09yZGVyPTNdIC0gQW1iaXNvbmljIG9yZGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5ocmlyUGF0aExpc3RdIC0gQSBsaXN0IG9mIHBhdGhzIHRvIEhSSVIgZmlsZXMuIEl0XG4gKiBvdmVycmlkZXMgdGhlIGludGVybmFsIEhSSVIgbGlzdCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gW2NvbmZpZy5yZW5kZXJpbmdNb2RlPSdhbWJpc29uaWMnXSAtIFJlbmRlcmluZyBtb2RlLlxuICovXG5mdW5jdGlvbiBIT0FSZW5kZXJlcihjb250ZXh0LCBjb25maWcpIHtcbiAgdGhpcy5fY29udGV4dCA9IFV0aWxzLmlzQXVkaW9Db250ZXh0KGNvbnRleHQpID9cbiAgICAgIGNvbnRleHQgOlxuICAgICAgVXRpbHMudGhyb3coJ0hPQVJlbmRlcmVyOiBJbnZhbGlkIEJhc2VBdWRpb0NvbnRleHQuJyk7XG5cbiAgdGhpcy5fY29uZmlnID0ge1xuICAgIGFtYmlzb25pY09yZGVyOiAzLFxuICAgIHJlbmRlcmluZ01vZGU6IFJlbmRlcmluZ01vZGUuQU1CSVNPTklDLFxuICB9O1xuXG4gIGlmIChjb25maWcgJiYgY29uZmlnLmFtYmlzb25pY09yZGVyKSB7XG4gICAgaWYgKFN1cHBvcnRlZEFtYmlzb25pY09yZGVyLmluY2x1ZGVzKGNvbmZpZy5hbWJpc29uaWNPcmRlcikpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlciA9IGNvbmZpZy5hbWJpc29uaWNPcmRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICdIT0FSZW5kZXJlcjogSW52YWxpZCBhbWJpc29uaWMgb3JkZXIuIChnb3QgJyArXG4gICAgICAgICAgY29uZmlnLmFtYmlzb25pY09yZGVyICsgJykgRmFsbGJhY2tzIHRvIDNyZC1vcmRlciBhbWJpc29uaWMuJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY29uZmlnLm51bWJlck9mQ2hhbm5lbHMgPVxuICAgICAgKHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlciArIDEpICogKHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlciArIDEpO1xuICB0aGlzLl9jb25maWcubnVtYmVyT2ZTdGVyZW9DaGFubmVscyA9XG4gICAgICBNYXRoLmNlaWwodGhpcy5fY29uZmlnLm51bWJlck9mQ2hhbm5lbHMgLyAyKTtcblxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5ocmlyUGF0aExpc3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuaHJpclBhdGhMaXN0KSAmJlxuICAgICAgICBjb25maWcuaHJpclBhdGhMaXN0Lmxlbmd0aCA9PT0gdGhpcy5fY29uZmlnLm51bWJlck9mU3RlcmVvQ2hhbm5lbHMpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5wYXRoTGlzdCA9IGNvbmZpZy5ocmlyUGF0aExpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLnRocm93KFxuICAgICAgICAgICdIT0FSZW5kZXJlcjogSW52YWxpZCBIUklSIFVSTHMuIEl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAnICtcbiAgICAgICAgICB0aGlzLl9jb25maWcubnVtYmVyT2ZTdGVyZW9DaGFubmVscyArICcgVVJMcyB0byBIUklSIGZpbGVzLicgK1xuICAgICAgICAgICcgKGdvdCAnICsgY29uZmlnLmhyaXJQYXRoTGlzdCArICcpJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbmZpZyAmJiBjb25maWcucmVuZGVyaW5nTW9kZSkge1xuICAgIGlmIChPYmplY3QudmFsdWVzKFJlbmRlcmluZ01vZGUpLmluY2x1ZGVzKGNvbmZpZy5yZW5kZXJpbmdNb2RlKSkge1xuICAgICAgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgPSBjb25maWcucmVuZGVyaW5nTW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICdIT0FSZW5kZXJlcjogSW52YWxpZCByZW5kZXJpbmcgbW9kZS4gKGdvdCAnICtcbiAgICAgICAgICBjb25maWcucmVuZGVyaW5nTW9kZSArICcpIEZhbGxiYWNrcyB0byBcImFtYmlzb25pY1wiLicpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2J1aWxkQXVkaW9HcmFwaCgpO1xuXG4gIHRoaXMuX2lzUmVuZGVyZXJSZWFkeSA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogQnVpbGRzIHRoZSBpbnRlcm5hbCBhdWRpbyBncmFwaC5cbiAqIEBwcml2YXRlXG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5fYnVpbGRBdWRpb0dyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fYnlwYXNzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2hvYVJvdGF0b3IgPSBuZXcgSE9BUm90YXRvcih0aGlzLl9jb250ZXh0LCB0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIpO1xuICB0aGlzLl9ob2FDb252b2x2ZXIgPVxuICAgICAgbmV3IEhPQUNvbnZvbHZlcih0aGlzLl9jb250ZXh0LCB0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIpO1xuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5faG9hUm90YXRvci5pbnB1dCk7XG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9ieXBhc3MpO1xuICB0aGlzLl9ob2FSb3RhdG9yLm91dHB1dC5jb25uZWN0KHRoaXMuX2hvYUNvbnZvbHZlci5pbnB1dCk7XG4gIHRoaXMuX2hvYUNvbnZvbHZlci5vdXRwdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgdGhpcy5pbnB1dC5jaGFubmVsQ291bnQgPSB0aGlzLl9jb25maWcubnVtYmVyT2ZDaGFubmVscztcbiAgdGhpcy5pbnB1dC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0JztcbiAgdGhpcy5pbnB1dC5jaGFubmVsSW50ZXJwcmV0YXRpb24gPSAnZGlzY3JldGUnO1xufTtcblxuXG4vKipcbiAqIEludGVybmFsIGNhbGxiYWNrIGhhbmRsZXIgZm9yIHxpbml0aWFsaXplfCBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVzb2x2ZSAtIFJlc29sdXRpb24gaGFuZGxlci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlamVjdCAtIFJlamVjdGlvbiBoYW5kbGVyLlxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuX2luaXRpYWxpemVDYWxsYmFjayA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICBsZXQgYnVmZmVyTGlzdDtcbiAgaWYgKHRoaXMuX2NvbmZpZy5wYXRoTGlzdCkge1xuICAgIGJ1ZmZlckxpc3QgPVxuICAgICAgICBuZXcgQnVmZmVyTGlzdCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb25maWcucGF0aExpc3QsIHtkYXRhVHlwZTogJ3VybCd9KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXJMaXN0ID0gdGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyID09PSAyXG4gICAgICAgID8gbmV3IEJ1ZmZlckxpc3QodGhpcy5fY29udGV4dCwgU09BSHJpckJhc2U2NClcbiAgICAgICAgOiBuZXcgQnVmZmVyTGlzdCh0aGlzLl9jb250ZXh0LCBUT0FIcmlyQmFzZTY0KTtcbiAgfVxuXG4gIGJ1ZmZlckxpc3QubG9hZCgpLnRoZW4oXG4gICAgICBmdW5jdGlvbihocmlyQnVmZmVyTGlzdCkge1xuICAgICAgICB0aGlzLl9ob2FDb252b2x2ZXIuc2V0SFJJUkJ1ZmZlckxpc3QoaHJpckJ1ZmZlckxpc3QpO1xuICAgICAgICB0aGlzLnNldFJlbmRlcmluZ01vZGUodGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUpO1xuICAgICAgICB0aGlzLl9pc1JlbmRlcmVyUmVhZHkgPSB0cnVlO1xuICAgICAgICBVdGlscy5sb2coJ0hPQVJlbmRlcmVyOiBIUklScyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LiBSZWFkeS4nKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdIT0FSZW5kZXJlcjogSFJJUiBsb2FkaW5nL2RlY29kaW5nIGZhaWxlZC4nO1xuICAgICAgICBVdGlscy50aHJvdyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuZCBsb2FkcyB0aGUgcmVzb3VyY2UgZm9yIHRoZSByZW5kZXJlci5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIFV0aWxzLmxvZyhcbiAgICAgICdIT0FSZW5kZXJlcjogSW5pdGlhbGl6aW5nLi4uIChtb2RlOiAnICsgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgK1xuICAgICAgJywgYW1iaXNvbmljIG9yZGVyOiAnICsgdGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyICsgJyknKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UodGhpcy5faW5pdGlhbGl6ZUNhbGxiYWNrLmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgVXRpbHMudGhyb3coJ0hPQVJlbmRlcmVyOiBJbml0aWFsaXphdGlvbiBmYWlsZWQuICgnICsgZXJyb3IgKyAnKScpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCAzeDMgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXgzIC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXgzKSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5faG9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDMocm90YXRpb25NYXRyaXgzKTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCA0eDQgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXg0IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXg0KSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5faG9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDQocm90YXRpb25NYXRyaXg0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGRlY29kaW5nIG1vZGUuXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IG1vZGUgLSBEZWNvZGluZyBtb2RlLlxuICogIC0gJ2FtYmlzb25pYyc6IGFjdGl2YXRlcyB0aGUgYW1iaXNvbmljIGRlY29kaW5nL2JpbmF1cmwgcmVuZGVyaW5nLlxuICogIC0gJ2J5cGFzcyc6IGJ5cGFzc2VzIHRoZSBpbnB1dCBzdHJlYW0gZGlyZWN0bHkgdG8gdGhlIG91dHB1dC4gTm8gYW1iaXNvbmljXG4gKiAgICBkZWNvZGluZyBvciBlbmNvZGluZy5cbiAqICAtICdvZmYnOiBhbGwgdGhlIHByb2Nlc3Npbmcgb2ZmIHNhdmluZyB0aGUgQ1BVIHBvd2VyLlxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0UmVuZGVyaW5nTW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT09IHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLkFNQklTT05JQzpcbiAgICAgIHRoaXMuX2hvYUNvbnZvbHZlci5lbmFibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuQllQQVNTOlxuICAgICAgdGhpcy5faG9hQ29udm9sdmVyLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5PRkY6XG4gICAgICB0aGlzLl9ob2FDb252b2x2ZXIuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBVdGlscy5sb2coXG4gICAgICAgICAgJ0hPQVJlbmRlcmVyOiBSZW5kZXJpbmcgbW9kZSBcIicgKyBtb2RlICsgJ1wiIGlzIG5vdCAnICtcbiAgICAgICAgICAnc3VwcG9ydGVkLicpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICBVdGlscy5sb2coJ0hPQVJlbmRlcmVyOiBSZW5kZXJpbmcgbW9kZSBjaGFuZ2VkLiAoJyArIG1vZGUgKyAnKScpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhPQVJlbmRlcmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuY29uc3QgT21uaXRvbmVUT0FIcmlyQmFzZTY0ID0gW1xuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRCsvd1FBOC84WUFQMy9DZ0FDQUFBQS8vOENBQVlBOC84QUFQSC9DZ0R2Lzk3L2UvK3kvOVArVVFEd0FIVUJFd1Y3L3BQOFAveTA5YnNEd0FmTkJHWUlGZi9ZKzczNitmUDg5MEh2OEFHY0MzVC92d1l5K1M3MEFBSUNBM0FENEFhZ0J3MFI0dzNaRUFjTjhSVllBVjhROFAyeitrRUNId2RLL2pJRzBRTktBWVVFbGY4SUNsajdCZ2pYKy9mOGovbDMvNWYvNmZrSyt4ejhGUDB2L25qL01mL24vRmNCUGZ2SC8xSDMrZ0JQL0hmOGNmaUNBUi81NFFCaCtVUUFjdmt6QVdMOFRQMTMraUQvVi83Myt3djlLditZL2h2K3hQejcvVUw4My8vYS96LzlBUDZSLzVMK2pmMjYvUDMrclAyNi90RDhuUDdCL1B2K1dQMVYvc1A5Z3Y5MS8zUDl4UDNKL252L0dQNVMvc2IrSVA4di85ai9kdjdVL3ByKzZ2K3UvWjMvc3Y1Y0FPcjlRLzgzLytuL3pQNXgvNTcrMi8vay9ud0EvdjAxLy9MK1NBQ0Ivc0QvRmY4MUFKVCtUZ0RwL29jQW0vNWRBRlQrTWdEKy9wTUFXLzdvL3lIL3hRREEva2tBOVA2TEFMMytwQUMwL2lRQXovNVVBTEQrVXdBdC8zVUFoZjRVQUEvL3B3Qysvam9Bei81YUFBdi9md0RZL2lNQUlmK3VBUFArWkFBYy8wUUF5LzR4QUI3L1RnRHMvZ29BRFA4d0FFTC9Od0RvL3ViL1VmOUJBQzMvK3Y5Ri95NEFSUDlIQUZQL0VRQTMveE1BVFA4MUFHMy9IUUF1L3dnQWFQOUZBQ2IvOWY5Qi95MEFVUDhyQUVEL0N3QlYvejRBVy84VEFHSC9CUUJLL3hzQWZ2OGVBRm4vQWdCMy96d0FmZjhSQUdqLy92K0UveUFBYi8vMC8zbi9Gd0J6L3hjQWl2OFBBSG4vRlFDSi94Z0FnLy94LzNqL0VRQ2EveWNBZmYvdy80Ny9Id0NJLy9YL2l2LzcvNDMvSlFDTS8rbi9rUDhBQUpiL0pBQ2ovLzcvb1A4WkFNTC9Td0NvL3c0QXR2OHRBTWIvUEFDci94Y0F3UDlIQU1QL09BREYveTRBMGY5SUFOTC9Od0MvL3pFQTBmOUxBTWIvTUFDOC95NEEzZjlHQU1IL0ZRRFEveVlBMi84c0FNVC9Bd0RYL3hrQTN2OFNBTTMvOXYvYy93OEE0ZjhMQU1qLzhmL2gveFFBMlA4Q0FNbi84Ly9qL3hRQTB2LzcvOUgvL1AvaS94RUEwdi8xLzlMLy9mL2ovdzBBMGYveC85Zi8vdi9rL3dnQXovL3UvOXovQXdEZy93TUEwUC92LzkvL0JRRGYvLy8vMHYveS8rRC9DQURjLy8zLzB2LzIvK0wvQ2dEYS8vci8xdi81LytUL0NnRFkvL2ovMmYvOS8rVC9DQURZLy9mLzNQOEFBT1QvQndEWS8vZi80UDhFQU9QL0JBRFovL2ovNHY4R0FPTC9Bd0RhLy9yLzVmOElBT0gvQVFEYy8vMy81djhKQU9ELy92L2YvLy8vNXY4SUFPRC8vdi9oL3dJQTUvOEhBT0QvL2Yvai93TUE1LzhHQU9ELy9mL2wvd1lBNXY4RUFPRC8vdi9tL3dZQTVmOENBT0wvLy8vbi93WUE1UDhCQU9IL0FBRGwvd1VBNGYvLy8rSC9BUURrL3dNQTRmLy8vK1QvQVFEbS93RUE1Ly8vLytyL0FBRHQvd0FBNy8vLy8vUC9BQUQxLy8vL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vL3YvLy93QUFBQUFBQUFBQUFRQUFBQUFBLy8vOS93QUFCQUQrLy9uL0FnQUpBQUFBK3YvKy8vZi9EQUFkQVB2Lyt2K2wvOEwramYvNC92Z0Fkd1ZQQVFBQ0xRQm8rUWovRXY3by9OMy9WZ0NiQTA4QnhmK0wreW45Si8ySENVOEZtZ0J2RGUzMFJ2NWgvTFQwOWdpNUN4a0E1Z09pOC8zMGt3RU0rNFlKTWYybkJta0pKQVFRQkxvRnR2dnYrbTRBN1BGNi9SMEJpZjNxQXVmOFdBUkFBZjRHeUFCRy9CSUF3dnI0QWN2OFUvL2MveUlDOEFFbi9COERhZjJDQWdNQkFmM01BTjM4dmdMSy9VVC9Rd0N5QVBZQ2xQeXZBVy8rcFFBb0FTRCt6UCtSL0lZQzFmN0MvbkVCUVA5NkFaYisxUUFJQU0vL3lRRTcvdGtBWi83VEFYTC93LzgrQUlzQXR3QjcvMjRBNHY5YS96NEE3djRpQURiL2R3Q2ovMjMva2dCT0FOVUFJdjhsQUtFQXhQOWdBSzcvQndDUC81a0E3Lzl2LzB3QXp2OURBR1QvMy85dkFIdi82UCtxL3hVQTdQOFhBTy8vdXYvZy8yVUFFZ0NWL3dFQVRBRE0vKzcvKy8vai8rRC85di9pLy9qL0lnRCsveG9BeGYvNi96NEE1Lys4LzlEL1F3RHEvKzMvT1FEVC96VUFJZ0EvQVBQL1BnQWpBUEQvQndBR0FDQUFEQUMzLy9iL0hBQTNBTi8vUmdETi93OEFJQUFDQU4vL0dRQkRBQ0VBSXdBK0FDb0FKUUFlQVB6L0tnQVlBUHIvRGdBRUFCWUFJZ0FjQU1ULzdmOE9BT0wvNVAvMi8vTC85UDhHQVBULzd2LzgvKzcvNnYvdC8vei9BZ0FVQU9MLy9QOFZBQU1BNC84SUFQYi8rUDhNQUFvQTV2OE5BQXNBOXYvLy93RUFBQUQ5Ly9uLzkvOEpBQVlBN3YvNi93TUErZjhHQUFFQTdmLzcveGdBQ0FENC93OEEvLy8zL3cwQStmOEJBQUlBL1AvNS94SUEvLy85Ly9yLzd2LysveFlBQ1FELy8vSC9Dd0R6L3dFQURnQUhBUFAvRkFEbi8rMy9BUUQ1Ly9mL0FnRDcvd0VBQndBTUFBRUFEUUQ4Ly9uLzhmOE9BUFgvQkFEKy8vWC8rdjhXQUFRQStmOENBQUVBNy84UUFBRUEvUDhEQUFVQTlmOEtBQXdBOXY4REFBVUErZjhPQUFvQTlmLzcvdzBBK3Y4RUFBZ0E4UC82L3dvQSsvLzgvd2tBK1AvMy93b0ErLy84L3djQTkvLzEvd29BQXdENS93Y0EvUC8zL3cwQUF3RDMvd0VBQkFEMi93a0FCZ0QzL3dFQUJRRDMvd1VBQlFEMy8vdi9Cd0QzL3dNQUJRRDMvL3IvQ1FENy8vLy9CUUQ2Ly9uL0NRRDkvLzMvQkFEOS8vai9Cd0FBQVB2L0F3RC8vL2ovQndBQkFQbi9BUUFCQVBuL0JRQUNBUG4vLy84REFQci9Bd0FEQVByLy92OEVBUHYvQVFBREFQdi8vUDhGQVAzLy8vOERBUHovKy84RkFQNy8vZjhDQVA3LysvOEVBUC8vL1A4QkFQLy8rLzhEQUFFQSsvOEFBQUVBKy84Q0FBSUErLy8vL3dJQS9mOEFBQUlBL1AvKy93SUEvZjhBQUFJQS9mLzkvd01BLy8vLy93RUEvLy8rL3dJQS8vLy8vd0FBQUFEKy93QUFBQUQvLy8vL0FBRC8vd0FBLy84QUFQLy9BQUQvL3dBQVwiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vLy8vKy8vLy8vLzhBQVAvLy8vOEFBUC8vQUFBQUFQei8vZjhJQUFNQTkvLy8vdzRBQVFENi93d0E4Ly8rL3k4QWZ2LzAvMkgvVVA1Z0FiSCsyUUcxQjJjQVZBSWgvbDMyRlB5TS9uQUNQUURWLytVRW8vUTZBUXdDdS9vTEQ5a0Y4UUpBL1V6K1dmMktDT2NDK3dVS0JzTDVhUUJROTdyd09QaVBBdm41Q0FsOEFIRURrUVBjQUE4Qm4vbElBZHo3SFFGMSt4ejljQU00Lzk0RTRnREtBdW4rY2dQWUFZcjlKZ0pyL2JmK2l2eHovTW9CZ3Y1VUE4RUJTZ0FRQUo3L1VnRWsvY1FCN2Y2My9zRC92ZjRYQWhUL0JRRkNBRFlBblFHSS85RUJ0djNoQUxEL3ZQK2MvM0gvVGdJTi8xc0JwZjh5QVAzLzRmOHFBQnIrMWY4T0FKMy9kd0FHQURFQm52OUpBUHovSVFCd0FJSC9qZ0FTLzR3QXNBQ1RBT24vRFFEQ0FMbi9aUUNTQUFJQUF3RDEvOS8vanY5YUFEUUEvdjlFQUIwQWZnQThBQVFBQ2dCOUFQci9JQUFSQVBULzV2OXhBQ0FBQkFBSEFHVUF0Lzg5QUM0QUNnQWpBTVAvK3YvOS94WUE3Zi8xLytELzdQODdBQzBBdXY4UkFBY0E5LzhGQUM4QTIvL3kveElBRXdBYUFEUUFKQURwL3pvQUFnQWZBQklBMmYvZS96VUErUC82L3c0QTkvL0EvemNBNC8vUC8vVC81Zi9SLy8vL0V3RGIvdzRBOC84QkFCa0FOQURoL3hFQStmLzAvd0lBSEFEYy8vai9Hd0QxLy9mL0dBRHMvK3YvRUFBQUFQei9FZ0QzLytyL0ZnQU1BQWtBR0FEOS8rei9JUUFRQVBIL0dRRDMvL3ovQ2dBZkFPWC9BZ0Q4Ly9IL0JBQVRBT3YvK3YvLy93SUFCQUFkQU9qL0JRQVBBQWNBQVFBVEFPei84LzhKQUFrQTZmOFZBT3YvK2Y4UUFCVUEvdjhPQU8zLytQOEtBQlVBOWY4RkFQdi81LzhUQUEwQTdmOFhBQWtBQVFBSkFCWUE0LzhXQUFjQUNnQU5BQkVBN3Y4RUFQNy9BQUQrL3dNQTkvLzcveEFBQVFEOC93UUErZi83L3dNQUJnRHEvd0FBK3YvMy93WUFDUUQxLy8zL0JBRDkvd2dBRGdEdy8vci9BZ0Q2L3dFQUNBRHYvL2ovQlFELy8vWC9Cd0R1Ly9qL0FnQUNBUFAvQkFEMi8vbi9CQUFHQVBiL0JBRDgvLzMvQlFBSkFQTC9Bd0QrLy8zL0JBQUlBUFAvL2Y4REFQei9BQUFHQVBQLysvOENBUDcvL2Y4RkFQWC8rZjhEQUFBQS9QOEVBUGYvK3Y4R0FBTUErLzhFQVB2LysvOEdBQVFBK3Y4Q0FQLy8vUDhFQUFVQStmOEFBUC8vL2Y4Q0FBVUErUC8vL3dFQS92OEJBQVVBK2YvKy93SUFBQUQvL3dVQSt2Lzkvd01BQVFEOS93UUErLy85L3dNQUFnRDgvd01BL1AvOS93TUFBd0Q3L3dFQS92Lysvd0lBQXdENi93RUEvLy8rL3dBQUJBRDYvd0FBQVFELy93QUFBd0Q3Ly8vL0FRQUFBUC8vQXdEOC8vNy9BZ0FCQVAzL0FnRDkvLzcvQVFBQkFQMy9BUUQrLy83L0FBQUNBUHovQUFEKy8vLy8vLzhCQVAzL0FBRC8vd0FBLy84QkFQNy9BQUQvL3dBQS92OEFBUDcvQUFELy93QUEvLzhBQVAvL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vL1AvOS8vMy8vLy8vL3dBQUFBQUFBQUlBQWdBQ0FQLy9DQUFFQUVFQS8vK2NBQVVBYi84SEFBSDkrUDllQVJrQW9nUVVBSm44QndDZC9nWC8rUVFOQUtvQzlnRmRBdGIvYi92ZC85MzZUUC82QXNEL25mcW4vdW4xVy8wZEE4SUVzUUx2QUp2MmJQNzIrV01Ba1A4ZEFjWCtuUU8yQUlyNmJQL0VBQlgrTmdLL0JkajJJUXYyQUU0RVVBaUQveFFBbndJbS9CMEIvd0dOQW9IN3NRYVAvYjhDaVFha0FxRCtSLzl4QTQ3N0tRTC8vNnI3NXYvTy9wY0NnUUN0QWlNQ0JRQWtBTkFBUndIZi8vMzloZ0JsL2tVQUpnRXRBVUVBVGdBL0Fnb0FTQURLL3pVQUp2MjkvdkwrbC85Yy8wY0FVd0JCQUU4QTZRRTUvODcvV3Y5TkFPZis1djdQLzVQLzQvOUJBS1lBUXdERC96WUI1dityL3pZQVR3QXAvMXYvV1FBRUFCMEFod0EwQUEwQUlBQTNBQUVBenYvdS8rLy81djltL3p3QUlBRFEvOFQvU0FCaUFOYi9Td0FiQUZmL01RRFgvN0wvaFA4VEFQci9BZ0FNQUFzQUh3QVpBSTMvVmdEQy85di81Ly94LzZQL0F3QmxBTXYveWY4MkFCNEErUDlXQVBqL053RGkvMUVBMHY5SkFOai9Kd0FjQUFFQURBQllBTmovNGY4TUFFd0FtUDgyQU4vLzNQOFVBRFlBNy8vNi93SUFDQURVL3lnQXl2ODJBTjcvOXYvMi95Z0F4di85LyszLzUvL24velVBNi8vZy95NEFEZ0Q1L3dzQUJ3RHYveElBRHdBR0FDb0FKUUQzL3pJQSsvOEZBQnNBRmdETy96QUFIQUFJQUJRQUxBRHAveGNBQ0FBQUFQSC9HQURzL3drQUNRQUZBQWdBRlFEcC93SUFIQUQxLy9QL0VRRHcvKzMvR0FEOS8rZi9IQUQ4Ly9UL0RBQVFBUEgvSHdENC8vci9Ed0FQQU9qL0VRQUNBT24vREFBWEFPWC9CQUFPQU5ILzkvOE1BTy8vOWY4TEFOVC85ZjhFQU8vLzZmOE5BTmIvK1A4S0FPei81djhNQU9ELzdmOFVBTy8vNy8vKy8vNy85djhZQVBqLzlmL3ovd3NBK3Y4U0FQRC8rdi94L3hZQStmOFNBUGIvOS8vMy94RUFCUUFDQVBuLzkvL3kveFFBQ1FELy8vYi8vdi83L3hJQUNRRDkvL0gvQUFENy94RUFBZ0Q1Ly9QL0F3RDkvdzhBQWdEMy8vRC9CQUQvL3dVQS92LzAvL0QvQmdBREFBTUEvUC8yLy9mL0J3QUdBUDcvKy8vMi8vai9DQUFGQVB2LytmLzUvL3YvQndBSEFQbi85Ly83Ly83L0JRQUZBUGYvOS8vKy93RUFCQUFDQVBmLytQOEJBQUlBQWdBQUFQai85LzhDQUFNQUFBRCsvL24vK2Y4RUFBUUEvdi84Ly9yLysvOEVBQU1BL1AvNy8vei8vUDhFQUFJQS9QLzUvLzcvL3Y4REFBRUErLy81Ly8vLy8vOENBQUFBKy8vNS93RUFBQUFCQVAvLysvLzYvd0lBQVFELy8vMy8vUC83L3dNQUFRRC8vLzMvL2YvOS93SUFBUUQ5Ly8zLy92Lzkvd01BQVFEOS8vei9BQUQvL3dFQUFBRDkvL3ovQUFBQUFBQUEvLy85Ly8zL0FBRC8vd0FBL3YvLy8vNy9BQUQvL3dBQS8vLy8vLy8vQUFELy93QUEvLzhBQVAvL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRCsvLy8vK2YvLy8vdi8vdi8vL3dBQS8vLy8vd1VBQVFBSUFBSUFCd0FDQUhrQVRBQU9BYU1BQWY5Qy85WDZRdndoQXJBQXRnaEFCVzM3bnYveSswd0FXUU5jQUU4SlJ3U09DNkFFSmU4UDhTL3pyUFdhQkkvK0xRQS8rMEwrUC80SzhBZ0FiLzh1Q2g3OEJRdEM2MTRHYVFXZkFpbjVVZnpOOFRmK0dRaXpBWjRNQ1FNYkdKNEJvUlM3QXZjSHlRQVJBNm45WndIWi96NER2d0FaQWxBQjZnYk5BUzRHRkFERkFUTDdFLzJLK2ozN0MveHAvU0Q5VXYwVkFPc0RzLy9XQWQzK2J2N0YvZjc5bVAyWC9LSCtGd0MwLzFuK1ZnRmNBVEFCSFFHYUFFVCtuZjhZL2hvQW92cHFBWGo5Q1FLVy9sc0NsLzRSQXBqK2JBSGsvUmNBbHY0QkFHLytEZ0RpLy8zL0d3QU9BRUlBcS8reS8zei84djgrLzdUL1R2OC8vMjcvbWdEWi8xc0ErUCtjQUFBQS9QL2kveU1BaS84NUFNUC9LZ0RNLzlNQTlQK1FBQm9BNFFBaUFDd0FDd0JkQVA3L1RRRGIveTBBeWYrU0FBMEFad0RnLzR3QSsvOC9BQU1BZ1FEcC93MEFEQUFRQUFvQU5nQWdBQTRBS0FCSUFCNEE0di8zLytmLyt2L2MvK24vRUFEbi93Z0FGQUFxQU96L0l3RGMvOS8vM2Y4WEFORC8ydi9hL3cwQTV2OEJBTmIvOVAvbS93QUE4UDhaQU4zL1J3QUdBRXNBQmdCL0FQNy9OQUFTQUVnQUJBQTNBUDMvS2dEOS8xc0E4UDhsQU9yL0ZnRDEveEFBNC84a0FPdi9Bd0Q0L3hFQTVmOE5BUFQvK3YvMy94OEE3ZjhQQVBqL0l3RDUveUFBOS84WkFBRUFHZ0Q0L3hvQTlmOEhBQU1BQ0FEMC94Z0ErUDhBQVByL0lRRHAvdzRBOHY4SEFQWC9JZ0QxL3dZQStQOEdBUFgvR2dEMy93b0FCUUFTQUFjQUdRRHcvK3YvOVA4YkFQMy9IQURzLytmLzcvOExBUHIvL3YvMC8vVC9BZ0QyL3dzQTZQLy8vK1AvQ0FEWS8vNy81di8zL3dRQS92OExBUEQvR2dEMS95TUEvUDhRQU92L0xBRHcveVFBK1A4WEFPNy9NUUQ5L3lFQUFRQWNBUEQvSWdEOS94TUErLzhPQU8vL0ZRQUJBQW9BKy84UEFQUC9GUUFCQUFRQTkvOFBBUFgvQ0FBREFBRUErUDhOQVB2L0NBQUdBQVVBOS84SkFQLy9BQUFGQVB6LytmOEhBQVFBL2Y4RkFQMy8vUDhGQUFZQStQOERBUDcvKy84QUFBY0E5LzhCQVAvLy9mLy8vd2dBOS8vKy93QUEvdi84L3dVQTkvLzgvd0lBLy8vNy93VUErdi83L3dJQUFBRDYvd01BL1AvNi93RUFBUUQ2L3dFQS92Lzcvd0lBQWdENi8vLy9BQUQ3L3dFQUFnRDcvLzcvQVFEOC93QUFBd0Q4Ly8zL0F3RDkvd0FBQWdEOS8vei9Bd0QvLy8vL0FnRCsvL3ovQXdBQUFQNy9BUUQvLy8zL0FnQUJBUDMvQUFBQUFQMy9BZ0FDQVB6Ly8vOEJBUDMvQVFBQ0FQMy8vdjhCQVA3L0FBQUJBUDMvL3Y4Q0FQNy8vLzhCQVA3Ly9mOENBUC8vLy84QUFBQUEvdjhDQUFBQUFBQUFBQUFBL3Y4QkFBQUFBQUQvL3dBQS8vOEFBUC8vQUFELy93QUEvLzhBQVAvL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBQUFBUC8vQUFELy93QUEvLzhBQUFBQS8vLy8vd0FBQVFEKy8vLy9BQUFHQVAzL09BQUJBSUlBQXdCdi8vZi9FLzBRQUswQURRQ3pBLzcvOFA0dS8wY0JEUUNKQTZBQmJRRGcvdzcvei85bytWbi9TUG5MLzEvL0VmKzIranI5UmZaZ0E1UUZad0lMREZqK1BBYjIvbkVGS2dLay9SMERsdjZiL0ZVRHNQNllBb2o5U2dBVC9pTC90QVB3QXY4QTBQNnpBcjcvZHdBbkFmMzl1UDIyL3NrQTJ2Ly8vMllDb1A0VUFVc0FaZ0YyQUpIKzRQNzAvcno5K2YrVS9Ydi84djdDQWNiK1RBQ1Mva3dBdi8reC90WDlvUDcxL29MLzFmOG5BRVVBWndHdEFBZ0FJZ0MvQUQ0QmFQOEdBR0gvZFFERi82NEFyZjhuQWFrQWhBSDkvK2tBUVFEM0FGYi9xLzhwL3lJQVIvOEZBUEQvWkFBL0FJWUEzdjh0QURRQURRQnAvM2YvQ3dBQkFQMy9XZjhPQU5qL1d3REgveG9BZS84REFLei96djk2L3o4QTNmL0ovNVgvSUFENS8vai9xLy9jLysvL1JBRHEvL0QvdnY4cEFEVUFGUURJL3k4QUNBQWJBTmIvT3dEMy8rMy85Zi9lL3djQUlBQWVBTUgvOC84eEFDMEFFQURXLyszL0hBQURBUHYvOFA4REFPTC9Pd0QzL3hjQUNRQUhBTS8vNWY4WEFBY0F6Ly9ULzlEL0hnRDkvLy8veWYvZS8vdi9BZ0QvLzlILzYvLy8vL0gvKy84aEFBSUE5Ly83L3cwQUZnQVFBUEwvMnYvOC94c0FHUUFCQU56LzlQOFlBQVFBL3YveS93TUE1djhZQUFrQUFBQUFBQU1BNy84S0FCZ0FEd0RzLy9qL0J3QVRBQnNBOFAvMS8vei9CQUFNQUFBQTlQL3MveEFBL3Y4R0FBa0Evdi9wL3dNQUN3QUxBUDcvOVAvcC93Y0FEUUFGQVBiLzcvLzQvdzBBQ0FEOC8vYi8vdi8xL3dNQUN3RDEvL1QvOFAvOC93QUFDUUR6LytmLzVQOEdBQWtBQlFENS8vRC8rdjhGQUEwQUF3RC8vL1QvQWdBQ0FCQUEvdjhDQVBELysvOEZBQW9BOWYvMy8vZi8vdjhHQVA3Lzl2L3QvL3ovK2Y4QUFQai8rdi8zL3dFQSt2OEhBUHIvL1AvNS93UUEvLzhEQVByLytQLzMvd1lBLy8vKy8vWC8rLy81L3dRQS9mLzcvL1gvKy8vNC93TUEvZi84Ly9qLy92Lzkvd1lBLy8vOC8vZi9BZ0FBQUFVQS9mLzYvL24vQXdBQ0FBSUEvZi83Ly96L0F3QUNBQUFBL2YvNi8vMy9BZ0FEQVA3Ly9mLzcvd0FBQXdBRkFQei8vLy84L3dNQUFnQUVBUHYvL3YvKy93TUFBZ0FEQVB2Ly92Ly8vd01BQVFBQkFQdi8vZjhBQUFJQUFBRC8vL3YvL2Y4QkFBSUEvLy8rLy96Ly92OENBQUlBL3YvOS8vMy8vLzhDQUFFQS92LzkvLzcvQUFBQ0FBQUEvdi85Ly8vL0FBQUJBQUFBL2YvOS93QUFBUUFCQVAvLy9mLysvd0VBQVFBQUFQLy8vdi8rL3dFQUFRRC8vLzcvL3YvLy93RUFBUUQvLy83Ly92Ly8vd0VBQUFEKy8vNy8vLzhBQUFBQUFBRCsvLzcvLy84QUFBQUEvLy8rLy83Ly8vOEFBQUFBLy8vLy8vLy9BQUFBQVAvLy8vLy8vLy8vLy84QUFQLy8vLy8vLy8vL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBQUFBQUFBQUFBQkFBQUFBQUQvLy8vLy8vLy8vLy8vL3YvLy8vMy8vLy8vLy8vLysvLzgvLy8vQVFEOS8vei85ZjhCQUFJQStmOGRBQ2dBV1FCeEFKWC9xditZL3V6OWFQOWsvN1VEVVFRQkFpUUE0UGdpL0FrQjBnS2FCc0QvK2Z4cC92ejlDUVNwL0kvK3l3RE8rdk1EMGZ6Sy9QQUJjZ0JlQmZvQnYvK3VBdUg5U2Y1Z0F5Mzlhd01tQldVQnVQOWZBOS85ZmdEai8yLytFQUNhQUNjQ1N2OVovMmovcnY3aEFBMEFXZjU1LzdMODRQN0UvU0lBVC82N0FNdi90ZitGQUE3LzF2KzcvZ3YvSVArRS9zUUErUDVhQVh6L3RQOVhBRlgvdFA4by80ci9qLy9lL3lRQU12OW1BSlQvcmdDci85WC9Fd0NiLy9ILzlmN0YvNkQvRUFBb0FLMy8vditlL3pzQWgvK0IvN3IvaWYvQy8yci80UC96LzYvL0h3Q3kvMElBNy85WkFMVC95LzgwQUNnQTl2L0ovOS8vRGdBNUFEVUFMUUFSQURJQUN3QWZBT2YvTmdBckFDTUFDUUJCQUVjQUdBQWpBQzRBV1FCVUFIY0FBQUFmQUNFQUlBQWNBUGovQ0FEay95UUE3djg5QUVFQUZ3RDUveFlBNmY4YUFPWC9BQURGL3pRQUR3QVVBT1QvQlFEci95VUE2UDhYQU9mL0hBRFIvMEFBOFA4bkFBZ0FDUUR0L3ljQUtBQUhBUEgvSVFEei94c0FDQURuLy9uL0RnQURBQTRBOFAvLy84ei9HZ0ROL3lNQS9mOFFBTmovTXdBQ0FDMEFDd0FPQU8zL0pnQVpBQVVBQ2dBQUFBNEFJZ0FhQUFrQUR3QUNBQUFBSFFBVEFBVUFCUUFDQUFnQUN3QWpBTy8vLy84QUFBOEFCUUFQQVBMLy9mOEdBQXNBQmdBR0FQRC84djhHQVB6L0NBRDYvL0gvNnY4UEFBZ0FCZ0Q0Ly8zLzl2OGFBQWdBQndEMS8vNy8vdjhRQUFvQUNBRC8vd1VBOXY4UUFBb0FCQUFGQUFnQUFnQUpBQW9BQXdELy93MEFBZ0QvL3djQS92OERBQW9BQlFBRkFCVUFCQUFLQUFZQUJ3QUhBQThBQ2dBR0FBd0FEd0FNQUFrQUVBQUpBQWdBRHdBTUFBZ0FEZ0FKQUFVQUNRQVBBQVVBQ3dBSEFBRUFCZ0FJQUFFQUJBQUdBUC8vQWdBSkFBQUFBZ0FFQVA3Ly8vOElBQUlBLy84R0FBRUFBUUFKQUFJQS92OEVBQU1BLy84SkFBRUEvdjhEQUFNQS92OEhBQU1BL2Y4QkFBVUEvdjhGQUFNQS92OEJBQWNBLy84REFBTUEvdjhCQUFZQS8vOENBQU1BLy8vLy93Y0FBQUFBQUFNQUFBRC8vd1lBQVFEKy93TUFBUUQvL3dVQUFRRCsvd0lBQWdELy93UUFBZ0QrL3dFQUF3RC8vd01BQXdEKy93RUFBd0QvL3dJQUF3RC8vd0VBQkFBQUFBRUFCQUQvL3dBQUJBQUJBQUFBQXdBQUFBQUFCQUFCQVAvL0F3QUJBQUFBQXdBQ0FQLy9BZ0FDQUFBQUF3QUNBUC8vQWdBQ0FBQUFBZ0FDQUFBQUFRQURBQUFBQVFBQ0FBQUFBUUFEQUFBQUFRQUNBQUFBQUFBQ0FBRUFBQUFDQUFFQUFBQUNBQUVBQUFBQkFBRUFBQUFCQUFFQUFBQUJBQUVBQUFBQkFBRUFBQUFCQUFFQUFBQUJBQUVBQUFBQUFBQUFBQUFBQUFBQVwiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBQUFBUC8vQUFELy93QUEvLzhBQUFBQS8vOEFBUC8vQUFBQ0FBQUErZjhCQUFZQS8vLzQvd0lBLy84QUFBOEEvdi9WL3dFQUV3QTlBQUVCUndBMkFGNy9rZm9nLzNnQnd2OTlDRFlCVS9xdEFVWC9BUDdPQWZrQVgvbzlCMzhGU2Z3YUF1VDE0LzYwQkFyOENRQUkvdGZ5SVFUekFYUCtlZ2RVQkJ3Qm9mN1RCTVQ4YkFXaS81RUVXd0JSQUFBS3lmeEUvOGI4OHZwNkFDUCtQQUY0L3FEOE1RTk0veWdDSi8yWEFQRDlrUDVnQVZUL2lQOUkvbEVCNFA4cUFEMEJGQUdhLys3L0RnQjJBT1A5OGdGbS91LytWdjUvQUc4QVNQOWdBTS8vcXY5dy8vb0FjdisyL2pJQkhnQTcvNkQvb0FBR0FLSC9sQURUL3dBQWdnQzhBQVlBa1A5eUFFY0FrZjhCQU9EL1JBQXIvelVBTndEdC94UUFKUUFrQU1UL3p3QS9BT0gveHY5ekFHc0FOUUJUQUljQUxBQXZBQ0lBVEFDeS94TUFEQURnL3hjQVdBQnZBSkwvN2Y5VkFQYi9FZ0R0L3djQTRmOGtBUFAvNVAraC93Z0FDUUR5Ly9yL0xnQVFBTW4vOC85Q0FPWC81di9TLzkvLzNQOHBBQllBdVAvcy93OEFGZ0R0LyszLzd2L3cvOWovNS84R0FPZi8yUC8yLy9QLy92OGtBQk1BdWYvbS94b0FEQURaLytyLzNQOEtBQVVBS3dEZS93c0EzUDhWQUFBQURnQWZBQjBBQ0FBTUFGNEFHZ0FoQVBML013RHovMGtBQkFBS0FQWC9Md0FiQUFrQTl2L3MvKzMvOC84Q0FCQUFBQURtLy9uL0JRQUxBQVVBQVFEai8vbi9KUUFWQVBYLzl2Lysvd0lBRVFBQkFQUC84UC8xL3dBQUJnRDYvKzMvNy8vby8vai9EQUQ4LytiLzhQOElBQWtBQmdENC8vRC84UDhVQUFvQUF3RDQvd0FBK2Y4T0FBY0FBQUFGQVBYLzl2OFRBQWtBOHY4RUFQYi85LzhkQUEwQTcvOENBUG4vK2Y4U0FBUUE4LzhDQU9mLyt2OERBQWdBOVAvLy8vSC8vUDhJQUFVQTgvLzAvd0lBQVFBR0FBZ0E5Ly83L3dBQSsvOEVBUC8vK1AvKy8vLy9BZ0FDQUFzQTh2Lysvd0lBQlFENy93Z0E5di83L3dNQUJBRDUvd0FBL1AvMy93RUFBUUQ3Ly83Ly9QLzEvd1FBLy8vMy8vci8vLy8zL3dNQUF3RDEvL3IvQXdENi8vLy9BZ0Q0Ly9uL0F3RDgvLzcvQWdENC8vbi9Bd0QrLy8zL0FRRDQvL24vQlFELy8vbi9BQUQ2Ly9qL0JBQUJBUGovQUFEOS8vdi9Bd0FEQVBqLy92LysvL3ovQXdBRUFQai8vdjhCQVA3L0FRQURBUGovL2Y4Q0FQLy8vLzhFQVByLy9QOERBQUFBL3Y4Q0FQdi8vUDhEQUFFQS9mOEJBUDMvL2Y4REFBSUEvUDhBQVA3Ly9mOERBQUlBL1AvLy93QUEvZjhCQUFJQSsvLysvd0VBLy84QUFBRUErLy8rL3dFQS8vLy8vd0VBL1AvKy93RUEvLy8rL3dBQS9mLzkvd0VBQUFEOS93QUEvZi8rL3dFQUFRRDgvLy8vL3YvKy93QUFBUUQ4Ly8vLy8vLy8vLy8vQVFEOS8vLy9BQUQvLy8vL0FBRCsvLy8vQUFBQUFQLy9BQUQvLy8vLy8vOEFBUC8vQUFELy93QUEvLzhBQVAvL1wiLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBPbW5pdG9uZVRPQUhyaXJCYXNlNjQ7XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5jb25zdCBPbW5pdG9uZVNPQUhyaXJCYXNlNjQgPSBbXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFEKy93UUE4LzhaQVByL0RBRCsvd01BL3Y4S0FBUUEvZjhEQUFNQUJBRHMvL3ovOHYvei84Zi9SLzkwL29iKy8vekFBV3NEQXdZM0RLbjkvL3R1OTNEdmt3STZBbjRDdXdKMC9CSDdWUHV4OTJYMEd1N04vRVg5bWdmcUNra0lpUk1nQmQ0TlFRR0wvYzBHL3hCeEFLRUxaQVRVQS9zSUhSU3grZmtDeUFVbUJORUpJQVJsQWRIejJBak5BQ2NJc0FXNEFsRUNzdnRKL1AvN0svdGYrK244YVA0VytnMEZYQUVsQU1uOG5RSG4vc1QrWnY3Tis5WDJ4dnpNL08zK0V2cHFCQkQ3U1FMZCt2Yi9zUGx3L0pENzIvM24rUnIrTC93Uy92ejZVUUdnL05mK0F2NUwvNVg5R3YyLy9TUCttZjNqL2xmK3YvMkIvWkgvNVAwNS9pTDlNUDlGL3VmOVVQNHYvcXY5bXY3by9Ybit3UDJrLzhMK3VQNUovdEQrRHYvWS9iTCttUDcyL24zK3BQKzcvaEFBKy81ekFHSCtaLyt1L2c4QXp2MnkvNkwrLy85by9pSUFEUDhWQUN6L0N3Q04vcGIvMXY0eUFGUCt3Zis0L2pzQWNmNVZBUDMrYkFEYS9uTUE2ZjRzQU9UK0lRQmQvdjcvN3Y2YUFJTCtRQURlL25FQTBQNHlBS3orQ1FDby9tb0F1ZjV4QU43K21BQzgvamNBTmY5ZUFQWCtJQUExLzFrQUFQOWhBTXorUFFENS9tMEEyLzRnQVByK1VRRGgvalFBRXY5QkFQSCtGQUJOL3prQVN2OURBRFAvQkFCZS8xSUFHZjhvQUUzL1JRQXcveklBUWY4bUFEbi9HZ0JFL3hJQVIvOGhBRDcvQkFCeS96RUFLUC8wLzA3L0d3QlgvejRBUmY4bUFGci9RUUJWL3pVQVZQOGVBRnovSkFCdC8wRUFVUDhNQUh6L0tnQnIveWNBWXY4RUFIMy9NQUJsL3g4QWd2OGJBSWovR2dCdi8vei9mZjhBQUpYL0lBQnUvK1QvanYvci80ei85LzluLzc3L3BQOEpBSkQvRVFDSi8vci9xLzhXQUovL0dRQ1UveFlBdHY4cUFLci9QUUNXL3lzQXdmOCtBTGIvT2dDMy95Z0F6Lzh1QU03L09nREgveWdBei84a0FNei9PZ0MvL3hzQTFmOHFBTW4vTHdETi94Y0ExZjhvQU12L0pRRFIveE1BemY4YkFNLy9IZ0RVL3dVQTJ2OFpBTkwvRXdEVy93RUExZjhaQU16L0J3RFgvd0lBMHY4U0FOVC9CUURXL3dNQTAvOFBBTlQvQUFEWS93SUExZjhNQU5YLytmL2Evd1VBMHY4SUFOZi8rLy9ZL3dVQTAvOERBTnIvK2YvWS93UUExdjhCQU5yLytmL1ovd1VBMS8vOC85ei8rdi9ZL3dZQTJmLzgvOTMvL3YvWS93VUEydi85LzkzLy8vL1ovd1VBM1AvOC85Ny9BZ0RhL3dNQTN2LzgvOTcvQXdEYi93SUEzLy85Lzk3L0JBRGQvd0VBNGYvLy85Ly9CUURmL3dBQTR2OEFBTi8vQlFEZi93QUE0LzhDQU4vL0JBRGgvd0FBNC84REFPRC9CQURpLy8vLzQvOERBT0gvQXdEay93QUE1UDhGQU9ML0FnRGwvd0VBNVA4RkFPTC9BUURsL3dFQTQvOEVBT0wvQVFEai93SUE0UDhEQU4vL0FBRGcvd0lBM3Y4Q0FPRC9BQURoL3dFQTR2OEFBT1AvQUFEbS93QUE2UDhBQU96L0FBRHUvd0FBXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vZi8rLy83Ly8vOEFBUC8vLy84QkFBRUEvZjhBQUFFQUFRQUZBQVVBOS8vNi94MEEyZi85L3hNQTNQK2pBRS8vb2Y5SEFLUC8vZ0NqLzc3L1ovdmkvMjhEOS95d0RKQUpJdnI2QXNYMFhlYzRCaGNHemYyM0RaUDd5Zlo2QzEvL253QkRCSUh5WWdvYi9UZjNzUTQxQU5vS1JBL0ErRTd5ZmZBYTlnRDVFUVVCRE13TXlnaXFBSE1BcVBxaEFHVUIyL2dFK2E3OEgvKzRBUFQ2RHdJVUFBMEhOd01oQmZMOEUvOTBBNW43ZFA5Y0FMSUMrdjVDL3EwQU92OWtBb2dCSHYwMS8rMy9xQVFEL3ViOFQvNHZBT1VBNVA2S0FUdit5d0VZQWVUK0tQNmkvM2dDRlA2aC9oci8rUDgzQUNML1ZBRG4vOFVBUlFKSS80TUF1LzhxQWxqK3dmNGlBUGIvTGdGSi84UUFVQUJBQUk0QUJmK2svM1gvWWdGSy9pai9qLzlIQURvQWkvK1dBQTBCVndDL0FDTC9MQUNlLy9jQVJ2OWkveGdBVWdBMEFDai9GZ0JnQUlqLzVQOU0vN3ovenY4L0FLei9ndjhzQUVRQTYvK0kveVlBYXdETC83VC94ZjhxQU92L0ZRQ3UvNW4vRWdBeUFPMy9pLzlMQUU0QSsvL1IvL1AvRmdEZS84ei91LzhEQURJQUxBQVpBTEwvVEFBOEFCd0FvLy8xL3h3QS9QL0wvejBBNlA4akFONy83dithL3pBQXdmLzcvMy8vS1FBdUFDd0E5djhSQUdZQUl3Qk5BRGdBS2dBU0FGMEFEZ0FOQUNFQU1RREgvL0gvTFFBQ0FCMEF5Ly8vL3gwQVBBQUJBQVFBMnY4aUFBY0FFZ0RFLyt2L0ZRRCsvK1AvREFEMS85Ny82di80Ly9YL0V3RDQvKzcvNVA4Y0FBMEFDUURILy83L0NRQVhBQUVBL1AvNS8vai9Dd0FXQUFFQUJRRDkvL24vQVFBV0FCMEE3di9rL3dBQUNRQW1BUC8vOS84QUFQbi84LzhhQU8vLzYvOGZBT3YvNXY4aEFQLy81LzhQQU9mL0FBQUdBUG4vNnY4SkFBWUFCZ0FCQU92LzEvLzEvL0wvK1A4REFCY0E2Zi84L3dNQUNnRDcveEFBM3YvMi8vei9EQUR1Ly96LzV2LzUvd0VBL1AvNi8vNy83di94L3dRQUJnRDUvd0FBOHYvdy93a0FFUUQyLy9qLyt2OEVBQWNBRUFEMy8vdi8rdjhDQUFBQUNRRDMvL3YvL3YvOS93VUFEQUQyLy9YL0FnQUhBQUFBQndEMi8vVC9CZ0FLQVA3L0FRRDQvL3IvQkFBSUFQbi9BQUQzLy9mL0JRQUhBUHYvL3YvNy8vbi9CUUFKQVBqLyt2LzkvLzcvQWdBR0FQai8rZjhCQUFFQUFnQUZBUG4vK3Y4QkFBSUFBQUFFQVBuLytmOENBQVFBL3Y4QkFQci8rdjhDQUFRQS9QLy8vL3YvL1A4Q0FBUUErLy8rLy8zLy9mOENBQVVBK3YvOS8vLy8vLzhBQUFRQSt2LzgvLy8vQUFELy93SUErLy84L3dBQUFRRCsvd0VBKy8vOC93QUFBZ0Q5Ly8vLy9QLzkvd0VBQWdEOC8vNy8vZi85L3dBQUFnRDgvLzMvL3YvKy8vLy9BUUQ4Ly96Ly8vLy8vLy8vQUFEOC8vMy8vLzhBQVA3L0FBRDkvLzcvLy84QUFQNy8vLy8rLy8vLy8vOEFBUDcvLy8vKy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vdjhBQVAvLy8vLy8vd0FBQUFBQUFQNy9BUUFCQUFBQUJ3RC8vL1gvQlFBakFQTC9DUURiLzlEL0dBQWIvN3NBWXdDVy96MEJjUC9YLzdULzJRRFcrd0g4eUFOQ0NDVUo1UVQrK1VYbWhQd2hBNzhGdUF4SCtwNzhpZnVkQmxBRzl2bXUvbEFLMmZkbEIvLy9jZmpvQ2EwRTdBa245WWIvenZiYStBa0FIUHl3QkdFQkZ3VU5BTDhBWEFBR0EyMERGdm1SL2t6K0YvMDZBZy8rR3dIbC81RUVLZ0pkL3EwQVAveW0vOW42RWZ4WS8ySCsvUUZ0QUM0QzZRQkRBYU1Dby8yMC8rMy8zZi9wL2ZMOXJ2OVYvNmNCaFFIdUFYNEFjd0pZQWFIL0lQL1AvZ3NBcFAwTEFlNy9zUUJ1QUkwQUFnR0RBRTRCekFDZS81WC8vdit2LytmK1pmK2dBT3YvNVFCaEFPSUFwQUFOQVNZQXVQK2gvOGIvSFFCci85Ly9iQUNXQUdFQUZBQjVBRDBBV1FEVS8rRC9ZZi9wLy9EL3MvK1IvNFFBTVFCdkFCRUFrUUJmQUJRQUpnRFcvd3dBOC84WEFMei92Zjh6QUZBQUt3RDEvekVBUHdESi94MEE3LzhMQU9YL0Z3RFIvL0gvRVFBZEFPLy82UDhRQUZFQTJmOFdBQkVBTWdEeS94SUErZi9zL3hBQUxnRHYvLy8vSFFBdkFQVC8rZjhpQUFZQUVnQUZBQm9BR2dELy93MEErZi8wL3hzQUhnRHgvOWYvR0FBQ0FQSC84ZjhKQVBmL0d3QUxBQkVBNy84Y0FQVC9DZ0QyLy9qL0JRRDgvKzMvT2dBZ0FBWUE5ZjhQQU43L0RnRDkvOXIvMS8vMy8rMy85Ly8xLy9iLzgvLzUvL2YvQWdBSkFPZi8rdjhPQUFNQUN3RDkvKzcvNWY4ZUFBRUE5Ly9xLy83LzhQOFdBUDcvKy8vNC93SUErZjhUQUFJQTlmLzUvd2NBK1A4aUFBZ0E5di9uL3hvQS8vOGdBQVVBQndEai93QUE5djhCQUFVQUZRRG4vd01BN3Y4UUFCQUFFUURtL3d3QThmOGFBQUFBQndEdS93Y0FDZ0FTQUFFQTcvL3cvL2YvQmdBUkFBa0E2UC8zL3djQURnQUtBQVlBNGYvNC93WUFEZ0FBQVByLzhQLzkveFFBQ2dBSEFQbi83Ly85L3hFQUFnRCsvL0wvOHYvOC94VUFBd0R3Ly9ILzlmOENBQXNBL3YvcS8vTC8rZjhGQUFZQS9QL3IvL2ovLy84R0FBa0ErLy9vLy9qL0FRQUlBUC8vK3Yvby8vdi9DQUFJQVB2LytQL3cvd0VBQ1FBSEFQai8rZi8wL3dJQUN3QUZBUGIvK2YvNC93UUFDd0FDQVBQLytmLysvd1lBQ0FELy8vTC8rLzhCQUFZQUJRRDkvL1AvL1A4RkFBVUFBZ0Q3Ly9ULy9mOEhBQVFBLy8vNy8vZi8vLzhJQUFNQS9QLzYvL3IvQVFBSUFBRUErdi82Ly8zL0FnQUhBQUFBK2YvNy93QUFBd0FGQVA3LytQLzgvd0lBQWdBQ0FQMy8rZi85L3dNQUF3QUFBUHovK3YvKy93UUFBZ0QrLy96LysvOEFBQVFBQVFEOC8vei8vZjhCQUFRQUFBRDcvLzMvLy84QkFBTUEvLy83Ly8zL0FBQUNBQUVBL3YvNy8vNy9BUUFCQUFBQS92LzkvLy8vQVFBQUFQLy8vdi8rLy8vL0FBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vLy8rLy8vLy8vOEFBQUFBL3YvKy93QUFBUUQ4Ly8zL0NRQUpBUDMvK3Y4UEFBY0FwQUJsQUJrQmt3Q08vaS8vbGZxYS9IUUFjZi8zQmRrQ3p3SmNCQ01DMHdNTi85Lzl3Z0k3QWFFQ1lmeFYvVGY4M3Zobi94cnQ4T3d4LzhuN2NnSEFCWWI0M1FjWkRoNFd1Z05yQTdQNzRnSHUvOXovenYwdC9hY0NpUUhZL2l2NHFRT2wveXNDRS8wLy9YVDlTZjRPLy9qOXhmdXBBbjM5NGdITytyc0NYQUZJQXhRQzl3SVhCZ2NEMkFRdUFuYi85Z0poLzZ3QVZmeEVBSTRCdmY3b0FGdi9iQUxzQU1RQmUvODgvam9BVC80ZEFIMzkvdjlMQVhuL2d3REkvL1FCZEFCY0FBMEE3ZjRsQU1uLy8vKzkvdHYvaUFCcC8xMy9wUC9kQUx2L3cvOE1BSHYvL2YreS82Ly8vLzdVLzVBQVpQK1ovOHIvblFEUi81ci9Ed0RyL3hBQTR2K3MvM3ovK1A5dUFPdi90LzgyQUdjQUhnQ2IveVFBRlFCR0FNNy9DZ0QzL3hvQWVnQWFBT3ovQ2dCSEFBOEFkdjgvQUFBQUJRQzIveElBQUFBN0FCUUFLZ0NqL3o0QUFRQVhBSnovSkFBREFBY0E4Zi8xLzJBQUFRQWxBUEQvTmdEeC8xd0E3di80L3dNQVpBRHYvLzMvSFFBa0FGb0E4UDlGQVB2L0ZnQklBUGYvV1FBSEFFVUFDUUQwL3hJQVF3RHUvd01Bd1A5VkFMbi9Yd0N3L3lFQTVmOHNBUGovRmdERC8xWUF5djhyQU9YL0hRRG8vL2ovSVFBUUFDQUFId0Q5L3lRQUhRQkFBQmdBQlFBaUFBVUFLQUQzL3drQUN3QUtBQU1BQndBSkFQYi8rZjhHQU9yL0pRQUhBQk1BNlA4VEFBNEFHZ0QvL3dvQTgvOFpBUC8vR0FEdS93MEE5djhTQUFNQUJ3RDQvd1FBNVA4WEFBUUFDZ0RxL3dVQSsvOFZBQWNBQ0FEcy94SUFBQUFUQVBILyt2LzEvL1QvN2YvLy8rei8rdi95LysvLzkvOEtBQWNBQ2dBSkFQVC9CQUFLQUFBQUJnQUlBUEwvOXY4S0FBTUFCQUFDQVByLzl2OE9BQUlBK1AveC8vdi8rZjhNQVBiLytQL3cvd1FBOWY4TUFQbi8vLy83L3dvQS92OFBBQUVBQWdEMS94QUFBUUFQQVAvL0F3RC8veFFBQndBTEFBQUFCZ0FEQUJBQUFnQUhBQUFBQ0FBQkFBOEFCUUFGQUFNQUJ3QUVBQTRBQndBREFBRUFDUUFGQUFvQUF3RC8vd0FBQ1FBREFBVUFBUUQvLy8vL0NBQUJBQU1BQUFELy8vLy9Cd0FDQUFFQUFBRC8vLy8vQndBQ0FQNy8vLzhCQUFBQUJnQUJBUDcvLy84Q0FBQUFCQUFBQVA3Ly8vOERBQUFBQXdBQUFQMy8vLzhEQUFBQUFRQUFBUDMvL3Y4RUFBQUFBQUQrLy8vLy8vOEVBUC8vLy8vKy93QUEvdjhFQVAvLy8vLysvd0VBL3Y4RUFQLy8vdi8rL3dJQS8vOERBUC8vL3YvKy93SUEvLzhCQVAvLy92Lysvd01BLy84QkFQLy8vLy8rL3dNQS8vOEFBUC8vQUFEKy93UUEvLzhBQVA3L0FRRC8vd0lBLy8vLy8vLy9BUUQvL3dJQS8vLy8vLy8vQVFBQUFBRUFBQUFBQVAvL0FRRC8vd0VBQUFBQUFQLy9BUUFBQUFFQUFBQUFBQUFBXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFEKy93QUErdjhBQVB6L0FBRC8vd0FBL2Y4QUFBRUFBQUQrL3dBQUNRQUFBQVFBQUFBWkFBQUF0Z0FBQUZzQkFBQlcvZ0FBSC9vQUFHY0JBQUJvQndBQWxBQUFBTzMvQUFBUkFRQUErd0lBQUVvRUFBQ2UvZ0FBaXY0QUFMRDBBQURKOHdBQWtRUUFBRjM0QUFCaThRQUFQUUFBQUFIMkFBRDE5QUFBREFNQUFKd0dBQUNURUFBQTBBd0FBSmtIQUFDT0J3QUF1UUVBQU5jREFBQzZBZ0FBSHdVQUFIRUZBQUIwQXdBQWJnRUFBRHorQUFEWUFRQUFHQUFBQUp3Q0FBRGdBQUFBLy8wQUFNbitBQUFUL0FBQXdQOEFBT245QUFBSkFBQUFld0VBQU9uK0FBQ04vd0FBT3YwQUFPMytBQUROL2dBQWNQOEFBQ2ovQUFDcS9nQUErZjRBQU1MOUFBQ2Evd0FBL2Y0QUFONy9BQUJvL3dBQTYvNEFBRS8vQUFBQy93QUFFUUFBQUhYL0FBQjBBQUFBNWY4QUFFd0FBQUIzQUFBQTUvOEFBTUlBQUFCQ0FBQUF6Z0FBQUU4QUFBQjNBQUFBS0FBQUFETUFBQUNxQUFBQUx3QUFBSzRBQUFBU0FBQUFWZ0FBQUNnQUFBQXRBQUFBVEFBQUFQMy9BQUE3QUFBQTIvOEFBQ1FBQUFEdy93QUFMUUFBQURFQUFBQWxBQUFBYkFBQUFETUFBQUJVQUFBQUVBQUFBQ2dBQUFEMS93QUE5djhBQVByL0FBRHUvd0FBTGdBQUFCSUFBQUJVQUFBQVJBQUFBR1VBQUFCR0FBQUFPQUFBQUdBQUFBQXVBQUFBUlFBQUFDRUFBQUFmQUFBQUFBQUFBQWtBQUFBUUFBQUFBd0FBQUJJQUFBRHMvd0FBRUFBQUFBWUFBQUFTQUFBQUlnQUFBQkVBQUFBREFBQUFCQUFBQUE4QUFBRDQvd0FBSFFBQUFBc0FBQUFJQUFBQURnQUFBUC8vQUFBY0FBQUFEd0FBQUFZQUFBQVNBQUFBRndBQUFBTUFBQUFZQUFBQUVnQUFBUHIvQUFBUUFBQUFEUUFBQUFvQUFBRDMvd0FBQmdBQUFQYi9BQURmL3dBQS92OEFBUEwvQUFENi93QUFGQUFBQUFRQUFBQUVBQUFBR3dBQUFBRUFBQUFNQUFBQUlBQUFBQUlBQUFBZEFBQUFHQUFBQUFJQUFBQWNBQUFBRWdBQUFBY0FBQUFlQUFBQUR3QUFBQVFBQUFBZUFBQUFCQUFBQUFZQUFBQVpBQUFBQVFBQUFBNEFBQUFUQUFBQS92OEFBQW9BQUFBT0FBQUErLzhBQUFzQUFBQUpBQUFBK2Y4QUFBc0FBQUFCQUFBQStmOEFBQW9BQUFEOS93QUErdjhBQUFjQUFBRDUvd0FBK3Y4QUFBVUFBQUQzL3dBQS9mOEFBQVFBQUFEMi93QUFBQUFBQUFFQUFBRDMvd0FBQWdBQUFBQUFBQUQ0L3dBQUF3QUFBUDcvQUFENi93QUFCQUFBQVAzL0FBRDgvd0FBQkFBQUFQdi9BQUQrL3dBQUF3QUFBUHYvQUFELy93QUFBUUFBQVB2L0FBQUFBQUFBQUFBQUFQdi9BQUFDQUFBQS8vOEFBUHovQUFBQ0FBQUEvdjhBQVAzL0FBQUNBQUFBL2Y4QUFQNy9BQUFCQUFBQS9mOEFBUC8vQUFBQkFBQUEvZjhBQUFBQUFBQUFBQUFBL3Y4QUFBRUFBQUFBQUFBQS8vOEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIsXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9tbml0b25lU09BSHJpckJhc2U2NDtcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgQ3Jvc3MtYnJvd3NlciBzdXBwb3J0IHBvbHlmaWxsIGZvciBPbW5pdG9uZSBsaWJyYXJ5LlxuICovXG5cblxuXG5cbi8qKlxuICogRGV0ZWN0cyBicm93c2VyIHR5cGUgYW5kIHZlcnNpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX0gLSBBbiBhcnJheSBjb250YWlucyB0aGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lIGFuZCB2ZXJzaW9uLlxuICovXG5leHBvcnRzLmdldEJyb3dzZXJJbmZvID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgbGV0IE0gPSB1YS5tYXRjaChcbiAgICAgIC8ob3BlcmF8Y2hyb21lfHNhZmFyaXxmaXJlZm94fG1zaWV8dHJpZGVudCg/PVxcLykpXFwvP1xccyooW1xcZFxcLl0rKS9pKSB8fFxuICAgICAgW107XG4gIGxldCB0ZW07XG5cbiAgaWYgKC90cmlkZW50L2kudGVzdChNWzFdKSkge1xuICAgIHRlbSA9IC9cXGJydlsgOl0rKFxcZCspL2cuZXhlYyh1YSkgfHwgW107XG4gICAgcmV0dXJuIHtuYW1lOiAnSUUnLCB2ZXJzaW9uOiAodGVtWzFdIHx8ICcnKX07XG4gIH1cblxuICBpZiAoTVsxXSA9PT0gJ0Nocm9tZScpIHtcbiAgICB0ZW0gPSB1YS5tYXRjaCgvXFxiT1BSfEVkZ2VcXC8oXFxkKykvKTtcbiAgICBpZiAodGVtICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7bmFtZTogJ09wZXJhJywgdmVyc2lvbjogdGVtWzFdfTtcbiAgICB9XG4gIH1cblxuICBNID0gTVsyXSA/IFtNWzFdLCBNWzJdXSA6IFtuYXZpZ2F0b3IuYXBwTmFtZSwgbmF2aWdhdG9yLmFwcFZlcnNpb24sICctPyddO1xuICBpZiAoKHRlbSA9IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFtcXGQuXSspL2kpKSAhPSBudWxsKSB7XG4gICAgTS5zcGxpY2UoMSwgMSwgdGVtWzFdKTtcbiAgfVxuXG4gIGxldCBwbGF0Zm9ybSA9IHVhLm1hdGNoKC9hbmRyb2lkfGlwYWR8aXBob25lL2kpO1xuICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgcGxhdGZvcm0gPSB1YS5tYXRjaCgvY3Jvc3xsaW51eHxtYWMgb3MgeHx3aW5kb3dzL2kpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBNWzBdLFxuICAgIHZlcnNpb246IE1bMV0sXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtID8gcGxhdGZvcm1bMF0gOiAndW5rbm93bicsXG4gIH07XG59O1xuXG5cbi8qKlxuICogUGF0Y2hlcyBBdWRpb0NvbnRleHQgaWYgdGhlIHByZWZpeGVkIEFQSSBpcyBmb3VuZC5cbiAqL1xuZXhwb3J0cy5wYXRjaFNhZmFyaSA9IGZ1bmN0aW9uKCkge1xuICBpZiAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCAmJiB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCkge1xuICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xuICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIHZlcnNpb24uXG4gKi9cblxuXG5cblxuLyoqXG4gKiBPbW5pdG9uZSBsaWJyYXJ5IHZlcnNpb25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJzEuMC42JztcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFJlc29uYW5jZUF1ZGlvIHZlcnNpb24uXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vKipcbiAqIFJlc29uYW5jZUF1ZGlvIGxpYnJhcnkgdmVyc2lvblxuICogQHR5cGUge1N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAnMC4wLjQnO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyIsImltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSAnLi9NYXRyaXg0LmpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jb25zdCBfbWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNsYXNzIEV1bGVyIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSBFdWxlci5EZWZhdWx0T3JkZXIgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdGNvcHkoIGV1bGVyICkge1xuXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cztcblx0XHRjb25zdCBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xuXHRcdGNvbnN0IG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG5cdFx0Y29uc3QgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cblx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRcdGNhc2UgJ1hZWic6XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWFonOlxuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWlhZJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pZWCc6XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWlgnOlxuXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWFpZJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xuXG5cdH1cblxuXHRyZW9yZGVyKCBuZXdPcmRlciApIHtcblxuXHRcdC8vIFdBUk5JTkc6IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbiAtYmhvdXN0b25cblxuXHRcdF9xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLCBuZXdPcmRlciApO1xuXG5cdH1cblxuXHRlcXVhbHMoIGV1bGVyICkge1xuXG5cdFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XG5cdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHR0b1ZlY3RvcjMoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG59XG5cbkV1bGVyLnByb3RvdHlwZS5pc0V1bGVyID0gdHJ1ZTtcblxuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuXG5leHBvcnQgeyBFdWxlciB9O1xuIiwiY29uc3QgX2x1dCA9IFtdO1xuXG5mb3IgKCBsZXQgaSA9IDA7IGkgPCAyNTY7IGkgKysgKSB7XG5cblx0X2x1dFsgaSBdID0gKCBpIDwgMTYgPyAnMCcgOiAnJyApICsgKCBpICkudG9TdHJpbmcoIDE2ICk7XG5cbn1cblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkaWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdFx0IH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHRcdCB9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcyAlIDIxNDc0ODM2NDc7XG5cblx0Ly8gUGFyay1NaWxsZXIgYWxnb3JpdGhtXG5cblx0X3NlZWQgPSBfc2VlZCAqIDE2ODA3ICUgMjE0NzQ4MzY0NztcblxuXHRyZXR1cm4gKCBfc2VlZCAtIDEgKSAvIDIxNDc0ODM2NDY7XG5cbn1cblxuZnVuY3Rpb24gZGVnVG9SYWQoIGRlZ3JlZXMgKSB7XG5cblx0cmV0dXJuIGRlZ3JlZXMgKiBERUcyUkFEO1xuXG59XG5cbmZ1bmN0aW9uIHJhZFRvRGVnKCByYWRpYW5zICkge1xuXG5cdHJldHVybiByYWRpYW5zICogUkFEMkRFRztcblxufVxuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG59XG5cbmZ1bmN0aW9uIGNlaWxQb3dlck9mVHdvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gZmxvb3JQb3dlck9mVHdvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG59XG5cbmZ1bmN0aW9uIHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoIHEsIGEsIGIsIGMsIG9yZGVyICkge1xuXG5cdC8vIEludHJpbnNpYyBQcm9wZXIgRXVsZXIgQW5nbGVzIC0gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX2FuZ2xlc1xuXG5cdC8vIHJvdGF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgYXhlcyBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGJ5ICdvcmRlcidcblx0Ly8gcm90YXRpb24gYnkgYW5nbGUgJ2EnIGlzIGFwcGxpZWQgZmlyc3QsIHRoZW4gYnkgYW5nbGUgJ2InLCB0aGVuIGJ5IGFuZ2xlICdjJ1xuXHQvLyBhbmdsZXMgYXJlIGluIHJhZGlhbnNcblxuXHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0Y29uc3Qgc2luID0gTWF0aC5zaW47XG5cblx0Y29uc3QgYzIgPSBjb3MoIGIgLyAyICk7XG5cdGNvbnN0IHMyID0gc2luKCBiIC8gMiApO1xuXG5cdGNvbnN0IGMxMyA9IGNvcyggKCBhICsgYyApIC8gMiApO1xuXHRjb25zdCBzMTMgPSBzaW4oICggYSArIGMgKSAvIDIgKTtcblxuXHRjb25zdCBjMV8zID0gY29zKCAoIGEgLSBjICkgLyAyICk7XG5cdGNvbnN0IHMxXzMgPSBzaW4oICggYSAtIGMgKSAvIDIgKTtcblxuXHRjb25zdCBjM18xID0gY29zKCAoIGMgLSBhICkgLyAyICk7XG5cdGNvbnN0IHMzXzEgPSBzaW4oICggYyAtIGEgKSAvIDIgKTtcblxuXHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdGNhc2UgJ1hZWCc6XG5cdFx0XHRxLnNldCggYzIgKiBzMTMsIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdZWlknOlxuXHRcdFx0cS5zZXQoIHMyICogczFfMywgYzIgKiBzMTMsIHMyICogYzFfMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWlhaJzpcblx0XHRcdHEuc2V0KCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBzMTMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1haWCc6XG5cdFx0XHRxLnNldCggYzIgKiBzMTMsIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdZWFknOlxuXHRcdFx0cS5zZXQoIHMyICogYzNfMSwgYzIgKiBzMTMsIHMyICogczNfMSwgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWllaJzpcblx0XHRcdHEuc2V0KCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBzMTMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoVXRpbHM6IC5zZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0fVxuXG59XG5cblxuXG5cbmV4cG9ydCB7XG5cdERFRzJSQUQsXG5cdFJBRDJERUcsXG5cdGdlbmVyYXRlVVVJRCxcblx0Y2xhbXAsXG5cdGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyLFxuXHRpbnZlcnNlTGVycCxcblx0bGVycCxcblx0ZGFtcCxcblx0cGluZ3BvbmcsXG5cdHNtb290aHN0ZXAsXG5cdHNtb290aGVyc3RlcCxcblx0cmFuZEludCxcblx0cmFuZEZsb2F0LFxuXHRyYW5kRmxvYXRTcHJlYWQsXG5cdHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQsXG5cdHJhZFRvRGVnLFxuXHRpc1Bvd2VyT2ZUd28sXG5cdGNlaWxQb3dlck9mVHdvLFxuXHRmbG9vclBvd2VyT2ZUd28sXG5cdHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIsXG59O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbmNsYXNzIE1hdHJpeDQge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0XTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0c2V0KCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XG5cdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlkZW50aXR5KCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdOyB0ZVsgMyBdID0gbWVbIDMgXTtcblx0XHR0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07IHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTtcblx0XHR0ZVsgOCBdID0gbWVbIDggXTsgdGVbIDkgXSA9IG1lWyA5IF07IHRlWyAxMCBdID0gbWVbIDEwIF07IHRlWyAxMSBdID0gbWVbIDExIF07XG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTsgdGVbIDEzIF0gPSBtZVsgMTMgXTsgdGVbIDE0IF0gPSBtZVsgMTQgXTsgdGVbIDE1IF0gPSBtZVsgMTUgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb3B5UG9zaXRpb24oIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsIG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XG5cdFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcblx0XHR0ZVsgMTQgXSA9IG1lWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sIDAsXG5cdFx0XHRtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLCAwLFxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXh0cmFjdEJhc2lzKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDEgKTtcblx0XHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZUJhc2lzKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cdFx0XHR4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLFxuXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcblx0XHRcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0Um90YXRpb24oIG0gKSB7XG5cblx0XHQvLyB0aGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHJlZmxlY3Rpb24gbWF0cmljZXNcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRjb25zdCBzY2FsZVggPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVkgPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzY2FsZVogPSAxIC8gX3YxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuXHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25Gcm9tRXVsZXIoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuXHRcdGNvbnN0IGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0Y29uc3QgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCBfemVybywgcSwgX29uZSApO1xuXG5cdH1cblxuXHRsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggbSwgbiApIHtcblxuXHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseU1hdHJpY2VzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYWUgPSBhLmVsZW1lbnRzO1xuXHRcdGNvbnN0IGJlID0gYi5lbGVtZW50cztcblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgNCBdLCBhMTMgPSBhZVsgOCBdLCBhMTQgPSBhZVsgMTIgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcblx0XHRjb25zdCBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG5cdFx0Y29uc3QgYTQxID0gYWVbIDMgXSwgYTQyID0gYWVbIDcgXSwgYTQzID0gYWVbIDExIF0sIGE0NCA9IGFlWyAxNSBdO1xuXG5cdFx0Y29uc3QgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG5cdFx0Y29uc3QgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xuXHRcdGNvbnN0IGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0Mjtcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuXHRcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcblx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuXHRcdHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG5cdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0dGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cblx0XHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG5cdFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuXHRcdHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XG5cdFx0dGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XG5cdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGV0ZXJtaW5hbnQoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHRjb25zdCBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcblx0XHRjb25zdCBuMzEgPSB0ZVsgMiBdLCBuMzIgPSB0ZVsgNiBdLCBuMzMgPSB0ZVsgMTAgXSwgbjM0ID0gdGVbIDE0IF07XG5cdFx0Y29uc3QgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZSgpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRsZXQgdG1wO1xuXG5cdFx0dG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFBvc2l0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcblxuXHRcdFx0dGVbIDEyIF0gPSB4Lng7XG5cdFx0XHR0ZVsgMTMgXSA9IHgueTtcblx0XHRcdHRlWyAxNCBdID0geC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGVbIDEyIF0gPSB4O1xuXHRcdFx0dGVbIDEzIF0gPSB5O1xuXHRcdFx0dGVbIDE0IF0gPSB6O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGludmVydCgpIHtcblxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cyxcblxuXHRcdFx0bjExID0gdGVbIDAgXSwgbjIxID0gdGVbIDEgXSwgbjMxID0gdGVbIDIgXSwgbjQxID0gdGVbIDMgXSxcblx0XHRcdG4xMiA9IHRlWyA0IF0sIG4yMiA9IHRlWyA1IF0sIG4zMiA9IHRlWyA2IF0sIG40MiA9IHRlWyA3IF0sXG5cdFx0XHRuMTMgPSB0ZVsgOCBdLCBuMjMgPSB0ZVsgOSBdLCBuMzMgPSB0ZVsgMTAgXSwgbjQzID0gdGVbIDExIF0sXG5cdFx0XHRuMTQgPSB0ZVsgMTIgXSwgbjI0ID0gdGVbIDEzIF0sIG4zNCA9IHRlWyAxNCBdLCBuNDQgPSB0ZVsgMTUgXSxcblxuXHRcdFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxuXHRcdFx0dDEyID0gbjE0ICogbjMzICogbjQyIC0gbjEzICogbjM0ICogbjQyIC0gbjE0ICogbjMyICogbjQzICsgbjEyICogbjM0ICogbjQzICsgbjEzICogbjMyICogbjQ0IC0gbjEyICogbjMzICogbjQ0LFxuXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuXHRcdFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXG5cdFx0Y29uc3QgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDkgXSA9ICggbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDEwIF0gPSAoIG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xuXHRcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNjYWxlKCB2ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XG5cblx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xuXHRcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XG5cdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XG5cdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0TWF4U2NhbGVPbkF4aXMoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcblx0XHRjb25zdCBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcblx0XHRjb25zdCBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xuXG5cdH1cblxuXHRtYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgeCxcblx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHQwLCAwLCAxLCB6LFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25YKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHQwLCBzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25ZKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtIHMsIDAsIGMsIDAsXG5cdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25aKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHRjb25zdCB0ID0gMSAtIGM7XG5cdFx0Y29uc3QgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHRjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNoZWFyKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHksIHosIDAsXG5cdFx0XHR4LCAxLCB6LCAwLFxuXHRcdFx0eCwgeSwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgeCA9IHF1YXRlcm5pb24uX3gsIHkgPSBxdWF0ZXJuaW9uLl95LCB6ID0gcXVhdGVybmlvbi5feiwgdyA9IHF1YXRlcm5pb24uX3c7XG5cdFx0Y29uc3QgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0Y29uc3QgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6Mjtcblx0XHRjb25zdCB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuXHRcdGNvbnN0IHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHRjb25zdCBzeCA9IHNjYWxlLngsIHN5ID0gc2NhbGUueSwgc3ogPSBzY2FsZS56O1xuXG5cdFx0dGVbIDAgXSA9ICggMSAtICggeXkgKyB6eiApICkgKiBzeDtcblx0XHR0ZVsgMSBdID0gKCB4eSArIHd6ICkgKiBzeDtcblx0XHR0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xuXHRcdHRlWyA1IF0gPSAoIDEgLSAoIHh4ICsgenogKSApICogc3k7XG5cdFx0dGVbIDYgXSA9ICggeXogKyB3eCApICogc3k7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gKCB4eiArIHd5ICkgKiBzejtcblx0XHR0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcblx0XHR0ZVsgMTAgXSA9ICggMSAtICggeHggKyB5eSApICkgKiBzejtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IHBvc2l0aW9uLng7XG5cdFx0dGVbIDEzIF0gPSBwb3NpdGlvbi55O1xuXHRcdHRlWyAxNCBdID0gcG9zaXRpb24uejtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRsZXQgc3ggPSBfdjEuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0aWYgKCBkZXQgPCAwICkgc3ggPSAtIHN4O1xuXG5cdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXHRcdF9tMS5jb3B5KCB0aGlzICk7XG5cblx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRjb25zdCBpbnZTWSA9IDEgLyBzeTtcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuXHRcdF9tMS5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRfbTEuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0aWYgKCBmYXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRjb25zdCBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdGNvbnN0IGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cdFx0Y29uc3QgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdHRlWyAwIF0gPSB4O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gYTtcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAtIDE7XHR0ZVsgMTUgXSA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZU9ydGhvZ3JhcGhpYyggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgaCA9IDEuMCAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0Y29uc3QgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0Y29uc3QgeCA9ICggcmlnaHQgKyBsZWZ0ICkgKiB3O1xuXHRcdGNvbnN0IHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcblx0XHRjb25zdCB6ID0gKCBmYXIgKyBuZWFyICkgKiBwO1xuXG5cdFx0dGVbIDAgXSA9IDIgKiB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSAtIDIgKiBwO1x0dGVbIDE0IF0gPSAtIHo7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5NYXRyaXg0LnByb3RvdHlwZS5pc01hdHJpeDQgPSB0cnVlO1xuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcbmNvbnN0IF9vbmUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5jb25zdCBfeCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF95ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ogPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbmNsYXNzIFF1YXRlcm5pb24ge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdH1cblxuXHRzdGF0aWMgc2xlcnAoIHFhLCBxYiwgcW0sIHQgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiBTdGF0aWMgLnNsZXJwKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHFtLnNsZXJwUXVhdGVybmlvbnMoIHFhLCBxYiwgdCApIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBxbS5zbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKTtcblxuXHR9XG5cblx0c3RhdGljIHNsZXJwRmxhdCggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XG5cblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXG5cblx0XHRsZXQgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxuXHRcdFx0ejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdLFxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuXHRcdFx0eTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdLFxuXHRcdFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxuXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0aWYgKCB0ID09PSAwICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0ID09PSAxICkge1xuXG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDAgXSA9IHgxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcxO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEgKSB7XG5cblx0XHRcdGxldCBzID0gMSAtIHQ7XG5cdFx0XHRjb25zdCBjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXHRcdFx0XHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxuXHRcdFx0XHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xuXG5cdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuXHRcdFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuXHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XG5cblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XG5cdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHREaXIgPSB0ICogZGlyO1xuXG5cdFx0XHR4MCA9IHgwICogcyArIHgxICogdERpcjtcblx0XHRcdHkwID0geTAgKiBzICsgeTEgKiB0RGlyO1xuXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG5cdFx0XHR3MCA9IHcwICogcyArIHcxICogdERpcjtcblxuXHRcdFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcblxuXHRcdFx0XHRjb25zdCBmID0gMSAvIE1hdGguc3FydCggeDAgKiB4MCArIHkwICogeTAgKyB6MCAqIHowICsgdzAgKiB3MCApO1xuXG5cdFx0XHRcdHgwICo9IGY7XG5cdFx0XHRcdHkwICo9IGY7XG5cdFx0XHRcdHowICo9IGY7XG5cdFx0XHRcdHcwICo9IGY7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuXHR9XG5cblx0c3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSApIHtcblxuXHRcdGNvbnN0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCBdO1xuXHRcdGNvbnN0IHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXTtcblx0XHRjb25zdCB6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF07XG5cdFx0Y29uc3QgdzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdO1xuXG5cdFx0Y29uc3QgeDEgPSBzcmMxWyBzcmNPZmZzZXQxIF07XG5cdFx0Y29uc3QgeTEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMSBdO1xuXHRcdGNvbnN0IHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXTtcblx0XHRjb25zdCB3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwICogdzEgKyB3MCAqIHkxICsgejAgKiB4MSAtIHgwICogejE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcblxuXHRcdHJldHVybiBkc3Q7XG5cblx0fVxuXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB3KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3c7XG5cblx0fVxuXG5cdHNldCB3KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiwgdyApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cblx0fVxuXG5cdGNvcHkoIHF1YXRlcm5pb24gKSB7XG5cblx0XHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG5cdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcblx0XHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21FdWxlciggZXVsZXIsIHVwZGF0ZSApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdGNvbnN0IGMxID0gY29zKCB4IC8gMiApO1xuXHRcdGNvbnN0IGMyID0gY29zKCB5IC8gMiApO1xuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0Y29uc3QgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XG5cdFx0Y29uc3QgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0bGV0IHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHQvLyB2RnJvbSBhbmQgdlRvIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIE1hdGhVdGlscy5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEsIHAgKSB7XG5cblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG5cdFx0Y29uc3QgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcblx0XHRjb25zdCBxYnggPSBiLl94LCBxYnkgPSBiLl95LCBxYnogPSBiLl96LCBxYncgPSBiLl93O1xuXG5cdFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcblx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG5cdFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzbGVycCggcWIsIHQgKSB7XG5cblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcblx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gdGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG5cdFx0bGV0IGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcblxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IC0gcWIuX3c7XG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcblx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuXHRcdFx0dGhpcy5feiA9IC0gcWIuX3o7XG5cblx0XHRcdGNvc0hhbGZUaGV0YSA9IC0gY29zSGFsZlRoZXRhO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBxYiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG5cdFx0XHR0aGlzLl93ID0gdztcblx0XHRcdHRoaXMuX3ggPSB4O1xuXHRcdFx0dGhpcy5feSA9IHk7XG5cdFx0XHR0aGlzLl96ID0gejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzcXJTaW5IYWxmVGhldGEgPSAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGE7XG5cblx0XHRpZiAoIHNxclNpbkhhbGZUaGV0YSA8PSBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDEgLSB0O1xuXHRcdFx0dGhpcy5fdyA9IHMgKiB3ICsgdCAqIHRoaXMuX3c7XG5cdFx0XHR0aGlzLl94ID0gcyAqIHggKyB0ICogdGhpcy5feDtcblx0XHRcdHRoaXMuX3kgPSBzICogeSArIHQgKiB0aGlzLl95O1xuXHRcdFx0dGhpcy5feiA9IHMgKiB6ICsgdCAqIHRoaXMuX3o7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cdFx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCBzcXJTaW5IYWxmVGhldGEgKTtcblx0XHRjb25zdCBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xuXHRcdGNvbnN0IHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcblx0XHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwUXVhdGVybmlvbnMoIHFhLCBxYiwgdCApIHtcblxuXHRcdHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxufVxuXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pc1F1YXRlcm5pb24gPSB0cnVlO1xuXG5leHBvcnQgeyBRdWF0ZXJuaW9uIH07XG4iLCJpbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5cbmNsYXNzIFZlY3RvcjMge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFgoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFkoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKz0gdi54O1xuXHRcdHRoaXMueSArPSB2Lnk7XG5cdFx0dGhpcy56ICs9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGVkVmVjdG9yKCB2LCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHYueCAqIHM7XG5cdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cdFx0dGhpcy56ICs9IHYueiAqIHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggLT0gdi54O1xuXHRcdHRoaXMueSAtPSB2Lnk7XG5cdFx0dGhpcy56IC09IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseUV1bGVyKCBldWxlciApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG5cdH1cblxuXHRhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIF9xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXgzKCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5Tm9ybWFsTWF0cml4KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKCBtICkubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHRjb25zdCB3ID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTtcblxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6ICsgZVsgMTIgXSApICogdztcblx0XHR0aGlzLnkgPSAoIGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKSAqIHc7XG5cdFx0dGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdGNvbnN0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuXHRcdGNvbnN0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuXHRcdGNvbnN0IGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdGNvbnN0IGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cblx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cblx0XHR0aGlzLnggPSBpeCAqIHF3ICsgaXcgKiAtIHF4ICsgaXkgKiAtIHF6IC0gaXogKiAtIHF5O1xuXHRcdHRoaXMueSA9IGl5ICogcXcgKyBpdyAqIC0gcXkgKyBpeiAqIC0gcXggLSBpeCAqIC0gcXo7XG5cdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKS5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0fVxuXG5cdHVucHJvamVjdCggY2FtZXJhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UgKS5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XG5cdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGRpdmlkZSggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblx0XHR0aGlzLnogLz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9XG5cblx0bWluKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWF4KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnogKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcblxuXHR9XG5cblx0Zmxvb3IoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZWlsKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmQoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZFRvWmVybygpIHtcblxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG5lZ2F0ZSgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cblx0fVxuXG5cdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cblxuXHRsZW5ndGhTcSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG5cblx0fVxuXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xuXG5cdH1cblxuXHRtYW5oYXR0YW5MZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xuXG5cdH1cblxuXHRzZXRMZW5ndGgoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcblxuXHR9XG5cblx0bGVycCggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRsZXJwVmVjdG9ycyggdjEsIHYyLCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCA9IHYxLnggKyAoIHYyLnggLSB2MS54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgPSB2MS55ICsgKCB2Mi55IC0gdjEueSApICogYWxwaGE7XG5cdFx0dGhpcy56ID0gdjEueiArICggdjIueiAtIHYxLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNyb3NzKCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IgKTtcblxuXHR9XG5cblx0cmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdH1cblxuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWwoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9XG5cblx0c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKSB7XG5cblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDEyIF07XG5cdFx0dGhpcy55ID0gZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhTY2FsZSggbSApIHtcblxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4M0NvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblZlY3RvcjMucHJvdG90eXBlLmlzVmVjdG9yMyA9IHRydWU7XG5cbmNvbnN0IF92ZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcblxuZXhwb3J0IHsgVmVjdG9yMyB9O1xuIiwiaW1wb3J0IHsgZGV0ZWN0IH0gZnJvbSBcImRldGVjdC1icm93c2VyXCI7XG5pbXBvcnQgeyBpc0lvcyB9IGZyb20gXCIuL2lzSW9zXCI7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gIGNvbnN0IGJyb3dzZXIgPSBkZXRlY3QoKTtcbiAgY29uc29sZS5sb2coYnJvd3Nlcik7XG4gIGNvbnNvbGUubG9nKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAvL2lPUyB3ZSB3aWxsIHJlZGlyZWN0IHRvIG5vbiBhciB2ZXJzaW9uIGFueXdheVxuICBpZiAoaXNJb3MpIHJldHVybjtcbiAgaWYgKGJyb3dzZXIub3MgIT09IFwiQW5kcm9pZCBPU1wiICYmIGJyb3dzZXIub3MgIT09IFwiYW5kcm9pZFwiKSByZXR1cm47XG4gIGlmIChicm93c2VyLm5hbWUgIT09IFwiY2hyb21lXCIgJiYgYnJvd3Nlci5uYW1lICE9PSBcImNocm9taXVtLXdlYnZpZXdcIikge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZXJyb3Itb3ZlcmxheVwiKS5pbm5lckhUTUwgPSBgXG4gICAgPGRpdj5UaGlzIHNpdGUgb25seSBzdXBwb3J0cyB0aGUgPGEgaHJlZj0naHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPWNvbS5hbmRyb2lkLmNocm9tZSc+Q2hyb21lIHdlYiBicm93c2VyIG9uIEFuZHJvaWQuPC9hPjwvZGl2PjtcbiAgICBgO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZXJyb3Itb3ZlcmxheVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gIH1cbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4ge1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgIFwiI2Vycm9yLW92ZXJsYXlcIixcbiAgKS5pbm5lckhUTUwgPSBgPGRpdj5Pb3BzISBBbiBlcnJvcjxicj48YnI+UGxlYXNlIHJlZnJlc2ggdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi48YnI+PGJyPjxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAwLjVlbVwiPiR7ZXZlbnQubWVzc2FnZX08L3NwYW4+PC9kaXY+YDtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlcnJvci1vdmVybGF5XCIpLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbn0pO1xuIiwiZXhwb3J0IGNvbnN0IGlzSW9zID1cbiAgW1wiaVBhZCBTaW11bGF0b3JcIiwgXCJpUGhvbmUgU2ltdWxhdG9yXCIsIFwiaVBvZCBTaW11bGF0b3JcIiwgXCJpUGFkXCIsIFwiaVBob25lXCIsIFwiaVBvZFwiXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pIHx8XG4gIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTWFjXCIpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50KTtcbiIsImV4cG9ydCBpbnRlcmZhY2UgTG9hZE1lZGlhU3RhdGUge1xuICBsb2FkZWQ/OiBib29sZWFuO1xuICBudW1Mb2FkZWQ/OiBudW1iZXI7XG4gIG51bUl0ZW1zPzogbnVtYmVyO1xuICBidWZmZXJTb3VyY2VzPzogQXVkaW9CdWZmZXJTb3VyY2VOb2RlW107XG4gIHJlcXVlc3RzPzogWE1MSHR0cFJlcXVlc3RbXTtcbiAgcHJvZ3Jlc3M/OiBudW1iZXJbXTtcbn1cblxuaW50ZXJmYWNlIExvYWRNZWRpYVBhcmFtcyB7XG4gIGVsOiBIVE1MRWxlbWVudDtcbiAgYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gIG9uU3VjY2VzcyhiYXJjb2RlRGF0YTogc3RyaW5nLCBidWZmZXJTb3VyY2VzOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGVbXSk6IHZvaWQ7XG4gIG9uUHJvZ3Jlc3MocGVyY2VudDogbnVtYmVyKTogdm9pZDtcbiAgYmFyY29kZURhdGE6IHN0cmluZztcbiAgbG9hZGluZ0JhcmNvZGVDb250YWluZXI6IHsgbG9hZGluZ0JhcmNvZGU6IG51bWJlciB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZE1lZGlhKHN0YXRlOiBMb2FkTWVkaWFTdGF0ZSwgcGFyYW1zOiBMb2FkTWVkaWFQYXJhbXMpOiB2b2lkIHtcbiAgc3RhdGUubG9hZGVkID0gZmFsc2U7XG4gIHN0YXRlLm51bUxvYWRlZCA9IDA7XG4gIHN0YXRlLm51bUl0ZW1zID0gcGFyYW1zLmVsLmNoaWxkcmVuLmxlbmd0aDtcbiAgc3RhdGUuYnVmZmVyU291cmNlcyA9IFtdO1xuICBjb25zb2xlLmxvZyhwYXJhbXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICBzdGF0ZS5yZXF1ZXN0cyA9IFtdO1xuXG4gIGNvbnNvbGUubG9nKGBMb2FkaW5nICR7c3RhdGUubnVtSXRlbXN9IGF1ZGlvIGVsZW1lbnRzYCk7XG5cbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHBhcmFtcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgc3RhdGUucHJvZ3Jlc3MgPSBBcnJheShwYXJhbXMuZWwuY2hpbGRyZW4ubGVuZ3RoKS5maWxsKDApO1xuICBBcnJheS5mcm9tKHBhcmFtcy5lbC5jaGlsZHJlbikuZm9yRWFjaCgoYW5jaG9yRWwsIGluZGV4KSA9PiB7XG4gICAgaWYgKGFuY2hvckVsLnRhZ05hbWUgIT09IFwiQVwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGxvYWRlciBzaG91bGQgb25seSBoYXZlIDxhPiBjaGlsZHJlblwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxVcmw6IHN0cmluZyA9IGFuY2hvckVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgY29uc3QgdXJsID1cbiAgICAgIHNhbXBsZVJhdGUgPT09IDQ4MDAwXG4gICAgICAgID8gb3JpZ2luYWxVcmwuc2xpY2UoMCwgLTMpICsgXCI0OC5cIiArIG9yaWdpbmFsVXJsLnNsaWNlKC0zKVxuICAgICAgICA6IHNhbXBsZVJhdGUgPT09IDQ0MTAwXG4gICAgICAgID8gb3JpZ2luYWxVcmwuc2xpY2UoMCwgLTMpICsgXCI0NC5cIiArIG9yaWdpbmFsVXJsLnNsaWNlKC0zKVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKCF1cmwpIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBzYW1wbGUgcmF0ZSAke3NhbXBsZVJhdGV9YCk7XG5cbiAgICBzdGF0ZS5idWZmZXJTb3VyY2VzLnB1c2gocGFyYW1zLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHN0YXRlLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgY2hpbGRQcm9ncmVzcy5iaW5kKHRoaXMsIHN0YXRlLCBwYXJhbXMsIGluZGV4KSk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjaGlsZExvYWRTdWNjZXNzLmJpbmQodGhpcywgc3RhdGUsIHBhcmFtcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBjaGlsZEVycm9yLmJpbmQodGhpcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjaGlsZEFib3J0LmJpbmQodGhpcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICByZXF1ZXN0LnNlbmQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkUHJvZ3Jlc3Moc3RhdGU6IExvYWRNZWRpYVN0YXRlLCBwYXJhbXM6IExvYWRNZWRpYVBhcmFtcywgaW5kZXg6IG51bWJlciwgZXZlbnQ6IFByb2dyZXNzRXZlbnQpIHtcbiAgY29uc3QgcGVyY2VudCA9IGV2ZW50LnRvdGFsID8gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgOiAwO1xuICBzdGF0ZS5wcm9ncmVzc1tpbmRleF0gPSBwZXJjZW50O1xuICBjb25zdCB0b3RhbFBlcmNlbnQgPSBzdGF0ZS5wcm9ncmVzcy5yZWR1Y2UoKHByZXY6IG51bWJlciwgY3VyOiBudW1iZXIpID0+IHByZXYgKyBjdXIpIC8gc3RhdGUucHJvZ3Jlc3MubGVuZ3RoO1xuICBwYXJhbXMub25Qcm9ncmVzcyh0b3RhbFBlcmNlbnQpO1xufVxuXG5mdW5jdGlvbiBjaGlsZExvYWRTdWNjZXNzKHN0YXRlOiBMb2FkTWVkaWFTdGF0ZSwgcGFyYW1zOiBMb2FkTWVkaWFQYXJhbXMsIGluZGV4OiBudW1iZXIpIHtcbiAgY29uc29sZS5sb2coYExvYWRlZCAke2luZGV4fWApO1xuICBjb25zdCBkYXRhID0gc3RhdGUucmVxdWVzdHNbaW5kZXhdLnJlc3BvbnNlO1xuICAvL3NhZmFyaSBkb2Vzbid0IHN1cHBvcnQgcHJvbWlzZSBiYXNlZCBkZWNvZGVcbiAgcGFyYW1zLmF1ZGlvQ29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgZGF0YSxcbiAgICAoYnVmZmVyOiBBdWRpb0J1ZmZlcikgPT4ge1xuICAgICAgc3RhdGUuYnVmZmVyU291cmNlc1tpbmRleF0uYnVmZmVyID0gYnVmZmVyO1xuXG4gICAgICBzdGF0ZS5udW1Mb2FkZWQgKz0gMTtcbiAgICAgIGlmIChzdGF0ZS5udW1Mb2FkZWQgPj0gc3RhdGUubnVtSXRlbXMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgYWxsIGl0ZW1zXCIpO1xuICAgICAgICBzdGF0ZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICBwYXJhbXMub25TdWNjZXNzKHBhcmFtcy5iYXJjb2RlRGF0YSwgc3RhdGUuYnVmZmVyU291cmNlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBjaGlsZEVycm9yKGluZGV4KTtcbiAgICB9LFxuICApO1xufVxuXG5mdW5jdGlvbiBjaGlsZEVycm9yKGluZGV4OiBudW1iZXIsIGV2ZW50PzogUHJvZ3Jlc3NFdmVudCkge1xuICB0aHJvdyBFcnJvcihgQ291bGRuJ3QgbG9hZCBwaWVjZSAke2luZGV4fS5gKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRBYm9ydChpbmRleDogbnVtYmVyKSB7XG4gIGNvbnNvbGUubG9nKGBBYm9ydGluZyBsb2FkIGl0ZW0gJHtpbmRleH1gKTtcbn1cbiIsImltcG9ydCB7IFJlc29uYW5jZUF1ZGlvIH0gZnJvbSBcInJlc29uYW5jZS1hdWRpb1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFJlc29uYW5jZShhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCk6IFJlc29uYW5jZUF1ZGlvIHtcbiAgY29uc29sZS5sb2coXCJMb2FkaW5nIHJlc29uYW5jZVwiKTtcbiAgY29uc3QgYW1iaXNvbmljT3JkZXIgPSAxO1xuICBjb25zdCByZXNvbmFuY2VBdWRpb1NjZW5lID0gbmV3IFJlc29uYW5jZUF1ZGlvKGF1ZGlvQ29udGV4dCwgeyBhbWJpc29uaWNPcmRlciB9KTtcbiAgcmVzb25hbmNlQXVkaW9TY2VuZS5zZXRSb29tUHJvcGVydGllcyhcbiAgICB7IHdpZHRoOiA2LCBoZWlnaHQ6IDUsIGRlcHRoOiA2IH0sXG4gICAge1xuICAgICAgYmFjazogXCJ3b29kLXBhbmVsXCIsXG4gICAgICBsZWZ0OiBcImJyaWNrLWJhcmVcIixcbiAgICAgIHJpZ2h0OiBcImJyaWNrLWJhcmVcIixcbiAgICAgIGZyb250OiBcIndvb2QtcGFuZWxcIixcbiAgICAgIGRvd246IFwicGx5d29vZC1wYW5lbFwiLFxuICAgICAgdXA6IFwiYWNvdXN0aWMtY2VpbGluZy10aWxlc1wiLFxuICAgIH0sXG4gICk7XG4gIHJlc29uYW5jZUF1ZGlvU2NlbmUub3V0cHV0LmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgcmV0dXJuIHJlc29uYW5jZUF1ZGlvU2NlbmU7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcblx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHsgRXVsZXIgfSBmcm9tIFwidGhyZWUvc3JjL21hdGgvRXVsZXJcIjtcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwidGhyZWUvc3JjL21hdGgvVmVjdG9yM1wiO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gXCJ0aHJlZS9zcmMvbWF0aC9RdWF0ZXJuaW9uXCI7XG5pbXBvcnQgeyBSZXNvbmFuY2VBdWRpbywgU291cmNlIH0gZnJvbSBcInJlc29uYW5jZS1hdWRpb1wiO1xuaW1wb3J0ICogYXMgTnVuanVja3MgZnJvbSBcIm51bmp1Y2tzXCI7XG5pbXBvcnQgXCIuL2dsb2JhbFwiO1xuaW1wb3J0IHsgbG9hZFJlc29uYW5jZSB9IGZyb20gXCIuL2xvYWRSZXNvbmFuY2VcIjtcbmltcG9ydCB7IGxvYWRNZWRpYSwgTG9hZE1lZGlhU3RhdGUgfSBmcm9tIFwiLi9sb2FkTWVkaWFcIjtcblxuY29uc3QgaW5kZXggPSBOdW1iZXIucGFyc2VJbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC8/KFxcZCspXFwuaHRtbC8pWzFdKTtcblxuTnVuanVja3MuY29uZmlndXJlKFwidGVtcGxhdGVzXCIsIHsgYXV0b2VzY2FwZTogdHJ1ZSB9KTtcbmRvY3VtZW50LndyaXRlKE51bmp1Y2tzLnJlbmRlcihgbG9hZGVyLSR7aW5kZXh9Lm5qa2ApKTtcbmRvY3VtZW50LndyaXRlKE51bmp1Y2tzLnJlbmRlcihgc2NlbmUtJHtpbmRleH0ubmprYCkpO1xuXG5jb25zdCBsb2FkTWVkaWFTdGF0ZTogTG9hZE1lZGlhU3RhdGUgPSB7fTtcbmxldCByZXNvbmFuY2VBdWRpb1NjZW5lOiBSZXNvbmFuY2VBdWRpbyB8IHVuZGVmaW5lZDtcbmxldCBhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCB8IHVuZGVmaW5lZDtcbmxldCBvcmllbnRhdGlvblBlcm1pc3Npb246IFBlcm1pc3Npb25TdGF0ZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuY29uc3QgZGVndG9yYWQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbmNvbnN0IHlBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5jb25zdCB6QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuY29uc3QgdXBBeGlzID0gbmV3IFZlY3RvcjMoMCwgLTEsIDApO1xuY29uc3QgZm9yd2FyZEF4aXMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKTtcbmxldCBpbml0aWFsRGlyZWN0aW9uOiB1bmRlZmluZWQgfCBWZWN0b3IzID0gdW5kZWZpbmVkO1xuY29uc3QgcTAgPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBhbHBoYU9mZnNldCA9IDA7XG5jb25zdCBmb3J3YXJkID0gbmV3IFZlY3RvcjMoMCwgMCwgLTEpO1xuY29uc3QgdXAgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbmNvbnN0IGV1bGVyT3JpZ2luID0gbmV3IEV1bGVyKE1hdGguUEkgLyAyLCAwLCAwLCBcIllaWFwiKTtcblxuY29uc3QgZnJlZXplQ2hlY2tib3hFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlZXplLWNoZWNrYm94XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbmludGVyZmFjZSBBbmltYXRpb25UaW1lbGluZUl0ZW0ge1xuICBhbmltYXRpb246IEVudGl0eUFuaW1hdGlvbjtcbiAgZW50aXR5OiBBdWRpb0VudGl0eTtcbiAgc3RhcnRUaW1lOiBudW1iZXI7XG4gIGZpbmlzaFRpbWU6IG51bWJlcjtcbn1cbmludGVyZmFjZSBBbmltYXRpb25UaW1lbGluZUdyb3VwIHtcbiAgaXRlbXM6IEFuaW1hdGlvblRpbWVsaW5lSXRlbVtdO1xuICBmaW5pc2hUaW1lOiBudW1iZXI7XG59XG5jb25zdCBhbmltYXRpb25UaW1lbGluZTogKEFuaW1hdGlvblRpbWVsaW5lSXRlbSB8IEFuaW1hdGlvblRpbWVsaW5lR3JvdXApW10gPSBbXTtcbmxldCB0aW1lbGluZUxvb3A6IG51bGwgfCBib29sZWFuID0gbnVsbDtcbmxldCBhbmltYXRpb25UaW1lbGluZUluZGV4ID0gLTE7XG5sZXQgYW5pbWF0aW9uU3RhcnRUaW1lID0gMDtcblxuaW50ZXJmYWNlIEVudGl0eUFuaW1hdGlvbiB7XG4gIGR1cjogbnVtYmVyO1xuICBmcm9tOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHRvOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGRlbGF5PzogbnVtYmVyO1xuICBlYXNpbmc6IFwibGluZWFyXCI7XG59XG5cbmludGVyZmFjZSBBdWRpb0VudGl0eSB7XG4gIGVsOiBFbGVtZW50O1xuICBwb3NpdGlvbjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBpbmRleDogbnVtYmVyO1xuICBidWZmZXJTb3VyY2U6IEF1ZGlvQnVmZmVyU291cmNlTm9kZTtcbiAgcmVzb25hbmNlU291cmNlOiBTb3VyY2U7XG4gIGFuaW1hdGlvbnM6IFJlY29yZDxzdHJpbmcsIEVudGl0eUFuaW1hdGlvbj47XG59XG5jb25zdCBlbnRpdGllczogQXVkaW9FbnRpdHlbXSA9IFtdO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoXCIjcGxheS1vdmVybGF5XCIpLmNsYXNzTGlzdC5yZW1vdmUoXCJmYWRlLW91dFwiKTtcbiAgYXVkaW9Db250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcbiAgcmVzb25hbmNlQXVkaW9TY2VuZSA9IGxvYWRSZXNvbmFuY2UoYXVkaW9Db250ZXh0KTtcbiAgY29uc3QgbG9hZGVyRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2xvYWRlcl1cIik7XG4gIGxvYWRNZWRpYShsb2FkTWVkaWFTdGF0ZSwge1xuICAgIGVsOiBsb2FkZXJFbCxcbiAgICBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCxcbiAgICBvblN1Y2Nlc3M6IG1lZGlhTG9hZGVkLFxuICAgIG9uUHJvZ3Jlc3M6IChwZXJjZW50KSA9PiB7XG4gICAgICBjb25zdCBsb2FkaW5nQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwbGF5LWJ1dHRvblwiKTtcbiAgICAgIGlmIChsb2FkaW5nQnV0dG9uKSBsb2FkaW5nQnV0dG9uLmlubmVyVGV4dCA9IGBMb2FkaW5nICR7TWF0aC5yb3VuZChwZXJjZW50ICogOTgpfSUuLi5gO1xuICAgIH0sXG4gICAgYmFyY29kZURhdGE6IGluZGV4LnRvU3RyaW5nKCksXG4gICAgbG9hZGluZ0JhcmNvZGVDb250YWluZXI6IHsgbG9hZGluZ0JhcmNvZGU6IGluZGV4IH0sXG4gIH0pO1xuXG4gIGxvYWRFbnRpdGllcygpO1xufSk7XG5cbmZ1bmN0aW9uIGxvYWRFbnRpdGllcygpIHtcbiAgZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiW3Jlc29uYW5jZS1zb3VyY2VdXCIpLmZvckVhY2goKGUpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IE51bWJlci5wYXJzZUludChlLmdldEF0dHJpYnV0ZShcInJlc29uYW5jZS1zb3VyY2VcIikpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZVxuICAgICAgLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpXG4gICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAubWFwKChpKSA9PiBOdW1iZXIucGFyc2VGbG9hdChpKSkgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGNvbnN0IGJ1ZmZlclNvdXJjZSA9IGxvYWRNZWRpYVN0YXRlLmJ1ZmZlclNvdXJjZXM/LltpbmRleF07XG4gICAgY29uc3QgcmVzb25hbmNlU291cmNlID0gcmVzb25hbmNlQXVkaW9TY2VuZS5jcmVhdGVTb3VyY2UoKTtcbiAgICBidWZmZXJTb3VyY2UuY29ubmVjdChyZXNvbmFuY2VTb3VyY2UuaW5wdXQpO1xuICAgIHJlc29uYW5jZVNvdXJjZS5zZXRQb3NpdGlvbihwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzJdKTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBleHRyYWN0QW5pbWF0aW9ucyhlKTtcbiAgICBjb25zdCBtaXhpbkFuaW1hdGlvbnMgPSBlLmhhc0F0dHJpYnV0ZShcIm1peGluXCIpXG4gICAgICA/IGV4dHJhY3RBbmltYXRpb25zKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuZ2V0QXR0cmlidXRlKFwibWl4aW5cIikpKVxuICAgICAgOiB7fTtcblxuICAgIGNvbnN0IGVudGl0eSA9IHtcbiAgICAgIGVsOiBlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBpbmRleCxcbiAgICAgIGJ1ZmZlclNvdXJjZSxcbiAgICAgIHJlc29uYW5jZVNvdXJjZSxcbiAgICAgIGFuaW1hdGlvbnM6IHsgLi4ubWl4aW5BbmltYXRpb25zLCAuLi5hbmltYXRpb25zIH0sXG4gICAgfTtcbiAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gIH0pO1xuXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLWVudGl0eVwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgYXR0ciA9IEFycmF5LmZyb20oZS5hdHRyaWJ1dGVzKS5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUuc3RhcnRzV2l0aChcImFuaW1hdGlvbi10aW1lbGluZVwiKSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIGlmICh0aW1lbGluZUxvb3AgIT09IG51bGwpIHRocm93IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSBlbnRpdHkgd2l0aCBhbmltYXRpb24tdGltZWxpbmUgYXR0cmlidXRlXCIpO1xuICAgICAgaWYgKGF0dHIudmFsdWUubWF0Y2goL2xvb3A6XFxzP3RydWUvKSkgdGltZWxpbmVMb29wID0gdHJ1ZTtcbiAgICAgIGVsc2UgdGltZWxpbmVMb29wID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgY29uc29sZS5sb2coYGxvb3A6ICR7dGltZWxpbmVMb29wfWApO1xuXG4gIGNvbnN0IHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYS10aW1lbGluZVwiKTtcbiAgaWYgKCF0KSB0aHJvdyBFcnJvcihcIk5vIGFuaW1hdGlvbiB0aW1lbGluZSBmb3VuZFwiKTtcbiAgbGV0IHRpbWUgPSAwO1xuICBBcnJheS5mcm9tKHQuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09IFwiQS1USU1FTElORS1BTklNQVRJT05cIikge1xuICAgICAgY29uc3QgbmFtZSA9IGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikgPz8gMDtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoaWxkLmdldEF0dHJpYnV0ZShcInNlbGVjdFwiKTtcbiAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzLmZpbmQoKGUpID0+IGUuZWwgPT09IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KSk7XG4gICAgICBpZiAoIWVudGl0eSkgdGhyb3cgRXJyb3IoYENvdWxkbid0IGZpbmQgZW50aXR5ICR7dGFyZ2V0fWApO1xuICAgICAgY29uc3QgYW5pbWF0aW9uID0gZW50aXR5LmFuaW1hdGlvbnNbbmFtZV07XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lICsgKGFuaW1hdGlvbi5kZWxheSA/PyAwKSArIG9mZnNldDtcbiAgICAgIGNvbnN0IGZpbmlzaFRpbWUgPSBzdGFydFRpbWUgKyBhbmltYXRpb24uZHVyO1xuICAgICAgYW5pbWF0aW9uVGltZWxpbmUucHVzaCh7XG4gICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgZW50aXR5LFxuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGZpbmlzaFRpbWUsXG4gICAgICB9KTtcbiAgICAgIHRpbWUgPSBmaW5pc2hUaW1lO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudGFnTmFtZSA9PT0gXCJBLVRJTUVMSU5FLUdST1VQXCIpIHtcbiAgICAgIGNvbnN0IGdyb3VwOiBBbmltYXRpb25UaW1lbGluZUdyb3VwID0geyBpdGVtczogW10sIGZpbmlzaFRpbWU6IDAgfTtcbiAgICAgIGNvbnN0IGdyb3VwT2Zmc2V0ID0gY2hpbGQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpID8/IDA7XG4gICAgICBBcnJheS5mcm9tKGNoaWxkLmNoaWxkcmVuKS5mb3JFYWNoKChncmFuZGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChncmFuZGNoaWxkLnRhZ05hbWUgPT09IFwiQS1USU1FTElORS1BTklNQVRJT05cIikge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBgYW5pbWF0aW9uX18ke2dyYW5kY2hpbGQuZ2V0QXR0cmlidXRlKFwibmFtZVwiKX1gO1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGdyYW5kY2hpbGQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpID8/IDA7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ3JhbmRjaGlsZC5nZXRBdHRyaWJ1dGUoXCJzZWxlY3RcIik7XG4gICAgICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXMuZmluZCgoZSkgPT4gZS5lbCA9PT0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpKTtcbiAgICAgICAgICBpZiAoIWVudGl0eSkgdGhyb3cgRXJyb3IoYENvdWxkbid0IGZpbmQgZW50aXR5ICR7dGFyZ2V0fWApO1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGVudGl0eS5hbmltYXRpb25zW25hbWVdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUgKyAoYW5pbWF0aW9uLmRlbGF5ID8/IDApICsgZ3JvdXBPZmZzZXQgKyBvZmZzZXQ7XG4gICAgICAgICAgY29uc3QgZmluaXNoVGltZSA9IHN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXI7XG4gICAgICAgICAgZ3JvdXAuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBmaW5pc2hUaW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdyb3VwLmZpbmlzaFRpbWUgPSBNYXRoLm1heChncm91cC5maW5pc2hUaW1lLCBmaW5pc2hUaW1lKTtcbiAgICAgICAgfSBlbHNlIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCB0aW1lbGluZSB0YWcgJHtncmFuZGNoaWxkLnRhZ05hbWV9YCk7XG4gICAgICB9KTtcbiAgICAgIGFuaW1hdGlvblRpbWVsaW5lLnB1c2goZ3JvdXApO1xuICAgICAgdGltZSA9IGdyb3VwLmZpbmlzaFRpbWU7XG4gICAgfSBlbHNlIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCB0aW1lbGluZSB0YWcgJHtjaGlsZC50YWdOYW1lfWApO1xuICB9KTtcbiAgY29uc29sZS5sb2coYW5pbWF0aW9uVGltZWxpbmUpO1xufVxuXG5mdW5jdGlvbiBtZWRpYUxvYWRlZCgpIHtcbiAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcIiNwbGF5LWJ1dHRvblwiKTtcbiAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gIGJ1dHRvbi5pbm5lclRleHQgPSBcIlBsYXlcIjtcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDE7XG4gICAgYW5pbWF0aW9uU3RhcnRUaW1lID0gRGF0ZS5ub3coKSArIDEwMDA7XG4gICAgZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiBlbnRpdHkuYnVmZmVyU291cmNlLnN0YXJ0KHN0YXJ0VGltZSkpO1xuICAgIHdpbmRvdy5zZXRJbnRlcnZhbChtYWluTG9vcCwgNTApO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVcIikuaW5uZXJUZXh0ID0gXCJZb3UgYXJlIGxpc3RlbmluZyB0byB0aGUgc3BhdGlhbCBleHBlcmllbmNlLlwiO1xuICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICBpZiAod2luZG93LkRldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgRGV2aWNlT3JpZW50YXRpb25FdmVudC5yZXF1ZXN0UGVybWlzc2lvbiAmJlxuICAgICAgICBvcmllbnRhdGlvblBlcm1pc3Npb24gIT09IFwiZGVuaWVkXCIgJiZcbiAgICAgICAgb3JpZW50YXRpb25QZXJtaXNzaW9uICE9PSBcImdyYW50ZWRcIlxuICAgICAgKSB7XG4gICAgICAgIG9yaWVudGF0aW9uUGVybWlzc2lvbiA9IGF3YWl0IERldmljZU9yaWVudGF0aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uUGVybWlzc2lvbiA9PT0gXCJkZW5pZWRcIikge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgICBtZXNzYWdlLmlubmVyVGV4dCA9IFwiWW91IGRpZCBub3QgZ2l2ZSBwZXJtaXNzaW9uIHRvIHVzZSBkZXZpY2UgbW90aW9uLiBZb3VyIHZpZXdwb2ludCB3aWxsIHJlbWFpbiBzdGF0aWMuXCI7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRocm90dGxlKHVwZGF0ZUxpc3RlbmVyLCA1MCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1haW5Mb29wKCkge1xuICB1cGRhdGVFbnRpdGllcygpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFbnRpdGllcygpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgLy9pbmNyZW1lbnQgdGhlIHRpbWVsaW5lIGlmIG5lY2Vzc2FyeVxuICB3aGlsZSAobm93ID4gKGFuaW1hdGlvblRpbWVsaW5lPy5bYW5pbWF0aW9uVGltZWxpbmVJbmRleF0/LmZpbmlzaFRpbWUgPz8gMCkgKyBhbmltYXRpb25TdGFydFRpbWUpIHtcbiAgICBhbmltYXRpb25UaW1lbGluZUluZGV4Kys7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPj0gYW5pbWF0aW9uVGltZWxpbmUubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRpbWVsaW5lTG9vcCkgcmV0dXJuO1xuICAgICAgYW5pbWF0aW9uU3RhcnRUaW1lID0gYW5pbWF0aW9uU3RhcnRUaW1lICsgYW5pbWF0aW9uVGltZWxpbmVbYW5pbWF0aW9uVGltZWxpbmVJbmRleCAtIDFdLmZpbmlzaFRpbWU7XG4gICAgICBhbmltYXRpb25UaW1lbGluZUluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgLy9pbmRleCBpcyBsZXNzIHRoYW4gemVybyBhdCB0aGUgc3RhcnQgYmVjYXVzZSB0aGUgYXVkaW8gcGxheXMgYWZ0ZXIgMSBzZWNcbiAgaWYgKGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPCAwKSByZXR1cm47XG5cbiAgLy9wbGFjZSBpdGVtc1xuICBjb25zdCBhID0gYW5pbWF0aW9uVGltZWxpbmVbYW5pbWF0aW9uVGltZWxpbmVJbmRleF07XG4gIC8vaXMgYXJyYXlcbiAgaWYgKFwiaXRlbXNcIiBpbiBhKSB7XG4gICAgYS5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpbnRlcnBvbGF0ZShcbiAgICAgICAgaXRlbS5lbnRpdHkucmVzb25hbmNlU291cmNlLFxuICAgICAgICBNYXRoLm1heCgwLCAobm93IC0gYW5pbWF0aW9uU3RhcnRUaW1lIC0gaXRlbS5zdGFydFRpbWUpIC8gKGl0ZW0uZmluaXNoVGltZSAtIGl0ZW0uc3RhcnRUaW1lKSksXG4gICAgICAgIGl0ZW0uYW5pbWF0aW9uLmZyb20sXG4gICAgICAgIGl0ZW0uYW5pbWF0aW9uLnRvLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvL3NpbmdsZSBpdGVtLCBub3QgYXJyYXlcbiAgICBpbnRlcnBvbGF0ZShcbiAgICAgIGEuZW50aXR5LnJlc29uYW5jZVNvdXJjZSxcbiAgICAgIE1hdGgubWF4KDAsIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgLSBhLnN0YXJ0VGltZSkgLyAoYS5maW5pc2hUaW1lIC0gYS5zdGFydFRpbWUpKSxcbiAgICAgIGEuYW5pbWF0aW9uLmZyb20sXG4gICAgICBhLmFuaW1hdGlvbi50byxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVyKGU6IERldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgaWYgKGZyZWV6ZUNoZWNrYm94RWwuY2hlY2tlZCkgcmV0dXJuO1xuICBjb25zdCBhbHBoYSA9IGUuYWxwaGEgPyBlLmFscGhhICogZGVndG9yYWQgKyBhbHBoYU9mZnNldCA6IDA7IC8vIFpcbiAgY29uc3QgYmV0YSA9IGUuYmV0YSA/IGUuYmV0YSAqIGRlZ3RvcmFkIDogMDsgLy8gWCdcbiAgY29uc3QgZ2FtbWEgPSBlLmdhbW1hID8gZS5nYW1tYSAqIGRlZ3RvcmFkIDogMDsgLy8gWScnXG4gIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyT3JpZ2luKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh6QXhpcywgYWxwaGEpO1xuICBxdWF0ZXJuaW9uLm11bHRpcGx5KHEwKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh4QXhpcywgYmV0YSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuICBxMC5zZXRGcm9tQXhpc0FuZ2xlKHlBeGlzLCBnYW1tYSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuXG4gIHVwLmNvcHkodXBBeGlzKS5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gIGZvcndhcmQuY29weShmb3J3YXJkQXhpcykuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuXG4gIGlmICghaW5pdGlhbERpcmVjdGlvbikge1xuICAgIGluaXRpYWxEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpLnByb2plY3RPblBsYW5lKHVwQXhpcykubm9ybWFsaXplKCk7XG4gICAgY29uc3QgYW5nbGUgPSBpbml0aWFsRGlyZWN0aW9uLmFuZ2xlVG8oZm9yd2FyZEF4aXMpO1xuICAgIGV1bGVyT3JpZ2luLnkgPSBhbmdsZTtcbiAgfVxuICAvKmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWdcIikuaW5uZXJIVE1MID0gYCR7Zm9yd2FyZC54LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC55LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC56LnRvRml4ZWQoXG4gICAgMixcbiAgKX08YnI+JHt1cC54LnRvRml4ZWQoMil9ICR7dXAueS50b0ZpeGVkKDIpfSAke3VwLnoudG9GaXhlZCgyKX08YnI+XG4gICR7YWxwaGEudG9GaXhlZCgyKX0gJHtiZXRhLnRvRml4ZWQoMil9ICR7Z2FtbWEudG9GaXhlZCgyKX08YnI+XG4gICR7ZXVsZXJPcmlnaW4ueC50b0ZpeGVkKDIpfSAke2V1bGVyT3JpZ2luLnkudG9GaXhlZCgyKX0gJHtldWxlck9yaWdpbi56LnRvRml4ZWQoMil9YDsqL1xuXG4gIC8vQHRzLWV4cGVjdC1lcnJvciAtIGJhZCB0eXBpbmdcbiAgcmVzb25hbmNlQXVkaW9TY2VuZS5zZXRMaXN0ZW5lck9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjazogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93biwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgcHJldiA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKG5vdyAtIHByZXYgPCBkZWxheSkgcmV0dXJuO1xuICAgIHByZXYgPSBub3c7XG4gICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QW5pbWF0aW9ucyhlbGVtZW50OiBFbGVtZW50KTogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBlbGVtZW50LmF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKFwiYW5pbWF0aW9uX19cIikgfHwgYXR0ci5uYW1lID09PSBcImFuaW1hdGlvblwiKSB7XG4gICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IHBhcnNlQW5pbWF0aW9uKGF0dHIudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUFuaW1hdGlvbihhOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGNvbnN0IGRhdGEgPSBhLnNwbGl0KFwiO1wiKS5tYXAoKGUpID0+XG4gICAgZVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFwiOlwiKVxuICAgICAgLm1hcCgoZTIpID0+IGUyLnRyaW0oKSksXG4gICk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkYXRhW2ldLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuICAgIGlmIChkYXRhW2ldWzBdID09PSBcImZyb21cIiB8fCBkYXRhW2ldWzBdID09PSBcInRvXCIpIHtcbiAgICAgIHJlc3VsdFtkYXRhW2ldWzBdXSA9IGRhdGFbaV1bMV0uc3BsaXQoXCIgXCIpLm1hcCgobikgPT4gTnVtYmVyLnBhcnNlRmxvYXQobikpO1xuICAgIH0gZWxzZSBpZiAoZGF0YVtpXVswXSA9PT0gXCJkdXJcIiB8fCBkYXRhW2ldWzBdID09PSBcImRlbGF5XCIpIHtcbiAgICAgIHJlc3VsdFtkYXRhW2ldWzBdXSA9IE51bWJlci5wYXJzZUludChkYXRhW2ldWzFdKTtcbiAgICB9IGVsc2UgaWYgKGRhdGFbaV1bMV0gPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXN1bHRbZGF0YVtpXVswXV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YVtpXVsxXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXN1bHRbZGF0YVtpXVswXV0gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2RhdGFbaV1bMF1dID0gZGF0YVtpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCBhcyBFbnRpdHlBbmltYXRpb247XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKFxuICByZXNvbmFuY2VTb3VyY2U6IFNvdXJjZSxcbiAgdDogbnVtYmVyLFxuICBmcm9tOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHRvOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGVhc2luZzogRW50aXR5QW5pbWF0aW9uW1wiZWFzaW5nXCJdID0gXCJsaW5lYXJcIixcbikge1xuICBzd2l0Y2ggKGVhc2luZykge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJlc29uYW5jZVNvdXJjZS5zZXRQb3NpdGlvbihcbiAgICAgICAgZnJvbVswXSArIHQgKiAodG9bMF0gLSBmcm9tWzBdKSxcbiAgICAgICAgZnJvbVsxXSArIHQgKiAodG9bMV0gLSBmcm9tWzFdKSxcbiAgICAgICAgZnJvbVsyXSArIHQgKiAodG9bMl0gLSBmcm9tWzJdKSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoYFVuaGFuZGxlZCBlYXNpbmcgJHtlYXNpbmd9YCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=