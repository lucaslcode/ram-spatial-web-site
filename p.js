/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/detect-browser/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/detect-browser/es/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserInfo": function() { return /* binding */ BrowserInfo; },
/* harmony export */   "NodeInfo": function() { return /* binding */ NodeInfo; },
/* harmony export */   "SearchBotDeviceInfo": function() { return /* binding */ SearchBotDeviceInfo; },
/* harmony export */   "BotInfo": function() { return /* binding */ BotInfo; },
/* harmony export */   "ReactNativeInfo": function() { return /* binding */ ReactNativeInfo; },
/* harmony export */   "detect": function() { return /* binding */ detect; },
/* harmony export */   "browserName": function() { return /* binding */ browserName; },
/* harmony export */   "parseUserAgent": function() { return /* binding */ parseUserAgent; },
/* harmony export */   "detectOS": function() { return /* binding */ detectOS; },
/* harmony export */   "getNodeVersion": function() { return /* binding */ getNodeVersion; }
/* harmony export */ });
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


/***/ }),

/***/ "./node_modules/nunjucks/browser/nunjucks.js":
/*!***************************************************!*\
  !*** ./node_modules/nunjucks/browser/nunjucks.js ***!
  \***************************************************/
/***/ (function(module) {

/*! Browser bundle of nunjucks 3.2.2  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_617__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_617__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_617__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_617__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_617__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_617__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_617__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_617__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_617__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_617__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_617__(__nested_webpack_require_617__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};
var escapeRegex = /[&"'<>]/g;
var exports = module.exports = {};

function hasOwnProp(obj, k) {
  return ObjProto.hasOwnProperty.call(obj, k);
}

exports.hasOwnProp = hasOwnProp;

function lookupEscape(ch) {
  return escapeMap[ch];
}

function _prettifyError(path, withInternals, err) {
  if (!err.Update) {
    // not one of ours, cast it
    err = new exports.TemplateError(err);
  }

  err.Update(path); // Unless they marked the dev flag, show them a trace from here

  if (!withInternals) {
    var old = err;
    err = new Error(old.message);
    err.name = old.name;
  }

  return err;
}

exports._prettifyError = _prettifyError;

function TemplateError(message, lineno, colno) {
  var err;
  var cause;

  if (message instanceof Error) {
    cause = message;
    message = cause.name + ": " + cause.message;
  }

  if (Object.setPrototypeOf) {
    err = new Error(message);
    Object.setPrototypeOf(err, TemplateError.prototype);
  } else {
    err = this;
    Object.defineProperty(err, 'message', {
      enumerable: false,
      writable: true,
      value: message
    });
  }

  Object.defineProperty(err, 'name', {
    value: 'Template render error'
  });

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, this.constructor);
  }

  var getStack;

  if (cause) {
    var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

    getStack = stackDescriptor && (stackDescriptor.get || function () {
      return stackDescriptor.value;
    });

    if (!getStack) {
      getStack = function getStack() {
        return cause.stack;
      };
    }
  } else {
    var stack = new Error(message).stack;

    getStack = function getStack() {
      return stack;
    };
  }

  Object.defineProperty(err, 'stack', {
    get: function get() {
      return getStack.call(err);
    }
  });
  Object.defineProperty(err, 'cause', {
    value: cause
  });
  err.lineno = lineno;
  err.colno = colno;
  err.firstUpdate = true;

  err.Update = function Update(path) {
    var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
    // where error occurred

    if (this.firstUpdate) {
      if (this.lineno && this.colno) {
        msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
      } else if (this.lineno) {
        msg += " [Line " + this.lineno + "]";
      }
    }

    msg += '\n ';

    if (this.firstUpdate) {
      msg += ' ';
    }

    this.message = msg + (this.message || '');
    this.firstUpdate = false;
    return this;
  };

  return err;
}

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
  TemplateError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: TemplateError
    }
  });
}

exports.TemplateError = TemplateError;

function escape(val) {
  return val.replace(escapeRegex, lookupEscape);
}

exports.escape = escape;

function isFunction(obj) {
  return ObjProto.toString.call(obj) === '[object Function]';
}

exports.isFunction = isFunction;

function isArray(obj) {
  return ObjProto.toString.call(obj) === '[object Array]';
}

exports.isArray = isArray;

function isString(obj) {
  return ObjProto.toString.call(obj) === '[object String]';
}

exports.isString = isString;

function isObject(obj) {
  return ObjProto.toString.call(obj) === '[object Object]';
}

exports.isObject = isObject;
/**
 * @param {string|number} attr
 * @returns {(string|number)[]}
 * @private
 */

function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }

  if (typeof attr === 'string') {
    return attr.split('.');
  }

  return [attr];
}
/**
 * @param {string}   attribute      Attribute value. Dots allowed.
 * @returns {function(Object): *}
 */


function getAttrGetter(attribute) {
  var parts = _prepareAttributeParts(attribute);

  return function attrGetter(item) {
    var _item = item;

    for (var i = 0; i < parts.length; i++) {
      var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
      // that something goes wrong. Just roll out to undefined in that case.

      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return undefined;
      }
    }

    return _item;
  };
}

function groupBy(obj, val, throwOnUndefined) {
  var result = {};
  var iterator = isFunction(val) ? val : getAttrGetter(val);

  for (var i = 0; i < obj.length; i++) {
    var value = obj[i];
    var key = iterator(value, i);

    if (key === undefined && throwOnUndefined === true) {
      throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
    }

    (result[key] || (result[key] = [])).push(value);
  }

  return result;
}

exports.groupBy = groupBy;

function toArray(obj) {
  return Array.prototype.slice.call(obj);
}

exports.toArray = toArray;

function without(array) {
  var result = [];

  if (!array) {
    return result;
  }

  var length = array.length;
  var contains = toArray(arguments).slice(1);
  var index = -1;

  while (++index < length) {
    if (indexOf(contains, array[index]) === -1) {
      result.push(array[index]);
    }
  }

  return result;
}

exports.without = without;

function repeat(char_, n) {
  var str = '';

  for (var i = 0; i < n; i++) {
    str += char_;
  }

  return str;
}

exports.repeat = repeat;

function each(obj, func, context) {
  if (obj == null) {
    return;
  }

  if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
    obj.forEach(func, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      func.call(context, obj[i], i, obj);
    }
  }
}

exports.each = each;

function map(obj, func) {
  var results = [];

  if (obj == null) {
    return results;
  }

  if (ArrayProto.map && obj.map === ArrayProto.map) {
    return obj.map(func);
  }

  for (var i = 0; i < obj.length; i++) {
    results[results.length] = func(obj[i], i);
  }

  if (obj.length === +obj.length) {
    results.length = obj.length;
  }

  return results;
}

exports.map = map;

function asyncIter(arr, iter, cb) {
  var i = -1;

  function next() {
    i++;

    if (i < arr.length) {
      iter(arr[i], i, next, cb);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncIter = asyncIter;

function asyncFor(obj, iter, cb) {
  var keys = keys_(obj || {});
  var len = keys.length;
  var i = -1;

  function next() {
    i++;
    var k = keys[i];

    if (i < len) {
      iter(k, obj[k], i, len, next);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncFor = asyncFor;

function indexOf(arr, searchElement, fromIndex) {
  return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}

exports.indexOf = indexOf;

function keys_(obj) {
  /* eslint-disable no-restricted-syntax */
  var arr = [];

  for (var k in obj) {
    if (hasOwnProp(obj, k)) {
      arr.push(k);
    }
  }

  return arr;
}

exports.keys = keys_;

function _entries(obj) {
  return keys_(obj).map(function (k) {
    return [k, obj[k]];
  });
}

exports._entries = _entries;

function _values(obj) {
  return keys_(obj).map(function (k) {
    return obj[k];
  });
}

exports._values = _values;

function extend(obj1, obj2) {
  obj1 = obj1 || {};
  keys_(obj2).forEach(function (k) {
    obj1[k] = obj2[k];
  });
  return obj1;
}

exports._assign = exports.extend = extend;

function inOperator(key, val) {
  if (isArray(val) || isString(val)) {
    return val.indexOf(key) !== -1;
  } else if (isObject(val)) {
    return key in val;
  }

  throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}

exports.inOperator = inOperator;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_10825__) {

"use strict";
 // A simple class system, more documentation to come

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var EventEmitter = __nested_webpack_require_10825__(16);

var lib = __nested_webpack_require_10825__(0);

function parentWrap(parent, prop) {
  if (typeof parent !== 'function' || typeof prop !== 'function') {
    return prop;
  }

  return function wrap() {
    // Save the current parent method
    var tmp = this.parent; // Set parent to the previous method, call, and restore

    this.parent = parent;
    var res = prop.apply(this, arguments);
    this.parent = tmp;
    return res;
  };
}

function extendClass(cls, name, props) {
  props = props || {};
  lib.keys(props).forEach(function (k) {
    props[k] = parentWrap(cls.prototype[k], props[k]);
  });

  var subclass = /*#__PURE__*/function (_cls) {
    _inheritsLoose(subclass, _cls);

    function subclass() {
      return _cls.apply(this, arguments) || this;
    }

    _createClass(subclass, [{
      key: "typename",
      get: function get() {
        return name;
      }
    }]);

    return subclass;
  }(cls);

  lib._assign(subclass.prototype, props);

  return subclass;
}

var Obj = /*#__PURE__*/function () {
  function Obj() {
    // Unfortunately necessary for backwards compatibility
    this.init.apply(this, arguments);
  }

  var _proto = Obj.prototype;

  _proto.init = function init() {};

  Obj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(Obj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Obj;
}();

var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(EmitterObj, _EventEmitter);

  function EmitterObj() {
    var _this2;

    var _this;

    _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

    (_this2 = _this).init.apply(_this2, arguments);

    return _this;
  }

  var _proto2 = EmitterObj.prototype;

  _proto2.init = function init() {};

  EmitterObj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(EmitterObj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return EmitterObj;
}(EventEmitter);

module.exports = {
  Obj: Obj,
  EmitterObj: EmitterObj
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_14097__) {

"use strict";


var lib = __nested_webpack_require_14097__(0);

var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
// we know how to access variables. Block tags can introduce special
// variables, for example.

var Frame = /*#__PURE__*/function () {
  function Frame(parent, isolateWrites) {
    this.variables = {};
    this.parent = parent;
    this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
    // this frame to its parent (though reads may).

    this.isolateWrites = isolateWrites;
  }

  var _proto = Frame.prototype;

  _proto.set = function set(name, val, resolveUp) {
    // Allow variables with dots by automatically creating the
    // nested structure
    var parts = name.split('.');
    var obj = this.variables;
    var frame = this;

    if (resolveUp) {
      if (frame = this.resolve(parts[0], true)) {
        frame.set(name, val);
        return;
      }
    }

    for (var i = 0; i < parts.length - 1; i++) {
      var id = parts[i];

      if (!obj[id]) {
        obj[id] = {};
      }

      obj = obj[id];
    }

    obj[parts[parts.length - 1]] = val;
  };

  _proto.get = function get(name) {
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return null;
  };

  _proto.lookup = function lookup(name) {
    var p = this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return p && p.lookup(name);
  };

  _proto.resolve = function resolve(name, forWrite) {
    var p = forWrite && this.isolateWrites ? undefined : this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return this;
    }

    return p && p.resolve(name);
  };

  _proto.push = function push(isolateWrites) {
    return new Frame(this, isolateWrites);
  };

  _proto.pop = function pop() {
    return this.parent;
  };

  return Frame;
}();

function makeMacro(argNames, kwargNames, func) {
  var _this = this;

  return function () {
    for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      macroArgs[_key] = arguments[_key];
    }

    var argCount = numArgs(macroArgs);
    var args;
    var kwargs = getKeywordArgs(macroArgs);

    if (argCount > argNames.length) {
      args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
      // keyword arguments (essentially default values)

      macroArgs.slice(args.length, argCount).forEach(function (val, i) {
        if (i < kwargNames.length) {
          kwargs[kwargNames[i]] = val;
        }
      });
      args.push(kwargs);
    } else if (argCount < argNames.length) {
      args = macroArgs.slice(0, argCount);

      for (var i = argCount; i < argNames.length; i++) {
        var arg = argNames[i]; // Keyword arguments that should be passed as
        // positional arguments, i.e. the caller explicitly
        // used the name of a positional arg

        args.push(kwargs[arg]);
        delete kwargs[arg];
      }

      args.push(kwargs);
    } else {
      args = macroArgs;
    }

    return func.apply(_this, args);
  };
}

function makeKeywordArgs(obj) {
  obj.__keywords = true;
  return obj;
}

function isKeywordArgs(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
}

function getKeywordArgs(args) {
  var len = args.length;

  if (len) {
    var lastArg = args[len - 1];

    if (isKeywordArgs(lastArg)) {
      return lastArg;
    }
  }

  return {};
}

function numArgs(args) {
  var len = args.length;

  if (len === 0) {
    return 0;
  }

  var lastArg = args[len - 1];

  if (isKeywordArgs(lastArg)) {
    return len - 1;
  } else {
    return len;
  }
} // A SafeString object indicates that the string should not be
// autoescaped. This happens magically because autoescaping only
// occurs on primitive string objects.


function SafeString(val) {
  if (typeof val !== 'string') {
    return val;
  }

  this.val = val;
  this.length = val.length;
}

SafeString.prototype = Object.create(String.prototype, {
  length: {
    writable: true,
    configurable: true,
    value: 0
  }
});

SafeString.prototype.valueOf = function valueOf() {
  return this.val;
};

SafeString.prototype.toString = function toString() {
  return this.val;
};

function copySafeness(dest, target) {
  if (dest instanceof SafeString) {
    return new SafeString(target);
  }

  return target.toString();
}

function markSafe(val) {
  var type = typeof val;

  if (type === 'string') {
    return new SafeString(val);
  } else if (type !== 'function') {
    return val;
  } else {
    return function wrapSafe(args) {
      var ret = val.apply(this, arguments);

      if (typeof ret === 'string') {
        return new SafeString(ret);
      }

      return ret;
    };
  }
}

function suppressValue(val, autoescape) {
  val = val !== undefined && val !== null ? val : '';

  if (autoescape && !(val instanceof SafeString)) {
    val = lib.escape(val.toString());
  }

  return val;
}

function ensureDefined(val, lineno, colno) {
  if (val === null || val === undefined) {
    throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
  }

  return val;
}

function memberLookup(obj, val) {
  if (obj === undefined || obj === null) {
    return undefined;
  }

  if (typeof obj[val] === 'function') {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return obj[val].apply(obj, args);
    };
  }

  return obj[val];
}

function callWrap(obj, name, context, args) {
  if (!obj) {
    throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
  } else if (typeof obj !== 'function') {
    throw new Error('Unable to call `' + name + '`, which is not a function');
  }

  return obj.apply(context, args);
}

function contextOrFrameLookup(context, frame, name) {
  var val = frame.lookup(name);
  return val !== undefined ? val : context.lookup(name);
}

function handleError(error, lineno, colno) {
  if (error.lineno) {
    return error;
  } else {
    return new lib.TemplateError(error, lineno, colno);
  }
}

function asyncEach(arr, dimen, iter, cb) {
  if (lib.isArray(arr)) {
    var len = arr.length;
    lib.asyncIter(arr, function iterCallback(item, i, next) {
      switch (dimen) {
        case 1:
          iter(item, i, len, next);
          break;

        case 2:
          iter(item[0], item[1], i, len, next);
          break;

        case 3:
          iter(item[0], item[1], item[2], i, len, next);
          break;

        default:
          item.push(i, len, next);
          iter.apply(this, item);
      }
    }, cb);
  } else {
    lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
      iter(key, val, i, len, next);
    }, cb);
  }
}

function asyncAll(arr, dimen, func, cb) {
  var finished = 0;
  var len;
  var outputArr;

  function done(i, output) {
    finished++;
    outputArr[i] = output;

    if (finished === len) {
      cb(null, outputArr.join(''));
    }
  }

  if (lib.isArray(arr)) {
    len = arr.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        switch (dimen) {
          case 1:
            func(item, i, len, done);
            break;

          case 2:
            func(item[0], item[1], i, len, done);
            break;

          case 3:
            func(item[0], item[1], item[2], i, len, done);
            break;

          default:
            item.push(i, len, done);
            func.apply(this, item);
        }
      }
    }
  } else {
    var keys = lib.keys(arr || {});
    len = keys.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var _i = 0; _i < keys.length; _i++) {
        var k = keys[_i];
        func(k, arr[k], _i, len, done);
      }
    }
  }
}

function fromIterator(arr) {
  if (typeof arr !== 'object' || arr === null || lib.isArray(arr)) {
    return arr;
  } else if (supportsIterators && Symbol.iterator in arr) {
    return arrayFrom(arr);
  } else {
    return arr;
  }
}

module.exports = {
  Frame: Frame,
  makeMacro: makeMacro,
  makeKeywordArgs: makeKeywordArgs,
  numArgs: numArgs,
  suppressValue: suppressValue,
  ensureDefined: ensureDefined,
  memberLookup: memberLookup,
  contextOrFrameLookup: contextOrFrameLookup,
  callWrap: callWrap,
  handleError: handleError,
  isArray: lib.isArray,
  keys: lib.keys,
  SafeString: SafeString,
  copySafeness: copySafeness,
  markSafe: markSafe,
  asyncEach: asyncEach,
  asyncAll: asyncAll,
  inOperator: lib.inOperator,
  fromIterator: fromIterator
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_23145__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = __nested_webpack_require_23145__(1),
    Obj = _require.Obj;

function traverseAndCheck(obj, type, results) {
  if (obj instanceof type) {
    results.push(obj);
  }

  if (obj instanceof Node) {
    obj.findAll(type, results);
  }
}

var Node = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Node, _Obj);

  function Node() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Node.prototype;

  _proto.init = function init(lineno, colno) {
    var _arguments = arguments,
        _this = this;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.lineno = lineno;
    this.colno = colno;
    this.fields.forEach(function (field, i) {
      // The first two args are line/col numbers, so offset by 2
      var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
      // testing easier to normalize values.

      if (val === undefined) {
        val = null;
      }

      _this[field] = val;
    });
  };

  _proto.findAll = function findAll(type, results) {
    var _this2 = this;

    results = results || [];

    if (this instanceof NodeList) {
      this.children.forEach(function (child) {
        return traverseAndCheck(child, type, results);
      });
    } else {
      this.fields.forEach(function (field) {
        return traverseAndCheck(_this2[field], type, results);
      });
    }

    return results;
  };

  _proto.iterFields = function iterFields(func) {
    var _this3 = this;

    this.fields.forEach(function (field) {
      func(_this3[field], field);
    });
  };

  return Node;
}(Obj); // Abstract nodes


var Value = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Value, _Node);

  function Value() {
    return _Node.apply(this, arguments) || this;
  }

  _createClass(Value, [{
    key: "typename",
    get: function get() {
      return 'Value';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['value'];
    }
  }]);

  return Value;
}(Node); // Concrete nodes


var NodeList = /*#__PURE__*/function (_Node2) {
  _inheritsLoose(NodeList, _Node2);

  function NodeList() {
    return _Node2.apply(this, arguments) || this;
  }

  var _proto2 = NodeList.prototype;

  _proto2.init = function init(lineno, colno, nodes) {
    _Node2.prototype.init.call(this, lineno, colno, nodes || []);
  };

  _proto2.addChild = function addChild(node) {
    this.children.push(node);
  };

  _createClass(NodeList, [{
    key: "typename",
    get: function get() {
      return 'NodeList';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['children'];
    }
  }]);

  return NodeList;
}(Node);

var Root = NodeList.extend('Root');
var Literal = Value.extend('Literal');
var Symbol = Value.extend('Symbol');
var Group = NodeList.extend('Group');
var ArrayNode = NodeList.extend('Array');
var Pair = Node.extend('Pair', {
  fields: ['key', 'value']
});
var Dict = NodeList.extend('Dict');
var LookupVal = Node.extend('LookupVal', {
  fields: ['target', 'val']
});
var If = Node.extend('If', {
  fields: ['cond', 'body', 'else_']
});
var IfAsync = If.extend('IfAsync');
var InlineIf = Node.extend('InlineIf', {
  fields: ['cond', 'body', 'else_']
});
var For = Node.extend('For', {
  fields: ['arr', 'name', 'body', 'else_']
});
var AsyncEach = For.extend('AsyncEach');
var AsyncAll = For.extend('AsyncAll');
var Macro = Node.extend('Macro', {
  fields: ['name', 'args', 'body']
});
var Caller = Macro.extend('Caller');
var Import = Node.extend('Import', {
  fields: ['template', 'target', 'withContext']
});

var FromImport = /*#__PURE__*/function (_Node3) {
  _inheritsLoose(FromImport, _Node3);

  function FromImport() {
    return _Node3.apply(this, arguments) || this;
  }

  var _proto3 = FromImport.prototype;

  _proto3.init = function init(lineno, colno, template, names, withContext) {
    _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
  };

  _createClass(FromImport, [{
    key: "typename",
    get: function get() {
      return 'FromImport';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['template', 'names', 'withContext'];
    }
  }]);

  return FromImport;
}(Node);

var FunCall = Node.extend('FunCall', {
  fields: ['name', 'args']
});
var Filter = FunCall.extend('Filter');
var FilterAsync = Filter.extend('FilterAsync', {
  fields: ['name', 'args', 'symbol']
});
var KeywordArgs = Dict.extend('KeywordArgs');
var Block = Node.extend('Block', {
  fields: ['name', 'body']
});
var Super = Node.extend('Super', {
  fields: ['blockName', 'symbol']
});
var TemplateRef = Node.extend('TemplateRef', {
  fields: ['template']
});
var Extends = TemplateRef.extend('Extends');
var Include = Node.extend('Include', {
  fields: ['template', 'ignoreMissing']
});
var Set = Node.extend('Set', {
  fields: ['targets', 'value']
});
var Switch = Node.extend('Switch', {
  fields: ['expr', 'cases', 'default']
});
var Case = Node.extend('Case', {
  fields: ['cond', 'body']
});
var Output = NodeList.extend('Output');
var Capture = Node.extend('Capture', {
  fields: ['body']
});
var TemplateData = Literal.extend('TemplateData');
var UnaryOp = Node.extend('UnaryOp', {
  fields: ['target']
});
var BinOp = Node.extend('BinOp', {
  fields: ['left', 'right']
});
var In = BinOp.extend('In');
var Is = BinOp.extend('Is');
var Or = BinOp.extend('Or');
var And = BinOp.extend('And');
var Not = UnaryOp.extend('Not');
var Add = BinOp.extend('Add');
var Concat = BinOp.extend('Concat');
var Sub = BinOp.extend('Sub');
var Mul = BinOp.extend('Mul');
var Div = BinOp.extend('Div');
var FloorDiv = BinOp.extend('FloorDiv');
var Mod = BinOp.extend('Mod');
var Pow = BinOp.extend('Pow');
var Neg = UnaryOp.extend('Neg');
var Pos = UnaryOp.extend('Pos');
var Compare = Node.extend('Compare', {
  fields: ['expr', 'ops']
});
var CompareOperand = Node.extend('CompareOperand', {
  fields: ['expr', 'type']
});
var CallExtension = Node.extend('CallExtension', {
  init: function init(ext, prop, args, contentArgs) {
    this.parent();
    this.extName = ext.__name || ext;
    this.prop = prop;
    this.args = args || new NodeList();
    this.contentArgs = contentArgs || [];
    this.autoescape = ext.autoescape;
  },
  fields: ['extName', 'prop', 'args', 'contentArgs']
});
var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

function print(str, indent, inline) {
  var lines = str.split('\n');
  lines.forEach(function (line, i) {
    if (line && (inline && i > 0 || !inline)) {
      process.stdout.write(' '.repeat(indent));
    }

    var nl = i === lines.length - 1 ? '' : '\n';
    process.stdout.write("" + line + nl);
  });
} // Print the AST in a nicely formatted tree format for debuggin


function printNodes(node, indent) {
  indent = indent || 0;
  print(node.typename + ': ', indent);

  if (node instanceof NodeList) {
    print('\n');
    node.children.forEach(function (n) {
      printNodes(n, indent + 2);
    });
  } else if (node instanceof CallExtension) {
    print(node.extName + "." + node.prop + "\n");

    if (node.args) {
      printNodes(node.args, indent + 2);
    }

    if (node.contentArgs) {
      node.contentArgs.forEach(function (n) {
        printNodes(n, indent + 2);
      });
    }
  } else {
    var nodes = [];
    var props = null;
    node.iterFields(function (val, fieldName) {
      if (val instanceof Node) {
        nodes.push([fieldName, val]);
      } else {
        props = props || {};
        props[fieldName] = val;
      }
    });

    if (props) {
      print(JSON.stringify(props, null, 2) + '\n', null, true);
    } else {
      print('\n');
    }

    nodes.forEach(function (_ref) {
      var fieldName = _ref[0],
          n = _ref[1];
      print("[" + fieldName + "] =>", indent + 2);
      printNodes(n, indent + 4);
    });
  }
}

module.exports = {
  Node: Node,
  Root: Root,
  NodeList: NodeList,
  Value: Value,
  Literal: Literal,
  Symbol: Symbol,
  Group: Group,
  Array: ArrayNode,
  Pair: Pair,
  Dict: Dict,
  Output: Output,
  Capture: Capture,
  TemplateData: TemplateData,
  If: If,
  IfAsync: IfAsync,
  InlineIf: InlineIf,
  For: For,
  AsyncEach: AsyncEach,
  AsyncAll: AsyncAll,
  Macro: Macro,
  Caller: Caller,
  Import: Import,
  FromImport: FromImport,
  FunCall: FunCall,
  Filter: Filter,
  FilterAsync: FilterAsync,
  KeywordArgs: KeywordArgs,
  Block: Block,
  Super: Super,
  Extends: Extends,
  Include: Include,
  Set: Set,
  Switch: Switch,
  Case: Case,
  LookupVal: LookupVal,
  BinOp: BinOp,
  In: In,
  Is: Is,
  Or: Or,
  And: And,
  Not: Not,
  Add: Add,
  Concat: Concat,
  Sub: Sub,
  Mul: Mul,
  Div: Div,
  FloorDiv: FloorDiv,
  Mod: Mod,
  Pow: Pow,
  Neg: Neg,
  Pos: Pos,
  Compare: Compare,
  CompareOperand: CompareOperand,
  CallExtension: CallExtension,
  CallExtensionAsync: CallExtensionAsync,
  printNodes: printNodes
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {



/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_33031__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var parser = __nested_webpack_require_33031__(8);

var transformer = __nested_webpack_require_33031__(17);

var nodes = __nested_webpack_require_33031__(3);

var _require = __nested_webpack_require_33031__(0),
    TemplateError = _require.TemplateError;

var _require2 = __nested_webpack_require_33031__(2),
    Frame = _require2.Frame;

var _require3 = __nested_webpack_require_33031__(1),
    Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
// through


var compareOps = {
  '==': '==',
  '===': '===',
  '!=': '!=',
  '!==': '!==',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>='
};

var Compiler = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Compiler, _Obj);

  function Compiler() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Compiler.prototype;

  _proto.init = function init(templateName, throwOnUndefined) {
    this.templateName = templateName;
    this.codebuf = [];
    this.lastId = 0;
    this.buffer = null;
    this.bufferStack = [];
    this._scopeClosers = '';
    this.inBlock = false;
    this.throwOnUndefined = throwOnUndefined;
  };

  _proto.fail = function fail(msg, lineno, colno) {
    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    throw new TemplateError(msg, lineno, colno);
  };

  _proto._pushBuffer = function _pushBuffer() {
    var id = this._tmpid();

    this.bufferStack.push(this.buffer);
    this.buffer = id;

    this._emit("var " + this.buffer + " = \"\";");

    return id;
  };

  _proto._popBuffer = function _popBuffer() {
    this.buffer = this.bufferStack.pop();
  };

  _proto._emit = function _emit(code) {
    this.codebuf.push(code);
  };

  _proto._emitLine = function _emitLine(code) {
    this._emit(code + '\n');
  };

  _proto._emitLines = function _emitLines() {
    var _this = this;

    for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
      lines[_key] = arguments[_key];
    }

    lines.forEach(function (line) {
      return _this._emitLine(line);
    });
  };

  _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
    this.buffer = 'output';
    this._scopeClosers = '';

    this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

    this._emitLine("var lineno = " + node.lineno + ";");

    this._emitLine("var colno = " + node.colno + ";");

    this._emitLine("var " + this.buffer + " = \"\";");

    this._emitLine('try {');
  };

  _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
    if (!noReturn) {
      this._emitLine('cb(null, ' + this.buffer + ');');
    }

    this._closeScopeLevels();

    this._emitLine('} catch (e) {');

    this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

    this._emitLine('}');

    this._emitLine('}');

    this.buffer = null;
  };

  _proto._addScopeLevel = function _addScopeLevel() {
    this._scopeClosers += '})';
  };

  _proto._closeScopeLevels = function _closeScopeLevels() {
    this._emitLine(this._scopeClosers + ';');

    this._scopeClosers = '';
  };

  _proto._withScopedSyntax = function _withScopedSyntax(func) {
    var _scopeClosers = this._scopeClosers;
    this._scopeClosers = '';
    func.call(this);

    this._closeScopeLevels();

    this._scopeClosers = _scopeClosers;
  };

  _proto._makeCallback = function _makeCallback(res) {
    var err = this._tmpid();

    return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
  };

  _proto._tmpid = function _tmpid() {
    this.lastId++;
    return 't_' + this.lastId;
  };

  _proto._templateName = function _templateName() {
    return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
  };

  _proto._compileChildren = function _compileChildren(node, frame) {
    var _this2 = this;

    node.children.forEach(function (child) {
      _this2.compile(child, frame);
    });
  };

  _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
    var _this3 = this;

    if (startChar) {
      this._emit(startChar);
    }

    node.children.forEach(function (child, i) {
      if (i > 0) {
        _this3._emit(',');
      }

      _this3.compile(child, frame);
    });

    if (endChar) {
      this._emit(endChar);
    }
  };

  _proto._compileExpression = function _compileExpression(node, frame) {
    // TODO: I'm not really sure if this type check is worth it or
    // not.
    this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
    this.compile(node, frame);
  };

  _proto.assertType = function assertType(node) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      types[_key2 - 1] = arguments[_key2];
    }

    if (!types.some(function (t) {
      return node instanceof t;
    })) {
      this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
    var _this4 = this;

    var args = node.args;
    var contentArgs = node.contentArgs;
    var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

    if (!async) {
      this._emit(this.buffer + " += runtime.suppressValue(");
    }

    this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

    this._emit('context');

    if (args || contentArgs) {
      this._emit(',');
    }

    if (args) {
      if (!(args instanceof nodes.NodeList)) {
        this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
      }

      args.children.forEach(function (arg, i) {
        // Tag arguments are passed normally to the call. Note
        // that keyword arguments are turned into a single js
        // object as the last argument, if they exist.
        _this4._compileExpression(arg, frame);

        if (i !== args.children.length - 1 || contentArgs.length) {
          _this4._emit(',');
        }
      });
    }

    if (contentArgs.length) {
      contentArgs.forEach(function (arg, i) {
        if (i > 0) {
          _this4._emit(',');
        }

        if (arg) {
          _this4._emitLine('function(cb) {');

          _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

          var id = _this4._pushBuffer();

          _this4._withScopedSyntax(function () {
            _this4.compile(arg, frame);

            _this4._emitLine("cb(null, " + id + ");");
          });

          _this4._popBuffer();

          _this4._emitLine("return " + id + ";");

          _this4._emitLine('}');
        } else {
          _this4._emit('null');
        }
      });
    }

    if (async) {
      var res = this._tmpid();

      this._emitLine(', ' + this._makeCallback(res));

      this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

      this._addScopeLevel();
    } else {
      this._emit(')');

      this._emit(", " + autoescape + " && env.opts.autoescape);\n");
    }
  };

  _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
    this.compileCallExtension(node, frame, true);
  };

  _proto.compileNodeList = function compileNodeList(node, frame) {
    this._compileChildren(node, frame);
  };

  _proto.compileLiteral = function compileLiteral(node) {
    if (typeof node.value === 'string') {
      var val = node.value.replace(/\\/g, '\\\\');
      val = val.replace(/"/g, '\\"');
      val = val.replace(/\n/g, '\\n');
      val = val.replace(/\r/g, '\\r');
      val = val.replace(/\t/g, '\\t');
      val = val.replace(/\u2028/g, "\\u2028");

      this._emit("\"" + val + "\"");
    } else if (node.value === null) {
      this._emit('null');
    } else {
      this._emit(node.value.toString());
    }
  };

  _proto.compileSymbol = function compileSymbol(node, frame) {
    var name = node.value;
    var v = frame.lookup(name);

    if (v) {
      this._emit(v);
    } else {
      this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
    }
  };

  _proto.compileGroup = function compileGroup(node, frame) {
    this._compileAggregate(node, frame, '(', ')');
  };

  _proto.compileArray = function compileArray(node, frame) {
    this._compileAggregate(node, frame, '[', ']');
  };

  _proto.compileDict = function compileDict(node, frame) {
    this._compileAggregate(node, frame, '{', '}');
  };

  _proto.compilePair = function compilePair(node, frame) {
    var key = node.key;
    var val = node.value;

    if (key instanceof nodes.Symbol) {
      key = new nodes.Literal(key.lineno, key.colno, key.value);
    } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
      this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
    }

    this.compile(key, frame);

    this._emit(': ');

    this._compileExpression(val, frame);
  };

  _proto.compileInlineIf = function compileInlineIf(node, frame) {
    this._emit('(');

    this.compile(node.cond, frame);

    this._emit('?');

    this.compile(node.body, frame);

    this._emit(':');

    if (node.else_ !== null) {
      this.compile(node.else_, frame);
    } else {
      this._emit('""');
    }

    this._emit(')');
  };

  _proto.compileIn = function compileIn(node, frame) {
    this._emit('runtime.inOperator(');

    this.compile(node.left, frame);

    this._emit(',');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileIs = function compileIs(node, frame) {
    // first, we need to try to get the name of the test function, if it's a
    // callable (i.e., has args) and not a symbol.
    var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
    : node.right.value;

    this._emit('env.getTest("' + right + '").call(context, ');

    this.compile(node.left, frame); // compile the arguments for the callable if they exist

    if (node.right.args) {
      this._emit(',');

      this.compile(node.right.args, frame);
    }

    this._emit(') === true');
  };

  _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
    this.compile(node.left, frame);

    this._emit(str);

    this.compile(node.right, frame);
  } // ensure concatenation instead of addition
  // by adding empty string in between
  ;

  _proto.compileOr = function compileOr(node, frame) {
    return this._binOpEmitter(node, frame, ' || ');
  };

  _proto.compileAnd = function compileAnd(node, frame) {
    return this._binOpEmitter(node, frame, ' && ');
  };

  _proto.compileAdd = function compileAdd(node, frame) {
    return this._binOpEmitter(node, frame, ' + ');
  };

  _proto.compileConcat = function compileConcat(node, frame) {
    return this._binOpEmitter(node, frame, ' + "" + ');
  };

  _proto.compileSub = function compileSub(node, frame) {
    return this._binOpEmitter(node, frame, ' - ');
  };

  _proto.compileMul = function compileMul(node, frame) {
    return this._binOpEmitter(node, frame, ' * ');
  };

  _proto.compileDiv = function compileDiv(node, frame) {
    return this._binOpEmitter(node, frame, ' / ');
  };

  _proto.compileMod = function compileMod(node, frame) {
    return this._binOpEmitter(node, frame, ' % ');
  };

  _proto.compileNot = function compileNot(node, frame) {
    this._emit('!');

    this.compile(node.target, frame);
  };

  _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
    this._emit('Math.floor(');

    this.compile(node.left, frame);

    this._emit(' / ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compilePow = function compilePow(node, frame) {
    this._emit('Math.pow(');

    this.compile(node.left, frame);

    this._emit(', ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileNeg = function compileNeg(node, frame) {
    this._emit('-');

    this.compile(node.target, frame);
  };

  _proto.compilePos = function compilePos(node, frame) {
    this._emit('+');

    this.compile(node.target, frame);
  };

  _proto.compileCompare = function compileCompare(node, frame) {
    var _this5 = this;

    this.compile(node.expr, frame);
    node.ops.forEach(function (op) {
      _this5._emit(" " + compareOps[op.type] + " ");

      _this5.compile(op.expr, frame);
    });
  };

  _proto.compileLookupVal = function compileLookupVal(node, frame) {
    this._emit('runtime.memberLookup((');

    this._compileExpression(node.target, frame);

    this._emit('),');

    this._compileExpression(node.val, frame);

    this._emit(')');
  };

  _proto._getNodeName = function _getNodeName(node) {
    switch (node.typename) {
      case 'Symbol':
        return node.value;

      case 'FunCall':
        return 'the return value of (' + this._getNodeName(node.name) + ')';

      case 'LookupVal':
        return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

      case 'Literal':
        return node.value.toString();

      default:
        return '--expression--';
    }
  };

  _proto.compileFunCall = function compileFunCall(node, frame) {
    // Keep track of line/col info at runtime by settings
    // variables within an expression. An expression in javascript
    // like (x, y, z) returns the last value, and x and y can be
    // anything
    this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

    this._emit('runtime.callWrap('); // Compile it as normal.


    this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
    // if the lookup fails.


    this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

    this._compileAggregate(node.args, frame, '[', '])');

    this._emit(')');
  };

  _proto.compileFilter = function compileFilter(node, frame) {
    var name = node.name;
    this.assertType(name, nodes.Symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emit(')');
  };

  _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
    var name = node.name;
    var symbol = node.symbol.value;
    this.assertType(name, nodes.Symbol);
    frame.set(symbol, symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emitLine(', ' + this._makeCallback(symbol));

    this._addScopeLevel();
  };

  _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
    this._emit('runtime.makeKeywordArgs(');

    this.compileDict(node, frame);

    this._emit(')');
  };

  _proto.compileSet = function compileSet(node, frame) {
    var _this6 = this;

    var ids = []; // Lookup the variable names for each identifier and create
    // new ones if necessary

    node.targets.forEach(function (target) {
      var name = target.value;
      var id = frame.lookup(name);

      if (id === null || id === undefined) {
        id = _this6._tmpid(); // Note: This relies on js allowing scope across
        // blocks, in case this is created inside an `if`

        _this6._emitLine('var ' + id + ';');
      }

      ids.push(id);
    });

    if (node.value) {
      this._emit(ids.join(' = ') + ' = ');

      this._compileExpression(node.value, frame);

      this._emitLine(';');
    } else {
      this._emit(ids.join(' = ') + ' = ');

      this.compile(node.body, frame);

      this._emitLine(';');
    }

    node.targets.forEach(function (target, i) {
      var id = ids[i];
      var name = target.value; // We are running this for every var, but it's very
      // uncommon to assign to multiple vars anyway

      _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

      _this6._emitLine('if(frame.topLevel) {');

      _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

      _this6._emitLine('}');

      if (name.charAt(0) !== '_') {
        _this6._emitLine('if(frame.topLevel) {');

        _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

        _this6._emitLine('}');
      }
    });
  };

  _proto.compileSwitch = function compileSwitch(node, frame) {
    var _this7 = this;

    this._emit('switch (');

    this.compile(node.expr, frame);

    this._emit(') {');

    node.cases.forEach(function (c, i) {
      _this7._emit('case ');

      _this7.compile(c.cond, frame);

      _this7._emit(': ');

      _this7.compile(c.body, frame); // preserve fall-throughs


      if (c.body.children.length) {
        _this7._emitLine('break;');
      }
    });

    if (node.default) {
      this._emit('default:');

      this.compile(node.default, frame);
    }

    this._emit('}');
  };

  _proto.compileIf = function compileIf(node, frame, async) {
    var _this8 = this;

    this._emit('if(');

    this._compileExpression(node.cond, frame);

    this._emitLine(') {');

    this._withScopedSyntax(function () {
      _this8.compile(node.body, frame);

      if (async) {
        _this8._emit('cb()');
      }
    });

    if (node.else_) {
      this._emitLine('}\nelse {');

      this._withScopedSyntax(function () {
        _this8.compile(node.else_, frame);

        if (async) {
          _this8._emit('cb()');
        }
      });
    } else if (async) {
      this._emitLine('}\nelse {');

      this._emit('cb()');
    }

    this._emitLine('}');
  };

  _proto.compileIfAsync = function compileIfAsync(node, frame) {
    this._emit('(function(cb) {');

    this.compileIf(node, frame, true);

    this._emit('})(' + this._makeCallback());

    this._addScopeLevel();
  };

  _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
    var _this9 = this;

    var bindings = [{
      name: 'index',
      val: i + " + 1"
    }, {
      name: 'index0',
      val: i
    }, {
      name: 'revindex',
      val: len + " - " + i
    }, {
      name: 'revindex0',
      val: len + " - " + i + " - 1"
    }, {
      name: 'first',
      val: i + " === 0"
    }, {
      name: 'last',
      val: i + " === " + len + " - 1"
    }, {
      name: 'length',
      val: len
    }];
    bindings.forEach(function (b) {
      _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
    });
  };

  _proto.compileFor = function compileFor(node, frame) {
    var _this10 = this;

    // Some of this code is ugly, but it keeps the generated code
    // as fast as possible. ForAsync also shares some of this, but
    // not much.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit("var " + arr + " = ");

    this._compileExpression(node.arr, frame);

    this._emitLine(';');

    this._emit("if(" + arr + ") {");

    this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
    // appropriately


    if (node.name instanceof nodes.Array) {
      this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
      // body of the loop is duplicated for each condition, but
      // we are optimizing for speed over size.


      this._emitLine("if(runtime.isArray(" + arr + ")) {");

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


      node.name.children.forEach(function (child, u) {
        var tid = _this10._tmpid();

        _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

        _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

        frame.set(node.name.children[u].value, tid);
      });

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('} else {'); // Iterate over the key/values of an object


      var _node$name$children = node.name.children,
          key = _node$name$children[0],
          val = _node$name$children[1];

      var k = this._tmpid();

      var v = this._tmpid();

      frame.set(key.value, k);
      frame.set(val.value, v);

      this._emitLine(i + " = -1;");

      this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

      this._emitLine("for(var " + k + " in " + arr + ") {");

      this._emitLine(i + "++;");

      this._emitLine("var " + v + " = " + arr + "[" + k + "];");

      this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

      this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('}');
    } else {
      // Generate a typical array iteration
      var _v = this._tmpid();

      frame.set(node.name.value, _v);

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

      this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

      this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');
    }

    this._emitLine('}');

    if (node.else_) {
      this._emitLine('if (!' + len + ') {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
    var _this11 = this;

    // This shares some code with the For tag, but not enough to
    // worry about. This iterates across an object asynchronously,
    // but not in parallel.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit('var ' + arr + ' = runtime.fromIterator(');

    this._compileExpression(node.arr, frame);

    this._emitLine(');');

    if (node.name instanceof nodes.Array) {
      var arrayLen = node.name.children.length;

      this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

      node.name.children.forEach(function (name) {
        _this11._emit(name.value + ",");
      });

      this._emit(i + ',' + len + ',next) {');

      node.name.children.forEach(function (name) {
        var id = name.value;
        frame.set(id, id);

        _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
      });
    } else {
      var id = node.name.value;

      this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

      this._emitLine('frame.set("' + id + '", ' + id + ');');

      frame.set(id, id);
    }

    this._emitLoopBindings(node, arr, i, len);

    this._withScopedSyntax(function () {
      var buf;

      if (parallel) {
        buf = _this11._pushBuffer();
      }

      _this11.compile(node.body, frame);

      _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

      if (parallel) {
        _this11._popBuffer();
      }
    });

    var output = this._tmpid();

    this._emitLine('}, ' + this._makeCallback(output));

    this._addScopeLevel();

    if (parallel) {
      this._emitLine(this.buffer + ' += ' + output + ';');
    }

    if (node.else_) {
      this._emitLine('if (!' + arr + '.length) {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
    this._compileAsyncLoop(node, frame);
  };

  _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
    this._compileAsyncLoop(node, frame, true);
  };

  _proto._compileMacro = function _compileMacro(node, frame) {
    var _this12 = this;

    var args = [];
    var kwargs = null;

    var funcId = 'macro_' + this._tmpid();

    var keepFrame = frame !== undefined; // Type check the definition of the args

    node.args.children.forEach(function (arg, i) {
      if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
        kwargs = arg;
      } else {
        _this12.assertType(arg, nodes.Symbol);

        args.push(arg);
      }
    });
    var realNames = [].concat(args.map(function (n) {
      return "l_" + n.value;
    }), ['kwargs']); // Quoted argument names

    var argNames = args.map(function (n) {
      return "\"" + n.value + "\"";
    });
    var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
      return "\"" + n.key.value + "\"";
    }); // We pass a function to makeMacro which destructures the
    // arguments so support setting positional args with keywords
    // args and passing keyword args as positional args
    // (essentially default values). See runtime.js.

    var currFrame;

    if (keepFrame) {
      currFrame = frame.push(true);
    } else {
      currFrame = new Frame();
    }

    this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
    // random names because the function
    // will create a new run-time scope for us


    args.forEach(function (arg) {
      _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

      currFrame.set(arg.value, "l_" + arg.value);
    }); // Expose the keyword arguments

    if (kwargs) {
      kwargs.children.forEach(function (pair) {
        var name = pair.key.value;

        _this12._emit("frame.set(\"" + name + "\", ");

        _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

        _this12._emit(" ? kwargs[\"" + name + "\"] : ");

        _this12._compileExpression(pair.value, currFrame);

        _this12._emit(');');
      });
    }

    var bufferId = this._pushBuffer();

    this._withScopedSyntax(function () {
      _this12.compile(node.body, currFrame);
    });

    this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

    this._emitLine("return new runtime.SafeString(" + bufferId + ");");

    this._emitLine('});');

    this._popBuffer();

    return funcId;
  };

  _proto.compileMacro = function compileMacro(node, frame) {
    var funcId = this._compileMacro(node); // Expose the macro to the templates


    var name = node.name.value;
    frame.set(name, funcId);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
    } else {
      if (node.name.value.charAt(0) !== '_') {
        this._emitLine("context.addExport(\"" + name + "\");");
      }

      this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
    }
  };

  _proto.compileCaller = function compileCaller(node, frame) {
    // basically an anonymous "macro expression"
    this._emit('(function (){');

    var funcId = this._compileMacro(node, frame);

    this._emit("return " + funcId + ";})()");
  };

  _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
    var parentTemplateId = this._tmpid();

    var parentName = this._templateName();

    var cb = this._makeCallback(parentTemplateId);

    var eagerCompileArg = eagerCompile ? 'true' : 'false';
    var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

    this._emit('env.getTemplate(');

    this._compileExpression(node.template, frame);

    this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

    return parentTemplateId;
  };

  _proto.compileImport = function compileImport(node, frame) {
    var target = node.target.value;

    var id = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

    this._addScopeLevel();

    frame.set(target, id);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + target + "\", " + id + ");");
    } else {
      this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
    }
  };

  _proto.compileFromImport = function compileFromImport(node, frame) {
    var _this13 = this;

    var importedId = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

    this._addScopeLevel();

    node.names.children.forEach(function (nameNode) {
      var name;
      var alias;

      var id = _this13._tmpid();

      if (nameNode instanceof nodes.Pair) {
        name = nameNode.key.value;
        alias = nameNode.value.value;
      } else {
        name = nameNode.value;
        alias = name;
      }

      _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

      _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

      _this13._emitLine('} else {');

      _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

      _this13._emitLine('}');

      frame.set(alias, id);

      if (frame.parent) {
        _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
      } else {
        _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
      }
    });
  };

  _proto.compileBlock = function compileBlock(node) {
    var id = this._tmpid(); // If we are executing outside a block (creating a top-level
    // block), we really don't want to execute its code because it
    // will execute twice: once when the child template runs and
    // again when the parent template runs. Note that blocks
    // within blocks will *always* execute immediately *and*
    // wherever else they are invoked (like used in a parent
    // template). This may have behavioral differences from jinja
    // because blocks can have side effects, but it seems like a
    // waste of performance to always execute huge top-level
    // blocks twice


    if (!this.inBlock) {
      this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
    }

    this._emit("context.getBlock(\"" + node.name.value + "\")");

    if (!this.inBlock) {
      this._emit(')');
    }

    this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

    this._emitLine(this.buffer + " += " + id + ";");

    this._addScopeLevel();
  };

  _proto.compileSuper = function compileSuper(node, frame) {
    var name = node.blockName.value;
    var id = node.symbol.value;

    var cb = this._makeCallback(id);

    this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

    this._emitLine(id + " = runtime.markSafe(" + id + ");");

    this._addScopeLevel();

    frame.set(id, id);
  };

  _proto.compileExtends = function compileExtends(node, frame) {
    var k = this._tmpid();

    var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
    // `if`, so if this happens we need to capture the parent
    // template in the top-level scope


    this._emitLine("parentTemplate = " + parentTemplateId);

    this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

    this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

    this._emitLine('}');

    this._addScopeLevel();
  };

  _proto.compileInclude = function compileInclude(node, frame) {
    this._emitLine('var tasks = [];');

    this._emitLine('tasks.push(');

    this._emitLine('function(callback) {');

    var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

    this._emitLine("callback(null," + id + ");});");

    this._emitLine('});');

    var id2 = this._tmpid();

    this._emitLine('tasks.push(');

    this._emitLine('function(template, callback){');

    this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

    this._emitLine('callback(null,' + id2 + ');});');

    this._emitLine('});');

    this._emitLine('tasks.push(');

    this._emitLine('function(result, callback){');

    this._emitLine(this.buffer + " += result;");

    this._emitLine('callback(null);');

    this._emitLine('});');

    this._emitLine('env.waterfall(tasks, function(){');

    this._addScopeLevel();
  };

  _proto.compileTemplateData = function compileTemplateData(node, frame) {
    this.compileLiteral(node, frame);
  };

  _proto.compileCapture = function compileCapture(node, frame) {
    var _this14 = this;

    // we need to temporarily override the current buffer id as 'output'
    // so the set block writes to the capture output instead of the buffer
    var buffer = this.buffer;
    this.buffer = 'output';

    this._emitLine('(function() {');

    this._emitLine('var output = "";');

    this._withScopedSyntax(function () {
      _this14.compile(node.body, frame);
    });

    this._emitLine('return output;');

    this._emitLine('})()'); // and of course, revert back to the old buffer id


    this.buffer = buffer;
  };

  _proto.compileOutput = function compileOutput(node, frame) {
    var _this15 = this;

    var children = node.children;
    children.forEach(function (child) {
      // TemplateData is a special case because it is never
      // autoescaped, so simply output it for optimization
      if (child instanceof nodes.TemplateData) {
        if (child.value) {
          _this15._emit(_this15.buffer + " += ");

          _this15.compileLiteral(child, frame);

          _this15._emitLine(';');
        }
      } else {
        _this15._emit(_this15.buffer + " += runtime.suppressValue(");

        if (_this15.throwOnUndefined) {
          _this15._emit('runtime.ensureDefined(');
        }

        _this15.compile(child, frame);

        if (_this15.throwOnUndefined) {
          _this15._emit("," + node.lineno + "," + node.colno + ")");
        }

        _this15._emit(', env.opts.autoescape);\n');
      }
    });
  };

  _proto.compileRoot = function compileRoot(node, frame) {
    var _this16 = this;

    if (frame) {
      this.fail('compileRoot: root node can\'t have frame');
    }

    frame = new Frame();

    this._emitFuncBegin(node, 'root');

    this._emitLine('var parentTemplate = null;');

    this._compileChildren(node, frame);

    this._emitLine('if(parentTemplate) {');

    this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

    this._emitLine('} else {');

    this._emitLine("cb(null, " + this.buffer + ");");

    this._emitLine('}');

    this._emitFuncEnd(true);

    this.inBlock = true;
    var blockNames = [];
    var blocks = node.findAll(nodes.Block);
    blocks.forEach(function (block, i) {
      var name = block.name.value;

      if (blockNames.indexOf(name) !== -1) {
        throw new Error("Block \"" + name + "\" defined more than once.");
      }

      blockNames.push(name);

      _this16._emitFuncBegin(block, "b_" + name);

      var tmpFrame = new Frame();

      _this16._emitLine('var frame = frame.push(true);');

      _this16.compile(block.body, tmpFrame);

      _this16._emitFuncEnd();
    });

    this._emitLine('return {');

    blocks.forEach(function (block, i) {
      var blockName = "b_" + block.name.value;

      _this16._emitLine(blockName + ": " + blockName + ",");
    });

    this._emitLine('root: root\n};');
  };

  _proto.compile = function compile(node, frame) {
    var _compile = this['compile' + node.typename];

    if (_compile) {
      _compile.call(this, node, frame);
    } else {
      this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.getCode = function getCode() {
    return this.codebuf.join('');
  };

  return Compiler;
}(Obj);

module.exports = {
  compile: function compile(src, asyncFilters, extensions, name, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

    var preprocessors = (extensions || []).map(function (ext) {
      return ext.preprocess;
    }).filter(function (f) {
      return !!f;
    });
    var processedSrc = preprocessors.reduce(function (s, processor) {
      return processor(s);
    }, src);
    c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
    return c.getCode();
  },
  Compiler: Compiler
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_71017__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var path = __nested_webpack_require_71017__(4);

var _require = __nested_webpack_require_71017__(1),
    EmitterObj = _require.EmitterObj;

module.exports = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Loader, _EmitterObj);

  function Loader() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Loader.prototype;

  _proto.resolve = function resolve(from, to) {
    return path.resolve(path.dirname(from), to);
  };

  _proto.isRelative = function isRelative(filename) {
    return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
  };

  return Loader;
}(EmitterObj);

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_71888__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var asap = __nested_webpack_require_71888__(12);

var _waterfall = __nested_webpack_require_71888__(15);

var lib = __nested_webpack_require_71888__(0);

var compiler = __nested_webpack_require_71888__(5);

var filters = __nested_webpack_require_71888__(18);

var _require = __nested_webpack_require_71888__(10),
    FileSystemLoader = _require.FileSystemLoader,
    WebLoader = _require.WebLoader,
    PrecompiledLoader = _require.PrecompiledLoader;

var tests = __nested_webpack_require_71888__(20);

var globals = __nested_webpack_require_71888__(21);

var _require2 = __nested_webpack_require_71888__(1),
    Obj = _require2.Obj,
    EmitterObj = _require2.EmitterObj;

var globalRuntime = __nested_webpack_require_71888__(2);

var handleError = globalRuntime.handleError,
    Frame = globalRuntime.Frame;

var expressApp = __nested_webpack_require_71888__(22); // If the user is using the async API, *always* call it
// asynchronously even if the template was synchronous.


function callbackAsap(cb, err, res) {
  asap(function () {
    cb(err, res);
  });
}
/**
 * A no-op template, for use with {% include ignore missing %}
 */


var noopTmplSrc = {
  type: 'code',
  obj: {
    root: function root(env, context, frame, runtime, cb) {
      try {
        cb(null, '');
      } catch (e) {
        cb(handleError(e, null, null));
      }
    }
  }
};

var Environment = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Environment, _EmitterObj);

  function Environment() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Environment.prototype;

  _proto.init = function init(loaders, opts) {
    var _this = this;

    // The dev flag determines the trace that'll be shown on errors.
    // If set to true, returns the full trace from the error point,
    // otherwise will return trace starting from Template.render
    // (the full trace from within nunjucks may confuse developers using
    //  the library)
    // defaults to false
    opts = this.opts = opts || {};
    this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
    // every string variable will be escaped by default.
    // If false, strings can be manually escaped using the `escape` filter.
    // defaults to true

    this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
    // to output a null or undefined value

    this.opts.throwOnUndefined = !!opts.throwOnUndefined;
    this.opts.trimBlocks = !!opts.trimBlocks;
    this.opts.lstripBlocks = !!opts.lstripBlocks;
    this.loaders = [];

    if (!loaders) {
      // The filesystem loader is only available server-side
      if (FileSystemLoader) {
        this.loaders = [new FileSystemLoader('views')];
      } else if (WebLoader) {
        this.loaders = [new WebLoader('/views')];
      }
    } else {
      this.loaders = lib.isArray(loaders) ? loaders : [loaders];
    } // It's easy to use precompiled templates: just include them
    // before you configure nunjucks and this will automatically
    // pick it up and use it


    if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
      this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
    }

    this._initLoaders();

    this.globals = globals();
    this.filters = {};
    this.tests = {};
    this.asyncFilters = [];
    this.extensions = {};
    this.extensionsList = [];

    lib._entries(filters).forEach(function (_ref) {
      var name = _ref[0],
          filter = _ref[1];
      return _this.addFilter(name, filter);
    });

    lib._entries(tests).forEach(function (_ref2) {
      var name = _ref2[0],
          test = _ref2[1];
      return _this.addTest(name, test);
    });
  };

  _proto._initLoaders = function _initLoaders() {
    var _this2 = this;

    this.loaders.forEach(function (loader) {
      // Caching and cache busting
      loader.cache = {};

      if (typeof loader.on === 'function') {
        loader.on('update', function (name, fullname) {
          loader.cache[name] = null;

          _this2.emit('update', name, fullname, loader);
        });
        loader.on('load', function (name, source) {
          _this2.emit('load', name, source, loader);
        });
      }
    });
  };

  _proto.invalidateCache = function invalidateCache() {
    this.loaders.forEach(function (loader) {
      loader.cache = {};
    });
  };

  _proto.addExtension = function addExtension(name, extension) {
    extension.__name = name;
    this.extensions[name] = extension;
    this.extensionsList.push(extension);
    return this;
  };

  _proto.removeExtension = function removeExtension(name) {
    var extension = this.getExtension(name);

    if (!extension) {
      return;
    }

    this.extensionsList = lib.without(this.extensionsList, extension);
    delete this.extensions[name];
  };

  _proto.getExtension = function getExtension(name) {
    return this.extensions[name];
  };

  _proto.hasExtension = function hasExtension(name) {
    return !!this.extensions[name];
  };

  _proto.addGlobal = function addGlobal(name, value) {
    this.globals[name] = value;
    return this;
  };

  _proto.getGlobal = function getGlobal(name) {
    if (typeof this.globals[name] === 'undefined') {
      throw new Error('global not found: ' + name);
    }

    return this.globals[name];
  };

  _proto.addFilter = function addFilter(name, func, async) {
    var wrapped = func;

    if (async) {
      this.asyncFilters.push(name);
    }

    this.filters[name] = wrapped;
    return this;
  };

  _proto.getFilter = function getFilter(name) {
    if (!this.filters[name]) {
      throw new Error('filter not found: ' + name);
    }

    return this.filters[name];
  };

  _proto.addTest = function addTest(name, func) {
    this.tests[name] = func;
    return this;
  };

  _proto.getTest = function getTest(name) {
    if (!this.tests[name]) {
      throw new Error('test not found: ' + name);
    }

    return this.tests[name];
  };

  _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
    var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
    return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
  };

  _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
    var _this3 = this;

    var that = this;
    var tmpl = null;

    if (name && name.raw) {
      // this fixes autoescape for templates referenced in symbols
      name = name.raw;
    }

    if (lib.isFunction(parentName)) {
      cb = parentName;
      parentName = null;
      eagerCompile = eagerCompile || false;
    }

    if (lib.isFunction(eagerCompile)) {
      cb = eagerCompile;
      eagerCompile = false;
    }

    if (name instanceof Template) {
      tmpl = name;
    } else if (typeof name !== 'string') {
      throw new Error('template names must be a string: ' + name);
    } else {
      for (var i = 0; i < this.loaders.length; i++) {
        var loader = this.loaders[i];
        tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

        if (tmpl) {
          break;
        }
      }
    }

    if (tmpl) {
      if (eagerCompile) {
        tmpl.compile();
      }

      if (cb) {
        cb(null, tmpl);
        return undefined;
      } else {
        return tmpl;
      }
    }

    var syncResult;

    var createTemplate = function createTemplate(err, info) {
      if (!info && !err && !ignoreMissing) {
        err = new Error('template not found: ' + name);
      }

      if (err) {
        if (cb) {
          cb(err);
          return;
        } else {
          throw err;
        }
      }

      var newTmpl;

      if (!info) {
        newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
      } else {
        newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

        if (!info.noCache) {
          info.loader.cache[name] = newTmpl;
        }
      }

      if (cb) {
        cb(null, newTmpl);
      } else {
        syncResult = newTmpl;
      }
    };

    lib.asyncIter(this.loaders, function (loader, i, next, done) {
      function handle(err, src) {
        if (err) {
          done(err);
        } else if (src) {
          src.loader = loader;
          done(null, src);
        } else {
          next();
        }
      } // Resolve name relative to parentName


      name = that.resolveTemplate(loader, parentName, name);

      if (loader.async) {
        loader.getSource(name, handle);
      } else {
        handle(null, loader.getSource(name));
      }
    }, createTemplate);
    return syncResult;
  };

  _proto.express = function express(app) {
    return expressApp(this, app);
  };

  _proto.render = function render(name, ctx, cb) {
    if (lib.isFunction(ctx)) {
      cb = ctx;
      ctx = null;
    } // We support a synchronous API to make it easier to migrate
    // existing code to async. This works because if you don't do
    // anything async work, the whole thing is actually run
    // synchronously.


    var syncResult = null;
    this.getTemplate(name, function (err, tmpl) {
      if (err && cb) {
        callbackAsap(cb, err);
      } else if (err) {
        throw err;
      } else {
        syncResult = tmpl.render(ctx, cb);
      }
    });
    return syncResult;
  };

  _proto.renderString = function renderString(src, ctx, opts, cb) {
    if (lib.isFunction(opts)) {
      cb = opts;
      opts = {};
    }

    opts = opts || {};
    var tmpl = new Template(src, this, opts.path);
    return tmpl.render(ctx, cb);
  };

  _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
    return _waterfall(tasks, callback, forceAsync);
  };

  return Environment;
}(EmitterObj);

var Context = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Context, _Obj);

  function Context() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto2 = Context.prototype;

  _proto2.init = function init(ctx, blocks, env) {
    var _this4 = this;

    // Has to be tied to an environment so we can tap into its globals.
    this.env = env || new Environment(); // Make a duplicate of ctx

    this.ctx = lib.extend({}, ctx);
    this.blocks = {};
    this.exported = [];
    lib.keys(blocks).forEach(function (name) {
      _this4.addBlock(name, blocks[name]);
    });
  };

  _proto2.lookup = function lookup(name) {
    // This is one of the most called functions, so optimize for
    // the typical case where the name isn't in the globals
    if (name in this.env.globals && !(name in this.ctx)) {
      return this.env.globals[name];
    } else {
      return this.ctx[name];
    }
  };

  _proto2.setVariable = function setVariable(name, val) {
    this.ctx[name] = val;
  };

  _proto2.getVariables = function getVariables() {
    return this.ctx;
  };

  _proto2.addBlock = function addBlock(name, block) {
    this.blocks[name] = this.blocks[name] || [];
    this.blocks[name].push(block);
    return this;
  };

  _proto2.getBlock = function getBlock(name) {
    if (!this.blocks[name]) {
      throw new Error('unknown block "' + name + '"');
    }

    return this.blocks[name][0];
  };

  _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
    var idx = lib.indexOf(this.blocks[name] || [], block);
    var blk = this.blocks[name][idx + 1];
    var context = this;

    if (idx === -1 || !blk) {
      throw new Error('no super block available for "' + name + '"');
    }

    blk(env, context, frame, runtime, cb);
  };

  _proto2.addExport = function addExport(name) {
    this.exported.push(name);
  };

  _proto2.getExported = function getExported() {
    var _this5 = this;

    var exported = {};
    this.exported.forEach(function (name) {
      exported[name] = _this5.ctx[name];
    });
    return exported;
  };

  return Context;
}(Obj);

var Template = /*#__PURE__*/function (_Obj2) {
  _inheritsLoose(Template, _Obj2);

  function Template() {
    return _Obj2.apply(this, arguments) || this;
  }

  var _proto3 = Template.prototype;

  _proto3.init = function init(src, env, path, eagerCompile) {
    this.env = env || new Environment();

    if (lib.isObject(src)) {
      switch (src.type) {
        case 'code':
          this.tmplProps = src.obj;
          break;

        case 'string':
          this.tmplStr = src.obj;
          break;

        default:
          throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
      }
    } else if (lib.isString(src)) {
      this.tmplStr = src;
    } else {
      throw new Error('src must be a string or an object describing the source');
    }

    this.path = path;

    if (eagerCompile) {
      try {
        this._compile();
      } catch (err) {
        throw lib._prettifyError(this.path, this.env.opts.dev, err);
      }
    } else {
      this.compiled = false;
    }
  };

  _proto3.render = function render(ctx, parentFrame, cb) {
    var _this6 = this;

    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    } else if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // If there is a parent frame, we are being called from internal
    // code of another template, and the internal system
    // depends on the sync/async nature of the parent template
    // to be inherited, so force an async callback


    var forceAsync = !parentFrame; // Catch compile errors for async rendering

    try {
      this.compile();
    } catch (e) {
      var err = lib._prettifyError(this.path, this.env.opts.dev, e);

      if (cb) {
        return callbackAsap(cb, err);
      } else {
        throw err;
      }
    }

    var context = new Context(ctx || {}, this.blocks, this.env);
    var frame = parentFrame ? parentFrame.push(true) : new Frame();
    frame.topLevel = true;
    var syncResult = null;
    var didError = false;
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
      // TODO: this is actually a bug in the compiled template (because waterfall
      // tasks are both not passing errors up the chain of callbacks AND are not
      // causing a return from the top-most render function). But fixing that
      // will require a more substantial change to the compiler.
      if (didError && cb && typeof res !== 'undefined') {
        // prevent multiple calls to cb
        return;
      }

      if (err) {
        err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
        didError = true;
      }

      if (cb) {
        if (forceAsync) {
          callbackAsap(cb, err, res);
        } else {
          cb(err, res);
        }
      } else {
        if (err) {
          throw err;
        }

        syncResult = res;
      }
    });
    return syncResult;
  };

  _proto3.getExported = function getExported(ctx, parentFrame, cb) {
    // eslint-disable-line consistent-return
    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    }

    if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // Catch compile errors for async rendering


    try {
      this.compile();
    } catch (e) {
      if (cb) {
        return cb(e);
      } else {
        throw e;
      }
    }

    var frame = parentFrame ? parentFrame.push() : new Frame();
    frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

    var context = new Context(ctx || {}, this.blocks, this.env);
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
      if (err) {
        cb(err, null);
      } else {
        cb(null, context.getExported());
      }
    });
  };

  _proto3.compile = function compile() {
    if (!this.compiled) {
      this._compile();
    }
  };

  _proto3._compile = function _compile() {
    var props;

    if (this.tmplProps) {
      props = this.tmplProps;
    } else {
      var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
      var func = new Function(source); // eslint-disable-line no-new-func

      props = func();
    }

    this.blocks = this._getBlocks(props);
    this.rootRenderFunc = props.root;
    this.compiled = true;
  };

  _proto3._getBlocks = function _getBlocks(props) {
    var blocks = {};
    lib.keys(props).forEach(function (k) {
      if (k.slice(0, 2) === 'b_') {
        blocks[k.slice(2)] = props[k];
      }
    });
    return blocks;
  };

  return Template;
}(Obj);

module.exports = {
  Environment: Environment,
  Template: Template
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_88740__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var lexer = __nested_webpack_require_88740__(9);

var nodes = __nested_webpack_require_88740__(3);

var Obj = __nested_webpack_require_88740__(1).Obj;

var lib = __nested_webpack_require_88740__(0);

var Parser = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Parser, _Obj);

  function Parser() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Parser.prototype;

  _proto.init = function init(tokens) {
    this.tokens = tokens;
    this.peeked = null;
    this.breakOnBlocks = null;
    this.dropLeadingWhitespace = false;
    this.extensions = [];
  };

  _proto.nextToken = function nextToken(withWhitespace) {
    var tok;

    if (this.peeked) {
      if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
        this.peeked = null;
      } else {
        tok = this.peeked;
        this.peeked = null;
        return tok;
      }
    }

    tok = this.tokens.nextToken();

    if (!withWhitespace) {
      while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
        tok = this.tokens.nextToken();
      }
    }

    return tok;
  };

  _proto.peekToken = function peekToken() {
    this.peeked = this.peeked || this.nextToken();
    return this.peeked;
  };

  _proto.pushToken = function pushToken(tok) {
    if (this.peeked) {
      throw new Error('pushToken: can only push one token on between reads');
    }

    this.peeked = tok;
  };

  _proto.error = function error(msg, lineno, colno) {
    if (lineno === undefined || colno === undefined) {
      var tok = this.peekToken() || {};
      lineno = tok.lineno;
      colno = tok.colno;
    }

    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    return new lib.TemplateError(msg, lineno, colno);
  };

  _proto.fail = function fail(msg, lineno, colno) {
    throw this.error(msg, lineno, colno);
  };

  _proto.skip = function skip(type) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.expect = function expect(type) {
    var tok = this.nextToken();

    if (tok.type !== type) {
      this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
    }

    return tok;
  };

  _proto.skipValue = function skipValue(type, val) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type || tok.value !== val) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.skipSymbol = function skipSymbol(val) {
    return this.skipValue(lexer.TOKEN_SYMBOL, val);
  };

  _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
    var tok;

    if (!name) {
      tok = this.peekToken();

      if (!tok) {
        this.fail('unexpected end of file');
      }

      if (tok.type !== lexer.TOKEN_SYMBOL) {
        this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
      }

      name = this.nextToken().value;
    }

    tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
      if (tok.value.charAt(0) === '-') {
        this.dropLeadingWhitespace = true;
      }
    } else {
      this.fail('expected block end in ' + name + ' statement');
    }

    return tok;
  };

  _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
    var tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
      this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
    } else {
      this.pushToken(tok);
      this.fail('expected variable end');
    }
  };

  _proto.parseFor = function parseFor() {
    var forTok = this.peekToken();
    var node;
    var endBlock;

    if (this.skipSymbol('for')) {
      node = new nodes.For(forTok.lineno, forTok.colno);
      endBlock = 'endfor';
    } else if (this.skipSymbol('asyncEach')) {
      node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
      endBlock = 'endeach';
    } else if (this.skipSymbol('asyncAll')) {
      node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
      endBlock = 'endall';
    } else {
      this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
    }

    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseFor: variable name expected for loop');
    }

    var type = this.peekToken().type;

    if (type === lexer.TOKEN_COMMA) {
      // key/value iteration
      var key = node.name;
      node.name = new nodes.Array(key.lineno, key.colno);
      node.name.addChild(key);

      while (this.skip(lexer.TOKEN_COMMA)) {
        var prim = this.parsePrimary();
        node.name.addChild(prim);
      }
    }

    if (!this.skipSymbol('in')) {
      this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
    }

    node.arr = this.parseExpression();
    this.advanceAfterBlockEnd(forTok.value);
    node.body = this.parseUntilBlocks(endBlock, 'else');

    if (this.skipSymbol('else')) {
      this.advanceAfterBlockEnd('else');
      node.else_ = this.parseUntilBlocks(endBlock);
    }

    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseMacro = function parseMacro() {
    var macroTok = this.peekToken();

    if (!this.skipSymbol('macro')) {
      this.fail('expected macro');
    }

    var name = this.parsePrimary(true);
    var args = this.parseSignature();
    var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
    this.advanceAfterBlockEnd(macroTok.value);
    node.body = this.parseUntilBlocks('endmacro');
    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseCall = function parseCall() {
    // a call block is parsed as a normal FunCall, but with an added
    // 'caller' kwarg which is a Caller node.
    var callTok = this.peekToken();

    if (!this.skipSymbol('call')) {
      this.fail('expected call');
    }

    var callerArgs = this.parseSignature(true) || new nodes.NodeList();
    var macroCall = this.parsePrimary();
    this.advanceAfterBlockEnd(callTok.value);
    var body = this.parseUntilBlocks('endcall');
    this.advanceAfterBlockEnd();
    var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
    var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

    var args = macroCall.args.children;

    if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
      args.push(new nodes.KeywordArgs());
    }

    var kwargs = args[args.length - 1];
    kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
    return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
  };

  _proto.parseWithContext = function parseWithContext() {
    var tok = this.peekToken();
    var withContext = null;

    if (this.skipSymbol('with')) {
      withContext = true;
    } else if (this.skipSymbol('without')) {
      withContext = false;
    }

    if (withContext !== null) {
      if (!this.skipSymbol('context')) {
        this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
      }
    }

    return withContext;
  };

  _proto.parseImport = function parseImport() {
    var importTok = this.peekToken();

    if (!this.skipSymbol('import')) {
      this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('as')) {
      this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
    }

    var target = this.parseExpression();
    var withContext = this.parseWithContext();
    var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
    this.advanceAfterBlockEnd(importTok.value);
    return node;
  };

  _proto.parseFrom = function parseFrom() {
    var fromTok = this.peekToken();

    if (!this.skipSymbol('from')) {
      this.fail('parseFrom: expected from');
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('import')) {
      this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
    }

    var names = new nodes.NodeList();
    var withContext;

    while (1) {
      // eslint-disable-line no-constant-condition
      var nextTok = this.peekToken();

      if (nextTok.type === lexer.TOKEN_BLOCK_END) {
        if (!names.children.length) {
          this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
        } // Since we are manually advancing past the block end,
        // need to keep track of whitespace control (normally
        // this is done in `advanceAfterBlockEnd`


        if (nextTok.value.charAt(0) === '-') {
          this.dropLeadingWhitespace = true;
        }

        this.nextToken();
        break;
      }

      if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
      }

      var name = this.parsePrimary();

      if (name.value.charAt(0) === '_') {
        this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
      }

      if (this.skipSymbol('as')) {
        var alias = this.parsePrimary();
        names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
      } else {
        names.addChild(name);
      }

      withContext = this.parseWithContext();
    }

    return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
  };

  _proto.parseBlock = function parseBlock() {
    var tag = this.peekToken();

    if (!this.skipSymbol('block')) {
      this.fail('parseBlock: expected block', tag.lineno, tag.colno);
    }

    var node = new nodes.Block(tag.lineno, tag.colno);
    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
    }

    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('endblock');
    this.skipSymbol('endblock');
    this.skipSymbol(node.name.value);
    var tok = this.peekToken();

    if (!tok) {
      this.fail('parseBlock: expected endblock, got end of file');
    }

    this.advanceAfterBlockEnd(tok.value);
    return node;
  };

  _proto.parseExtends = function parseExtends() {
    var tagName = 'extends';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseTemplateRef: expected ' + tagName);
    }

    var node = new nodes.Extends(tag.lineno, tag.colno);
    node.template = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseInclude = function parseInclude() {
    var tagName = 'include';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseInclude: expected ' + tagName);
    }

    var node = new nodes.Include(tag.lineno, tag.colno);
    node.template = this.parseExpression();

    if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
      node.ignoreMissing = true;
    }

    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseIf = function parseIf() {
    var tag = this.peekToken();
    var node;

    if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
      node = new nodes.If(tag.lineno, tag.colno);
    } else if (this.skipSymbol('ifAsync')) {
      node = new nodes.IfAsync(tag.lineno, tag.colno);
    } else {
      this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
    }

    node.cond = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
    var tok = this.peekToken();

    switch (tok && tok.value) {
      case 'elseif':
      case 'elif':
        node.else_ = this.parseIf();
        break;

      case 'else':
        this.advanceAfterBlockEnd();
        node.else_ = this.parseUntilBlocks('endif');
        this.advanceAfterBlockEnd();
        break;

      case 'endif':
        node.else_ = null;
        this.advanceAfterBlockEnd();
        break;

      default:
        this.fail('parseIf: expected elif, else, or endif, got end of file');
    }

    return node;
  };

  _proto.parseSet = function parseSet() {
    var tag = this.peekToken();

    if (!this.skipSymbol('set')) {
      this.fail('parseSet: expected set', tag.lineno, tag.colno);
    }

    var node = new nodes.Set(tag.lineno, tag.colno, []);
    var target;

    while (target = this.parsePrimary()) {
      node.targets.push(target);

      if (!this.skip(lexer.TOKEN_COMMA)) {
        break;
      }
    }

    if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
      if (!this.skip(lexer.TOKEN_BLOCK_END)) {
        this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
      } else {
        node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
        node.value = null;
        this.advanceAfterBlockEnd();
      }
    } else {
      node.value = this.parseExpression();
      this.advanceAfterBlockEnd(tag.value);
    }

    return node;
  };

  _proto.parseSwitch = function parseSwitch() {
    /*
     * Store the tag names in variables in case someone ever wants to
     * customize this.
     */
    var switchStart = 'switch';
    var switchEnd = 'endswitch';
    var caseStart = 'case';
    var caseDefault = 'default'; // Get the switch tag.

    var tag = this.peekToken(); // fail early if we get some unexpected tag.

    if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
      this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
    } // parse the switch expression


    var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

    this.advanceAfterBlockEnd(switchStart);
    this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

    var tok = this.peekToken(); // create new variables for our cases and default case.

    var cases = [];
    var defaultCase; // while we're dealing with new cases nodes...

    do {
      // skip the start symbol and get the case expression
      this.skipSymbol(caseStart);
      var cond = this.parseExpression();
      this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

      var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
      cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

      tok = this.peekToken();
    } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


    switch (tok.value) {
      case caseDefault:
        this.advanceAfterBlockEnd();
        defaultCase = this.parseUntilBlocks(switchEnd);
        this.advanceAfterBlockEnd();
        break;

      case switchEnd:
        this.advanceAfterBlockEnd();
        break;

      default:
        // otherwise bail because EOF
        this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
    } // and return the switch node.


    return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
  };

  _proto.parseStatement = function parseStatement() {
    var tok = this.peekToken();
    var node;

    if (tok.type !== lexer.TOKEN_SYMBOL) {
      this.fail('tag name expected', tok.lineno, tok.colno);
    }

    if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
      return null;
    }

    switch (tok.value) {
      case 'raw':
        return this.parseRaw();

      case 'verbatim':
        return this.parseRaw('verbatim');

      case 'if':
      case 'ifAsync':
        return this.parseIf();

      case 'for':
      case 'asyncEach':
      case 'asyncAll':
        return this.parseFor();

      case 'block':
        return this.parseBlock();

      case 'extends':
        return this.parseExtends();

      case 'include':
        return this.parseInclude();

      case 'set':
        return this.parseSet();

      case 'macro':
        return this.parseMacro();

      case 'call':
        return this.parseCall();

      case 'import':
        return this.parseImport();

      case 'from':
        return this.parseFrom();

      case 'filter':
        return this.parseFilterStatement();

      case 'switch':
        return this.parseSwitch();

      default:
        if (this.extensions.length) {
          for (var i = 0; i < this.extensions.length; i++) {
            var ext = this.extensions[i];

            if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
              return ext.parse(this, nodes, lexer);
            }
          }
        }

        this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
    }

    return node;
  };

  _proto.parseRaw = function parseRaw(tagName) {
    tagName = tagName || 'raw';
    var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

    var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
    var rawLevel = 1;
    var str = '';
    var matches = null; // Skip opening raw token
    // Keep this token to track line and column numbers

    var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
    // or when we've found the matching "endraw" block

    while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
      var all = matches[0];
      var pre = matches[1];
      var blockName = matches[2]; // Adjust rawlevel

      if (blockName === tagName) {
        rawLevel += 1;
      } else if (blockName === endTagName) {
        rawLevel -= 1;
      } // Add to str


      if (rawLevel === 0) {
        // We want to exclude the last "endraw"
        str += pre; // Move tokenizer to beginning of endraw block

        this.tokens.backN(all.length - pre.length);
      } else {
        str += all;
      }
    }

    return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
  };

  _proto.parsePostfix = function parsePostfix(node) {
    var lookup;
    var tok = this.peekToken();

    while (tok) {
      if (tok.type === lexer.TOKEN_LEFT_PAREN) {
        // Function call
        node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
      } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
        // Reference
        lookup = this.parseAggregate();

        if (lookup.children.length > 1) {
          this.fail('invalid index');
        }

        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
      } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
        // Reference
        this.nextToken();
        var val = this.nextToken();

        if (val.type !== lexer.TOKEN_SYMBOL) {
          this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
        } // Make a literal string because it's not a variable
        // reference


        lookup = new nodes.Literal(val.lineno, val.colno, val.value);
        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
      } else {
        break;
      }

      tok = this.peekToken();
    }

    return node;
  };

  _proto.parseExpression = function parseExpression() {
    var node = this.parseInlineIf();
    return node;
  };

  _proto.parseInlineIf = function parseInlineIf() {
    var node = this.parseOr();

    if (this.skipSymbol('if')) {
      var condNode = this.parseOr();
      var bodyNode = node;
      node = new nodes.InlineIf(node.lineno, node.colno);
      node.body = bodyNode;
      node.cond = condNode;

      if (this.skipSymbol('else')) {
        node.else_ = this.parseOr();
      } else {
        node.else_ = null;
      }
    }

    return node;
  };

  _proto.parseOr = function parseOr() {
    var node = this.parseAnd();

    while (this.skipSymbol('or')) {
      var node2 = this.parseAnd();
      node = new nodes.Or(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAnd = function parseAnd() {
    var node = this.parseNot();

    while (this.skipSymbol('and')) {
      var node2 = this.parseNot();
      node = new nodes.And(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseNot = function parseNot() {
    var tok = this.peekToken();

    if (this.skipSymbol('not')) {
      return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
    }

    return this.parseIn();
  };

  _proto.parseIn = function parseIn() {
    var node = this.parseIs();

    while (1) {
      // eslint-disable-line no-constant-condition
      // check if the next token is 'not'
      var tok = this.nextToken();

      if (!tok) {
        break;
      }

      var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

      if (!invert) {
        this.pushToken(tok);
      }

      if (this.skipSymbol('in')) {
        var node2 = this.parseIs();
        node = new nodes.In(node.lineno, node.colno, node, node2);

        if (invert) {
          node = new nodes.Not(node.lineno, node.colno, node);
        }
      } else {
        // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
        if (invert) {
          this.pushToken(tok);
        }

        break;
      }
    }

    return node;
  } // I put this right after "in" in the operator precedence stack. That can
  // obviously be changed to be closer to Jinja.
  ;

  _proto.parseIs = function parseIs() {
    var node = this.parseCompare(); // look for an is

    if (this.skipSymbol('is')) {
      // look for a not
      var not = this.skipSymbol('not'); // get the next node

      var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

      node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

      if (not) {
        node = new nodes.Not(node.lineno, node.colno, node);
      }
    } // return the node.


    return node;
  };

  _proto.parseCompare = function parseCompare() {
    var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
    var expr = this.parseConcat();
    var ops = [];

    while (1) {
      // eslint-disable-line no-constant-condition
      var tok = this.nextToken();

      if (!tok) {
        break;
      } else if (compareOps.indexOf(tok.value) !== -1) {
        ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
      } else {
        this.pushToken(tok);
        break;
      }
    }

    if (ops.length) {
      return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
    } else {
      return expr;
    }
  } // finds the '~' for string concatenation
  ;

  _proto.parseConcat = function parseConcat() {
    var node = this.parseAdd();

    while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
      var node2 = this.parseAdd();
      node = new nodes.Concat(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAdd = function parseAdd() {
    var node = this.parseSub();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      var node2 = this.parseSub();
      node = new nodes.Add(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseSub = function parseSub() {
    var node = this.parseMul();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      var node2 = this.parseMul();
      node = new nodes.Sub(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMul = function parseMul() {
    var node = this.parseDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
      var node2 = this.parseDiv();
      node = new nodes.Mul(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseDiv = function parseDiv() {
    var node = this.parseFloorDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
      var node2 = this.parseFloorDiv();
      node = new nodes.Div(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseFloorDiv = function parseFloorDiv() {
    var node = this.parseMod();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
      var node2 = this.parseMod();
      node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMod = function parseMod() {
    var node = this.parsePow();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
      var node2 = this.parsePow();
      node = new nodes.Mod(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parsePow = function parsePow() {
    var node = this.parseUnary();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
      var node2 = this.parseUnary();
      node = new nodes.Pow(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseUnary = function parseUnary(noFilters) {
    var tok = this.peekToken();
    var node;

    if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
    } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
    } else {
      node = this.parsePrimary();
    }

    if (!noFilters) {
      node = this.parseFilter(node);
    }

    return node;
  };

  _proto.parsePrimary = function parsePrimary(noPostfix) {
    var tok = this.nextToken();
    var val;
    var node = null;

    if (!tok) {
      this.fail('expected expression, got end of file');
    } else if (tok.type === lexer.TOKEN_STRING) {
      val = tok.value;
    } else if (tok.type === lexer.TOKEN_INT) {
      val = parseInt(tok.value, 10);
    } else if (tok.type === lexer.TOKEN_FLOAT) {
      val = parseFloat(tok.value);
    } else if (tok.type === lexer.TOKEN_BOOLEAN) {
      if (tok.value === 'true') {
        val = true;
      } else if (tok.value === 'false') {
        val = false;
      } else {
        this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
      }
    } else if (tok.type === lexer.TOKEN_NONE) {
      val = null;
    } else if (tok.type === lexer.TOKEN_REGEX) {
      val = new RegExp(tok.value.body, tok.value.flags);
    }

    if (val !== undefined) {
      node = new nodes.Literal(tok.lineno, tok.colno, val);
    } else if (tok.type === lexer.TOKEN_SYMBOL) {
      node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    } else {
      // See if it's an aggregate type, we need to push the
      // current delimiter token back on
      this.pushToken(tok);
      node = this.parseAggregate();
    }

    if (!noPostfix) {
      node = this.parsePostfix(node);
    }

    if (node) {
      return node;
    } else {
      throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
    }
  };

  _proto.parseFilterName = function parseFilterName() {
    var tok = this.expect(lexer.TOKEN_SYMBOL);
    var name = tok.value;

    while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
      name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
    }

    return new nodes.Symbol(tok.lineno, tok.colno, name);
  };

  _proto.parseFilterArgs = function parseFilterArgs(node) {
    if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
      // Get a FunCall node and add the parameters to the
      // filter
      var call = this.parsePostfix(node);
      return call.args.children;
    }

    return [];
  };

  _proto.parseFilter = function parseFilter(node) {
    while (this.skip(lexer.TOKEN_PIPE)) {
      var name = this.parseFilterName();
      node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
    }

    return node;
  };

  _proto.parseFilterStatement = function parseFilterStatement() {
    var filterTok = this.peekToken();

    if (!this.skipSymbol('filter')) {
      this.fail('parseFilterStatement: expected filter');
    }

    var name = this.parseFilterName();
    var args = this.parseFilterArgs(name);
    this.advanceAfterBlockEnd(filterTok.value);
    var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
    this.advanceAfterBlockEnd();
    var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
    return new nodes.Output(name.lineno, name.colno, [node]);
  };

  _proto.parseAggregate = function parseAggregate() {
    var tok = this.nextToken();
    var node;

    switch (tok.type) {
      case lexer.TOKEN_LEFT_PAREN:
        node = new nodes.Group(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_BRACKET:
        node = new nodes.Array(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_CURLY:
        node = new nodes.Dict(tok.lineno, tok.colno);
        break;

      default:
        return null;
    }

    while (1) {
      // eslint-disable-line no-constant-condition
      var type = this.peekToken().type;

      if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
        this.nextToken();
        break;
      }

      if (node.children.length > 0) {
        if (!this.skip(lexer.TOKEN_COMMA)) {
          this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
        }
      }

      if (node instanceof nodes.Dict) {
        // TODO: check for errors
        var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
        // colon

        if (!this.skip(lexer.TOKEN_COLON)) {
          this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
        } // TODO: check for errors


        var value = this.parseExpression();
        node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
      } else {
        // TODO: check for errors
        var expr = this.parseExpression();
        node.addChild(expr);
      }
    }

    return node;
  };

  _proto.parseSignature = function parseSignature(tolerant, noParens) {
    var tok = this.peekToken();

    if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
      if (tolerant) {
        return null;
      } else {
        this.fail('expected arguments', tok.lineno, tok.colno);
      }
    }

    if (tok.type === lexer.TOKEN_LEFT_PAREN) {
      tok = this.nextToken();
    }

    var args = new nodes.NodeList(tok.lineno, tok.colno);
    var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
    var checkComma = false;

    while (1) {
      // eslint-disable-line no-constant-condition
      tok = this.peekToken();

      if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
        this.nextToken();
        break;
      } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
        break;
      }

      if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
      } else {
        var arg = this.parseExpression();

        if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
          kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
        } else {
          args.addChild(arg);
        }
      }

      checkComma = true;
    }

    if (kwargs.children.length) {
      args.addChild(kwargs);
    }

    return args;
  };

  _proto.parseUntilBlocks = function parseUntilBlocks() {
    var prev = this.breakOnBlocks;

    for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
      blockNames[_key] = arguments[_key];
    }

    this.breakOnBlocks = blockNames;
    var ret = this.parse();
    this.breakOnBlocks = prev;
    return ret;
  };

  _proto.parseNodes = function parseNodes() {
    var tok;
    var buf = [];

    while (tok = this.nextToken()) {
      if (tok.type === lexer.TOKEN_DATA) {
        var data = tok.value;
        var nextToken = this.peekToken();
        var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
        // leading whitespace of the data. This is marked with
        // the `dropLeadingWhitespace` variable.

        if (this.dropLeadingWhitespace) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/^\s*/, '');
          this.dropLeadingWhitespace = false;
        } // Same for the succeeding block start token


        if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/\s*$/, '');
        }

        buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
      } else if (tok.type === lexer.TOKEN_BLOCK_START) {
        this.dropLeadingWhitespace = false;
        var n = this.parseStatement();

        if (!n) {
          break;
        }

        buf.push(n);
      } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
        var e = this.parseExpression();
        this.dropLeadingWhitespace = false;
        this.advanceAfterVariableEnd();
        buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
      } else if (tok.type === lexer.TOKEN_COMMENT) {
        this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
      } else {
        // Ignore comments, otherwise this should be an error
        this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
      }
    }

    return buf;
  };

  _proto.parse = function parse() {
    return new nodes.NodeList(0, 0, this.parseNodes());
  };

  _proto.parseAsRoot = function parseAsRoot() {
    return new nodes.Root(0, 0, this.parseNodes());
  };

  return Parser;
}(Obj); // var util = require('util');
// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
// var t;
// while((t = l.nextToken())) {
//     console.log(util.inspect(t));
// }
// var p = new Parser(lexer.lex('hello {% filter title %}' +
//                              'Hello madam how are you' +
//                              '{% endfilter %}'));
// var n = p.parseAsRoot();
// nodes.printNodes(n);


module.exports = {
  parse: function parse(src, extensions, opts) {
    var p = new Parser(lexer.lex(src, opts));

    if (extensions !== undefined) {
      p.extensions = extensions;
    }

    return p.parseAsRoot();
  },
  Parser: Parser
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_124205__) {

"use strict";


var lib = __nested_webpack_require_124205__(0);

var whitespaceChars = " \n\t\r\xA0";
var delimChars = '()[]{}%*-+~/#,:|.<>=!';
var intChars = '0123456789';
var BLOCK_START = '{%';
var BLOCK_END = '%}';
var VARIABLE_START = '{{';
var VARIABLE_END = '}}';
var COMMENT_START = '{#';
var COMMENT_END = '#}';
var TOKEN_STRING = 'string';
var TOKEN_WHITESPACE = 'whitespace';
var TOKEN_DATA = 'data';
var TOKEN_BLOCK_START = 'block-start';
var TOKEN_BLOCK_END = 'block-end';
var TOKEN_VARIABLE_START = 'variable-start';
var TOKEN_VARIABLE_END = 'variable-end';
var TOKEN_COMMENT = 'comment';
var TOKEN_LEFT_PAREN = 'left-paren';
var TOKEN_RIGHT_PAREN = 'right-paren';
var TOKEN_LEFT_BRACKET = 'left-bracket';
var TOKEN_RIGHT_BRACKET = 'right-bracket';
var TOKEN_LEFT_CURLY = 'left-curly';
var TOKEN_RIGHT_CURLY = 'right-curly';
var TOKEN_OPERATOR = 'operator';
var TOKEN_COMMA = 'comma';
var TOKEN_COLON = 'colon';
var TOKEN_TILDE = 'tilde';
var TOKEN_PIPE = 'pipe';
var TOKEN_INT = 'int';
var TOKEN_FLOAT = 'float';
var TOKEN_BOOLEAN = 'boolean';
var TOKEN_NONE = 'none';
var TOKEN_SYMBOL = 'symbol';
var TOKEN_SPECIAL = 'special';
var TOKEN_REGEX = 'regex';

function token(type, value, lineno, colno) {
  return {
    type: type,
    value: value,
    lineno: lineno,
    colno: colno
  };
}

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(str, opts) {
    this.str = str;
    this.index = 0;
    this.len = str.length;
    this.lineno = 0;
    this.colno = 0;
    this.in_code = false;
    opts = opts || {};
    var tags = opts.tags || {};
    this.tags = {
      BLOCK_START: tags.blockStart || BLOCK_START,
      BLOCK_END: tags.blockEnd || BLOCK_END,
      VARIABLE_START: tags.variableStart || VARIABLE_START,
      VARIABLE_END: tags.variableEnd || VARIABLE_END,
      COMMENT_START: tags.commentStart || COMMENT_START,
      COMMENT_END: tags.commentEnd || COMMENT_END
    };
    this.trimBlocks = !!opts.trimBlocks;
    this.lstripBlocks = !!opts.lstripBlocks;
  }

  var _proto = Tokenizer.prototype;

  _proto.nextToken = function nextToken() {
    var lineno = this.lineno;
    var colno = this.colno;
    var tok;

    if (this.in_code) {
      // Otherwise, if we are in a block parse it as code
      var cur = this.current();

      if (this.isFinished()) {
        // We have nothing else to parse
        return null;
      } else if (cur === '"' || cur === '\'') {
        // We've hit a string
        return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
      } else if (tok = this._extract(whitespaceChars)) {
        // We hit some whitespace
        return token(TOKEN_WHITESPACE, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
        // Special check for the block end tag
        //
        // It is a requirement that start and end tags are composed of
        // delimiter characters (%{}[] etc), and our code always
        // breaks on delimiters so we can assume the token parsing
        // doesn't consume these elsewhere
        this.in_code = false;

        if (this.trimBlocks) {
          cur = this.current();

          if (cur === '\n') {
            // Skip newline
            this.forward();
          } else if (cur === '\r') {
            // Skip CRLF newline
            this.forward();
            cur = this.current();

            if (cur === '\n') {
              this.forward();
            } else {
              // Was not a CRLF, so go back
              this.back();
            }
          }
        }

        return token(TOKEN_BLOCK_END, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
        // Special check for variable end tag (see above)
        this.in_code = false;
        return token(TOKEN_VARIABLE_END, tok, lineno, colno);
      } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
        // Skip past 'r/'.
        this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

        var regexBody = '';

        while (!this.isFinished()) {
          if (this.current() === '/' && this.previous() !== '\\') {
            this.forward();
            break;
          } else {
            regexBody += this.current();
            this.forward();
          }
        } // Check for flags.
        // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


        var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
        var regexFlags = '';

        while (!this.isFinished()) {
          var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

          if (isCurrentAFlag) {
            regexFlags += this.current();
            this.forward();
          } else {
            break;
          }
        }

        return token(TOKEN_REGEX, {
          body: regexBody,
          flags: regexFlags
        }, lineno, colno);
      } else if (delimChars.indexOf(cur) !== -1) {
        // We've hit a delimiter (a special char like a bracket)
        this.forward();
        var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
        var curComplex = cur + this.current();
        var type;

        if (lib.indexOf(complexOps, curComplex) !== -1) {
          this.forward();
          cur = curComplex; // See if this is a strict equality/inequality comparator

          if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
            cur = curComplex + this.current();
            this.forward();
          }
        }

        switch (cur) {
          case '(':
            type = TOKEN_LEFT_PAREN;
            break;

          case ')':
            type = TOKEN_RIGHT_PAREN;
            break;

          case '[':
            type = TOKEN_LEFT_BRACKET;
            break;

          case ']':
            type = TOKEN_RIGHT_BRACKET;
            break;

          case '{':
            type = TOKEN_LEFT_CURLY;
            break;

          case '}':
            type = TOKEN_RIGHT_CURLY;
            break;

          case ',':
            type = TOKEN_COMMA;
            break;

          case ':':
            type = TOKEN_COLON;
            break;

          case '~':
            type = TOKEN_TILDE;
            break;

          case '|':
            type = TOKEN_PIPE;
            break;

          default:
            type = TOKEN_OPERATOR;
        }

        return token(type, cur, lineno, colno);
      } else {
        // We are not at whitespace or a delimiter, so extract the
        // text and parse it
        tok = this._extractUntil(whitespaceChars + delimChars);

        if (tok.match(/^[-+]?[0-9]+$/)) {
          if (this.current() === '.') {
            this.forward();

            var dec = this._extract(intChars);

            return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
          } else {
            return token(TOKEN_INT, tok, lineno, colno);
          }
        } else if (tok.match(/^(true|false)$/)) {
          return token(TOKEN_BOOLEAN, tok, lineno, colno);
        } else if (tok === 'none') {
          return token(TOKEN_NONE, tok, lineno, colno);
          /*
           * Added to make the test `null is null` evaluate truthily.
           * Otherwise, Nunjucks will look up null in the context and
           * return `undefined`, which is not what we want. This *may* have
           * consequences is someone is using null in their templates as a
           * variable.
           */
        } else if (tok === 'null') {
          return token(TOKEN_NONE, tok, lineno, colno);
        } else if (tok) {
          return token(TOKEN_SYMBOL, tok, lineno, colno);
        } else {
          throw new Error('Unexpected value while parsing: ' + tok);
        }
      }
    } else {
      // Parse out the template text, breaking on tag
      // delimiters because we need to look for block/variable start
      // tags (don't use the full delimChars for optimization)
      var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

      if (this.isFinished()) {
        return null;
      } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
        this.in_code = true;
        return token(TOKEN_BLOCK_START, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
        this.in_code = true;
        return token(TOKEN_VARIABLE_START, tok, lineno, colno);
      } else {
        tok = '';
        var data;
        var inComment = false;

        if (this._matches(this.tags.COMMENT_START)) {
          inComment = true;
          tok = this._extractString(this.tags.COMMENT_START);
        } // Continually consume text, breaking on the tag delimiter
        // characters and checking to see if it's a start tag.
        //
        // We could hit the end of the template in the middle of
        // our looping, so check for the null return value from
        // _extractUntil


        while ((data = this._extractUntil(beginChars)) !== null) {
          tok += data;

          if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
            if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
              var lastLine = tok.slice(-this.colno);

              if (/^\s+$/.test(lastLine)) {
                // Remove block leading whitespace from beginning of the string
                tok = tok.slice(0, -this.colno);

                if (!tok.length) {
                  // All data removed, collapse to avoid unnecessary nodes
                  // by returning next token (block start)
                  return this.nextToken();
                }
              }
            } // If it is a start tag, stop looping


            break;
          } else if (this._matches(this.tags.COMMENT_END)) {
            if (!inComment) {
              throw new Error('unexpected end of comment');
            }

            tok += this._extractString(this.tags.COMMENT_END);
            break;
          } else {
            // It does not match any tag, so add the character and
            // carry on
            tok += this.current();
            this.forward();
          }
        }

        if (data === null && inComment) {
          throw new Error('expected end of comment, got end of file');
        }

        return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
      }
    }
  };

  _proto._parseString = function _parseString(delimiter) {
    this.forward();
    var str = '';

    while (!this.isFinished() && this.current() !== delimiter) {
      var cur = this.current();

      if (cur === '\\') {
        this.forward();

        switch (this.current()) {
          case 'n':
            str += '\n';
            break;

          case 't':
            str += '\t';
            break;

          case 'r':
            str += '\r';
            break;

          default:
            str += this.current();
        }

        this.forward();
      } else {
        str += cur;
        this.forward();
      }
    }

    this.forward();
    return str;
  };

  _proto._matches = function _matches(str) {
    if (this.index + str.length > this.len) {
      return null;
    }

    var m = this.str.slice(this.index, this.index + str.length);
    return m === str;
  };

  _proto._extractString = function _extractString(str) {
    if (this._matches(str)) {
      this.forwardN(str.length);
      return str;
    }

    return null;
  };

  _proto._extractUntil = function _extractUntil(charString) {
    // Extract all non-matching chars, with the default matching set
    // to everything
    return this._extractMatching(true, charString || '');
  };

  _proto._extract = function _extract(charString) {
    // Extract all matching chars (no default, so charString must be
    // explicit)
    return this._extractMatching(false, charString);
  };

  _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
    // Pull out characters until a breaking char is hit.
    // If breakOnMatch is false, a non-matching char stops it.
    // If breakOnMatch is true, a matching char stops it.
    if (this.isFinished()) {
      return null;
    }

    var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

    if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
      var t = this.current();
      this.forward(); // And pull out all the chars one at a time until we hit a
      // breaking char

      var idx = charString.indexOf(this.current());

      while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
        t += this.current();
        this.forward();
        idx = charString.indexOf(this.current());
      }

      return t;
    }

    return '';
  };

  _proto._extractRegex = function _extractRegex(regex) {
    var matches = this.currentStr().match(regex);

    if (!matches) {
      return null;
    } // Move forward whatever was matched


    this.forwardN(matches[0].length);
    return matches;
  };

  _proto.isFinished = function isFinished() {
    return this.index >= this.len;
  };

  _proto.forwardN = function forwardN(n) {
    for (var i = 0; i < n; i++) {
      this.forward();
    }
  };

  _proto.forward = function forward() {
    this.index++;

    if (this.previous() === '\n') {
      this.lineno++;
      this.colno = 0;
    } else {
      this.colno++;
    }
  };

  _proto.backN = function backN(n) {
    for (var i = 0; i < n; i++) {
      this.back();
    }
  };

  _proto.back = function back() {
    this.index--;

    if (this.current() === '\n') {
      this.lineno--;
      var idx = this.src.lastIndexOf('\n', this.index - 1);

      if (idx === -1) {
        this.colno = this.index;
      } else {
        this.colno = this.index - idx;
      }
    } else {
      this.colno--;
    }
  } // current returns current character
  ;

  _proto.current = function current() {
    if (!this.isFinished()) {
      return this.str.charAt(this.index);
    }

    return '';
  } // currentStr returns what's left of the unparsed string
  ;

  _proto.currentStr = function currentStr() {
    if (!this.isFinished()) {
      return this.str.substr(this.index);
    }

    return '';
  };

  _proto.previous = function previous() {
    return this.str.charAt(this.index - 1);
  };

  return Tokenizer;
}();

module.exports = {
  lex: function lex(src, opts) {
    return new Tokenizer(src, opts);
  },
  TOKEN_STRING: TOKEN_STRING,
  TOKEN_WHITESPACE: TOKEN_WHITESPACE,
  TOKEN_DATA: TOKEN_DATA,
  TOKEN_BLOCK_START: TOKEN_BLOCK_START,
  TOKEN_BLOCK_END: TOKEN_BLOCK_END,
  TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
  TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
  TOKEN_COMMENT: TOKEN_COMMENT,
  TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
  TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
  TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
  TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
  TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
  TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
  TOKEN_OPERATOR: TOKEN_OPERATOR,
  TOKEN_COMMA: TOKEN_COMMA,
  TOKEN_COLON: TOKEN_COLON,
  TOKEN_TILDE: TOKEN_TILDE,
  TOKEN_PIPE: TOKEN_PIPE,
  TOKEN_INT: TOKEN_INT,
  TOKEN_FLOAT: TOKEN_FLOAT,
  TOKEN_BOOLEAN: TOKEN_BOOLEAN,
  TOKEN_NONE: TOKEN_NONE,
  TOKEN_SYMBOL: TOKEN_SYMBOL,
  TOKEN_SPECIAL: TOKEN_SPECIAL,
  TOKEN_REGEX: TOKEN_REGEX
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_140122__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Loader = __nested_webpack_require_140122__(6);

var _require = __nested_webpack_require_140122__(19),
    PrecompiledLoader = _require.PrecompiledLoader;

var WebLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(WebLoader, _Loader);

  function WebLoader(baseURL, opts) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.baseURL = baseURL || '.';
    opts = opts || {}; // By default, the cache is turned off because there's no way
    // to "watch" templates over HTTP, so they are re-downloaded
    // and compiled each time. (Remember, PRECOMPILE YOUR
    // TEMPLATES in production!)

    _this.useCache = !!opts.useCache; // We default `async` to false so that the simple synchronous
    // API can be used when you aren't doing anything async in
    // your templates (which is most of the time). This performs a
    // sync ajax request, but that's ok because it should *only*
    // happen in development. PRECOMPILE YOUR TEMPLATES.

    _this.async = !!opts.async;
    return _this;
  }

  var _proto = WebLoader.prototype;

  _proto.resolve = function resolve(from, to) {
    throw new Error('relative templates not support in the browser yet');
  };

  _proto.getSource = function getSource(name, cb) {
    var _this2 = this;

    var useCache = this.useCache;
    var result;
    this.fetch(this.baseURL + '/' + name, function (err, src) {
      if (err) {
        if (cb) {
          cb(err.content);
        } else if (err.status === 404) {
          result = null;
        } else {
          throw err.content;
        }
      } else {
        result = {
          src: src,
          path: name,
          noCache: !useCache
        };

        _this2.emit('load', name, result);

        if (cb) {
          cb(null, result);
        }
      }
    }); // if this WebLoader isn't running asynchronously, the
    // fetch above would actually run sync and we'll have a
    // result here

    return result;
  };

  _proto.fetch = function fetch(url, cb) {
    // Only in the browser please
    if (typeof window === 'undefined') {
      throw new Error('WebLoader can only by used in a browser');
    }

    var ajax = new XMLHttpRequest();
    var loading = true;

    ajax.onreadystatechange = function () {
      if (ajax.readyState === 4 && loading) {
        loading = false;

        if (ajax.status === 0 || ajax.status === 200) {
          cb(null, ajax.responseText);
        } else {
          cb({
            status: ajax.status,
            content: ajax.responseText
          });
        }
      }
    };

    url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' + new Date().getTime();
    ajax.open('GET', url, this.async);
    ajax.send();
  };

  return WebLoader;
}(Loader);

module.exports = {
  WebLoader: WebLoader,
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_143199__) {

"use strict";


var lib = __nested_webpack_require_143199__(0);

var _require = __nested_webpack_require_143199__(7),
    Environment = _require.Environment,
    Template = _require.Template;

var Loader = __nested_webpack_require_143199__(6);

var loaders = __nested_webpack_require_143199__(10);

var precompile = __nested_webpack_require_143199__(23);

var compiler = __nested_webpack_require_143199__(5);

var parser = __nested_webpack_require_143199__(8);

var lexer = __nested_webpack_require_143199__(9);

var runtime = __nested_webpack_require_143199__(2);

var nodes = __nested_webpack_require_143199__(3);

var installJinjaCompat = __nested_webpack_require_143199__(25); // A single instance of an environment, since this is so commonly used


var e;

function configure(templatesPath, opts) {
  opts = opts || {};

  if (lib.isObject(templatesPath)) {
    opts = templatesPath;
    templatesPath = null;
  }

  var TemplateLoader;

  if (loaders.FileSystemLoader) {
    TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
      watch: opts.watch,
      noCache: opts.noCache
    });
  } else if (loaders.WebLoader) {
    TemplateLoader = new loaders.WebLoader(templatesPath, {
      useCache: opts.web && opts.web.useCache,
      async: opts.web && opts.web.async
    });
  }

  e = new Environment(TemplateLoader, opts);

  if (opts && opts.express) {
    e.express(opts.express);
  }

  return e;
}

module.exports = {
  Environment: Environment,
  Template: Template,
  Loader: Loader,
  FileSystemLoader: loaders.FileSystemLoader,
  NodeResolveLoader: loaders.NodeResolveLoader,
  PrecompiledLoader: loaders.PrecompiledLoader,
  WebLoader: loaders.WebLoader,
  compiler: compiler,
  parser: parser,
  lexer: lexer,
  runtime: runtime,
  lib: lib,
  nodes: nodes,
  installJinjaCompat: installJinjaCompat,
  configure: configure,
  reset: function reset() {
    e = undefined;
  },
  compile: function compile(src, env, path, eagerCompile) {
    if (!e) {
      configure();
    }

    return new Template(src, env, path, eagerCompile);
  },
  render: function render(name, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.render(name, ctx, cb);
  },
  renderString: function renderString(src, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.renderString(src, ctx, cb);
  },
  precompile: precompile ? precompile.precompile : undefined,
  precompileString: precompile ? precompile.precompileString : undefined
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_145591__) {

"use strict";


// rawAsap provides everything we need except exception management.
var rawAsap = __nested_webpack_require_145591__(13);
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_147861__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_147861__(14)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MIT license (by Elan Shanker).
(function(globals) {
  'use strict';

  var executeSync = function(){
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'function'){
      args[0].apply(null, args.splice(1));
    }
  };

  var executeAsync = function(fn){
    if (typeof setImmediate === 'function') {
      setImmediate(fn);
    } else if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };

  var makeIterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  
  var _isArray = Array.isArray || function(maybeArray){
    return Object.prototype.toString.call(maybeArray) === '[object Array]';
  };

  var waterfall = function (tasks, callback, forceAsync) {
    var nextTick = forceAsync ? executeAsync : executeSync;
    callback = callback || function () {};
    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {};
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(makeIterator(tasks))();
  };

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return waterfall;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
  } else {}
})(this);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_174189__) {

"use strict";


var nodes = __nested_webpack_require_174189__(3);

var lib = __nested_webpack_require_174189__(0);

var sym = 0;

function gensym() {
  return 'hole_' + sym++;
} // copy-on-write version of map


function mapCOW(arr, func) {
  var res = null;

  for (var i = 0; i < arr.length; i++) {
    var item = func(arr[i]);

    if (item !== arr[i]) {
      if (!res) {
        res = arr.slice();
      }

      res[i] = item;
    }
  }

  return res || arr;
}

function walk(ast, func, depthFirst) {
  if (!(ast instanceof nodes.Node)) {
    return ast;
  }

  if (!depthFirst) {
    var astT = func(ast);

    if (astT && astT !== ast) {
      return astT;
    }
  }

  if (ast instanceof nodes.NodeList) {
    var children = mapCOW(ast.children, function (node) {
      return walk(node, func, depthFirst);
    });

    if (children !== ast.children) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
    }
  } else if (ast instanceof nodes.CallExtension) {
    var args = walk(ast.args, func, depthFirst);
    var contentArgs = mapCOW(ast.contentArgs, function (node) {
      return walk(node, func, depthFirst);
    });

    if (args !== ast.args || contentArgs !== ast.contentArgs) {
      ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
    }
  } else {
    var props = ast.fields.map(function (field) {
      return ast[field];
    });
    var propsT = mapCOW(props, function (prop) {
      return walk(prop, func, depthFirst);
    });

    if (propsT !== props) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno);
      propsT.forEach(function (prop, i) {
        ast[ast.fields[i]] = prop;
      });
    }
  }

  return depthFirst ? func(ast) || ast : ast;
}

function depthWalk(ast, func) {
  return walk(ast, func, true);
}

function _liftFilters(node, asyncFilters, prop) {
  var children = [];
  var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
    var symbol;

    if (descNode instanceof nodes.Block) {
      return descNode;
    } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
      symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
      children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
    }

    return symbol;
  });

  if (prop) {
    node[prop] = walked;
  } else {
    node = walked;
  }

  if (children.length) {
    children.push(node);
    return new nodes.NodeList(node.lineno, node.colno, children);
  } else {
    return node;
  }
}

function liftFilters(ast, asyncFilters) {
  return depthWalk(ast, function (node) {
    if (node instanceof nodes.Output) {
      return _liftFilters(node, asyncFilters);
    } else if (node instanceof nodes.Set) {
      return _liftFilters(node, asyncFilters, 'value');
    } else if (node instanceof nodes.For) {
      return _liftFilters(node, asyncFilters, 'arr');
    } else if (node instanceof nodes.If) {
      return _liftFilters(node, asyncFilters, 'cond');
    } else if (node instanceof nodes.CallExtension) {
      return _liftFilters(node, asyncFilters, 'args');
    } else {
      return undefined;
    }
  });
}

function liftSuper(ast) {
  return walk(ast, function (blockNode) {
    if (!(blockNode instanceof nodes.Block)) {
      return;
    }

    var hasSuper = false;
    var symbol = gensym();
    blockNode.body = walk(blockNode.body, function (node) {
      // eslint-disable-line consistent-return
      if (node instanceof nodes.FunCall && node.name.value === 'super') {
        hasSuper = true;
        return new nodes.Symbol(node.lineno, node.colno, symbol);
      }
    });

    if (hasSuper) {
      blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
    }
  });
}

function convertStatements(ast) {
  return depthWalk(ast, function (node) {
    if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
      return undefined;
    }

    var async = false;
    walk(node, function (child) {
      if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
        async = true; // Stop iterating by returning the node

        return child;
      }

      return undefined;
    });

    if (async) {
      if (node instanceof nodes.If) {
        return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
      } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
        return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
      }
    }

    return undefined;
  });
}

function cps(ast, asyncFilters) {
  return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}

function transform(ast, asyncFilters) {
  return cps(ast, asyncFilters || []);
} // var parser = require('./parser');
// var src = 'hello {% foo %}{% endfoo %} end';
// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
// nodes.printNodes(ast);


module.exports = {
  transform: transform
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_179484__) {

"use strict";


var lib = __nested_webpack_require_179484__(0);

var r = __nested_webpack_require_179484__(2);

var exports = module.exports = {};

function normalize(value, defaultValue) {
  if (value === null || value === undefined || value === false) {
    return defaultValue;
  }

  return value;
}

exports.abs = Math.abs;

function isNaN(num) {
  return num !== num; // eslint-disable-line no-self-compare
}

function batch(arr, linecount, fillWith) {
  var i;
  var res = [];
  var tmp = [];

  for (i = 0; i < arr.length; i++) {
    if (i % linecount === 0 && tmp.length) {
      res.push(tmp);
      tmp = [];
    }

    tmp.push(arr[i]);
  }

  if (tmp.length) {
    if (fillWith) {
      for (i = tmp.length; i < linecount; i++) {
        tmp.push(fillWith);
      }
    }

    res.push(tmp);
  }

  return res;
}

exports.batch = batch;

function capitalize(str) {
  str = normalize(str, '');
  var ret = str.toLowerCase();
  return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}

exports.capitalize = capitalize;

function center(str, width) {
  str = normalize(str, '');
  width = width || 80;

  if (str.length >= width) {
    return str;
  }

  var spaces = width - str.length;
  var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
  var post = lib.repeat(' ', spaces / 2);
  return r.copySafeness(str, pre + str + post);
}

exports.center = center;

function default_(val, def, bool) {
  if (bool) {
    return val || def;
  } else {
    return val !== undefined ? val : def;
  }
} // TODO: it is confusing to export something called 'default'


exports['default'] = default_; // eslint-disable-line dot-notation

function dictsort(val, caseSensitive, by) {
  if (!lib.isObject(val)) {
    throw new lib.TemplateError('dictsort filter: val must be an object');
  }

  var array = []; // deliberately include properties from the object's prototype

  for (var k in val) {
    // eslint-disable-line guard-for-in, no-restricted-syntax
    array.push([k, val[k]]);
  }

  var si;

  if (by === undefined || by === 'key') {
    si = 0;
  } else if (by === 'value') {
    si = 1;
  } else {
    throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
  }

  array.sort(function (t1, t2) {
    var a = t1[si];
    var b = t2[si];

    if (!caseSensitive) {
      if (lib.isString(a)) {
        a = a.toUpperCase();
      }

      if (lib.isString(b)) {
        b = b.toUpperCase();
      }
    }

    return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
  });
  return array;
}

exports.dictsort = dictsort;

function dump(obj, spaces) {
  return JSON.stringify(obj, null, spaces);
}

exports.dump = dump;

function escape(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.escape = escape;

function safe(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(str.toString());
}

exports.safe = safe;

function first(arr) {
  return arr[0];
}

exports.first = first;

function forceescape(str) {
  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.forceescape = forceescape;

function groupby(arr, attr) {
  return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
}

exports.groupby = groupby;

function indent(str, width, indentfirst) {
  str = normalize(str, '');

  if (str === '') {
    return '';
  }

  width = width || 4; // let res = '';

  var lines = str.split('\n');
  var sp = lib.repeat(' ', width);
  var res = lines.map(function (l, i) {
    return i === 0 && !indentfirst ? l : "" + sp + l;
  }).join('\n');
  return r.copySafeness(str, res);
}

exports.indent = indent;

function join(arr, del, attr) {
  del = del || '';

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return arr.join(del);
}

exports.join = join;

function last(arr) {
  return arr[arr.length - 1];
}

exports.last = last;

function lengthFilter(val) {
  var value = normalize(val, '');

  if (value !== undefined) {
    if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
      // ECMAScript 2015 Maps and Sets
      return value.size;
    }

    if (lib.isObject(value) && !(value instanceof r.SafeString)) {
      // Objects (besides SafeStrings), non-primative Arrays
      return lib.keys(value).length;
    }

    return value.length;
  }

  return 0;
}

exports.length = lengthFilter;

function list(val) {
  if (lib.isString(val)) {
    return val.split('');
  } else if (lib.isObject(val)) {
    return lib._entries(val || {}).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        key: key,
        value: value
      };
    });
  } else if (lib.isArray(val)) {
    return val;
  } else {
    throw new lib.TemplateError('list filter: type not iterable');
  }
}

exports.list = list;

function lower(str) {
  str = normalize(str, '');
  return str.toLowerCase();
}

exports.lower = lower;

function nl2br(str) {
  if (str === null || str === undefined) {
    return '';
  }

  return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
}

exports.nl2br = nl2br;

function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

exports.random = random;
/**
 * Construct select or reject filter
 *
 * @param {boolean} expectedTestResult
 * @returns {function(array, string, *): array}
 */

function getSelectOrReject(expectedTestResult) {
  function filter(arr, testName, secondArg) {
    if (testName === void 0) {
      testName = 'truthy';
    }

    var context = this;
    var test = context.env.getTest(testName);
    return lib.toArray(arr).filter(function examineTestResult(item) {
      return test.call(context, item, secondArg) === expectedTestResult;
    });
  }

  return filter;
}

exports.reject = getSelectOrReject(false);

function rejectattr(arr, attr) {
  return arr.filter(function (item) {
    return !item[attr];
  });
}

exports.rejectattr = rejectattr;
exports.select = getSelectOrReject(true);

function selectattr(arr, attr) {
  return arr.filter(function (item) {
    return !!item[attr];
  });
}

exports.selectattr = selectattr;

function replace(str, old, new_, maxCount) {
  var originalStr = str;

  if (old instanceof RegExp) {
    return str.replace(old, new_);
  }

  if (typeof maxCount === 'undefined') {
    maxCount = -1;
  }

  var res = ''; // Output
  // Cast Numbers in the search term to string

  if (typeof old === 'number') {
    old = '' + old;
  } else if (typeof old !== 'string') {
    // If it is something other than number or string,
    // return the original string
    return str;
  } // Cast numbers in the replacement to string


  if (typeof str === 'number') {
    str = '' + str;
  } // If by now, we don't have a string, throw it back


  if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
    return str;
  } // ShortCircuits


  if (old === '') {
    // Mimic the python behaviour: empty string is replaced
    // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
    res = new_ + str.split('').join(new_) + new_;
    return r.copySafeness(str, res);
  }

  var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
  // not contain the old value, return the string

  if (maxCount === 0 || nextIndex === -1) {
    return str;
  }

  var pos = 0;
  var count = 0; // # of replacements made

  while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
    // Grab the next chunk of src string and add it with the
    // replacement, to the result
    res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

    pos = nextIndex + old.length;
    count++; // See if there are any more replacements to be made

    nextIndex = str.indexOf(old, pos);
  } // We've either reached the end, or done the max # of
  // replacements, tack on any remaining string


  if (pos < str.length) {
    res += str.substring(pos);
  }

  return r.copySafeness(originalStr, res);
}

exports.replace = replace;

function reverse(val) {
  var arr;

  if (lib.isString(val)) {
    arr = list(val);
  } else {
    // Copy it
    arr = lib.map(val, function (v) {
      return v;
    });
  }

  arr.reverse();

  if (lib.isString(val)) {
    return r.copySafeness(val, arr.join(''));
  }

  return arr;
}

exports.reverse = reverse;

function round(val, precision, method) {
  precision = precision || 0;
  var factor = Math.pow(10, precision);
  var rounder;

  if (method === 'ceil') {
    rounder = Math.ceil;
  } else if (method === 'floor') {
    rounder = Math.floor;
  } else {
    rounder = Math.round;
  }

  return rounder(val * factor) / factor;
}

exports.round = round;

function slice(arr, slices, fillWith) {
  var sliceLength = Math.floor(arr.length / slices);
  var extra = arr.length % slices;
  var res = [];
  var offset = 0;

  for (var i = 0; i < slices; i++) {
    var start = offset + i * sliceLength;

    if (i < extra) {
      offset++;
    }

    var end = offset + (i + 1) * sliceLength;
    var currSlice = arr.slice(start, end);

    if (fillWith && i >= extra) {
      currSlice.push(fillWith);
    }

    res.push(currSlice);
  }

  return res;
}

exports.slice = slice;

function sum(arr, attr, start) {
  if (start === void 0) {
    start = 0;
  }

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return start + arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

exports.sum = sum;
exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function (arr, reversed, caseSens, attr) {
  // Copy it
  var array = lib.map(arr, function (v) {
    return v;
  });
  array.sort(function (a, b) {
    var x = attr ? a[attr] : a;
    var y = attr ? b[attr] : b;

    if (!caseSens && lib.isString(x) && lib.isString(y)) {
      x = x.toLowerCase();
      y = y.toLowerCase();
    }

    if (x < y) {
      return reversed ? 1 : -1;
    } else if (x > y) {
      return reversed ? -1 : 1;
    } else {
      return 0;
    }
  });
  return array;
});

function string(obj) {
  return r.copySafeness(obj, obj);
}

exports.string = string;

function striptags(input, preserveLinebreaks) {
  input = normalize(input, '');
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
  var trimmedInput = trim(input.replace(tags, ''));
  var res = '';

  if (preserveLinebreaks) {
    res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
    .replace(/ +/g, ' ') // squash adjacent spaces
    .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
    .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
  } else {
    res = trimmedInput.replace(/\s+/gi, ' ');
  }

  return r.copySafeness(input, res);
}

exports.striptags = striptags;

function title(str) {
  str = normalize(str, '');
  var words = str.split(' ').map(function (word) {
    return capitalize(word);
  });
  return r.copySafeness(str, words.join(' '));
}

exports.title = title;

function trim(str) {
  return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
}

exports.trim = trim;

function truncate(input, length, killwords, end) {
  var orig = input;
  input = normalize(input, '');
  length = length || 255;

  if (input.length <= length) {
    return input;
  }

  if (killwords) {
    input = input.substring(0, length);
  } else {
    var idx = input.lastIndexOf(' ', length);

    if (idx === -1) {
      idx = length;
    }

    input = input.substring(0, idx);
  }

  input += end !== undefined && end !== null ? end : '...';
  return r.copySafeness(orig, input);
}

exports.truncate = truncate;

function upper(str) {
  str = normalize(str, '');
  return str.toUpperCase();
}

exports.upper = upper;

function urlencode(obj) {
  var enc = encodeURIComponent;

  if (lib.isString(obj)) {
    return enc(obj);
  } else {
    var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
    return keyvals.map(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      return enc(k) + "=" + enc(v);
    }).join('&');
  }
}

exports.urlencode = urlencode; // For the jinja regexp, see
// https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
var httpHttpsRe = /^https?:\/\/.*$/;
var wwwRe = /^www\./;
var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

function urlize(str, length, nofollow) {
  if (isNaN(length)) {
    length = Infinity;
  }

  var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
  var words = str.split(/(\s+)/).filter(function (word) {
    // If the word has no length, bail. This can happen for str with
    // trailing whitespace.
    return word && word.length;
  }).map(function (word) {
    var matches = word.match(puncRe);
    var possibleUrl = matches ? matches[1] : word;
    var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

    if (httpHttpsRe.test(possibleUrl)) {
      return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // url that starts with www.


    if (wwwRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // an email address of the form username@domain.tld


    if (emailRe.test(possibleUrl)) {
      return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
    } // url that ends in .com, .org or .net that is not an email address


    if (tldRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    }

    return word;
  });
  return words.join('');
}

exports.urlize = urlize;

function wordcount(str) {
  str = normalize(str, '');
  var words = str ? str.match(/\w+/g) : null;
  return words ? words.length : null;
}

exports.wordcount = wordcount;

function float(val, def) {
  var res = parseFloat(val);
  return isNaN(res) ? def : res;
}

exports.float = float;

function int(val, def) {
  var res = parseInt(val, 10);
  return isNaN(res) ? def : res;
}

exports.int = int; // Aliases

exports.d = exports.default;
exports.e = exports.escape;

/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_194122__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var Loader = __nested_webpack_require_194122__(6);

var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(PrecompiledLoader, _Loader);

  function PrecompiledLoader(compiledTemplates) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.precompiled = compiledTemplates || {};
    return _this;
  }

  var _proto = PrecompiledLoader.prototype;

  _proto.getSource = function getSource(name) {
    if (this.precompiled[name]) {
      return {
        src: {
          type: 'code',
          obj: this.precompiled[name]
        },
        path: name
      };
    }

    return null;
  };

  return PrecompiledLoader;
}(Loader);

module.exports = {
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_195110__) {

"use strict";


var SafeString = __nested_webpack_require_195110__(2).SafeString;
/**
 * Returns `true` if the object is a function, otherwise `false`.
 * @param { any } value
 * @returns { boolean }
 */


function callable(value) {
  return typeof value === 'function';
}

exports.callable = callable;
/**
 * Returns `true` if the object is strictly not `undefined`.
 * @param { any } value
 * @returns { boolean }
 */

function defined(value) {
  return value !== undefined;
}

exports.defined = defined;
/**
 * Returns `true` if the operand (one) is divisble by the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function divisibleby(one, two) {
  return one % two === 0;
}

exports.divisibleby = divisibleby;
/**
 * Returns true if the string has been escaped (i.e., is a SafeString).
 * @param { any } value
 * @returns { boolean }
 */

function escaped(value) {
  return value instanceof SafeString;
}

exports.escaped = escaped;
/**
 * Returns `true` if the arguments are strictly equal.
 * @param { any } one
 * @param { any } two
 */

function equalto(one, two) {
  return one === two;
}

exports.equalto = equalto; // Aliases

exports.eq = exports.equalto;
exports.sameas = exports.equalto;
/**
 * Returns `true` if the value is evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function even(value) {
  return value % 2 === 0;
}

exports.even = even;
/**
 * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
 * undefined, NaN or null. I don't know if we should stick to the default JS
 * behavior or attempt to replicate what Python believes should be falsy (i.e.,
 * empty arrays, empty dicts, not 0...).
 * @param { any } value
 * @returns { boolean }
 */

function falsy(value) {
  return !value;
}

exports.falsy = falsy;
/**
 * Returns `true` if the operand (one) is greater or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ge(one, two) {
  return one >= two;
}

exports.ge = ge;
/**
 * Returns `true` if the operand (one) is greater than the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function greaterthan(one, two) {
  return one > two;
}

exports.greaterthan = greaterthan; // alias

exports.gt = exports.greaterthan;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function le(one, two) {
  return one <= two;
}

exports.le = le;
/**
 * Returns `true` if the operand (one) is less than the test's passed argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function lessthan(one, two) {
  return one < two;
}

exports.lessthan = lessthan; // alias

exports.lt = exports.lessthan;
/**
 * Returns `true` if the string is lowercased.
 * @param { string } value
 * @returns { boolean }
 */

function lower(value) {
  return value.toLowerCase() === value;
}

exports.lower = lower;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ne(one, two) {
  return one !== two;
}

exports.ne = ne;
/**
 * Returns true if the value is strictly equal to `null`.
 * @param { any }
 * @returns { boolean }
 */

function nullTest(value) {
  return value === null;
}

exports.null = nullTest;
/**
 * Returns true if value is a number.
 * @param { any }
 * @returns { boolean }
 */

function number(value) {
  return typeof value === 'number';
}

exports.number = number;
/**
 * Returns `true` if the value is *not* evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function odd(value) {
  return value % 2 === 1;
}

exports.odd = odd;
/**
 * Returns `true` if the value is a string, `false` if not.
 * @param { any } value
 * @returns { boolean }
 */

function string(value) {
  return typeof value === 'string';
}

exports.string = string;
/**
 * Returns `true` if the value is not in the list of things considered falsy:
 * '', null, undefined, 0, NaN and false.
 * @param { any } value
 * @returns { boolean }
 */

function truthy(value) {
  return !!value;
}

exports.truthy = truthy;
/**
 * Returns `true` if the value is undefined.
 * @param { any } value
 * @returns { boolean }
 */

function undefinedTest(value) {
  return value === undefined;
}

exports.undefined = undefinedTest;
/**
 * Returns `true` if the string is uppercased.
 * @param { string } value
 * @returns { boolean }
 */

function upper(value) {
  return value.toUpperCase() === value;
}

exports.upper = upper;
/**
 * If ES6 features are available, returns `true` if the value implements the
 * `Symbol.iterator` method. If not, it's a string or Array.
 *
 * Could potentially cause issues if a browser exists that has Set and Map but
 * not Symbol.
 *
 * @param { any } value
 * @returns { boolean }
 */

function iterable(value) {
  if (typeof Symbol !== 'undefined') {
    return !!value[Symbol.iterator];
  } else {
    return Array.isArray(value) || typeof value === 'string';
  }
}

exports.iterable = iterable;
/**
 * If ES6 features are available, returns `true` if the value is an object hash
 * or an ES6 Map. Otherwise just return if it's an object hash.
 * @param { any } value
 * @returns { boolean }
 */

function mapping(value) {
  // only maps and object hashes
  var bool = value !== null && value !== undefined && typeof value === 'object' && !Array.isArray(value);

  if (Set) {
    return bool && !(value instanceof Set);
  } else {
    return bool;
  }
}

exports.mapping = mapping;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _cycler(items) {
  var index = -1;
  return {
    current: null,
    reset: function reset() {
      index = -1;
      this.current = null;
    },
    next: function next() {
      index++;

      if (index >= items.length) {
        index = 0;
      }

      this.current = items[index];
      return this.current;
    }
  };
}

function _joiner(sep) {
  sep = sep || ',';
  var first = true;
  return function () {
    var val = first ? '' : sep;
    first = false;
    return val;
  };
} // Making this a function instead so it returns a new object
// each time it's called. That way, if something like an environment
// uses it, they will each have their own copy.


function globals() {
  return {
    range: function range(start, stop, step) {
      if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
        step = 1;
      } else if (!step) {
        step = 1;
      }

      var arr = [];

      if (step > 0) {
        for (var i = start; i < stop; i += step) {
          arr.push(i);
        }
      } else {
        for (var _i = start; _i > stop; _i += step) {
          // eslint-disable-line for-direction
          arr.push(_i);
        }
      }

      return arr;
    },
    cycler: function cycler() {
      return _cycler(Array.prototype.slice.call(arguments));
    },
    joiner: function joiner(sep) {
      return _joiner(sep);
    }
  };
}

module.exports = globals;

/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_202467__) {

var path = __nested_webpack_require_202467__(4);

module.exports = function express(env, app) {
  function NunjucksView(name, opts) {
    this.name = name;
    this.path = name;
    this.defaultEngine = opts.defaultEngine;
    this.ext = path.extname(name);

    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }

    if (!this.ext) {
      this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
    }
  }

  NunjucksView.prototype.render = function render(opts, cb) {
    env.render(this.name, opts, cb);
  };

  app.set('view', NunjucksView);
  app.set('nunjucksEnv', env);
  return env;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_203242__) {

"use strict";


var fs = __nested_webpack_require_203242__(4);

var path = __nested_webpack_require_203242__(4);

var _require = __nested_webpack_require_203242__(0),
    _prettifyError = _require._prettifyError;

var compiler = __nested_webpack_require_203242__(5);

var _require2 = __nested_webpack_require_203242__(7),
    Environment = _require2.Environment;

var precompileGlobal = __nested_webpack_require_203242__(24);

function match(filename, patterns) {
  if (!Array.isArray(patterns)) {
    return false;
  }

  return patterns.some(function (pattern) {
    return filename.match(pattern);
  });
}

function precompileString(str, opts) {
  opts = opts || {};
  opts.isString = true;
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (!opts.name) {
    throw new Error('the "name" option is required when compiling a string');
  }

  return wrapper([_precompile(str, opts.name, env)], opts);
}

function precompile(input, opts) {
  // The following options are available:
  //
  // * name: name of the template (auto-generated when compiling a directory)
  // * isString: input is a string, not a file path
  // * asFunction: generate a callable function
  // * force: keep compiling on error
  // * env: the Environment to use (gets extensions and async filters from it)
  // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
  // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
  // * wrapper: function(templates, opts) {...}
  //       Customize the output format to store the compiled template.
  //       By default, templates are stored in a global variable used by the runtime.
  //       A custom loader will be necessary to load your custom wrapper.
  opts = opts || {};
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (opts.isString) {
    return precompileString(input, opts);
  }

  var pathStats = fs.existsSync(input) && fs.statSync(input);
  var precompiled = [];
  var templates = [];

  function addTemplates(dir) {
    fs.readdirSync(dir).forEach(function (file) {
      var filepath = path.join(dir, file);
      var subpath = filepath.substr(path.join(input, '/').length);
      var stat = fs.statSync(filepath);

      if (stat && stat.isDirectory()) {
        subpath += '/';

        if (!match(subpath, opts.exclude)) {
          addTemplates(filepath);
        }
      } else if (match(subpath, opts.include)) {
        templates.push(filepath);
      }
    });
  }

  if (pathStats.isFile()) {
    precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
  } else if (pathStats.isDirectory()) {
    addTemplates(input);

    for (var i = 0; i < templates.length; i++) {
      var name = templates[i].replace(path.join(input, '/'), '');

      try {
        precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
      } catch (e) {
        if (opts.force) {
          // Don't stop generating the output if we're
          // forcing compilation.
          console.error(e); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }
    }
  }

  return wrapper(precompiled, opts);
}

function _precompile(str, name, env) {
  env = env || new Environment([]);
  var asyncFilters = env.asyncFilters;
  var extensions = env.extensionsList;
  var template;
  name = name.replace(/\\/g, '/');

  try {
    template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
  } catch (err) {
    throw _prettifyError(name, false, err);
  }

  return {
    name: name,
    template: template
  };
}

module.exports = {
  precompile: precompile,
  precompileString: precompileString
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function precompileGlobal(templates, opts) {
  var out = '';
  opts = opts || {};

  for (var i = 0; i < templates.length; i++) {
    var name = JSON.stringify(templates[i].name);
    var template = templates[i].template;
    out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

    if (opts.asFunction) {
      out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
    }

    out += '})();\n';
  }

  return out;
}

module.exports = precompileGlobal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

function installCompat() {
  'use strict';
  /* eslint-disable camelcase */
  // This must be called like `nunjucks.installCompat` so that `this`
  // references the nunjucks instance

  var runtime = this.runtime;
  var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

  var Compiler = this.compiler.Compiler;
  var Parser = this.parser.Parser;
  var nodes = this.nodes;
  var lexer = this.lexer;
  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
  var orig_memberLookup = runtime.memberLookup;
  var orig_Compiler_assertType;
  var orig_Parser_parseAggregate;

  if (Compiler) {
    orig_Compiler_assertType = Compiler.prototype.assertType;
  }

  if (Parser) {
    orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
  }

  function uninstall() {
    runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
    runtime.memberLookup = orig_memberLookup;

    if (Compiler) {
      Compiler.prototype.assertType = orig_Compiler_assertType;
    }

    if (Parser) {
      Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
    }
  }

  runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
    var val = orig_contextOrFrameLookup.apply(this, arguments);

    if (val !== undefined) {
      return val;
    }

    switch (key) {
      case 'True':
        return true;

      case 'False':
        return false;

      case 'None':
        return null;

      default:
        return undefined;
    }
  };

  function getTokensState(tokens) {
    return {
      index: tokens.index,
      lineno: tokens.lineno,
      colno: tokens.colno
    };
  }

  if ( true && nodes && Compiler && Parser) {
    // i.e., not slim mode
    var Slice = nodes.Node.extend('Slice', {
      fields: ['start', 'stop', 'step'],
      init: function init(lineno, colno, start, stop, step) {
        start = start || new nodes.Literal(lineno, colno, null);
        stop = stop || new nodes.Literal(lineno, colno, null);
        step = step || new nodes.Literal(lineno, colno, 1);
        this.parent(lineno, colno, start, stop, step);
      }
    });

    Compiler.prototype.assertType = function assertType(node) {
      if (node instanceof Slice) {
        return;
      }

      orig_Compiler_assertType.apply(this, arguments);
    };

    Compiler.prototype.compileSlice = function compileSlice(node, frame) {
      this._emit('(');

      this._compileExpression(node.start, frame);

      this._emit('),(');

      this._compileExpression(node.stop, frame);

      this._emit('),(');

      this._compileExpression(node.step, frame);

      this._emit(')');
    };

    Parser.prototype.parseAggregate = function parseAggregate() {
      var _this = this;

      var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

      origState.colno--;
      origState.index--;

      try {
        return orig_Parser_parseAggregate.apply(this);
      } catch (e) {
        var errState = getTokensState(this.tokens);

        var rethrow = function rethrow() {
          lib._assign(_this.tokens, errState);

          return e;
        }; // Reset to state before original parseAggregate called


        lib._assign(this.tokens, origState);

        this.peeked = false;
        var tok = this.peekToken();

        if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
          throw rethrow();
        } else {
          this.nextToken();
        }

        var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
        // so re-raise the original exception.

        var isSlice = false;

        for (var i = 0; i <= node.fields.length; i++) {
          if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
            break;
          }

          if (i === node.fields.length) {
            if (isSlice) {
              this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
            } else {
              break;
            }
          }

          if (this.skip(lexer.TOKEN_COLON)) {
            isSlice = true;
          } else {
            var field = node.fields[i];
            node[field] = this.parseExpression();
            isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
          }
        }

        if (!isSlice) {
          throw rethrow();
        }

        return new nodes.Array(tok.lineno, tok.colno, [node]);
      }
    };
  }

  function sliceLookup(obj, start, stop, step) {
    obj = obj || [];

    if (start === null) {
      start = step < 0 ? obj.length - 1 : 0;
    }

    if (stop === null) {
      stop = step < 0 ? -1 : obj.length;
    } else if (stop < 0) {
      stop += obj.length;
    }

    if (start < 0) {
      start += obj.length;
    }

    var results = [];

    for (var i = start;; i += step) {
      if (i < 0 || i > obj.length) {
        break;
      }

      if (step > 0 && i >= stop) {
        break;
      }

      if (step < 0 && i <= stop) {
        break;
      }

      results.push(runtime.memberLookup(obj, i));
    }

    return results;
  }

  function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var ARRAY_MEMBERS = {
    pop: function pop(index) {
      if (index === undefined) {
        return this.pop();
      }

      if (index >= this.length || index < 0) {
        throw new Error('KeyError');
      }

      return this.splice(index, 1);
    },
    append: function append(element) {
      return this.push(element);
    },
    remove: function remove(element) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          return this.splice(i, 1);
        }
      }

      throw new Error('ValueError');
    },
    count: function count(element) {
      var count = 0;

      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          count++;
        }
      }

      return count;
    },
    index: function index(element) {
      var i;

      if ((i = this.indexOf(element)) === -1) {
        throw new Error('ValueError');
      }

      return i;
    },
    find: function find(element) {
      return this.indexOf(element);
    },
    insert: function insert(index, elem) {
      return this.splice(index, 0, elem);
    }
  };
  var OBJECT_MEMBERS = {
    items: function items() {
      return lib._entries(this);
    },
    values: function values() {
      return lib._values(this);
    },
    keys: function keys() {
      return lib.keys(this);
    },
    get: function get(key, def) {
      var output = this[key];

      if (output === undefined) {
        output = def;
      }

      return output;
    },
    has_key: function has_key(key) {
      return hasOwnProp(this, key);
    },
    pop: function pop(key, def) {
      var output = this[key];

      if (output === undefined && def !== undefined) {
        output = def;
      } else if (output === undefined) {
        throw new Error('KeyError');
      } else {
        delete this[key];
      }

      return output;
    },
    popitem: function popitem() {
      var keys = lib.keys(this);

      if (!keys.length) {
        throw new Error('KeyError');
      }

      var k = keys[0];
      var val = this[k];
      delete this[k];
      return [k, val];
    },
    setdefault: function setdefault(key, def) {
      if (def === void 0) {
        def = null;
      }

      if (!(key in this)) {
        this[key] = def;
      }

      return this[key];
    },
    update: function update(kwargs) {
      lib._assign(this, kwargs);

      return null; // Always returns None
    }
  };
  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

  runtime.memberLookup = function memberLookup(obj, val, autoescape) {
    if (arguments.length === 4) {
      return sliceLookup.apply(this, arguments);
    }

    obj = obj || {}; // If the object is an object, return any of the methods that Python would
    // otherwise provide.

    if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
      return ARRAY_MEMBERS[val].bind(obj);
    }

    if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
      return OBJECT_MEMBERS[val].bind(obj);
    }

    return orig_memberLookup.apply(this, arguments);
  };

  return uninstall;
}

module.exports = installCompat;

/***/ })
/******/ ]);
});
//# sourceMappingURL=nunjucks.js.map

/***/ }),

/***/ "./node_modules/resonance-audio/build/resonance-audio.js":
/*!***************************************************************!*\
  !*** ./node_modules/resonance-audio/build/resonance-audio.js ***!
  \***************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_536__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_536__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_536__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_536__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_536__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_536__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_536__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_536__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_536__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_536__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_536__(__nested_webpack_require_536__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library common utilities, mathematical constants,
 * and default values.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * @class Utils
 * @description A set of defaults, constants and utility functions.
 */
function Utils() {};


/**
 * Default input gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_GAIN = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field listener by.
 * @type {Number}
 */
Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field sources by.
 * @type {Number}
 */
Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Default distance from listener when setting angle.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_DISTANCE = 1;


/** @type {Float32Array} */
Utils.DEFAULT_POSITION = [0, 0, 0];


/** @type {Float32Array} */
Utils.DEFAULT_FORWARD = [0, 0, -1];


/** @type {Float32Array} */
Utils.DEFAULT_UP = [0, 1, 0];


/** @type {Float32Array} */
Utils.DEFAULT_RIGHT = [1, 0, 0];


/**
 * @type {Number}
 */
Utils.DEFAULT_SPEED_OF_SOUND = 343;


/** Rolloff models (e.g. 'logarithmic', 'linear', or 'none').
 * @type {Array}
 */
Utils.ATTENUATION_ROLLOFFS = ['logarithmic', 'linear', 'none'];


/** Default rolloff model ('logarithmic').
 * @type {string}
 */
Utils.DEFAULT_ATTENUATION_ROLLOFF = 'logarithmic';


/** @type {Number} */
Utils.DEFAULT_MIN_DISTANCE = 1;


/** @type {Number} */
Utils.DEFAULT_MAX_DISTANCE = 1000;


/**
 * The default alpha (i.e. microphone pattern).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_ALPHA = 0;


/**
 * The default pattern sharpness (i.e. pattern exponent).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_SHARPNESS = 1;


/**
 * Default azimuth (in degrees). Suitable range is 0 to 360.
 * @type {Number}
 */
Utils.DEFAULT_AZIMUTH = 0;


/**
 * Default elevation (in degres).
 * Suitable range is from -90 (below) to 90 (above).
 * @type {Number}
 */
Utils.DEFAULT_ELEVATION = 0;


/**
 * The default ambisonic order.
 * @type {Number}
 */
Utils.DEFAULT_AMBISONIC_ORDER = 1;


/**
 * The default source width.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_WIDTH = 0;


/**
 * The maximum delay (in seconds) of a single wall reflection.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MAX_DURATION = 0.5;


/**
 * The -12dB cutoff frequency (in Hertz) for the lowpass filter applied to
 * all reflections.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY = 6400; // Uses -12dB cutoff.


/**
 * The default reflection coefficients (where 0 = no reflection, 1 = perfect
 * reflection, -1 = mirrored reflection (180-degrees out of phase)).
 * @type {Object}
 */
Utils.DEFAULT_REFLECTION_COEFFICIENTS = {
  left: 0, right: 0, front: 0, back: 0, down: 0, up: 0,
};


/**
 * The minimum distance we consider the listener to be to any given wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MIN_DISTANCE = 1;


/**
 * Default room dimensions (in meters).
 * @type {Object}
 */
Utils.DEFAULT_ROOM_DIMENSIONS = {
  width: 0, height: 0, depth: 0,
};


/**
 * The multiplier to apply to distances from the listener to each wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MULTIPLIER = 1;


/** The default bandwidth (in octaves) of the center frequencies.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_BANDWIDTH = 1;


/** The default multiplier applied when computing tail lengths.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_DURATION_MULTIPLIER = 1;


/**
 * The late reflections pre-delay (in milliseconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_PREDELAY = 1.5;


/**
 * The length of the beginning of the impulse response to apply a
 * half-Hann window to.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_TAIL_ONSET = 3.8;


/**
 * The default gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_GAIN = 0.01;


/**
 * The maximum impulse response length (in seconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_MAX_DURATION = 3;


/**
 * Center frequencies of the multiband late reflections.
 * Nine bands are computed by: 31.25 * 2^(0:8).
 * @type {Array}
 */
Utils.DEFAULT_REVERB_FREQUENCY_BANDS = [
  31.25, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000,
];


/**
 * The number of frequency bands.
 */
Utils.NUMBER_REVERB_FREQUENCY_BANDS =
  Utils.DEFAULT_REVERB_FREQUENCY_BANDS.length;


/**
 * The default multiband RT60 durations (in seconds).
 * @type {Float32Array}
 */
Utils.DEFAULT_REVERB_DURATIONS =
  new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);


/**
 * Pre-defined frequency-dependent absorption coefficients for listed materials.
 * Currently supported materials are:
 * <ul>
 * <li>'transparent'</li>
 * <li>'acoustic-ceiling-tiles'</li>
 * <li>'brick-bare'</li>
 * <li>'brick-painted'</li>
 * <li>'concrete-block-coarse'</li>
 * <li>'concrete-block-painted'</li>
 * <li>'curtain-heavy'</li>
 * <li>'fiber-glass-insulation'</li>
 * <li>'glass-thin'</li>
 * <li>'glass-thick'</li>
 * <li>'grass'</li>
 * <li>'linoleum-on-concrete'</li>
 * <li>'marble'</li>
 * <li>'metal'</li>
 * <li>'parquet-on-concrete'</li>
 * <li>'plaster-smooth'</li>
 * <li>'plywood-panel'</li>
 * <li>'polished-concrete-or-tile'</li>
 * <li>'sheetrock'</li>
 * <li>'water-or-ice-surface'</li>
 * <li>'wood-ceiling'</li>
 * <li>'wood-panel'</li>
 * <li>'uniform'</li>
 * </ul>
 * @type {Object}
 */
Utils.ROOM_MATERIAL_COEFFICIENTS = {
  'transparent':
  [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000],
  'acoustic-ceiling-tiles':
  [0.672, 0.675, 0.700, 0.660, 0.720, 0.920, 0.880, 0.750, 1.000],
  'brick-bare':
  [0.030, 0.030, 0.030, 0.030, 0.030, 0.040, 0.050, 0.070, 0.140],
  'brick-painted':
  [0.006, 0.007, 0.010, 0.010, 0.020, 0.020, 0.020, 0.030, 0.060],
  'concrete-block-coarse':
  [0.360, 0.360, 0.360, 0.440, 0.310, 0.290, 0.390, 0.250, 0.500],
  'concrete-block-painted':
  [0.092, 0.090, 0.100, 0.050, 0.060, 0.070, 0.090, 0.080, 0.160],
  'curtain-heavy':
  [0.073, 0.106, 0.140, 0.350, 0.550, 0.720, 0.700, 0.650, 1.000],
  'fiber-glass-insulation':
  [0.193, 0.220, 0.220, 0.820, 0.990, 0.990, 0.990, 0.990, 1.000],
  'glass-thin':
  [0.180, 0.169, 0.180, 0.060, 0.040, 0.030, 0.020, 0.020, 0.040],
  'glass-thick':
  [0.350, 0.350, 0.350, 0.250, 0.180, 0.120, 0.070, 0.040, 0.080],
  'grass':
  [0.050, 0.050, 0.150, 0.250, 0.400, 0.550, 0.600, 0.600, 0.600],
  'linoleum-on-concrete':
  [0.020, 0.020, 0.020, 0.030, 0.030, 0.030, 0.030, 0.020, 0.040],
  'marble':
  [0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.020, 0.020, 0.040],
  'metal':
  [0.030, 0.035, 0.040, 0.040, 0.050, 0.050, 0.050, 0.070, 0.090],
  'parquet-on-concrete':
  [0.028, 0.030, 0.040, 0.040, 0.070, 0.060, 0.060, 0.070, 0.140],
  'plaster-rough':
  [0.017, 0.018, 0.020, 0.030, 0.040, 0.050, 0.040, 0.030, 0.060],
  'plaster-smooth':
  [0.011, 0.012, 0.013, 0.015, 0.020, 0.030, 0.040, 0.050, 0.100],
  'plywood-panel':
  [0.400, 0.340, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'polished-concrete-or-tile':
  [0.008, 0.008, 0.010, 0.010, 0.015, 0.020, 0.020, 0.020, 0.040],
  'sheet-rock':
  [0.290, 0.279, 0.290, 0.100, 0.050, 0.040, 0.070, 0.090, 0.180],
  'water-or-ice-surface':
  [0.006, 0.006, 0.008, 0.008, 0.013, 0.015, 0.020, 0.025, 0.050],
  'wood-ceiling':
  [0.150, 0.147, 0.150, 0.110, 0.100, 0.070, 0.060, 0.070, 0.140],
  'wood-panel':
  [0.280, 0.280, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'uniform':
  [0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500],
};


/**
 * Default materials that use strings from
 * {@linkcode Utils.MATERIAL_COEFFICIENTS MATERIAL_COEFFICIENTS}
 * @type {Object}
 */
Utils.DEFAULT_ROOM_MATERIALS = {
  left: 'transparent', right: 'transparent', front: 'transparent',
  back: 'transparent', down: 'transparent', up: 'transparent',
};


/**
 * The number of bands to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.NUMBER_REFLECTION_AVERAGING_BANDS = 3;


/**
 * The starting band to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.ROOM_STARTING_AVERAGING_BAND = 4;


/**
 * The minimum threshold for room volume.
 * Room model is disabled if volume is below this value.
 * @type {Number} */
Utils.ROOM_MIN_VOLUME = 1e-4;


/**
 * Air absorption coefficients per frequency band.
 * @type {Float32Array}
 */
Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS =
  [0.0006, 0.0006, 0.0007, 0.0008, 0.0010, 0.0015, 0.0026, 0.0060, 0.0207];


/**
 * A scalar correction value to ensure Sabine and Eyring produce the same RT60
 * value at the cross-over threshold.
 * @type {Number}
 */
Utils.ROOM_EYRING_CORRECTION_COEFFICIENT = 1.38;


/**
 * @type {Number}
 * @private
 */
Utils.TWO_PI = 6.28318530717959;


/**
 * @type {Number}
 * @private
 */
Utils.TWENTY_FOUR_LOG10 = 55.2620422318571;


/**
 * @type {Number}
 * @private
 */
Utils.LOG1000 = 6.90775527898214;


/**
 * @type {Number}
 * @private
 */
Utils.LOG2_DIV2 = 0.346573590279973;


/**
 * @type {Number}
 * @private
 */
Utils.DEGREES_TO_RADIANS = 0.017453292519943;


/**
 * @type {Number}
 * @private
 */
Utils.RADIANS_TO_DEGREES = 57.295779513082323;


/**
 * @type {Number}
 * @private
 */
Utils.EPSILON_FLOAT = 1e-8;


/**
 * ResonanceAudio library logging function.
 * @type {Function}
 * @param {any} Message to be printed out.
 * @private
 */
Utils.log = function() {
  window.console.log.apply(window.console, [
    '%c[ResonanceAudio]%c '
      + Array.prototype.slice.call(arguments).join(' ') + ' %c(@'
      + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 700',
    'font-weight: 400',
    'color: #AAA',
  ]);
};


/**
 * Normalize a 3-d vector.
 * @param {Float32Array} v 3-element vector.
 * @return {Float32Array} 3-element vector.
 * @private
 */
Utils.normalizeVector = function(v) {
  let n = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  if (n > exports.EPSILON_FLOAT) {
    n = 1 / n;
    v[0] *= n;
    v[1] *= n;
    v[2] *= n;
  }
  return v;
};


/**
 * Cross-product between two 3-d vectors.
 * @param {Float32Array} a 3-element vector.
 * @param {Float32Array} b 3-element vector.
 * @return {Float32Array}
 * @private
 */
Utils.crossProduct = function(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0],
  ];
};

module.exports = Utils;


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_13812__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Spatially encodes input using weighted spherical harmonics.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Tables = __nested_webpack_require_13812__(3);
const Utils = __nested_webpack_require_13812__(0);


/**
 * @class Encoder
 * @description Spatially encodes input using weighted spherical harmonics.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Number} options.azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} options.elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Encoder(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Encoder
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Encoder
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.azimuth == undefined) {
    options.azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (options.elevation == undefined) {
    options.elevation = Utils.DEFAULT_ELEVATION;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  this._context = context;

  // Create I/O nodes.
  this.input = context.createGain();
  this._channelGain = [];
  this._merger = undefined;
  this.output = context.createGain();

  // Set initial order, angle and source width.
  this.setAmbisonicOrder(options.ambisonicOrder);
  this._azimuth = options.azimuth;
  this._elevation = options.elevation;
  this.setSourceWidth(options.sourceWidth);
}

/**
 * Set the desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
Encoder.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);

  this.input.disconnect();
  for (let i = 0; i < this._channelGain.length; i++) {
    this._channelGain[i].disconnect();
  }
  if (this._merger != undefined) {
    this._merger.disconnect();
  }
  delete this._channelGain;
  delete this._merger;

  // Create audio graph.
  let numChannels = (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);
  this._merger = this._context.createChannelMerger(numChannels);
  this._channelGain = new Array(numChannels);
  for (let i = 0; i < numChannels; i++) {
    this._channelGain[i] = this._context.createGain();
    this.input.connect(this._channelGain[i]);
    this._channelGain[i].connect(this._merger, 0, i);
  }
  this._merger.connect(this.output);
};


/**
 * Set the direction of the encoded source signal.
 * @param {Number} azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 */
Encoder.prototype.setDirection = function(azimuth, elevation) {
  // Format input direction to nearest indices.
  if (azimuth == undefined || isNaN(azimuth)) {
    azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (elevation == undefined || isNaN(elevation)) {
    elevation = Utils.DEFAULT_ELEVATION;
  }

  // Store the formatted input (for updating source width).
  this._azimuth = azimuth;
  this._elevation = elevation;

  // Format direction for index lookups.
  azimuth = Math.round(azimuth % 360);
  if (azimuth < 0) {
    azimuth += 360;
  }
  elevation = Math.round(Math.min(90, Math.max(-90, elevation))) + 90;

  // Assign gains to each output.
  this._channelGain[0].gain.value = Tables.MAX_RE_WEIGHTS[this._spreadIndex][0];
  for (let i = 1; i <= this._ambisonicOrder; i++) {
    let degreeWeight = Tables.MAX_RE_WEIGHTS[this._spreadIndex][i];
    for (let j = -i; j <= i; j++) {
      let acnChannel = (i * i) + i + j;
      let elevationIndex = i * (i + 1) / 2 + Math.abs(j) - 1;
      let val = Tables.SPHERICAL_HARMONICS[1][elevation][elevationIndex];
      if (j != 0) {
        let azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j - 1;
        if (j < 0) {
          azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j;
        }
        val *= Tables.SPHERICAL_HARMONICS[0][azimuth][azimuthIndex];
      }
      this._channelGain[acnChannel].gain.value = val * degreeWeight;
    }
  }
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Encoder.prototype.setSourceWidth = function(sourceWidth) {
  // The MAX_RE_WEIGHTS is a 360 x (Tables.SPHERICAL_HARMONICS_MAX_ORDER+1)
  // size table.
  this._spreadIndex = Math.min(359, Math.max(0, Math.round(sourceWidth)));
  this.setDirection(this._azimuth, this._elevation);
};


/**
 * Validate the provided ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 * @return {Number} Validated/adjusted ambisonic order.
 * @private
 */
Encoder.validateAmbisonicOrder = function(ambisonicOrder) {
  if (isNaN(ambisonicOrder) || ambisonicOrder == undefined) {
    Utils.log('Error: Invalid ambisonic order',
    options.ambisonicOrder, '\nUsing ambisonicOrder=1 instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder < 1) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Min order is 1)',
    '\nUsing min order instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder > Tables.SPHERICAL_HARMONICS_MAX_ORDER) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Max order is',
    Tables.SPHERICAL_HARMONICS_MAX_ORDER, ')\nUsing max order instead.');
    options.ambisonicOrder = Tables.SPHERICAL_HARMONICS_MAX_ORDER;
  }
  return ambisonicOrder;
};


module.exports = Encoder;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_21131__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Listener model to spatialize sources in an environment.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Omnitone = __nested_webpack_require_21131__(12);
const Encoder = __nested_webpack_require_21131__(1);
const Utils = __nested_webpack_require_21131__(0);


/**
 * @class Listener
 * @description Listener model to spatialize sources in an environment.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.position
 * Initial position (in meters), where origin is the center of
 * the room. Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The listener's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The listener's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 */
function Listener(context, options) {
  // Public variables.
  /**
   * Position (in meters).
   * @member {Float32Array} position
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Listener
   * @instance
   */
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} ambisonicOutput
   * @memberof Listener
   * @instance
   */
  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }

  // Member variables.
  this.position = new Float32Array(3);
  this._tempMatrix3 = new Float32Array(9);

  // Select the appropriate HRIR filters using 2-channel chunks since
  // multichannel audio is not yet supported by a majority of browsers.
  this._ambisonicOrder =
    Encoder.validateAmbisonicOrder(options.ambisonicOrder);

    // Create audio nodes.
  this._context = context;
  if (this._ambisonicOrder == 1) {
    this._renderer = Omnitone.Omnitone.createFOARenderer(context, {});
  } else if (this._ambisonicOrder > 1) {
    this._renderer = Omnitone.Omnitone.createHOARenderer(context, {
      ambisonicOrder: this._ambisonicOrder,
    });
  }

  // These nodes are created in order to safely asynchronously load Omnitone
  // while the rest of the scene is being created.
  this.input = context.createGain();
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();

  // Initialize Omnitone (async) and connect to audio graph when complete.
  let that = this;
  this._renderer.initialize().then(function() {
    // Connect pre-rotated soundfield to renderer.
    that.input.connect(that._renderer.input);

    // Connect rotated soundfield to ambisonic output.
    if (that._ambisonicOrder > 1) {
      that._renderer._hoaRotator.output.connect(that.ambisonicOutput);
    } else {
      that._renderer._foaRotator.output.connect(that.ambisonicOutput);
    }

    // Connect binaurally-rendered soundfield to binaural output.
    that._renderer.output.connect(that.output);
  });

  // Set orientation and update rotation matrix accordingly.
  this.setOrientation(options.forward[0], options.forward[1],
    options.forward[2], options.up[0], options.up[1], options.up[2]);
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Listener.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
  upX, upY, upZ) {
  let right = Utils.crossProduct([forwardX, forwardY, forwardZ],
    [upX, upY, upZ]);
  this._tempMatrix3[0] = right[0];
  this._tempMatrix3[1] = right[1];
  this._tempMatrix3[2] = right[2];
  this._tempMatrix3[3] = upX;
  this._tempMatrix3[4] = upY;
  this._tempMatrix3[5] = upZ;
  this._tempMatrix3[6] = forwardX;
  this._tempMatrix3[7] = forwardY;
  this._tempMatrix3[8] = forwardZ;
  this._renderer.setRotationMatrix3(this._tempMatrix3);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix4
 * The Three.js Matrix4 object representing the listener's world transform.
 */
Listener.prototype.setFromMatrix = function(matrix4) {
  // Update ambisonic rotation matrix internally.
  this._renderer.setRotationMatrix4(matrix4.elements);

  // Extract position from matrix.
  this.position[0] = matrix4.elements[12];
  this.position[1] = matrix4.elements[13];
  this.position[2] = matrix4.elements[14];
};


module.exports = Listener;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Pre-computed lookup tables for encoding ambisonic sources.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * Pre-computed Spherical Harmonics Coefficients.
 *
 * This function generates an efficient lookup table of SH coefficients. It
 * exploits the way SHs are generated (i.e. Ylm = Nlm * Plm * Em). Since Nlm
 * & Plm coefficients only depend on theta, and Em only depends on phi, we
 * can separate the equation along these lines. Em does not depend on
 * degree, so we only need to compute (2 * l) per azimuth Em total and
 * Nlm * Plm is symmetrical across indexes, so only positive indexes are
 * computed ((l + 1) * (l + 2) / 2 - 1) per elevation.
 * @type {Float32Array}
 */
exports.SPHERICAL_HARMONICS =
[
  [
    [0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000],
    [0.052336, 0.034899, 0.017452, 0.999848, 0.999391, 0.998630],
    [0.104528, 0.069756, 0.034899, 0.999391, 0.997564, 0.994522],
    [0.156434, 0.104528, 0.052336, 0.998630, 0.994522, 0.987688],
    [0.207912, 0.139173, 0.069756, 0.997564, 0.990268, 0.978148],
    [0.258819, 0.173648, 0.087156, 0.996195, 0.984808, 0.965926],
    [0.309017, 0.207912, 0.104528, 0.994522, 0.978148, 0.951057],
    [0.358368, 0.241922, 0.121869, 0.992546, 0.970296, 0.933580],
    [0.406737, 0.275637, 0.139173, 0.990268, 0.961262, 0.913545],
    [0.453990, 0.309017, 0.156434, 0.987688, 0.951057, 0.891007],
    [0.500000, 0.342020, 0.173648, 0.984808, 0.939693, 0.866025],
    [0.544639, 0.374607, 0.190809, 0.981627, 0.927184, 0.838671],
    [0.587785, 0.406737, 0.207912, 0.978148, 0.913545, 0.809017],
    [0.629320, 0.438371, 0.224951, 0.974370, 0.898794, 0.777146],
    [0.669131, 0.469472, 0.241922, 0.970296, 0.882948, 0.743145],
    [0.707107, 0.500000, 0.258819, 0.965926, 0.866025, 0.707107],
    [0.743145, 0.529919, 0.275637, 0.961262, 0.848048, 0.669131],
    [0.777146, 0.559193, 0.292372, 0.956305, 0.829038, 0.629320],
    [0.809017, 0.587785, 0.309017, 0.951057, 0.809017, 0.587785],
    [0.838671, 0.615661, 0.325568, 0.945519, 0.788011, 0.544639],
    [0.866025, 0.642788, 0.342020, 0.939693, 0.766044, 0.500000],
    [0.891007, 0.669131, 0.358368, 0.933580, 0.743145, 0.453990],
    [0.913545, 0.694658, 0.374607, 0.927184, 0.719340, 0.406737],
    [0.933580, 0.719340, 0.390731, 0.920505, 0.694658, 0.358368],
    [0.951057, 0.743145, 0.406737, 0.913545, 0.669131, 0.309017],
    [0.965926, 0.766044, 0.422618, 0.906308, 0.642788, 0.258819],
    [0.978148, 0.788011, 0.438371, 0.898794, 0.615661, 0.207912],
    [0.987688, 0.809017, 0.453990, 0.891007, 0.587785, 0.156434],
    [0.994522, 0.829038, 0.469472, 0.882948, 0.559193, 0.104528],
    [0.998630, 0.848048, 0.484810, 0.874620, 0.529919, 0.052336],
    [1.000000, 0.866025, 0.500000, 0.866025, 0.500000, 0.000000],
    [0.998630, 0.882948, 0.515038, 0.857167, 0.469472, -0.052336],
    [0.994522, 0.898794, 0.529919, 0.848048, 0.438371, -0.104528],
    [0.987688, 0.913545, 0.544639, 0.838671, 0.406737, -0.156434],
    [0.978148, 0.927184, 0.559193, 0.829038, 0.374607, -0.207912],
    [0.965926, 0.939693, 0.573576, 0.819152, 0.342020, -0.258819],
    [0.951057, 0.951057, 0.587785, 0.809017, 0.309017, -0.309017],
    [0.933580, 0.961262, 0.601815, 0.798636, 0.275637, -0.358368],
    [0.913545, 0.970296, 0.615661, 0.788011, 0.241922, -0.406737],
    [0.891007, 0.978148, 0.629320, 0.777146, 0.207912, -0.453990],
    [0.866025, 0.984808, 0.642788, 0.766044, 0.173648, -0.500000],
    [0.838671, 0.990268, 0.656059, 0.754710, 0.139173, -0.544639],
    [0.809017, 0.994522, 0.669131, 0.743145, 0.104528, -0.587785],
    [0.777146, 0.997564, 0.681998, 0.731354, 0.069756, -0.629320],
    [0.743145, 0.999391, 0.694658, 0.719340, 0.034899, -0.669131],
    [0.707107, 1.000000, 0.707107, 0.707107, 0.000000, -0.707107],
    [0.669131, 0.999391, 0.719340, 0.694658, -0.034899, -0.743145],
    [0.629320, 0.997564, 0.731354, 0.681998, -0.069756, -0.777146],
    [0.587785, 0.994522, 0.743145, 0.669131, -0.104528, -0.809017],
    [0.544639, 0.990268, 0.754710, 0.656059, -0.139173, -0.838671],
    [0.500000, 0.984808, 0.766044, 0.642788, -0.173648, -0.866025],
    [0.453990, 0.978148, 0.777146, 0.629320, -0.207912, -0.891007],
    [0.406737, 0.970296, 0.788011, 0.615661, -0.241922, -0.913545],
    [0.358368, 0.961262, 0.798636, 0.601815, -0.275637, -0.933580],
    [0.309017, 0.951057, 0.809017, 0.587785, -0.309017, -0.951057],
    [0.258819, 0.939693, 0.819152, 0.573576, -0.342020, -0.965926],
    [0.207912, 0.927184, 0.829038, 0.559193, -0.374607, -0.978148],
    [0.156434, 0.913545, 0.838671, 0.544639, -0.406737, -0.987688],
    [0.104528, 0.898794, 0.848048, 0.529919, -0.438371, -0.994522],
    [0.052336, 0.882948, 0.857167, 0.515038, -0.469472, -0.998630],
    [0.000000, 0.866025, 0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, 0.848048, 0.874620, 0.484810, -0.529919, -0.998630],
    [-0.104528, 0.829038, 0.882948, 0.469472, -0.559193, -0.994522],
    [-0.156434, 0.809017, 0.891007, 0.453990, -0.587785, -0.987688],
    [-0.207912, 0.788011, 0.898794, 0.438371, -0.615661, -0.978148],
    [-0.258819, 0.766044, 0.906308, 0.422618, -0.642788, -0.965926],
    [-0.309017, 0.743145, 0.913545, 0.406737, -0.669131, -0.951057],
    [-0.358368, 0.719340, 0.920505, 0.390731, -0.694658, -0.933580],
    [-0.406737, 0.694658, 0.927184, 0.374607, -0.719340, -0.913545],
    [-0.453990, 0.669131, 0.933580, 0.358368, -0.743145, -0.891007],
    [-0.500000, 0.642788, 0.939693, 0.342020, -0.766044, -0.866025],
    [-0.544639, 0.615661, 0.945519, 0.325568, -0.788011, -0.838671],
    [-0.587785, 0.587785, 0.951057, 0.309017, -0.809017, -0.809017],
    [-0.629320, 0.559193, 0.956305, 0.292372, -0.829038, -0.777146],
    [-0.669131, 0.529919, 0.961262, 0.275637, -0.848048, -0.743145],
    [-0.707107, 0.500000, 0.965926, 0.258819, -0.866025, -0.707107],
    [-0.743145, 0.469472, 0.970296, 0.241922, -0.882948, -0.669131],
    [-0.777146, 0.438371, 0.974370, 0.224951, -0.898794, -0.629320],
    [-0.809017, 0.406737, 0.978148, 0.207912, -0.913545, -0.587785],
    [-0.838671, 0.374607, 0.981627, 0.190809, -0.927184, -0.544639],
    [-0.866025, 0.342020, 0.984808, 0.173648, -0.939693, -0.500000],
    [-0.891007, 0.309017, 0.987688, 0.156434, -0.951057, -0.453990],
    [-0.913545, 0.275637, 0.990268, 0.139173, -0.961262, -0.406737],
    [-0.933580, 0.241922, 0.992546, 0.121869, -0.970296, -0.358368],
    [-0.951057, 0.207912, 0.994522, 0.104528, -0.978148, -0.309017],
    [-0.965926, 0.173648, 0.996195, 0.087156, -0.984808, -0.258819],
    [-0.978148, 0.139173, 0.997564, 0.069756, -0.990268, -0.207912],
    [-0.987688, 0.104528, 0.998630, 0.052336, -0.994522, -0.156434],
    [-0.994522, 0.069756, 0.999391, 0.034899, -0.997564, -0.104528],
    [-0.998630, 0.034899, 0.999848, 0.017452, -0.999391, -0.052336],
    [-1.000000, 0.000000, 1.000000, 0.000000, -1.000000, -0.000000],
    [-0.998630, -0.034899, 0.999848, -0.017452, -0.999391, 0.052336],
    [-0.994522, -0.069756, 0.999391, -0.034899, -0.997564, 0.104528],
    [-0.987688, -0.104528, 0.998630, -0.052336, -0.994522, 0.156434],
    [-0.978148, -0.139173, 0.997564, -0.069756, -0.990268, 0.207912],
    [-0.965926, -0.173648, 0.996195, -0.087156, -0.984808, 0.258819],
    [-0.951057, -0.207912, 0.994522, -0.104528, -0.978148, 0.309017],
    [-0.933580, -0.241922, 0.992546, -0.121869, -0.970296, 0.358368],
    [-0.913545, -0.275637, 0.990268, -0.139173, -0.961262, 0.406737],
    [-0.891007, -0.309017, 0.987688, -0.156434, -0.951057, 0.453990],
    [-0.866025, -0.342020, 0.984808, -0.173648, -0.939693, 0.500000],
    [-0.838671, -0.374607, 0.981627, -0.190809, -0.927184, 0.544639],
    [-0.809017, -0.406737, 0.978148, -0.207912, -0.913545, 0.587785],
    [-0.777146, -0.438371, 0.974370, -0.224951, -0.898794, 0.629320],
    [-0.743145, -0.469472, 0.970296, -0.241922, -0.882948, 0.669131],
    [-0.707107, -0.500000, 0.965926, -0.258819, -0.866025, 0.707107],
    [-0.669131, -0.529919, 0.961262, -0.275637, -0.848048, 0.743145],
    [-0.629320, -0.559193, 0.956305, -0.292372, -0.829038, 0.777146],
    [-0.587785, -0.587785, 0.951057, -0.309017, -0.809017, 0.809017],
    [-0.544639, -0.615661, 0.945519, -0.325568, -0.788011, 0.838671],
    [-0.500000, -0.642788, 0.939693, -0.342020, -0.766044, 0.866025],
    [-0.453990, -0.669131, 0.933580, -0.358368, -0.743145, 0.891007],
    [-0.406737, -0.694658, 0.927184, -0.374607, -0.719340, 0.913545],
    [-0.358368, -0.719340, 0.920505, -0.390731, -0.694658, 0.933580],
    [-0.309017, -0.743145, 0.913545, -0.406737, -0.669131, 0.951057],
    [-0.258819, -0.766044, 0.906308, -0.422618, -0.642788, 0.965926],
    [-0.207912, -0.788011, 0.898794, -0.438371, -0.615661, 0.978148],
    [-0.156434, -0.809017, 0.891007, -0.453990, -0.587785, 0.987688],
    [-0.104528, -0.829038, 0.882948, -0.469472, -0.559193, 0.994522],
    [-0.052336, -0.848048, 0.874620, -0.484810, -0.529919, 0.998630],
    [-0.000000, -0.866025, 0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, -0.882948, 0.857167, -0.515038, -0.469472, 0.998630],
    [0.104528, -0.898794, 0.848048, -0.529919, -0.438371, 0.994522],
    [0.156434, -0.913545, 0.838671, -0.544639, -0.406737, 0.987688],
    [0.207912, -0.927184, 0.829038, -0.559193, -0.374607, 0.978148],
    [0.258819, -0.939693, 0.819152, -0.573576, -0.342020, 0.965926],
    [0.309017, -0.951057, 0.809017, -0.587785, -0.309017, 0.951057],
    [0.358368, -0.961262, 0.798636, -0.601815, -0.275637, 0.933580],
    [0.406737, -0.970296, 0.788011, -0.615661, -0.241922, 0.913545],
    [0.453990, -0.978148, 0.777146, -0.629320, -0.207912, 0.891007],
    [0.500000, -0.984808, 0.766044, -0.642788, -0.173648, 0.866025],
    [0.544639, -0.990268, 0.754710, -0.656059, -0.139173, 0.838671],
    [0.587785, -0.994522, 0.743145, -0.669131, -0.104528, 0.809017],
    [0.629320, -0.997564, 0.731354, -0.681998, -0.069756, 0.777146],
    [0.669131, -0.999391, 0.719340, -0.694658, -0.034899, 0.743145],
    [0.707107, -1.000000, 0.707107, -0.707107, -0.000000, 0.707107],
    [0.743145, -0.999391, 0.694658, -0.719340, 0.034899, 0.669131],
    [0.777146, -0.997564, 0.681998, -0.731354, 0.069756, 0.629320],
    [0.809017, -0.994522, 0.669131, -0.743145, 0.104528, 0.587785],
    [0.838671, -0.990268, 0.656059, -0.754710, 0.139173, 0.544639],
    [0.866025, -0.984808, 0.642788, -0.766044, 0.173648, 0.500000],
    [0.891007, -0.978148, 0.629320, -0.777146, 0.207912, 0.453990],
    [0.913545, -0.970296, 0.615661, -0.788011, 0.241922, 0.406737],
    [0.933580, -0.961262, 0.601815, -0.798636, 0.275637, 0.358368],
    [0.951057, -0.951057, 0.587785, -0.809017, 0.309017, 0.309017],
    [0.965926, -0.939693, 0.573576, -0.819152, 0.342020, 0.258819],
    [0.978148, -0.927184, 0.559193, -0.829038, 0.374607, 0.207912],
    [0.987688, -0.913545, 0.544639, -0.838671, 0.406737, 0.156434],
    [0.994522, -0.898794, 0.529919, -0.848048, 0.438371, 0.104528],
    [0.998630, -0.882948, 0.515038, -0.857167, 0.469472, 0.052336],
    [1.000000, -0.866025, 0.500000, -0.866025, 0.500000, 0.000000],
    [0.998630, -0.848048, 0.484810, -0.874620, 0.529919, -0.052336],
    [0.994522, -0.829038, 0.469472, -0.882948, 0.559193, -0.104528],
    [0.987688, -0.809017, 0.453990, -0.891007, 0.587785, -0.156434],
    [0.978148, -0.788011, 0.438371, -0.898794, 0.615661, -0.207912],
    [0.965926, -0.766044, 0.422618, -0.906308, 0.642788, -0.258819],
    [0.951057, -0.743145, 0.406737, -0.913545, 0.669131, -0.309017],
    [0.933580, -0.719340, 0.390731, -0.920505, 0.694658, -0.358368],
    [0.913545, -0.694658, 0.374607, -0.927184, 0.719340, -0.406737],
    [0.891007, -0.669131, 0.358368, -0.933580, 0.743145, -0.453990],
    [0.866025, -0.642788, 0.342020, -0.939693, 0.766044, -0.500000],
    [0.838671, -0.615661, 0.325568, -0.945519, 0.788011, -0.544639],
    [0.809017, -0.587785, 0.309017, -0.951057, 0.809017, -0.587785],
    [0.777146, -0.559193, 0.292372, -0.956305, 0.829038, -0.629320],
    [0.743145, -0.529919, 0.275637, -0.961262, 0.848048, -0.669131],
    [0.707107, -0.500000, 0.258819, -0.965926, 0.866025, -0.707107],
    [0.669131, -0.469472, 0.241922, -0.970296, 0.882948, -0.743145],
    [0.629320, -0.438371, 0.224951, -0.974370, 0.898794, -0.777146],
    [0.587785, -0.406737, 0.207912, -0.978148, 0.913545, -0.809017],
    [0.544639, -0.374607, 0.190809, -0.981627, 0.927184, -0.838671],
    [0.500000, -0.342020, 0.173648, -0.984808, 0.939693, -0.866025],
    [0.453990, -0.309017, 0.156434, -0.987688, 0.951057, -0.891007],
    [0.406737, -0.275637, 0.139173, -0.990268, 0.961262, -0.913545],
    [0.358368, -0.241922, 0.121869, -0.992546, 0.970296, -0.933580],
    [0.309017, -0.207912, 0.104528, -0.994522, 0.978148, -0.951057],
    [0.258819, -0.173648, 0.087156, -0.996195, 0.984808, -0.965926],
    [0.207912, -0.139173, 0.069756, -0.997564, 0.990268, -0.978148],
    [0.156434, -0.104528, 0.052336, -0.998630, 0.994522, -0.987688],
    [0.104528, -0.069756, 0.034899, -0.999391, 0.997564, -0.994522],
    [0.052336, -0.034899, 0.017452, -0.999848, 0.999391, -0.998630],
    [0.000000, -0.000000, 0.000000, -1.000000, 1.000000, -1.000000],
    [-0.052336, 0.034899, -0.017452, -0.999848, 0.999391, -0.998630],
    [-0.104528, 0.069756, -0.034899, -0.999391, 0.997564, -0.994522],
    [-0.156434, 0.104528, -0.052336, -0.998630, 0.994522, -0.987688],
    [-0.207912, 0.139173, -0.069756, -0.997564, 0.990268, -0.978148],
    [-0.258819, 0.173648, -0.087156, -0.996195, 0.984808, -0.965926],
    [-0.309017, 0.207912, -0.104528, -0.994522, 0.978148, -0.951057],
    [-0.358368, 0.241922, -0.121869, -0.992546, 0.970296, -0.933580],
    [-0.406737, 0.275637, -0.139173, -0.990268, 0.961262, -0.913545],
    [-0.453990, 0.309017, -0.156434, -0.987688, 0.951057, -0.891007],
    [-0.500000, 0.342020, -0.173648, -0.984808, 0.939693, -0.866025],
    [-0.544639, 0.374607, -0.190809, -0.981627, 0.927184, -0.838671],
    [-0.587785, 0.406737, -0.207912, -0.978148, 0.913545, -0.809017],
    [-0.629320, 0.438371, -0.224951, -0.974370, 0.898794, -0.777146],
    [-0.669131, 0.469472, -0.241922, -0.970296, 0.882948, -0.743145],
    [-0.707107, 0.500000, -0.258819, -0.965926, 0.866025, -0.707107],
    [-0.743145, 0.529919, -0.275637, -0.961262, 0.848048, -0.669131],
    [-0.777146, 0.559193, -0.292372, -0.956305, 0.829038, -0.629320],
    [-0.809017, 0.587785, -0.309017, -0.951057, 0.809017, -0.587785],
    [-0.838671, 0.615661, -0.325568, -0.945519, 0.788011, -0.544639],
    [-0.866025, 0.642788, -0.342020, -0.939693, 0.766044, -0.500000],
    [-0.891007, 0.669131, -0.358368, -0.933580, 0.743145, -0.453990],
    [-0.913545, 0.694658, -0.374607, -0.927184, 0.719340, -0.406737],
    [-0.933580, 0.719340, -0.390731, -0.920505, 0.694658, -0.358368],
    [-0.951057, 0.743145, -0.406737, -0.913545, 0.669131, -0.309017],
    [-0.965926, 0.766044, -0.422618, -0.906308, 0.642788, -0.258819],
    [-0.978148, 0.788011, -0.438371, -0.898794, 0.615661, -0.207912],
    [-0.987688, 0.809017, -0.453990, -0.891007, 0.587785, -0.156434],
    [-0.994522, 0.829038, -0.469472, -0.882948, 0.559193, -0.104528],
    [-0.998630, 0.848048, -0.484810, -0.874620, 0.529919, -0.052336],
    [-1.000000, 0.866025, -0.500000, -0.866025, 0.500000, 0.000000],
    [-0.998630, 0.882948, -0.515038, -0.857167, 0.469472, 0.052336],
    [-0.994522, 0.898794, -0.529919, -0.848048, 0.438371, 0.104528],
    [-0.987688, 0.913545, -0.544639, -0.838671, 0.406737, 0.156434],
    [-0.978148, 0.927184, -0.559193, -0.829038, 0.374607, 0.207912],
    [-0.965926, 0.939693, -0.573576, -0.819152, 0.342020, 0.258819],
    [-0.951057, 0.951057, -0.587785, -0.809017, 0.309017, 0.309017],
    [-0.933580, 0.961262, -0.601815, -0.798636, 0.275637, 0.358368],
    [-0.913545, 0.970296, -0.615661, -0.788011, 0.241922, 0.406737],
    [-0.891007, 0.978148, -0.629320, -0.777146, 0.207912, 0.453990],
    [-0.866025, 0.984808, -0.642788, -0.766044, 0.173648, 0.500000],
    [-0.838671, 0.990268, -0.656059, -0.754710, 0.139173, 0.544639],
    [-0.809017, 0.994522, -0.669131, -0.743145, 0.104528, 0.587785],
    [-0.777146, 0.997564, -0.681998, -0.731354, 0.069756, 0.629320],
    [-0.743145, 0.999391, -0.694658, -0.719340, 0.034899, 0.669131],
    [-0.707107, 1.000000, -0.707107, -0.707107, 0.000000, 0.707107],
    [-0.669131, 0.999391, -0.719340, -0.694658, -0.034899, 0.743145],
    [-0.629320, 0.997564, -0.731354, -0.681998, -0.069756, 0.777146],
    [-0.587785, 0.994522, -0.743145, -0.669131, -0.104528, 0.809017],
    [-0.544639, 0.990268, -0.754710, -0.656059, -0.139173, 0.838671],
    [-0.500000, 0.984808, -0.766044, -0.642788, -0.173648, 0.866025],
    [-0.453990, 0.978148, -0.777146, -0.629320, -0.207912, 0.891007],
    [-0.406737, 0.970296, -0.788011, -0.615661, -0.241922, 0.913545],
    [-0.358368, 0.961262, -0.798636, -0.601815, -0.275637, 0.933580],
    [-0.309017, 0.951057, -0.809017, -0.587785, -0.309017, 0.951057],
    [-0.258819, 0.939693, -0.819152, -0.573576, -0.342020, 0.965926],
    [-0.207912, 0.927184, -0.829038, -0.559193, -0.374607, 0.978148],
    [-0.156434, 0.913545, -0.838671, -0.544639, -0.406737, 0.987688],
    [-0.104528, 0.898794, -0.848048, -0.529919, -0.438371, 0.994522],
    [-0.052336, 0.882948, -0.857167, -0.515038, -0.469472, 0.998630],
    [-0.000000, 0.866025, -0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, 0.848048, -0.874620, -0.484810, -0.529919, 0.998630],
    [0.104528, 0.829038, -0.882948, -0.469472, -0.559193, 0.994522],
    [0.156434, 0.809017, -0.891007, -0.453990, -0.587785, 0.987688],
    [0.207912, 0.788011, -0.898794, -0.438371, -0.615661, 0.978148],
    [0.258819, 0.766044, -0.906308, -0.422618, -0.642788, 0.965926],
    [0.309017, 0.743145, -0.913545, -0.406737, -0.669131, 0.951057],
    [0.358368, 0.719340, -0.920505, -0.390731, -0.694658, 0.933580],
    [0.406737, 0.694658, -0.927184, -0.374607, -0.719340, 0.913545],
    [0.453990, 0.669131, -0.933580, -0.358368, -0.743145, 0.891007],
    [0.500000, 0.642788, -0.939693, -0.342020, -0.766044, 0.866025],
    [0.544639, 0.615661, -0.945519, -0.325568, -0.788011, 0.838671],
    [0.587785, 0.587785, -0.951057, -0.309017, -0.809017, 0.809017],
    [0.629320, 0.559193, -0.956305, -0.292372, -0.829038, 0.777146],
    [0.669131, 0.529919, -0.961262, -0.275637, -0.848048, 0.743145],
    [0.707107, 0.500000, -0.965926, -0.258819, -0.866025, 0.707107],
    [0.743145, 0.469472, -0.970296, -0.241922, -0.882948, 0.669131],
    [0.777146, 0.438371, -0.974370, -0.224951, -0.898794, 0.629320],
    [0.809017, 0.406737, -0.978148, -0.207912, -0.913545, 0.587785],
    [0.838671, 0.374607, -0.981627, -0.190809, -0.927184, 0.544639],
    [0.866025, 0.342020, -0.984808, -0.173648, -0.939693, 0.500000],
    [0.891007, 0.309017, -0.987688, -0.156434, -0.951057, 0.453990],
    [0.913545, 0.275637, -0.990268, -0.139173, -0.961262, 0.406737],
    [0.933580, 0.241922, -0.992546, -0.121869, -0.970296, 0.358368],
    [0.951057, 0.207912, -0.994522, -0.104528, -0.978148, 0.309017],
    [0.965926, 0.173648, -0.996195, -0.087156, -0.984808, 0.258819],
    [0.978148, 0.139173, -0.997564, -0.069756, -0.990268, 0.207912],
    [0.987688, 0.104528, -0.998630, -0.052336, -0.994522, 0.156434],
    [0.994522, 0.069756, -0.999391, -0.034899, -0.997564, 0.104528],
    [0.998630, 0.034899, -0.999848, -0.017452, -0.999391, 0.052336],
    [1.000000, 0.000000, -1.000000, -0.000000, -1.000000, 0.000000],
    [0.998630, -0.034899, -0.999848, 0.017452, -0.999391, -0.052336],
    [0.994522, -0.069756, -0.999391, 0.034899, -0.997564, -0.104528],
    [0.987688, -0.104528, -0.998630, 0.052336, -0.994522, -0.156434],
    [0.978148, -0.139173, -0.997564, 0.069756, -0.990268, -0.207912],
    [0.965926, -0.173648, -0.996195, 0.087156, -0.984808, -0.258819],
    [0.951057, -0.207912, -0.994522, 0.104528, -0.978148, -0.309017],
    [0.933580, -0.241922, -0.992546, 0.121869, -0.970296, -0.358368],
    [0.913545, -0.275637, -0.990268, 0.139173, -0.961262, -0.406737],
    [0.891007, -0.309017, -0.987688, 0.156434, -0.951057, -0.453990],
    [0.866025, -0.342020, -0.984808, 0.173648, -0.939693, -0.500000],
    [0.838671, -0.374607, -0.981627, 0.190809, -0.927184, -0.544639],
    [0.809017, -0.406737, -0.978148, 0.207912, -0.913545, -0.587785],
    [0.777146, -0.438371, -0.974370, 0.224951, -0.898794, -0.629320],
    [0.743145, -0.469472, -0.970296, 0.241922, -0.882948, -0.669131],
    [0.707107, -0.500000, -0.965926, 0.258819, -0.866025, -0.707107],
    [0.669131, -0.529919, -0.961262, 0.275637, -0.848048, -0.743145],
    [0.629320, -0.559193, -0.956305, 0.292372, -0.829038, -0.777146],
    [0.587785, -0.587785, -0.951057, 0.309017, -0.809017, -0.809017],
    [0.544639, -0.615661, -0.945519, 0.325568, -0.788011, -0.838671],
    [0.500000, -0.642788, -0.939693, 0.342020, -0.766044, -0.866025],
    [0.453990, -0.669131, -0.933580, 0.358368, -0.743145, -0.891007],
    [0.406737, -0.694658, -0.927184, 0.374607, -0.719340, -0.913545],
    [0.358368, -0.719340, -0.920505, 0.390731, -0.694658, -0.933580],
    [0.309017, -0.743145, -0.913545, 0.406737, -0.669131, -0.951057],
    [0.258819, -0.766044, -0.906308, 0.422618, -0.642788, -0.965926],
    [0.207912, -0.788011, -0.898794, 0.438371, -0.615661, -0.978148],
    [0.156434, -0.809017, -0.891007, 0.453990, -0.587785, -0.987688],
    [0.104528, -0.829038, -0.882948, 0.469472, -0.559193, -0.994522],
    [0.052336, -0.848048, -0.874620, 0.484810, -0.529919, -0.998630],
    [0.000000, -0.866025, -0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, -0.882948, -0.857167, 0.515038, -0.469472, -0.998630],
    [-0.104528, -0.898794, -0.848048, 0.529919, -0.438371, -0.994522],
    [-0.156434, -0.913545, -0.838671, 0.544639, -0.406737, -0.987688],
    [-0.207912, -0.927184, -0.829038, 0.559193, -0.374607, -0.978148],
    [-0.258819, -0.939693, -0.819152, 0.573576, -0.342020, -0.965926],
    [-0.309017, -0.951057, -0.809017, 0.587785, -0.309017, -0.951057],
    [-0.358368, -0.961262, -0.798636, 0.601815, -0.275637, -0.933580],
    [-0.406737, -0.970296, -0.788011, 0.615661, -0.241922, -0.913545],
    [-0.453990, -0.978148, -0.777146, 0.629320, -0.207912, -0.891007],
    [-0.500000, -0.984808, -0.766044, 0.642788, -0.173648, -0.866025],
    [-0.544639, -0.990268, -0.754710, 0.656059, -0.139173, -0.838671],
    [-0.587785, -0.994522, -0.743145, 0.669131, -0.104528, -0.809017],
    [-0.629320, -0.997564, -0.731354, 0.681998, -0.069756, -0.777146],
    [-0.669131, -0.999391, -0.719340, 0.694658, -0.034899, -0.743145],
    [-0.707107, -1.000000, -0.707107, 0.707107, -0.000000, -0.707107],
    [-0.743145, -0.999391, -0.694658, 0.719340, 0.034899, -0.669131],
    [-0.777146, -0.997564, -0.681998, 0.731354, 0.069756, -0.629320],
    [-0.809017, -0.994522, -0.669131, 0.743145, 0.104528, -0.587785],
    [-0.838671, -0.990268, -0.656059, 0.754710, 0.139173, -0.544639],
    [-0.866025, -0.984808, -0.642788, 0.766044, 0.173648, -0.500000],
    [-0.891007, -0.978148, -0.629320, 0.777146, 0.207912, -0.453990],
    [-0.913545, -0.970296, -0.615661, 0.788011, 0.241922, -0.406737],
    [-0.933580, -0.961262, -0.601815, 0.798636, 0.275637, -0.358368],
    [-0.951057, -0.951057, -0.587785, 0.809017, 0.309017, -0.309017],
    [-0.965926, -0.939693, -0.573576, 0.819152, 0.342020, -0.258819],
    [-0.978148, -0.927184, -0.559193, 0.829038, 0.374607, -0.207912],
    [-0.987688, -0.913545, -0.544639, 0.838671, 0.406737, -0.156434],
    [-0.994522, -0.898794, -0.529919, 0.848048, 0.438371, -0.104528],
    [-0.998630, -0.882948, -0.515038, 0.857167, 0.469472, -0.052336],
    [-1.000000, -0.866025, -0.500000, 0.866025, 0.500000, -0.000000],
    [-0.998630, -0.848048, -0.484810, 0.874620, 0.529919, 0.052336],
    [-0.994522, -0.829038, -0.469472, 0.882948, 0.559193, 0.104528],
    [-0.987688, -0.809017, -0.453990, 0.891007, 0.587785, 0.156434],
    [-0.978148, -0.788011, -0.438371, 0.898794, 0.615661, 0.207912],
    [-0.965926, -0.766044, -0.422618, 0.906308, 0.642788, 0.258819],
    [-0.951057, -0.743145, -0.406737, 0.913545, 0.669131, 0.309017],
    [-0.933580, -0.719340, -0.390731, 0.920505, 0.694658, 0.358368],
    [-0.913545, -0.694658, -0.374607, 0.927184, 0.719340, 0.406737],
    [-0.891007, -0.669131, -0.358368, 0.933580, 0.743145, 0.453990],
    [-0.866025, -0.642788, -0.342020, 0.939693, 0.766044, 0.500000],
    [-0.838671, -0.615661, -0.325568, 0.945519, 0.788011, 0.544639],
    [-0.809017, -0.587785, -0.309017, 0.951057, 0.809017, 0.587785],
    [-0.777146, -0.559193, -0.292372, 0.956305, 0.829038, 0.629320],
    [-0.743145, -0.529919, -0.275637, 0.961262, 0.848048, 0.669131],
    [-0.707107, -0.500000, -0.258819, 0.965926, 0.866025, 0.707107],
    [-0.669131, -0.469472, -0.241922, 0.970296, 0.882948, 0.743145],
    [-0.629320, -0.438371, -0.224951, 0.974370, 0.898794, 0.777146],
    [-0.587785, -0.406737, -0.207912, 0.978148, 0.913545, 0.809017],
    [-0.544639, -0.374607, -0.190809, 0.981627, 0.927184, 0.838671],
    [-0.500000, -0.342020, -0.173648, 0.984808, 0.939693, 0.866025],
    [-0.453990, -0.309017, -0.156434, 0.987688, 0.951057, 0.891007],
    [-0.406737, -0.275637, -0.139173, 0.990268, 0.961262, 0.913545],
    [-0.358368, -0.241922, -0.121869, 0.992546, 0.970296, 0.933580],
    [-0.309017, -0.207912, -0.104528, 0.994522, 0.978148, 0.951057],
    [-0.258819, -0.173648, -0.087156, 0.996195, 0.984808, 0.965926],
    [-0.207912, -0.139173, -0.069756, 0.997564, 0.990268, 0.978148],
    [-0.156434, -0.104528, -0.052336, 0.998630, 0.994522, 0.987688],
    [-0.104528, -0.069756, -0.034899, 0.999391, 0.997564, 0.994522],
    [-0.052336, -0.034899, -0.017452, 0.999848, 0.999391, 0.998630],
  ],
  [
    [-1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     -1.000000, -0.000000, 0.000000, -0.000000],
    [-0.999848, 0.017452, 0.999543, -0.030224, 0.000264,
     -0.999086, 0.042733, -0.000590, 0.000004],
    [-0.999391, 0.034899, 0.998173, -0.060411, 0.001055,
     -0.996348, 0.085356, -0.002357, 0.000034],
    [-0.998630, 0.052336, 0.995891, -0.090524, 0.002372,
     -0.991791, 0.127757, -0.005297, 0.000113],
    [-0.997564, 0.069756, 0.992701, -0.120527, 0.004214,
     -0.985429, 0.169828, -0.009400, 0.000268],
    [-0.996195, 0.087156, 0.988606, -0.150384, 0.006578,
     -0.977277, 0.211460, -0.014654, 0.000523],
    [-0.994522, 0.104528, 0.983611, -0.180057, 0.009462,
     -0.967356, 0.252544, -0.021043, 0.000903],
    [-0.992546, 0.121869, 0.977722, -0.209511, 0.012862,
     -0.955693, 0.292976, -0.028547, 0.001431],
    [-0.990268, 0.139173, 0.970946, -0.238709, 0.016774,
     -0.942316, 0.332649, -0.037143, 0.002131],
    [-0.987688, 0.156434, 0.963292, -0.267617, 0.021193,
     -0.927262, 0.371463, -0.046806, 0.003026],
    [-0.984808, 0.173648, 0.954769, -0.296198, 0.026114,
     -0.910569, 0.409317, -0.057505, 0.004140],
    [-0.981627, 0.190809, 0.945388, -0.324419, 0.031530,
     -0.892279, 0.446114, -0.069209, 0.005492],
    [-0.978148, 0.207912, 0.935159, -0.352244, 0.037436,
     -0.872441, 0.481759, -0.081880, 0.007105],
    [-0.974370, 0.224951, 0.924096, -0.379641, 0.043823,
     -0.851105, 0.516162, -0.095481, 0.008999],
    [-0.970296, 0.241922, 0.912211, -0.406574, 0.050685,
     -0.828326, 0.549233, -0.109969, 0.011193],
    [-0.965926, 0.258819, 0.899519, -0.433013, 0.058013,
     -0.804164, 0.580889, -0.125300, 0.013707],
    [-0.961262, 0.275637, 0.886036, -0.458924, 0.065797,
     -0.778680, 0.611050, -0.141427, 0.016556],
    [-0.956305, 0.292372, 0.871778, -0.484275, 0.074029,
     -0.751940, 0.639639, -0.158301, 0.019758],
    [-0.951057, 0.309017, 0.856763, -0.509037, 0.082698,
     -0.724012, 0.666583, -0.175868, 0.023329],
    [-0.945519, 0.325568, 0.841008, -0.533178, 0.091794,
     -0.694969, 0.691816, -0.194075, 0.027281],
    [-0.939693, 0.342020, 0.824533, -0.556670, 0.101306,
     -0.664885, 0.715274, -0.212865, 0.031630],
    [-0.933580, 0.358368, 0.807359, -0.579484, 0.111222,
     -0.633837, 0.736898, -0.232180, 0.036385],
    [-0.927184, 0.374607, 0.789505, -0.601592, 0.121529,
     -0.601904, 0.756637, -0.251960, 0.041559],
    [-0.920505, 0.390731, 0.770994, -0.622967, 0.132217,
     -0.569169, 0.774442, -0.272143, 0.047160],
    [-0.913545, 0.406737, 0.751848, -0.643582, 0.143271,
     -0.535715, 0.790270, -0.292666, 0.053196],
    [-0.906308, 0.422618, 0.732091, -0.663414, 0.154678,
     -0.501627, 0.804083, -0.313464, 0.059674],
    [-0.898794, 0.438371, 0.711746, -0.682437, 0.166423,
     -0.466993, 0.815850, -0.334472, 0.066599],
    [-0.891007, 0.453990, 0.690839, -0.700629, 0.178494,
     -0.431899, 0.825544, -0.355623, 0.073974],
    [-0.882948, 0.469472, 0.669395, -0.717968, 0.190875,
     -0.396436, 0.833145, -0.376851, 0.081803],
    [-0.874620, 0.484810, 0.647439, -0.734431, 0.203551,
     -0.360692, 0.838638, -0.398086, 0.090085],
    [-0.866025, 0.500000, 0.625000, -0.750000, 0.216506,
     -0.324760, 0.842012, -0.419263, 0.098821],
    [-0.857167, 0.515038, 0.602104, -0.764655, 0.229726,
     -0.288728, 0.843265, -0.440311, 0.108009],
    [-0.848048, 0.529919, 0.578778, -0.778378, 0.243192,
     -0.252688, 0.842399, -0.461164, 0.117644],
    [-0.838671, 0.544639, 0.555052, -0.791154, 0.256891,
     -0.216730, 0.839422, -0.481753, 0.127722],
    [-0.829038, 0.559193, 0.530955, -0.802965, 0.270803,
     -0.180944, 0.834347, -0.502011, 0.138237],
    [-0.819152, 0.573576, 0.506515, -0.813798, 0.284914,
     -0.145420, 0.827194, -0.521871, 0.149181],
    [-0.809017, 0.587785, 0.481763, -0.823639, 0.299204,
     -0.110246, 0.817987, -0.541266, 0.160545],
    [-0.798636, 0.601815, 0.456728, -0.832477, 0.313658,
     -0.075508, 0.806757, -0.560132, 0.172317],
    [-0.788011, 0.615661, 0.431441, -0.840301, 0.328257,
     -0.041294, 0.793541, -0.578405, 0.184487],
    [-0.777146, 0.629320, 0.405934, -0.847101, 0.342984,
     -0.007686, 0.778379, -0.596021, 0.197040],
    [-0.766044, 0.642788, 0.380236, -0.852869, 0.357821,
     0.025233, 0.761319, -0.612921, 0.209963],
    [-0.754710, 0.656059, 0.354380, -0.857597, 0.372749,
     0.057383, 0.742412, -0.629044, 0.223238],
    [-0.743145, 0.669131, 0.328396, -0.861281, 0.387751,
     0.088686, 0.721714, -0.644334, 0.236850],
    [-0.731354, 0.681998, 0.302317, -0.863916, 0.402807,
     0.119068, 0.699288, -0.658734, 0.250778],
    [-0.719340, 0.694658, 0.276175, -0.865498, 0.417901,
     0.148454, 0.675199, -0.672190, 0.265005],
    [-0.707107, 0.707107, 0.250000, -0.866025, 0.433013,
     0.176777, 0.649519, -0.684653, 0.279508],
    [-0.694658, 0.719340, 0.223825, -0.865498, 0.448125,
     0.203969, 0.622322, -0.696073, 0.294267],
    [-0.681998, 0.731354, 0.197683, -0.863916, 0.463218,
     0.229967, 0.593688, -0.706405, 0.309259],
    [-0.669131, 0.743145, 0.171604, -0.861281, 0.478275,
     0.254712, 0.563700, -0.715605, 0.324459],
    [-0.656059, 0.754710, 0.145620, -0.857597, 0.493276,
     0.278147, 0.532443, -0.723633, 0.339844],
    [-0.642788, 0.766044, 0.119764, -0.852869, 0.508205,
     0.300221, 0.500009, -0.730451, 0.355387],
    [-0.629320, 0.777146, 0.094066, -0.847101, 0.523041,
     0.320884, 0.466490, -0.736025, 0.371063],
    [-0.615661, 0.788011, 0.068559, -0.840301, 0.537768,
     0.340093, 0.431982, -0.740324, 0.386845],
    [-0.601815, 0.798636, 0.043272, -0.832477, 0.552367,
     0.357807, 0.396584, -0.743320, 0.402704],
    [-0.587785, 0.809017, 0.018237, -0.823639, 0.566821,
     0.373991, 0.360397, -0.744989, 0.418613],
    [-0.573576, 0.819152, -0.006515, -0.813798, 0.581112,
     0.388612, 0.323524, -0.745308, 0.434544],
    [-0.559193, 0.829038, -0.030955, -0.802965, 0.595222,
     0.401645, 0.286069, -0.744262, 0.450467],
    [-0.544639, 0.838671, -0.055052, -0.791154, 0.609135,
     0.413066, 0.248140, -0.741835, 0.466352],
    [-0.529919, 0.848048, -0.078778, -0.778378, 0.622833,
     0.422856, 0.209843, -0.738017, 0.482171],
    [-0.515038, 0.857167, -0.102104, -0.764655, 0.636300,
     0.431004, 0.171288, -0.732801, 0.497894],
    [-0.500000, 0.866025, -0.125000, -0.750000, 0.649519,
     0.437500, 0.132583, -0.726184, 0.513490],
    [-0.484810, 0.874620, -0.147439, -0.734431, 0.662474,
     0.442340, 0.093837, -0.718167, 0.528929],
    [-0.469472, 0.882948, -0.169395, -0.717968, 0.675150,
     0.445524, 0.055160, -0.708753, 0.544183],
    [-0.453990, 0.891007, -0.190839, -0.700629, 0.687531,
     0.447059, 0.016662, -0.697950, 0.559220],
    [-0.438371, 0.898794, -0.211746, -0.682437, 0.699602,
     0.446953, -0.021550, -0.685769, 0.574011],
    [-0.422618, 0.906308, -0.232091, -0.663414, 0.711348,
     0.445222, -0.059368, -0.672226, 0.588528],
    [-0.406737, 0.913545, -0.251848, -0.643582, 0.722755,
     0.441884, -0.096684, -0.657339, 0.602741],
    [-0.390731, 0.920505, -0.270994, -0.622967, 0.733809,
     0.436964, -0.133395, -0.641130, 0.616621],
    [-0.374607, 0.927184, -0.289505, -0.601592, 0.744496,
     0.430488, -0.169397, -0.623624, 0.630141],
    [-0.358368, 0.933580, -0.307359, -0.579484, 0.754804,
     0.422491, -0.204589, -0.604851, 0.643273],
    [-0.342020, 0.939693, -0.324533, -0.556670, 0.764720,
     0.413008, -0.238872, -0.584843, 0.655990],
    [-0.325568, 0.945519, -0.341008, -0.533178, 0.774231,
     0.402081, -0.272150, -0.563635, 0.668267],
    [-0.309017, 0.951057, -0.356763, -0.509037, 0.783327,
     0.389754, -0.304329, -0.541266, 0.680078],
    [-0.292372, 0.956305, -0.371778, -0.484275, 0.791997,
     0.376077, -0.335319, -0.517778, 0.691399],
    [-0.275637, 0.961262, -0.386036, -0.458924, 0.800228,
     0.361102, -0.365034, -0.493216, 0.702207],
    [-0.258819, 0.965926, -0.399519, -0.433013, 0.808013,
     0.344885, -0.393389, -0.467627, 0.712478],
    [-0.241922, 0.970296, -0.412211, -0.406574, 0.815340,
     0.327486, -0.420306, -0.441061, 0.722191],
    [-0.224951, 0.974370, -0.424096, -0.379641, 0.822202,
     0.308969, -0.445709, -0.413572, 0.731327],
    [-0.207912, 0.978148, -0.435159, -0.352244, 0.828589,
     0.289399, -0.469527, -0.385215, 0.739866],
    [-0.190809, 0.981627, -0.445388, -0.324419, 0.834495,
     0.268846, -0.491693, -0.356047, 0.747790],
    [-0.173648, 0.984808, -0.454769, -0.296198, 0.839912,
     0.247382, -0.512145, -0.326129, 0.755082],
    [-0.156434, 0.987688, -0.463292, -0.267617, 0.844832,
     0.225081, -0.530827, -0.295521, 0.761728],
    [-0.139173, 0.990268, -0.470946, -0.238709, 0.849251,
     0.202020, -0.547684, -0.264287, 0.767712],
    [-0.121869, 0.992546, -0.477722, -0.209511, 0.853163,
     0.178279, -0.562672, -0.232494, 0.773023],
    [-0.104528, 0.994522, -0.483611, -0.180057, 0.856563,
     0.153937, -0.575747, -0.200207, 0.777648],
    [-0.087156, 0.996195, -0.488606, -0.150384, 0.859447,
     0.129078, -0.586872, -0.167494, 0.781579],
    [-0.069756, 0.997564, -0.492701, -0.120527, 0.861811,
     0.103786, -0.596018, -0.134426, 0.784806],
    [-0.052336, 0.998630, -0.495891, -0.090524, 0.863653,
     0.078146, -0.603158, -0.101071, 0.787324],
    [-0.034899, 0.999391, -0.498173, -0.060411, 0.864971,
     0.052243, -0.608272, -0.067500, 0.789126],
    [-0.017452, 0.999848, -0.499543, -0.030224, 0.865762,
     0.026165, -0.611347, -0.033786, 0.790208],
    [0.000000, 1.000000, -0.500000, 0.000000, 0.866025,
     -0.000000, -0.612372, 0.000000, 0.790569],
    [0.017452, 0.999848, -0.499543, 0.030224, 0.865762,
     -0.026165, -0.611347, 0.033786, 0.790208],
    [0.034899, 0.999391, -0.498173, 0.060411, 0.864971,
     -0.052243, -0.608272, 0.067500, 0.789126],
    [0.052336, 0.998630, -0.495891, 0.090524, 0.863653,
     -0.078146, -0.603158, 0.101071, 0.787324],
    [0.069756, 0.997564, -0.492701, 0.120527, 0.861811,
     -0.103786, -0.596018, 0.134426, 0.784806],
    [0.087156, 0.996195, -0.488606, 0.150384, 0.859447,
     -0.129078, -0.586872, 0.167494, 0.781579],
    [0.104528, 0.994522, -0.483611, 0.180057, 0.856563,
     -0.153937, -0.575747, 0.200207, 0.777648],
    [0.121869, 0.992546, -0.477722, 0.209511, 0.853163,
     -0.178279, -0.562672, 0.232494, 0.773023],
    [0.139173, 0.990268, -0.470946, 0.238709, 0.849251,
     -0.202020, -0.547684, 0.264287, 0.767712],
    [0.156434, 0.987688, -0.463292, 0.267617, 0.844832,
     -0.225081, -0.530827, 0.295521, 0.761728],
    [0.173648, 0.984808, -0.454769, 0.296198, 0.839912,
     -0.247382, -0.512145, 0.326129, 0.755082],
    [0.190809, 0.981627, -0.445388, 0.324419, 0.834495,
     -0.268846, -0.491693, 0.356047, 0.747790],
    [0.207912, 0.978148, -0.435159, 0.352244, 0.828589,
     -0.289399, -0.469527, 0.385215, 0.739866],
    [0.224951, 0.974370, -0.424096, 0.379641, 0.822202,
     -0.308969, -0.445709, 0.413572, 0.731327],
    [0.241922, 0.970296, -0.412211, 0.406574, 0.815340,
     -0.327486, -0.420306, 0.441061, 0.722191],
    [0.258819, 0.965926, -0.399519, 0.433013, 0.808013,
     -0.344885, -0.393389, 0.467627, 0.712478],
    [0.275637, 0.961262, -0.386036, 0.458924, 0.800228,
     -0.361102, -0.365034, 0.493216, 0.702207],
    [0.292372, 0.956305, -0.371778, 0.484275, 0.791997,
     -0.376077, -0.335319, 0.517778, 0.691399],
    [0.309017, 0.951057, -0.356763, 0.509037, 0.783327,
     -0.389754, -0.304329, 0.541266, 0.680078],
    [0.325568, 0.945519, -0.341008, 0.533178, 0.774231,
     -0.402081, -0.272150, 0.563635, 0.668267],
    [0.342020, 0.939693, -0.324533, 0.556670, 0.764720,
     -0.413008, -0.238872, 0.584843, 0.655990],
    [0.358368, 0.933580, -0.307359, 0.579484, 0.754804,
     -0.422491, -0.204589, 0.604851, 0.643273],
    [0.374607, 0.927184, -0.289505, 0.601592, 0.744496,
     -0.430488, -0.169397, 0.623624, 0.630141],
    [0.390731, 0.920505, -0.270994, 0.622967, 0.733809,
     -0.436964, -0.133395, 0.641130, 0.616621],
    [0.406737, 0.913545, -0.251848, 0.643582, 0.722755,
     -0.441884, -0.096684, 0.657339, 0.602741],
    [0.422618, 0.906308, -0.232091, 0.663414, 0.711348,
     -0.445222, -0.059368, 0.672226, 0.588528],
    [0.438371, 0.898794, -0.211746, 0.682437, 0.699602,
     -0.446953, -0.021550, 0.685769, 0.574011],
    [0.453990, 0.891007, -0.190839, 0.700629, 0.687531,
     -0.447059, 0.016662, 0.697950, 0.559220],
    [0.469472, 0.882948, -0.169395, 0.717968, 0.675150,
     -0.445524, 0.055160, 0.708753, 0.544183],
    [0.484810, 0.874620, -0.147439, 0.734431, 0.662474,
     -0.442340, 0.093837, 0.718167, 0.528929],
    [0.500000, 0.866025, -0.125000, 0.750000, 0.649519,
     -0.437500, 0.132583, 0.726184, 0.513490],
    [0.515038, 0.857167, -0.102104, 0.764655, 0.636300,
     -0.431004, 0.171288, 0.732801, 0.497894],
    [0.529919, 0.848048, -0.078778, 0.778378, 0.622833,
     -0.422856, 0.209843, 0.738017, 0.482171],
    [0.544639, 0.838671, -0.055052, 0.791154, 0.609135,
     -0.413066, 0.248140, 0.741835, 0.466352],
    [0.559193, 0.829038, -0.030955, 0.802965, 0.595222,
     -0.401645, 0.286069, 0.744262, 0.450467],
    [0.573576, 0.819152, -0.006515, 0.813798, 0.581112,
     -0.388612, 0.323524, 0.745308, 0.434544],
    [0.587785, 0.809017, 0.018237, 0.823639, 0.566821,
     -0.373991, 0.360397, 0.744989, 0.418613],
    [0.601815, 0.798636, 0.043272, 0.832477, 0.552367,
     -0.357807, 0.396584, 0.743320, 0.402704],
    [0.615661, 0.788011, 0.068559, 0.840301, 0.537768,
     -0.340093, 0.431982, 0.740324, 0.386845],
    [0.629320, 0.777146, 0.094066, 0.847101, 0.523041,
     -0.320884, 0.466490, 0.736025, 0.371063],
    [0.642788, 0.766044, 0.119764, 0.852869, 0.508205,
     -0.300221, 0.500009, 0.730451, 0.355387],
    [0.656059, 0.754710, 0.145620, 0.857597, 0.493276,
     -0.278147, 0.532443, 0.723633, 0.339844],
    [0.669131, 0.743145, 0.171604, 0.861281, 0.478275,
     -0.254712, 0.563700, 0.715605, 0.324459],
    [0.681998, 0.731354, 0.197683, 0.863916, 0.463218,
     -0.229967, 0.593688, 0.706405, 0.309259],
    [0.694658, 0.719340, 0.223825, 0.865498, 0.448125,
     -0.203969, 0.622322, 0.696073, 0.294267],
    [0.707107, 0.707107, 0.250000, 0.866025, 0.433013,
     -0.176777, 0.649519, 0.684653, 0.279508],
    [0.719340, 0.694658, 0.276175, 0.865498, 0.417901,
     -0.148454, 0.675199, 0.672190, 0.265005],
    [0.731354, 0.681998, 0.302317, 0.863916, 0.402807,
     -0.119068, 0.699288, 0.658734, 0.250778],
    [0.743145, 0.669131, 0.328396, 0.861281, 0.387751,
     -0.088686, 0.721714, 0.644334, 0.236850],
    [0.754710, 0.656059, 0.354380, 0.857597, 0.372749,
     -0.057383, 0.742412, 0.629044, 0.223238],
    [0.766044, 0.642788, 0.380236, 0.852869, 0.357821,
     -0.025233, 0.761319, 0.612921, 0.209963],
    [0.777146, 0.629320, 0.405934, 0.847101, 0.342984,
     0.007686, 0.778379, 0.596021, 0.197040],
    [0.788011, 0.615661, 0.431441, 0.840301, 0.328257,
     0.041294, 0.793541, 0.578405, 0.184487],
    [0.798636, 0.601815, 0.456728, 0.832477, 0.313658,
     0.075508, 0.806757, 0.560132, 0.172317],
    [0.809017, 0.587785, 0.481763, 0.823639, 0.299204,
     0.110246, 0.817987, 0.541266, 0.160545],
    [0.819152, 0.573576, 0.506515, 0.813798, 0.284914,
     0.145420, 0.827194, 0.521871, 0.149181],
    [0.829038, 0.559193, 0.530955, 0.802965, 0.270803,
     0.180944, 0.834347, 0.502011, 0.138237],
    [0.838671, 0.544639, 0.555052, 0.791154, 0.256891,
     0.216730, 0.839422, 0.481753, 0.127722],
    [0.848048, 0.529919, 0.578778, 0.778378, 0.243192,
     0.252688, 0.842399, 0.461164, 0.117644],
    [0.857167, 0.515038, 0.602104, 0.764655, 0.229726,
     0.288728, 0.843265, 0.440311, 0.108009],
    [0.866025, 0.500000, 0.625000, 0.750000, 0.216506,
     0.324760, 0.842012, 0.419263, 0.098821],
    [0.874620, 0.484810, 0.647439, 0.734431, 0.203551,
     0.360692, 0.838638, 0.398086, 0.090085],
    [0.882948, 0.469472, 0.669395, 0.717968, 0.190875,
     0.396436, 0.833145, 0.376851, 0.081803],
    [0.891007, 0.453990, 0.690839, 0.700629, 0.178494,
     0.431899, 0.825544, 0.355623, 0.073974],
    [0.898794, 0.438371, 0.711746, 0.682437, 0.166423,
     0.466993, 0.815850, 0.334472, 0.066599],
    [0.906308, 0.422618, 0.732091, 0.663414, 0.154678,
     0.501627, 0.804083, 0.313464, 0.059674],
    [0.913545, 0.406737, 0.751848, 0.643582, 0.143271,
     0.535715, 0.790270, 0.292666, 0.053196],
    [0.920505, 0.390731, 0.770994, 0.622967, 0.132217,
     0.569169, 0.774442, 0.272143, 0.047160],
    [0.927184, 0.374607, 0.789505, 0.601592, 0.121529,
     0.601904, 0.756637, 0.251960, 0.041559],
    [0.933580, 0.358368, 0.807359, 0.579484, 0.111222,
     0.633837, 0.736898, 0.232180, 0.036385],
    [0.939693, 0.342020, 0.824533, 0.556670, 0.101306,
     0.664885, 0.715274, 0.212865, 0.031630],
    [0.945519, 0.325568, 0.841008, 0.533178, 0.091794,
     0.694969, 0.691816, 0.194075, 0.027281],
    [0.951057, 0.309017, 0.856763, 0.509037, 0.082698,
     0.724012, 0.666583, 0.175868, 0.023329],
    [0.956305, 0.292372, 0.871778, 0.484275, 0.074029,
     0.751940, 0.639639, 0.158301, 0.019758],
    [0.961262, 0.275637, 0.886036, 0.458924, 0.065797,
     0.778680, 0.611050, 0.141427, 0.016556],
    [0.965926, 0.258819, 0.899519, 0.433013, 0.058013,
     0.804164, 0.580889, 0.125300, 0.013707],
    [0.970296, 0.241922, 0.912211, 0.406574, 0.050685,
     0.828326, 0.549233, 0.109969, 0.011193],
    [0.974370, 0.224951, 0.924096, 0.379641, 0.043823,
     0.851105, 0.516162, 0.095481, 0.008999],
    [0.978148, 0.207912, 0.935159, 0.352244, 0.037436,
     0.872441, 0.481759, 0.081880, 0.007105],
    [0.981627, 0.190809, 0.945388, 0.324419, 0.031530,
     0.892279, 0.446114, 0.069209, 0.005492],
    [0.984808, 0.173648, 0.954769, 0.296198, 0.026114,
     0.910569, 0.409317, 0.057505, 0.004140],
    [0.987688, 0.156434, 0.963292, 0.267617, 0.021193,
     0.927262, 0.371463, 0.046806, 0.003026],
    [0.990268, 0.139173, 0.970946, 0.238709, 0.016774,
     0.942316, 0.332649, 0.037143, 0.002131],
    [0.992546, 0.121869, 0.977722, 0.209511, 0.012862,
     0.955693, 0.292976, 0.028547, 0.001431],
    [0.994522, 0.104528, 0.983611, 0.180057, 0.009462,
     0.967356, 0.252544, 0.021043, 0.000903],
    [0.996195, 0.087156, 0.988606, 0.150384, 0.006578,
     0.977277, 0.211460, 0.014654, 0.000523],
    [0.997564, 0.069756, 0.992701, 0.120527, 0.004214,
     0.985429, 0.169828, 0.009400, 0.000268],
    [0.998630, 0.052336, 0.995891, 0.090524, 0.002372,
     0.991791, 0.127757, 0.005297, 0.000113],
    [0.999391, 0.034899, 0.998173, 0.060411, 0.001055,
     0.996348, 0.085356, 0.002357, 0.000034],
    [0.999848, 0.017452, 0.999543, 0.030224, 0.000264,
     0.999086, 0.042733, 0.000590, 0.000004],
    [1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     1.000000, -0.000000, 0.000000, -0.000000],
  ],
];


/** @type {Number} */
exports.SPHERICAL_HARMONICS_AZIMUTH_RESOLUTION =
  exports.SPHERICAL_HARMONICS[0].length;


/** @type {Number} */
exports.SPHERICAL_HARMONICS_ELEVATION_RESOLUTION =
  exports.SPHERICAL_HARMONICS[1].length;


/**
 * The maximum allowed ambisonic order.
 * @type {Number}
 */
exports.SPHERICAL_HARMONICS_MAX_ORDER =
  exports.SPHERICAL_HARMONICS[0][0].length / 2;


/**
 * Pre-computed per-band weighting coefficients for producing energy-preserving
 * Max-Re sources.
 */
exports.MAX_RE_WEIGHTS =
[
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.003236, 1.002156, 0.999152, 0.990038],
  [1.032370, 1.021194, 0.990433, 0.898572],
  [1.062694, 1.040231, 0.979161, 0.799806],
  [1.093999, 1.058954, 0.964976, 0.693603],
  [1.126003, 1.077006, 0.947526, 0.579890],
  [1.158345, 1.093982, 0.926474, 0.458690],
  [1.190590, 1.109437, 0.901512, 0.330158],
  [1.222228, 1.122890, 0.872370, 0.194621],
  [1.252684, 1.133837, 0.838839, 0.052614],
  [1.281987, 1.142358, 0.801199, 0.000000],
  [1.312073, 1.150207, 0.760839, 0.000000],
  [1.343011, 1.157424, 0.717799, 0.000000],
  [1.374649, 1.163859, 0.671999, 0.000000],
  [1.406809, 1.169354, 0.623371, 0.000000],
  [1.439286, 1.173739, 0.571868, 0.000000],
  [1.471846, 1.176837, 0.517465, 0.000000],
  [1.504226, 1.178465, 0.460174, 0.000000],
  [1.536133, 1.178438, 0.400043, 0.000000],
  [1.567253, 1.176573, 0.337165, 0.000000],
  [1.597247, 1.172695, 0.271688, 0.000000],
  [1.625766, 1.166645, 0.203815, 0.000000],
  [1.652455, 1.158285, 0.133806, 0.000000],
  [1.676966, 1.147506, 0.061983, 0.000000],
  [1.699006, 1.134261, 0.000000, 0.000000],
  [1.720224, 1.119789, 0.000000, 0.000000],
  [1.741631, 1.104810, 0.000000, 0.000000],
  [1.763183, 1.089330, 0.000000, 0.000000],
  [1.784837, 1.073356, 0.000000, 0.000000],
  [1.806548, 1.056898, 0.000000, 0.000000],
  [1.828269, 1.039968, 0.000000, 0.000000],
  [1.849952, 1.022580, 0.000000, 0.000000],
  [1.871552, 1.004752, 0.000000, 0.000000],
  [1.893018, 0.986504, 0.000000, 0.000000],
  [1.914305, 0.967857, 0.000000, 0.000000],
  [1.935366, 0.948837, 0.000000, 0.000000],
  [1.956154, 0.929471, 0.000000, 0.000000],
  [1.976625, 0.909790, 0.000000, 0.000000],
  [1.996736, 0.889823, 0.000000, 0.000000],
  [2.016448, 0.869607, 0.000000, 0.000000],
  [2.035721, 0.849175, 0.000000, 0.000000],
  [2.054522, 0.828565, 0.000000, 0.000000],
  [2.072818, 0.807816, 0.000000, 0.000000],
  [2.090581, 0.786964, 0.000000, 0.000000],
  [2.107785, 0.766051, 0.000000, 0.000000],
  [2.124411, 0.745115, 0.000000, 0.000000],
  [2.140439, 0.724196, 0.000000, 0.000000],
  [2.155856, 0.703332, 0.000000, 0.000000],
  [2.170653, 0.682561, 0.000000, 0.000000],
  [2.184823, 0.661921, 0.000000, 0.000000],
  [2.198364, 0.641445, 0.000000, 0.000000],
  [2.211275, 0.621169, 0.000000, 0.000000],
  [2.223562, 0.601125, 0.000000, 0.000000],
  [2.235230, 0.581341, 0.000000, 0.000000],
  [2.246289, 0.561847, 0.000000, 0.000000],
  [2.256751, 0.542667, 0.000000, 0.000000],
  [2.266631, 0.523826, 0.000000, 0.000000],
  [2.275943, 0.505344, 0.000000, 0.000000],
  [2.284707, 0.487239, 0.000000, 0.000000],
  [2.292939, 0.469528, 0.000000, 0.000000],
  [2.300661, 0.452225, 0.000000, 0.000000],
  [2.307892, 0.435342, 0.000000, 0.000000],
  [2.314654, 0.418888, 0.000000, 0.000000],
  [2.320969, 0.402870, 0.000000, 0.000000],
  [2.326858, 0.387294, 0.000000, 0.000000],
  [2.332343, 0.372164, 0.000000, 0.000000],
  [2.337445, 0.357481, 0.000000, 0.000000],
  [2.342186, 0.343246, 0.000000, 0.000000],
  [2.346585, 0.329458, 0.000000, 0.000000],
  [2.350664, 0.316113, 0.000000, 0.000000],
  [2.354442, 0.303208, 0.000000, 0.000000],
  [2.357937, 0.290738, 0.000000, 0.000000],
  [2.361168, 0.278698, 0.000000, 0.000000],
  [2.364152, 0.267080, 0.000000, 0.000000],
  [2.366906, 0.255878, 0.000000, 0.000000],
  [2.369446, 0.245082, 0.000000, 0.000000],
  [2.371786, 0.234685, 0.000000, 0.000000],
  [2.373940, 0.224677, 0.000000, 0.000000],
  [2.375923, 0.215048, 0.000000, 0.000000],
  [2.377745, 0.205790, 0.000000, 0.000000],
  [2.379421, 0.196891, 0.000000, 0.000000],
  [2.380959, 0.188342, 0.000000, 0.000000],
  [2.382372, 0.180132, 0.000000, 0.000000],
  [2.383667, 0.172251, 0.000000, 0.000000],
  [2.384856, 0.164689, 0.000000, 0.000000],
  [2.385945, 0.157435, 0.000000, 0.000000],
  [2.386943, 0.150479, 0.000000, 0.000000],
  [2.387857, 0.143811, 0.000000, 0.000000],
  [2.388694, 0.137421, 0.000000, 0.000000],
  [2.389460, 0.131299, 0.000000, 0.000000],
  [2.390160, 0.125435, 0.000000, 0.000000],
  [2.390801, 0.119820, 0.000000, 0.000000],
  [2.391386, 0.114445, 0.000000, 0.000000],
  [2.391921, 0.109300, 0.000000, 0.000000],
  [2.392410, 0.104376, 0.000000, 0.000000],
  [2.392857, 0.099666, 0.000000, 0.000000],
  [2.393265, 0.095160, 0.000000, 0.000000],
  [2.393637, 0.090851, 0.000000, 0.000000],
  [2.393977, 0.086731, 0.000000, 0.000000],
  [2.394288, 0.082791, 0.000000, 0.000000],
  [2.394571, 0.079025, 0.000000, 0.000000],
  [2.394829, 0.075426, 0.000000, 0.000000],
  [2.395064, 0.071986, 0.000000, 0.000000],
  [2.395279, 0.068699, 0.000000, 0.000000],
  [2.395475, 0.065558, 0.000000, 0.000000],
  [2.395653, 0.062558, 0.000000, 0.000000],
  [2.395816, 0.059693, 0.000000, 0.000000],
  [2.395964, 0.056955, 0.000000, 0.000000],
  [2.396099, 0.054341, 0.000000, 0.000000],
  [2.396222, 0.051845, 0.000000, 0.000000],
  [2.396334, 0.049462, 0.000000, 0.000000],
  [2.396436, 0.047186, 0.000000, 0.000000],
  [2.396529, 0.045013, 0.000000, 0.000000],
  [2.396613, 0.042939, 0.000000, 0.000000],
  [2.396691, 0.040959, 0.000000, 0.000000],
  [2.396761, 0.039069, 0.000000, 0.000000],
  [2.396825, 0.037266, 0.000000, 0.000000],
  [2.396883, 0.035544, 0.000000, 0.000000],
  [2.396936, 0.033901, 0.000000, 0.000000],
  [2.396984, 0.032334, 0.000000, 0.000000],
  [2.397028, 0.030838, 0.000000, 0.000000],
  [2.397068, 0.029410, 0.000000, 0.000000],
  [2.397104, 0.028048, 0.000000, 0.000000],
  [2.397137, 0.026749, 0.000000, 0.000000],
  [2.397167, 0.025509, 0.000000, 0.000000],
  [2.397194, 0.024326, 0.000000, 0.000000],
  [2.397219, 0.023198, 0.000000, 0.000000],
  [2.397242, 0.022122, 0.000000, 0.000000],
  [2.397262, 0.021095, 0.000000, 0.000000],
  [2.397281, 0.020116, 0.000000, 0.000000],
  [2.397298, 0.019181, 0.000000, 0.000000],
  [2.397314, 0.018290, 0.000000, 0.000000],
  [2.397328, 0.017441, 0.000000, 0.000000],
  [2.397341, 0.016630, 0.000000, 0.000000],
  [2.397352, 0.015857, 0.000000, 0.000000],
  [2.397363, 0.015119, 0.000000, 0.000000],
  [2.397372, 0.014416, 0.000000, 0.000000],
  [2.397381, 0.013745, 0.000000, 0.000000],
  [2.397389, 0.013106, 0.000000, 0.000000],
  [2.397396, 0.012496, 0.000000, 0.000000],
  [2.397403, 0.011914, 0.000000, 0.000000],
  [2.397409, 0.011360, 0.000000, 0.000000],
  [2.397414, 0.010831, 0.000000, 0.000000],
  [2.397419, 0.010326, 0.000000, 0.000000],
  [2.397424, 0.009845, 0.000000, 0.000000],
  [2.397428, 0.009387, 0.000000, 0.000000],
  [2.397432, 0.008949, 0.000000, 0.000000],
  [2.397435, 0.008532, 0.000000, 0.000000],
  [2.397438, 0.008135, 0.000000, 0.000000],
  [2.397441, 0.007755, 0.000000, 0.000000],
  [2.397443, 0.007394, 0.000000, 0.000000],
  [2.397446, 0.007049, 0.000000, 0.000000],
  [2.397448, 0.006721, 0.000000, 0.000000],
  [2.397450, 0.006407, 0.000000, 0.000000],
  [2.397451, 0.006108, 0.000000, 0.000000],
  [2.397453, 0.005824, 0.000000, 0.000000],
  [2.397454, 0.005552, 0.000000, 0.000000],
  [2.397456, 0.005293, 0.000000, 0.000000],
  [2.397457, 0.005046, 0.000000, 0.000000],
  [2.397458, 0.004811, 0.000000, 0.000000],
  [2.397459, 0.004586, 0.000000, 0.000000],
  [2.397460, 0.004372, 0.000000, 0.000000],
  [2.397461, 0.004168, 0.000000, 0.000000],
  [2.397461, 0.003974, 0.000000, 0.000000],
  [2.397462, 0.003788, 0.000000, 0.000000],
  [2.397463, 0.003611, 0.000000, 0.000000],
  [2.397463, 0.003443, 0.000000, 0.000000],
  [2.397464, 0.003282, 0.000000, 0.000000],
  [2.397464, 0.003129, 0.000000, 0.000000],
  [2.397465, 0.002983, 0.000000, 0.000000],
  [2.397465, 0.002844, 0.000000, 0.000000],
  [2.397465, 0.002711, 0.000000, 0.000000],
  [2.397466, 0.002584, 0.000000, 0.000000],
  [2.397466, 0.002464, 0.000000, 0.000000],
  [2.397466, 0.002349, 0.000000, 0.000000],
  [2.397466, 0.002239, 0.000000, 0.000000],
  [2.397467, 0.002135, 0.000000, 0.000000],
  [2.397467, 0.002035, 0.000000, 0.000000],
  [2.397467, 0.001940, 0.000000, 0.000000],
  [2.397467, 0.001849, 0.000000, 0.000000],
  [2.397467, 0.001763, 0.000000, 0.000000],
  [2.397467, 0.001681, 0.000000, 0.000000],
  [2.397468, 0.001602, 0.000000, 0.000000],
  [2.397468, 0.001527, 0.000000, 0.000000],
  [2.397468, 0.001456, 0.000000, 0.000000],
  [2.397468, 0.001388, 0.000000, 0.000000],
  [2.397468, 0.001323, 0.000000, 0.000000],
  [2.397468, 0.001261, 0.000000, 0.000000],
  [2.397468, 0.001202, 0.000000, 0.000000],
  [2.397468, 0.001146, 0.000000, 0.000000],
  [2.397468, 0.001093, 0.000000, 0.000000],
  [2.397468, 0.001042, 0.000000, 0.000000],
  [2.397468, 0.000993, 0.000000, 0.000000],
  [2.397468, 0.000947, 0.000000, 0.000000],
  [2.397468, 0.000902, 0.000000, 0.000000],
  [2.397468, 0.000860, 0.000000, 0.000000],
  [2.397468, 0.000820, 0.000000, 0.000000],
  [2.397469, 0.000782, 0.000000, 0.000000],
  [2.397469, 0.000745, 0.000000, 0.000000],
  [2.397469, 0.000710, 0.000000, 0.000000],
  [2.397469, 0.000677, 0.000000, 0.000000],
  [2.397469, 0.000646, 0.000000, 0.000000],
  [2.397469, 0.000616, 0.000000, 0.000000],
  [2.397469, 0.000587, 0.000000, 0.000000],
  [2.397469, 0.000559, 0.000000, 0.000000],
  [2.397469, 0.000533, 0.000000, 0.000000],
  [2.397469, 0.000508, 0.000000, 0.000000],
  [2.397469, 0.000485, 0.000000, 0.000000],
  [2.397469, 0.000462, 0.000000, 0.000000],
  [2.397469, 0.000440, 0.000000, 0.000000],
  [2.397469, 0.000420, 0.000000, 0.000000],
  [2.397469, 0.000400, 0.000000, 0.000000],
  [2.397469, 0.000381, 0.000000, 0.000000],
  [2.397469, 0.000364, 0.000000, 0.000000],
  [2.397469, 0.000347, 0.000000, 0.000000],
  [2.397469, 0.000330, 0.000000, 0.000000],
  [2.397469, 0.000315, 0.000000, 0.000000],
  [2.397469, 0.000300, 0.000000, 0.000000],
  [2.397469, 0.000286, 0.000000, 0.000000],
  [2.397469, 0.000273, 0.000000, 0.000000],
  [2.397469, 0.000260, 0.000000, 0.000000],
  [2.397469, 0.000248, 0.000000, 0.000000],
  [2.397469, 0.000236, 0.000000, 0.000000],
  [2.397469, 0.000225, 0.000000, 0.000000],
  [2.397469, 0.000215, 0.000000, 0.000000],
  [2.397469, 0.000205, 0.000000, 0.000000],
  [2.397469, 0.000195, 0.000000, 0.000000],
  [2.397469, 0.000186, 0.000000, 0.000000],
  [2.397469, 0.000177, 0.000000, 0.000000],
  [2.397469, 0.000169, 0.000000, 0.000000],
  [2.397469, 0.000161, 0.000000, 0.000000],
  [2.397469, 0.000154, 0.000000, 0.000000],
  [2.397469, 0.000147, 0.000000, 0.000000],
  [2.397469, 0.000140, 0.000000, 0.000000],
  [2.397469, 0.000133, 0.000000, 0.000000],
  [2.397469, 0.000127, 0.000000, 0.000000],
  [2.397469, 0.000121, 0.000000, 0.000000],
  [2.397469, 0.000115, 0.000000, 0.000000],
  [2.397469, 0.000110, 0.000000, 0.000000],
  [2.397469, 0.000105, 0.000000, 0.000000],
  [2.397469, 0.000100, 0.000000, 0.000000],
  [2.397469, 0.000095, 0.000000, 0.000000],
  [2.397469, 0.000091, 0.000000, 0.000000],
  [2.397469, 0.000087, 0.000000, 0.000000],
  [2.397469, 0.000083, 0.000000, 0.000000],
  [2.397469, 0.000079, 0.000000, 0.000000],
  [2.397469, 0.000075, 0.000000, 0.000000],
  [2.397469, 0.000071, 0.000000, 0.000000],
  [2.397469, 0.000068, 0.000000, 0.000000],
  [2.397469, 0.000065, 0.000000, 0.000000],
  [2.397469, 0.000062, 0.000000, 0.000000],
  [2.397469, 0.000059, 0.000000, 0.000000],
  [2.397469, 0.000056, 0.000000, 0.000000],
  [2.397469, 0.000054, 0.000000, 0.000000],
  [2.397469, 0.000051, 0.000000, 0.000000],
  [2.397469, 0.000049, 0.000000, 0.000000],
  [2.397469, 0.000046, 0.000000, 0.000000],
  [2.397469, 0.000044, 0.000000, 0.000000],
  [2.397469, 0.000042, 0.000000, 0.000000],
  [2.397469, 0.000040, 0.000000, 0.000000],
  [2.397469, 0.000038, 0.000000, 0.000000],
  [2.397469, 0.000037, 0.000000, 0.000000],
  [2.397469, 0.000035, 0.000000, 0.000000],
  [2.397469, 0.000033, 0.000000, 0.000000],
  [2.397469, 0.000032, 0.000000, 0.000000],
  [2.397469, 0.000030, 0.000000, 0.000000],
  [2.397469, 0.000029, 0.000000, 0.000000],
  [2.397469, 0.000027, 0.000000, 0.000000],
  [2.397469, 0.000026, 0.000000, 0.000000],
  [2.397469, 0.000025, 0.000000, 0.000000],
  [2.397469, 0.000024, 0.000000, 0.000000],
  [2.397469, 0.000023, 0.000000, 0.000000],
  [2.397469, 0.000022, 0.000000, 0.000000],
  [2.397469, 0.000021, 0.000000, 0.000000],
  [2.397469, 0.000020, 0.000000, 0.000000],
  [2.397469, 0.000019, 0.000000, 0.000000],
  [2.397469, 0.000018, 0.000000, 0.000000],
  [2.397469, 0.000017, 0.000000, 0.000000],
  [2.397469, 0.000016, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000014, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
];


/** @type {Number} */
exports.MAX_RE_WEIGHTS_RESOLUTION = exports.MAX_RE_WEIGHTS.length;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_88844__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Source model to spatialize an audio buffer.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Directivity = __nested_webpack_require_88844__(5);
const Attenuation = __nested_webpack_require_88844__(6);
const Encoder = __nested_webpack_require_88844__(1);
const Utils = __nested_webpack_require_88844__(0);


/**
 * @class Source
 * @description Source model to spatialize an audio buffer.
 * @param {ResonanceAudio} scene Associated {@link ResonanceAudio
 * ResonanceAudio} instance.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Source(scene, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Source
   * @instance
   */
  /**
   *
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ROLLOFF;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_SOURCE_GAIN;
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  // Member variables.
  this._scene = scene;
  this._position = options.position;
  this._forward = options.forward;
  this._up = options.up;
  this._dx = new Float32Array(3);
  this._right = Utils.crossProduct(this._forward, this._up);

  // Create audio nodes.
  let context = scene._context;
  this.input = context.createGain();
  this._directivity = new Directivity(context, {
    alpha: options.alpha,
    sharpness: options.sharpness,
  });
  this._toEarly = context.createGain();
  this._toLate = context.createGain();
  this._attenuation = new Attenuation(context, {
    minDistance: options.minDistance,
    maxDistance: options.maxDistance,
    rolloff: options.rolloff,
  });
  this._encoder = new Encoder(context, {
    ambisonicOrder: scene._ambisonicOrder,
    sourceWidth: options.sourceWidth,
  });

  // Connect nodes.
  this.input.connect(this._toLate);
  this._toLate.connect(scene._room.late.input);

  this.input.connect(this._attenuation.input);
  this._attenuation.output.connect(this._toEarly);
  this._toEarly.connect(scene._room.early.input);

  this._attenuation.output.connect(this._directivity.input);
  this._directivity.output.connect(this._encoder.input);

  this._encoder.output.connect(scene._listener.input);

  // Assign initial conditions.
  this.setPosition(
    options.position[0], options.position[1], options.position[2]);
  this.input.gain.value = options.gain;
};


/**
 * Set source's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Source.prototype.setPosition = function(x, y, z) {
  // Assign new position.
  this._position[0] = x;
  this._position[1] = y;
  this._position[2] = z;

  // Handle far-field effect.
  let distance = this._scene._room.getDistanceOutsideRoom(
    this._position[0], this._position[1], this._position[2]);
    let gain = _computeDistanceOutsideRoom(distance);
  this._toLate.gain.value = gain;
  this._toEarly.gain.value = gain;

  this._update();
};


// Update the source when changing the listener's position.
Source.prototype._update = function() {
  // Compute distance to listener.
  for (let i = 0; i < 3; i++) {
    this._dx[i] = this._position[i] - this._scene._listener.position[i];
  }
  let distance = Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[1] * this._dx[1] + this._dx[2] * this._dx[2]);
  if (distance > 0) {
    // Normalize direction vector.
    this._dx[0] /= distance;
    this._dx[1] /= distance;
    this._dx[2] /= distance;
  }

  // Compuete angle of direction vector.
  let azimuth = Math.atan2(-this._dx[0], this._dx[2]) *
    Utils.RADIANS_TO_DEGREES;
  let elevation = Math.atan2(this._dx[1], Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[2] * this._dx[2])) * Utils.RADIANS_TO_DEGREES;

  // Set distance/directivity/direction values.
  this._attenuation.setDistance(distance);
  this._directivity.computeAngle(this._forward, this._dx);
  this._encoder.setDirection(azimuth, elevation);
};


/**
 * Set source's rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Source.prototype.setRolloff = function(rolloff) {
  this._attenuation.setRolloff(rolloff);
};


/**
 * Set source's minimum distance (in meters).
 * @param {Number} minDistance
 */
Source.prototype.setMinDistance = function(minDistance) {
  this._attenuation.minDistance = minDistance;
};


/**
 * Set source's maximum distance (in meters).
 * @param {Number} maxDistance
 */
Source.prototype.setMaxDistance = function(maxDistance) {
  this._attenuation.maxDistance = maxDistance;
};


/**
 * Set source's gain (linear).
 * @param {Number} gain
 */
Source.prototype.setGain = function(gain) {
  this.input.gain.value = gain;
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Source.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
    upX, upY, upZ) {
  this._forward[0] = forwardX;
  this._forward[1] = forwardY;
  this._forward[2] = forwardZ;
  this._up[0] = upX;
  this._up[1] = upY;
  this._up[2] = upZ;
  this._right = Utils.crossProduct(this._forward, this._up);
};


// TODO(bitllama): Make sure this works with Three.js as intended.
/**
 * Set source's position and orientation using a
 * Three.js modelViewMatrix object.
 * @param {Float32Array} matrix4
 * The Matrix4 representing the object position and rotation in world space.
 */
Source.prototype.setFromMatrix = function(matrix4) {
  this._right[0] = matrix4.elements[0];
  this._right[1] = matrix4.elements[1];
  this._right[2] = matrix4.elements[2];
  this._up[0] = matrix4.elements[4];
  this._up[1] = matrix4.elements[5];
  this._up[2] = matrix4.elements[6];
  this._forward[0] = matrix4.elements[8];
  this._forward[1] = matrix4.elements[9];
  this._forward[2] = matrix4.elements[10];

  // Normalize to remove scaling.
  this._right = Utils.normalizeVector(this._right);
  this._up = Utils.normalizeVector(this._up);
  this._forward = Utils.normalizeVector(this._forward);

  // Update position.
  this.setPosition(
    matrix4.elements[12], matrix4.elements[13], matrix4.elements[14]);
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Source.prototype.setSourceWidth = function(sourceWidth) {
  this._encoder.setSourceWidth(sourceWidth);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 */
Source.prototype.setDirectivityPattern = function(alpha, sharpness) {
  this._directivity.setPattern(alpha, sharpness);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Determine the distance a source is outside of a room. Attenuate gain going
 * to the reflections and reverb when the source is outside of the room.
 * @param {Number} distance Distance in meters.
 * @return {Number} Gain (linear) of source.
 * @private
 */
function _computeDistanceOutsideRoom(distance) {
  // We apply a linear ramp from 1 to 0 as the source is up to 1m outside.
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  return gain;
}


module.exports = Source;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_99936__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Directivity/occlusion filter.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_99936__(0);


/**
 * @class Directivity
 * @description Directivity/occlusion filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.alpha
 * Determines directivity pattern (0 to 1). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
function Directivity(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Directivity
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Directivity
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }

  // Create audio node.
  this._context = context;
  this._lowpass = context.createBiquadFilter();

  // Initialize filter coefficients.
  this._lowpass.type = 'lowpass';
  this._lowpass.Q.value = 0;
  this._lowpass.frequency.value = context.sampleRate * 0.5;

  this._cosTheta = 0;
  this.setPattern(options.alpha, options.sharpness);

  // Input/Output proxy.
  this.input = this._lowpass;
  this.output = this._lowpass;
}


/**
 * Compute the filter using the source's forward orientation and the listener's
 * position.
 * @param {Float32Array} forward The source's forward vector.
 * @param {Float32Array} direction The direction from the source to the
 * listener.
 */
Directivity.prototype.computeAngle = function(forward, direction) {
  let forwardNorm = Utils.normalizeVector(forward);
  let directionNorm = Utils.normalizeVector(direction);
  let coeff = 1;
  if (this._alpha > Utils.EPSILON_FLOAT) {
    let cosTheta = forwardNorm[0] * directionNorm[0] +
      forwardNorm[1] * directionNorm[1] + forwardNorm[2] * directionNorm[2];
    coeff = (1 - this._alpha) + this._alpha * cosTheta;
    coeff = Math.pow(Math.abs(coeff), this._sharpness);
  }
  this._lowpass.frequency.value = this._context.sampleRate * 0.5 * coeff;
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponenentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
Directivity.prototype.setPattern = function(alpha, sharpness) {
  // Clamp and set values.
  this._alpha = Math.min(1, Math.max(0, alpha));
  this._sharpness = Math.max(1, sharpness);

  // Update angle calculation using new values.
  this.computeAngle([this._cosTheta * this._cosTheta, 0, 0], [1, 0, 0]);
};


module.exports = Directivity;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_104304__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Distance-based attenuation filter.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Utils = __nested_webpack_require_104304__(0);


/**
 * @class Attenuation
 * @description Distance-based attenuation filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 */
function Attenuation(context, options) {
  // Public variables.
  /**
   * Min. distance (in meters).
   * @member {Number} minDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Max. distance (in meters).
   * @member {Number} maxDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Attenuation
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  }

  // Assign values.
  this.minDistance = options.minDistance;
  this.maxDistance = options.maxDistance;
  this.setRolloff(options.rolloff);

  // Create node.
  this._gainNode = context.createGain();

  // Initialize distance to max distance.
  this.setDistance(options.maxDistance);

  // Input/Output proxy.
  this.input = this._gainNode;
  this.output = this._gainNode;
}


/**
 * Set distance from the listener.
 * @param {Number} distance Distance (in meters).
 */
Attenuation.prototype.setDistance = function(distance) {
  let gain = 1;
  if (this._rolloff == 'logarithmic') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        // Compute the distance attenuation value by the logarithmic curve
        // "1 / (d + 1)" with an offset of |minDistance|.
        let relativeDistance = distance - this.minDistance;
        let attenuation = 1 / (relativeDistance + 1);
        let attenuationMax = 1 / (range + 1);
        gain = (attenuation - attenuationMax) / (1 - attenuationMax);
      }
    }
  } else if (this._rolloff == 'linear') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        gain = (this.maxDistance - distance) / range;
      }
    }
  }
  this._gainNode.gain.value = gain;
};


/**
 * Set rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Attenuation.prototype.setRolloff = function(rolloff) {
  let isValidModel = ~Utils.ATTENUATION_ROLLOFFS.indexOf(rolloff);
  if (rolloff == undefined || !isValidModel) {
    if (!isValidModel) {
      Utils.log('Invalid rolloff model (\"' + rolloff +
        '\"). Using default: \"' + Utils.DEFAULT_ATTENUATION_ROLLOFF + '\".');
    }
    rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  } else {
    rolloff = rolloff.toString().toLowerCase();
  }
  this._rolloff = rolloff;
};


module.exports = Attenuation;


/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_109231__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Complete room model with early and late reflections.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const LateReflections = __nested_webpack_require_109231__(8);
const EarlyReflections = __nested_webpack_require_109231__(9);
const Utils = __nested_webpack_require_109231__(0);


/**
 * Generate absorption coefficients from material names.
 * @param {Object} materials
 * @return {Object}
 */
function _getCoefficientsFromMaterials(materials) {
  // Initialize coefficients to use defaults.
  let coefficients = {};
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property)) {
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }

  // Sanitize materials.
  if (materials == undefined) {
    materials = {};
    Object.assign(materials, Utils.DEFAULT_ROOM_MATERIALS);
  }

  // Assign coefficients using provided materials.
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property) &&
        materials.hasOwnProperty(property)) {
      if (materials[property] in Utils.ROOM_MATERIAL_COEFFICIENTS) {
        coefficients[property] =
          Utils.ROOM_MATERIAL_COEFFICIENTS[materials[property]];
      } else {
        Utils.log('Material \"' + materials[property] + '\" on wall \"' +
          property + '\" not found. Using \"' +
          Utils.DEFAULT_ROOM_MATERIALS[property] + '\".');
      }
    } else {
      Utils.log('Wall \"' + property + '\" is not defined. Default used.');
    }
  }
  return coefficients;
}

/**
 * Sanitize coefficients.
 * @param {Object} coefficients
 * @return {Object}
 */
function _sanitizeCoefficients(coefficients) {
  if (coefficients == undefined) {
    coefficients = {};
  }
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (!(coefficients.hasOwnProperty(property))) {
      // If element is not present, use default coefficients.
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }
  return coefficients;
}

/**
 * Sanitize dimensions.
 * @param {Object} dimensions
 * @return {Object}
 */
function _sanitizeDimensions(dimensions) {
  if (dimensions == undefined) {
    dimensions = {};
  }
  for (let property in Utils.DEFAULT_ROOM_DIMENSIONS) {
    if (!(dimensions.hasOwnProperty(property))) {
      dimensions[property] = Utils.DEFAULT_ROOM_DIMENSIONS[property];
    }
  }
  return dimensions;
}

/**
 * Compute frequency-dependent reverb durations.
 * @param {Object} dimensions
 * @param {Object} coefficients
 * @param {Number} speedOfSound
 * @return {Array}
 */
function _getDurationsFromProperties(dimensions, coefficients, speedOfSound) {
  let durations = new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);

  // Sanitize inputs.
  dimensions = _sanitizeDimensions(dimensions);
  coefficients = _sanitizeCoefficients(coefficients);
  if (speedOfSound == undefined) {
    speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Acoustic constant.
  let k = Utils.TWENTY_FOUR_LOG10 / speedOfSound;

  // Compute volume, skip if room is not present.
  let volume = dimensions.width * dimensions.height * dimensions.depth;
  if (volume < Utils.ROOM_MIN_VOLUME) {
    return durations;
  }

  // Room surface area.
  let leftRightArea = dimensions.width * dimensions.height;
  let floorCeilingArea = dimensions.width * dimensions.depth;
  let frontBackArea = dimensions.depth * dimensions.height;
  let totalArea = 2 * (leftRightArea + floorCeilingArea + frontBackArea);
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Effective absorptive area.
    let absorbtionArea =
      (coefficients.left[i] + coefficients.right[i]) * leftRightArea +
      (coefficients.down[i] + coefficients.up[i]) * floorCeilingArea +
      (coefficients.front[i] + coefficients.back[i]) * frontBackArea;
    let meanAbsorbtionArea = absorbtionArea / totalArea;

    // Compute reverberation using Eyring equation [1].
    // [1] Beranek, Leo L. "Analysis of Sabine and Eyring equations and their
    //     application to concert hall audience and chair absorption." The
    //     Journal of the Acoustical Society of America, Vol. 120, No. 3.
    //     (2006), pp. 1399-1399.
    durations[i] = Utils.ROOM_EYRING_CORRECTION_COEFFICIENT * k * volume /
      (-totalArea * Math.log(1 - meanAbsorbtionArea) + 4 *
      Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS[i] * volume);
  }
  return durations;
}


/**
 * Compute reflection coefficients from absorption coefficients.
 * @param {Object} absorptionCoefficients
 * @return {Object}
 */
function _computeReflectionCoefficients(absorptionCoefficients) {
  let reflectionCoefficients = [];
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute average absorption coefficient (per wall).
      reflectionCoefficients[property] = 0;
      for (let j = 0; j < Utils.NUMBER_REFLECTION_AVERAGING_BANDS; j++) {
        let bandIndex = j + Utils.ROOM_STARTING_AVERAGING_BAND;
        reflectionCoefficients[property] +=
          absorptionCoefficients[property][bandIndex];
      }
      reflectionCoefficients[property] /=
        Utils.NUMBER_REFLECTION_AVERAGING_BANDS;

      // Convert absorption coefficient to reflection coefficient.
      reflectionCoefficients[property] =
        Math.sqrt(1 - reflectionCoefficients[property]);
    }
  }
  return reflectionCoefficients;
}


/**
 * @class Room
 * @description Model that manages early and late reflections using acoustic
 * properties and listener position relative to a rectangular room.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function Room(context, options) {
  // Public variables.
  /**
   * EarlyReflections {@link EarlyReflections EarlyReflections} submodule.
   * @member {AudioNode} early
   * @memberof Room
   * @instance
   */
  /**
   * LateReflections {@link LateReflections LateReflections} submodule.
   * @member {AudioNode} late
   * @memberof Room
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Room
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Sanitize room-properties-related arguments.
  options.dimensions = _sanitizeDimensions(options.dimensions);
  let absorptionCoefficients = _getCoefficientsFromMaterials(options.materials);
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  let durations = _getDurationsFromProperties(options.dimensions,
    absorptionCoefficients, options.speedOfSound);

  // Construct submodules for early and late reflections.
  this.early = new EarlyReflections(context, {
    dimensions: options.dimensions,
    coefficients: reflectionCoefficients,
    speedOfSound: options.speedOfSound,
    listenerPosition: options.listenerPosition,
  });
  this.late = new LateReflections(context, {
    durations: durations,
  });

  this.speedOfSound = options.speedOfSound;

  // Construct auxillary audio nodes.
  this.output = context.createGain();
  this.early.output.connect(this.output);
  this._merger = context.createChannelMerger(4);

  this.late.output.connect(this._merger, 0, 0);
  this._merger.connect(this.output);
}


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} materials Named acoustic materials per wall. Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 */
Room.prototype.setProperties = function(dimensions, materials) {
  // Compute late response.
  let absorptionCoefficients = _getCoefficientsFromMaterials(materials);
  let durations = _getDurationsFromProperties(dimensions,
    absorptionCoefficients, this.speedOfSound);
  this.late.setDurations(durations);

  // Compute early response.
  this.early.speedOfSound = this.speedOfSound;
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  this.early.setRoomProperties(dimensions, reflectionCoefficients);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Room.prototype.setListenerPosition = function(x, y, z) {
  this.early.speedOfSound = this.speedOfSound;
  this.early.setListenerPosition(x, y, z);

  // Disable room effects if the listener is outside the room boundaries.
  let distance = this.getDistanceOutsideRoom(x, y, z);
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  this.output.gain.value = gain;
};


/**
 * Compute distance outside room of provided position (in meters).
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return {Number}
 * Distance outside room (in meters). Returns 0 if inside room.
 */
Room.prototype.getDistanceOutsideRoom = function(x, y, z) {
  let dx = Math.max(0, -this.early._halfDimensions.width - x,
    x - this.early._halfDimensions.width);
    let dy = Math.max(0, -this.early._halfDimensions.height - y,
    y - this.early._halfDimensions.height);
    let dz = Math.max(0, -this.early._halfDimensions.depth - z,
    z - this.early._halfDimensions.depth);
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};


module.exports = Room;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_120970__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Late reverberation filter for Ambisonic content.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_120970__(0);


/**
 * @class LateReflections
 * @description Late-reflections reverberation filter for Ambisonic content.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Array} options.durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * FREQUDEFAULT_REVERB_FREQUENCY_BANDSENCY_BANDS}. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_DURATIONS DEFAULT_REVERB_DURATIONS}.
 * @param {Number} options.predelay Pre-delay (in milliseconds). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_PREDELAY DEFAULT_REVERB_PREDELAY}.
 * @param {Number} options.gain Output gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_GAIN DEFAULT_REVERB_GAIN}.
 * @param {Number} options.bandwidth Bandwidth (in octaves) for each frequency
 * band. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_BANDWIDTH DEFAULT_REVERB_BANDWIDTH}.
 * @param {Number} options.tailonset Length (in milliseconds) of impulse
 * response to apply a half-Hann window. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_TAIL_ONSET DEFAULT_REVERB_TAIL_ONSET}.
 */
function LateReflections(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof LateReflections
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof LateReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.durations == undefined) {
    options.durations = Utils.DEFAULT_REVERB_DURATIONS.slice();
  }
  if (options.predelay == undefined) {
    options.predelay = Utils.DEFAULT_REVERB_PREDELAY;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_REVERB_GAIN;
  }
  if (options.bandwidth == undefined) {
    options.bandwidth = Utils.DEFAULT_REVERB_BANDWIDTH;
  }
  if (options.tailonset == undefined) {
    options.tailonset = Utils.DEFAULT_REVERB_TAIL_ONSET;
  }

  // Assign pre-computed variables.
  let delaySecs = options.predelay / 1000;
  this._bandwidthCoeff = options.bandwidth * Utils.LOG2_DIV2;
  this._tailonsetSamples = options.tailonset / 1000;

  // Create nodes.
  this._context = context;
  this.input = context.createGain();
  this._predelay = context.createDelay(delaySecs);
  this._convolver = context.createConvolver();
  this.output = context.createGain();

  // Set reverb attenuation.
  this.output.gain.value = options.gain;

  // Disable normalization.
  this._convolver.normalize = false;

  // Connect nodes.
  this.input.connect(this._predelay);
  this._predelay.connect(this._convolver);
  this._convolver.connect(this.output);

  // Compute IR using RT60 values.
  this.setDurations(options.durations);
}


/**
 * Re-compute a new impulse response by providing Multiband RT60 durations.
 * @param {Array} durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * DEFAULT_REVERB_FREQUENCY_BANDS}.
 */
LateReflections.prototype.setDurations = function(durations) {
  if (durations.length !== Utils.NUMBER_REVERB_FREQUENCY_BANDS) {
    Utils.log('Warning: invalid number of RT60 values provided to reverb.');
    return;
  }

  // Compute impulse response.
  let durationsSamples =
    new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);
    let sampleRate = this._context.sampleRate;

  for (let i = 0; i < durations.length; i++) {
    // Clamp within suitable range.
    durations[i] =
      Math.max(0, Math.min(Utils.DEFAULT_REVERB_MAX_DURATION, durations[i]));

    // Convert seconds to samples.
    durationsSamples[i] = Math.round(durations[i] * sampleRate *
      Utils.DEFAULT_REVERB_DURATION_MULTIPLIER);
  };

  // Determine max RT60 length in samples.
  let durationsSamplesMax = 0;
  for (let i = 0; i < durationsSamples.length; i++) {
    if (durationsSamples[i] > durationsSamplesMax) {
      durationsSamplesMax = durationsSamples[i];
    }
  }

  // Skip this step if there is no reverberation to compute.
  if (durationsSamplesMax < 1) {
    durationsSamplesMax = 1;
  }

  // Create impulse response buffer.
  let buffer = this._context.createBuffer(1, durationsSamplesMax, sampleRate);
  let bufferData = buffer.getChannelData(0);

  // Create noise signal (computed once, referenced in each band's routine).
  let noiseSignal = new Float32Array(durationsSamplesMax);
  for (let i = 0; i < durationsSamplesMax; i++) {
    noiseSignal[i] = Math.random() * 2 - 1;
  }

  // Compute the decay rate per-band and filter the decaying noise signal.
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Compute decay rate.
    let decayRate = -Utils.LOG1000 / durationsSamples[i];

    // Construct a standard one-zero, two-pole bandpass filter:
    // H(z) = (b0 * z^0 + b1 * z^-1 + b2 * z^-2) / (1 + a1 * z^-1 + a2 * z^-2)
    let omega = Utils.TWO_PI *
      Utils.DEFAULT_REVERB_FREQUENCY_BANDS[i] / sampleRate;
    let sinOmega = Math.sin(omega);
    let alpha = sinOmega * Math.sinh(this._bandwidthCoeff * omega / sinOmega);
    let a0CoeffReciprocal = 1 / (1 + alpha);
    let b0Coeff = alpha * a0CoeffReciprocal;
    let a1Coeff = -2 * Math.cos(omega) * a0CoeffReciprocal;
    let a2Coeff = (1 - alpha) * a0CoeffReciprocal;

    // We optimize since b2 = -b0, b1 = 0.
    // Update equation for two-pole bandpass filter:
    //   u[n] = x[n] - a1 * x[n-1] - a2 * x[n-2]
    //   y[n] = b0 * (u[n] - u[n-2])
    let um1 = 0;
    let um2 = 0;
    for (let j = 0; j < durationsSamples[i]; j++) {
      // Exponentially-decaying white noise.
      let x = noiseSignal[j] * Math.exp(decayRate * j);

      // Filter signal with bandpass filter and add to output.
      let u = x - a1Coeff * um1 - a2Coeff * um2;
      bufferData[j] += b0Coeff * (u - um2);

      // Update coefficients.
      um2 = um1;
      um1 = u;
    }
  }

  // Create and apply half of a Hann window to the beginning of the
  // impulse response.
  let halfHannLength =
    Math.round(this._tailonsetSamples);
  for (let i = 0; i < Math.min(bufferData.length, halfHannLength); i++) {
    let halfHann =
      0.5 * (1 - Math.cos(Utils.TWO_PI * i / (2 * halfHannLength - 1)));
      bufferData[i] *= halfHann;
  }
  this._convolver.buffer = buffer;
};


module.exports = LateReflections;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_128486__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Ray-tracing-based early reflections model.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_128486__(0);


/**
 * @class EarlyReflections
 * @description Ray-tracing-based early reflections model.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Object} options.dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 * @param {Number} options.speedOfSound
 * (in meters / second). Defaults to {@linkcode Utils.DEFAULT_SPEED_OF_SOUND
 * DEFAULT_SPEED_OF_SOUND}.
 * @param {Float32Array} options.listenerPosition
 * (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 */
function EarlyReflections(context, options) {
  // Public variables.
  /**
   * The room's speed of sound (in meters/second).
   * @member {Number} speedOfSound
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * First-order ambisonic (4-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof EarlyReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.coefficients == undefined) {
    options.coefficients = {};
    Object.assign(options.coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }

  // Assign room's speed of sound.
  this.speedOfSound = options.speedOfSound;

  // Create nodes.
  this.input = context.createGain();
  this.output = context.createGain();
  this._lowpass = context.createBiquadFilter();
  this._delays = {};
  this._gains = {}; // gainPerWall = (ReflectionCoeff / Attenuation)
  this._inverters = {}; // 3 of these are needed for right/back/down walls.
  this._merger = context.createChannelMerger(4); // First-order encoding only.

  // Connect audio graph for each wall reflection.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property] =
        context.createDelay(Utils.MAX_DURATION);
      this._gains[property] = context.createGain();
    }
  }
  this._inverters.right = context.createGain();
  this._inverters.down = context.createGain();
  this._inverters.back = context.createGain();

  // Initialize lowpass filter.
  this._lowpass.type = 'lowpass';
  this._lowpass.frequency.value = Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY;
  this._lowpass.Q.value = 0;

  // Initialize encoder directions, set delay times and gains to 0.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property].delayTime.value = 0;
      this._gains[property].gain.value = 0;
    }
  }

  // Initialize inverters for opposite walls ('right', 'down', 'back' only).
  this._inverters.right.gain.value = -1;
  this._inverters.down.gain.value = -1;
  this._inverters.back.gain.value = -1;

  // Connect nodes.
  this.input.connect(this._lowpass);
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._lowpass.connect(this._delays[property]);
      this._delays[property].connect(this._gains[property]);
      this._gains[property].connect(this._merger, 0, 0);
    }
  }

  // Connect gains to ambisonic channel output.
  // Left: [1 1 0 0]
  // Right: [1 -1 0 0]
  // Up: [1 0 1 0]
  // Down: [1 0 -1 0]
  // Front: [1 0 0 1]
  // Back: [1 0 0 -1]
  this._gains.left.connect(this._merger, 0, 1);

  this._gains.right.connect(this._inverters.right);
  this._inverters.right.connect(this._merger, 0, 1);

  this._gains.up.connect(this._merger, 0, 2);

  this._gains.down.connect(this._inverters.down);
  this._inverters.down.connect(this._merger, 0, 2);

  this._gains.front.connect(this._merger, 0, 3);

  this._gains.back.connect(this._inverters.back);
  this._inverters.back.connect(this._merger, 0, 3);
  this._merger.connect(this.output);

  // Initialize.
  this._listenerPosition = options.listenerPosition;
  this.setRoomProperties(options.dimensions, options.coefficients);
}


/**
 * Set the listener's position (in meters),
 * where [0,0,0] is the center of the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
EarlyReflections.prototype.setListenerPosition = function(x, y, z) {
  // Assign listener position.
  this._listenerPosition = [x, y, z];

  // Determine distances to each wall.
  let distances = {
    left: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width + x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    right: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width - x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    front: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth + z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    back: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth - z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    down: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height + y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    up: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height - y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
  };

  // Assign delay & attenuation values using distances.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute and assign delay (in seconds).
      let delayInSecs = distances[property] / this.speedOfSound;
      this._delays[property].delayTime.value = delayInSecs;

      // Compute and assign gain, uses logarithmic rolloff: "g = R / (d + 1)"
      let attenuation = this._coefficients[property] / distances[property];
      this._gains[property].gain.value = attenuation;
    }
  }
};


/**
 * Set the room's properties which determines the characteristics of
 * reflections.
 * @param {Object} dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 */
EarlyReflections.prototype.setRoomProperties = function(dimensions,
                                                        coefficients) {
  if (dimensions == undefined) {
    dimensions = {};
    Object.assign(dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (coefficients == undefined) {
    coefficients = {};
    Object.assign(coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }
  this._coefficients = coefficients;

  // Sanitize dimensions and store half-dimensions.
  this._halfDimensions = {};
  this._halfDimensions.width = dimensions.width * 0.5;
  this._halfDimensions.height = dimensions.height * 0.5;
  this._halfDimensions.depth = dimensions.depth * 0.5;

  // Update listener position with new room properties.
  this.setListenerPosition(this._listenerPosition[0],
    this._listenerPosition[1], this._listenerPosition[2]);
};


module.exports = EarlyReflections;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_137320__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Primary namespace for ResonanceAudio library.
 * @author Andrew Allen <bitllama@google.com>
 */

 


// Main module.
exports.ResonanceAudio = __nested_webpack_require_137320__(11);


// Testable Submodules.
exports.ResonanceAudio.Attenuation = __nested_webpack_require_137320__(6);
exports.ResonanceAudio.Directivity = __nested_webpack_require_137320__(5);
exports.ResonanceAudio.EarlyReflections = __nested_webpack_require_137320__(9);
exports.ResonanceAudio.Encoder = __nested_webpack_require_137320__(1);
exports.ResonanceAudio.LateReflections = __nested_webpack_require_137320__(8);
exports.ResonanceAudio.Listener = __nested_webpack_require_137320__(2);
exports.ResonanceAudio.Room = __nested_webpack_require_137320__(7);
exports.ResonanceAudio.Source = __nested_webpack_require_137320__(4);
exports.ResonanceAudio.Tables = __nested_webpack_require_137320__(3);
exports.ResonanceAudio.Utils = __nested_webpack_require_137320__(0);
exports.ResonanceAudio.Version = __nested_webpack_require_137320__(13);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_138892__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library name space and common utilities.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Listener = __nested_webpack_require_138892__(2);
const Source = __nested_webpack_require_138892__(4);
const Room = __nested_webpack_require_138892__(7);
const Encoder = __nested_webpack_require_138892__(1);
const Utils = __nested_webpack_require_138892__(0);


/**
 * @class ResonanceAudio
 * @description Main class for managing sources, room and listener models.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic Order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.listenerForward
 * The listener's initial forward vector.
 * Defaults to {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.listenerUp
 * The listener's initial up vector.
 * Defaults to {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function ResonanceAudio(context, options) {
  // Public variables.
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For rendering input soundfields).
   * @member {AudioNode} ambisonicInput
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For allowing external rendering / post-processing).
   * @member {AudioNode} ambisonicOutput
   * @memberof ResonanceAudio
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.listenerForward == undefined) {
    options.listenerForward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.listenerUp == undefined) {
    options.listenerUp = Utils.DEFAULT_UP.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Create member submodules.
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(options.ambisonicOrder);
  this._sources = [];
  this._room = new Room(context, {
    listenerPosition: options.listenerPosition,
    dimensions: options.dimensions,
    materials: options.materials,
    speedOfSound: options.speedOfSound,
  });
  this._listener = new Listener(context, {
    ambisonicOrder: options.ambisonicOrder,
    position: options.listenerPosition,
    forward: options.listenerForward,
    up: options.listenerUp,
  });

  // Create auxillary audio nodes.
  this._context = context;
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();
  this.ambisonicInput = this._listener.input;

  // Connect audio graph.
  this._room.output.connect(this._listener.input);
  this._listener.output.connect(this.output);
  this._listener.ambisonicOutput.connect(this.ambisonicOutput);
}


/**
 * Create a new source for the scene.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 * @return {Source}
 */
ResonanceAudio.prototype.createSource = function(options) {
  // Create a source and push it to the internal sources array, returning
  // the object's reference to the user.
  let source = new Source(this, options);
  this._sources[this._sources.length] = source;
  return source;
};


/**
 * Set the scene's desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
ResonanceAudio.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);
};


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters).
 * @param {Object} materials Named acoustic materials per wall.
 */
ResonanceAudio.prototype.setRoomProperties = function(dimensions, materials) {
  this._room.setProperties(dimensions, materials);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
ResonanceAudio.prototype.setListenerPosition = function(x, y, z) {
  // Update listener position.
  this._listener.position[0] = x;
  this._listener.position[1] = y;
  this._listener.position[2] = z;
  this._room.setListenerPosition(x, y, z);

  // Update sources with new listener position.
  this._sources.forEach(function(element) {
     element._update();
  });
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
ResonanceAudio.prototype.setListenerOrientation = function(forwardX, forwardY,
  forwardZ, upX, upY, upZ) {
  this._listener.setOrientation(forwardX, forwardY, forwardZ, upX, upY, upZ);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix
 * The Three.js Matrix4 object representing the listener's world transform.
 */
ResonanceAudio.prototype.setListenerFromMatrix = function(matrix) {
  this._listener.setFromMatrix(matrix);

  // Update the rest of the scene using new listener position.
  this.setListenerPosition(this._listener.position[0],
    this._listener.position[1], this._listener.position[2]);
};


/**
 * Set the speed of sound.
 * @param {Number} speedOfSound
 */
ResonanceAudio.prototype.setSpeedOfSound = function(speedOfSound) {
  this._room.speedOfSound = speedOfSound;
};


module.exports = ResonanceAudio;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_148723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_148723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_148723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_148723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_148723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_148723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_148723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_148723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_148723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_148723__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_148723__(__nested_webpack_require_148723__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library common utilities.
 */


/**
 * Omnitone library logging function.
 * @param {any} Message to be printed out.
 */
exports.log = function() {
  window.console.log.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 500', 'font-weight: 300',
    'color: #AAA',
  ]);
};


/**
 * Omnitone library error-throwing function.
 * @param {any} Message to be printed out.
 */
exports.throw = function() {
  window.console.error.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #C62828; color: #FFEBEE; font-weight: 800', 'font-weight: 400',
    'color: #AAA',
  ]);

  throw new Error(false);
};


// Static temp storage for matrix inversion.
let a00;
let a01;
let a02;
let a03;
let a10;
let a11;
let a12;
let a13;
let a20;
let a21;
let a22;
let a23;
let a30;
let a31;
let a32;
let a33;
let b00;
let b01;
let b02;
let b03;
let b04;
let b05;
let b06;
let b07;
let b08;
let b09;
let b10;
let b11;
let det;


/**
 * A 4x4 matrix inversion utility. This does not handle the case when the
 * arguments are not proper 4x4 matrices.
 * @param {Float32Array} out   The inverted result.
 * @param {Float32Array} a     The source matrix.
 * @return {Float32Array} out
 */
exports.invertMatrix4 = function(out, a) {
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  a30 = a[12];
  a31 = a[13];
  a32 = a[14];
  a33 = a[15];
  b00 = a00 * a11 - a01 * a10;
  b01 = a00 * a12 - a02 * a10;
  b02 = a00 * a13 - a03 * a10;
  b03 = a01 * a12 - a02 * a11;
  b04 = a01 * a13 - a03 * a11;
  b05 = a02 * a13 - a03 * a12;
  b06 = a20 * a31 - a21 * a30;
  b07 = a20 * a32 - a22 * a30;
  b08 = a20 * a33 - a23 * a30;
  b09 = a21 * a32 - a22 * a31;
  b10 = a21 * a33 - a23 * a31;
  b11 = a22 * a33 - a23 * a32;
  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
};


/**
 * Check if a value is defined in the ENUM dictionary.
 * @param {Object} enumDictionary - ENUM dictionary.
 * @param {Number|String} entryValue - a value to probe.
 * @return {Boolean}
 */
exports.isDefinedENUMEntry = function(enumDictionary, entryValue) {
  for (let enumKey in enumDictionary) {
    if (entryValue === enumDictionary[enumKey]) {
      return true;
    }
  }
  return false;
};


/**
 * Check if the given object is an instance of BaseAudioContext.
 * @param {AudioContext} context - A context object to be checked.
 * @return {Boolean}
 */
exports.isAudioContext = function(context) {
  // TODO(hoch): Update this when BaseAudioContext is available for all
  // browsers.
  return context instanceof AudioContext ||
    context instanceof OfflineAudioContext;
};


/**
 * Check if the given object is a valid AudioBuffer.
 * @param {Object} audioBuffer An AudioBuffer object to be checked.
 * @return {Boolean}
 */
exports.isAudioBuffer = function(audioBuffer) {
  return audioBuffer instanceof AudioBuffer;
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
exports.mergeBufferListByChannel = function(context, bufferList) {
  const bufferLength = bufferList[0].length;
  const bufferSampleRate = bufferList[0].sampleRate;
  let bufferNumberOfChannel = 0;

  for (let i = 0; i < bufferList.length; ++i) {
    if (bufferNumberOfChannel > 32) {
      exports.throw('Utils.mergeBuffer: Number of channels cannot exceed 32.' +
          '(got ' + bufferNumberOfChannel + ')');
    }
    if (bufferLength !== bufferList[i].length) {
      exports.throw('Utils.mergeBuffer: AudioBuffer lengths are ' +
          'inconsistent. (expected ' + bufferLength + ' but got ' +
          bufferList[i].length + ')');
    }
    if (bufferSampleRate !== bufferList[i].sampleRate) {
      exports.throw('Utils.mergeBuffer: AudioBuffer sample rates are ' +
          'inconsistent. (expected ' + bufferSampleRate + ' but got ' +
          bufferList[i].sampleRate + ')');
    }
    bufferNumberOfChannel += bufferList[i].numberOfChannels;
  }

  const buffer = context.createBuffer(bufferNumberOfChannel,
                                      bufferLength,
                                      bufferSampleRate);
  let destinationChannelIndex = 0;
  for (let i = 0; i < bufferList.length; ++i) {
    for (let j = 0; j < bufferList[i].numberOfChannels; ++j) {
      buffer.getChannelData(destinationChannelIndex++).set(
          bufferList[i].getChannelData(j));
    }
  }

  return buffer;
};


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
exports.splitBufferbyChannel = function(context, audioBuffer, splitBy) {
  if (audioBuffer.numberOfChannels <= splitBy) {
    exports.throw('Utils.splitBuffer: Insufficient number of channels. (' +
        audioBuffer.numberOfChannels + ' splitted by ' + splitBy + ')');
  }

  let bufflerList = [];
  let sourceChannelIndex = 0;
  const numberOfSplittedBuffer =
      Math.ceil(audioBuffer.numberOfChannels / splitBy);
  for (let i = 0; i < numberOfSplittedBuffer; ++i) {
    let buffer = context.createBuffer(splitBy,
                                      audioBuffer.length,
                                      audioBuffer.sampleRate);
    for (let j = 0; j < splitBy; ++j) {
      if (sourceChannelIndex < audioBuffer.numberOfChannels) {
        buffer.getChannelData(j).set(
          audioBuffer.getChannelData(sourceChannelIndex++));
      }
    }
    bufflerList.push(buffer);
  }

  return bufferList;
};


/**
 * Converts Base64-encoded string to ArrayBuffer.
 * @param {string} base64String - Base64-encdoed string.
 * @return {ArrayByuffer} Converted ArrayBuffer object.
 */
exports.getArrayBufferFromBase64String = function(base64String) {
  let binaryString = window.atob(base64String);
  let byteArray = new Uint8Array(binaryString.length);
  byteArray.forEach(
    (value, index) => byteArray[index] = binaryString.charCodeAt(index));
  return byteArray.buffer;
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_159425__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Streamlined AudioBuffer loader.
 */




const Utils = __nested_webpack_require_159425__(0);

/**
 * @typedef {string} BufferDataType
 */

/**
 * Buffer data type for ENUM.
 * @enum {BufferDataType}
 */
const BufferDataType = {
  /** @type {string} The data contains Base64-encoded string.. */
  BASE64: 'base64',
  /** @type {string} The data is a URL for audio file. */
  URL: 'url',
};


/**
 * BufferList object mananges the async loading/decoding of multiple
 * AudioBuffers from multiple URLs.
 * @constructor
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} options - Options
 * @param {string} [options.dataType='base64'] - BufferDataType specifier.
 * @param {Boolean} [options.verbose=false] - Log verbosity. |true| prints the
 * individual message from each URL and AudioBuffer.
 */
function BufferList(context, bufferData, options) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('BufferList: Invalid BaseAudioContext.');

  this._options = {
    dataType: BufferDataType.BASE64,
    verbose: false,
  };

  if (options) {
    if (options.dataType &&
        Utils.isDefinedENUMEntry(BufferDataType, options.dataType)) {
      this._options.dataType = options.dataType;
    }
    if (options.verbose) {
      this._options.verbose = Boolean(options.verbose);
    }
  }

  this._bufferList = [];
  this._bufferData = this._options.dataType === BufferDataType.BASE64
      ? bufferData
      : bufferData.slice(0);
  this._numberOfTasks = this._bufferData.length;

  this._resolveHandler = null;
  this._rejectHandler = new Function();
}


/**
 * Starts AudioBuffer loading tasks.
 * @return {Promise<AudioBuffer[]>} The promise resolves with an array of
 * AudioBuffer.
 */
BufferList.prototype.load = function() {
  return new Promise(this._promiseGenerator.bind(this));
};


/**
 * Promise argument generator. Internally starts multiple async loading tasks.
 * @private
 * @param {function} resolve Promise resolver.
 * @param {function} reject Promise reject.
 */
BufferList.prototype._promiseGenerator = function(resolve, reject) {
  if (typeof resolve !== 'function') {
    Utils.throw('BufferList: Invalid Promise resolver.');
  } else {
    this._resolveHandler = resolve;
  }

  if (typeof reject === 'function') {
    this._rejectHandler = reject;
  }

  for (let i = 0; i < this._bufferData.length; ++i) {
    this._options.dataType === BufferDataType.BASE64
        ? this._launchAsyncLoadTask(i)
        : this._launchAsyncLoadTaskXHR(i);
  }
};


/**
 * Run async loading task for Base64-encoded string.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTask = function(taskId) {
  const that = this;
  this._context.decodeAudioData(
      Utils.getArrayBufferFromBase64String(this._bufferData[taskId]),
      function(audioBuffer) {
        that._updateProgress(taskId, audioBuffer);
      },
      function(errorMessage) {
        that._updateProgress(taskId, null);
        const message = 'BufferList: decoding ArrayByffer("' + taskId +
            '" from Base64-encoded data failed. (' + errorMessage + ')';
        Utils.throw(message);
        that._rejectHandler(message);
      });
};


/**
 * Run async loading task via XHR for audio file URLs.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTaskXHR = function(taskId) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', this._bufferData[taskId]);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(
          xhr.response,
          function(audioBuffer) {
            that._updateProgress(taskId, audioBuffer);
          },
          function(errorMessage) {
            that._updateProgress(taskId, null);
            const message = 'BufferList: decoding "' +
                that._bufferData[taskId] + '" failed. (' + errorMessage + ')';
            Utils.throw(message);
            that._rejectHandler(message);
          });
    } else {
      const message = 'BufferList: XHR error while loading "' +
          that._bufferData[taskId] + '(' + xhr.statusText + ')';
      Utils.throw(message);
      that._rejectHandler(message);
    }
  };

  xhr.onerror = function(event) {
    Utils.throw(
        'BufferList: XHR network failed on loading "' +
        that._bufferData[taskId] + '".');
    that._updateProgress(taskId, null);
    that._rejectHandler();
  };

  xhr.send();
};


/**
 * Updates the overall progress on loading tasks.
 * @param {Number} taskId Task ID number.
 * @param {AudioBuffer} audioBuffer Decoded AudioBuffer object.
 */
BufferList.prototype._updateProgress = function(taskId, audioBuffer) {
  this._bufferList[taskId] = audioBuffer;

  if (this._options.verbose) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? 'ArrayBuffer(' + taskId + ') from Base64-encoded HRIR'
        : '"' + this._bufferData[taskId] + '"';
    Utils.log('BufferList: ' + messageString + ' successfully loaded.');
  }

  if (--this._numberOfTasks === 0) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? this._bufferData.length + ' AudioBuffers from Base64-encoded HRIRs'
        : this._bufferData.length + ' files via XHR';
    Utils.log('BufferList: ' + messageString + ' loaded successfully.');
    this._resolveHandler(this._bufferList);
  }
};


module.exports = BufferList;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file An audio channel router to resolve different channel layouts between
 * browsers.
 */




/**
 * @typedef {Number[]} ChannelMap
 */

/**
 * Channel map dictionary ENUM.
 * @enum {ChannelMap}
 */
const ChannelMap = {
  /** @type {Number[]} - ACN channel map for Chrome and FireFox. (FFMPEG) */
  DEFAULT: [0, 1, 2, 3],
  /** @type {Number[]} - Safari's 4-channel map for AAC codec. */
  SAFARI: [2, 0, 1, 3],
  /** @type {Number[]} - ACN > FuMa conversion map. */
  FUMA: [0, 3, 1, 2],
};


/**
 * Channel router for FOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 */
function FOARouter(context, channelMap) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._merger = this._context.createChannelMerger(4);

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;

  this.setChannelMap(channelMap || ChannelMap.DEFAULT);
}


/**
 * Sets channel map.
 * @param {Number[]} channelMap - A new channel map for FOA stream.
 */
FOARouter.prototype.setChannelMap = function(channelMap) {
  if (!Array.isArray(channelMap)) {
    return;
  }

  this._channelMap = channelMap;
  this._splitter.disconnect();
  this._splitter.connect(this._merger, 0, this._channelMap[0]);
  this._splitter.connect(this._merger, 1, this._channelMap[1]);
  this._splitter.connect(this._merger, 2, this._channelMap[2]);
  this._splitter.connect(this._merger, 3, this._channelMap[3]);
};


/**
 * Static channel map ENUM.
 * @static
 * @type {ChannelMap}
 */
FOARouter.ChannelMap = ChannelMap;


module.exports = FOARouter;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for first-order-ambisonics decoding.
 */




/**
 * First-order-ambisonic decoder based on gain node network.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOARotator(context) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._inY = this._context.createGain();
  this._inZ = this._context.createGain();
  this._inX = this._context.createGain();
  this._m0 = this._context.createGain();
  this._m1 = this._context.createGain();
  this._m2 = this._context.createGain();
  this._m3 = this._context.createGain();
  this._m4 = this._context.createGain();
  this._m5 = this._context.createGain();
  this._m6 = this._context.createGain();
  this._m7 = this._context.createGain();
  this._m8 = this._context.createGain();
  this._outY = this._context.createGain();
  this._outZ = this._context.createGain();
  this._outX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  // ACN channel ordering: [1, 2, 3] => [-Y, Z, -X]
  // Y (from channel 1)
  this._splitter.connect(this._inY, 1);
  // Z (from channel 2)
  this._splitter.connect(this._inZ, 2);
  // X (from channel 3)
  this._splitter.connect(this._inX, 3);
  this._inY.gain.value = -1;
  this._inX.gain.value = -1;

  // Apply the rotation in the world space.
  // |Y|   | m0  m3  m6 |   | Y * m0 + Z * m3 + X * m6 |   | Yr |
  // |Z| * | m1  m4  m7 | = | Y * m1 + Z * m4 + X * m7 | = | Zr |
  // |X|   | m2  m5  m8 |   | Y * m2 + Z * m5 + X * m8 |   | Xr |
  this._inY.connect(this._m0);
  this._inY.connect(this._m1);
  this._inY.connect(this._m2);
  this._inZ.connect(this._m3);
  this._inZ.connect(this._m4);
  this._inZ.connect(this._m5);
  this._inX.connect(this._m6);
  this._inX.connect(this._m7);
  this._inX.connect(this._m8);
  this._m0.connect(this._outY);
  this._m1.connect(this._outZ);
  this._m2.connect(this._outX);
  this._m3.connect(this._outY);
  this._m4.connect(this._outZ);
  this._m5.connect(this._outX);
  this._m6.connect(this._outY);
  this._m7.connect(this._outZ);
  this._m8.connect(this._outX);

  // Transform 3: world space to audio space.
  // W -> W (to channel 0)
  this._splitter.connect(this._merger, 0, 0);
  // Y (to channel 1)
  this._outY.connect(this._merger, 0, 1);
  // Z (to channel 2)
  this._outZ.connect(this._merger, 0, 2);
  // X (to channel 3)
  this._outX.connect(this._merger, 0, 3);
  this._outY.gain.value = -1;
  this._outX.gain.value = -1;

  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  this._m0.gain.value = rotationMatrix3[0];
  this._m1.gain.value = rotationMatrix3[1];
  this._m2.gain.value = rotationMatrix3[2];
  this._m3.gain.value = rotationMatrix3[3];
  this._m4.gain.value = rotationMatrix3[4];
  this._m5.gain.value = rotationMatrix3[5];
  this._m6.gain.value = rotationMatrix3[6];
  this._m7.gain.value = rotationMatrix3[7];
  this._m8.gain.value = rotationMatrix3[8];
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._m0.gain.value = rotationMatrix4[0];
  this._m1.gain.value = rotationMatrix4[1];
  this._m2.gain.value = rotationMatrix4[2];
  this._m3.gain.value = rotationMatrix4[4];
  this._m4.gain.value = rotationMatrix4[5];
  this._m5.gain.value = rotationMatrix4[6];
  this._m6.gain.value = rotationMatrix4[8];
  this._m7.gain.value = rotationMatrix4[9];
  this._m8.gain.value = rotationMatrix4[10];
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix3 = function() {
  return [
    this._m0.gain.value, this._m1.gain.value, this._m2.gain.value,
    this._m3.gain.value, this._m4.gain.value, this._m5.gain.value,
    this._m6.gain.value, this._m7.gain.value, this._m8.gain.value,
  ];
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._m0.gain.value;
  rotationMatrix4[1] = this._m1.gain.value;
  rotationMatrix4[2] = this._m2.gain.value;
  rotationMatrix4[4] = this._m3.gain.value;
  rotationMatrix4[5] = this._m4.gain.value;
  rotationMatrix4[6] = this._m5.gain.value;
  rotationMatrix4[8] = this._m6.gain.value;
  rotationMatrix4[9] = this._m7.gain.value;
  rotationMatrix4[10] = this._m8.gain.value;
  return rotationMatrix4;
};


module.exports = FOARotator;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized FOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * FOAConvolver. A collection of 2 stereo convolvers for 4-channel FOA stream.
 * @constructor
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (i.e. 2 stereo AudioBuffers for FOA)
 */
function FOAConvolver(context, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  this._buildAudioGraph();

  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 *
 * @private
 */
FOAConvolver.prototype._buildAudioGraph = function() {
  this._splitterWYZX = this._context.createChannelSplitter(4);
  this._mergerWY = this._context.createChannelMerger(2);
  this._mergerZX = this._context.createChannelMerger(2);
  this._convolverWY = this._context.createConvolver();
  this._convolverZX = this._context.createConvolver();
  this._splitterWY = this._context.createChannelSplitter(2);
  this._splitterZX = this._context.createChannelSplitter(2);
  this._inverter = this._context.createGain();
  this._mergerBinaural = this._context.createChannelMerger(2);
  this._summingBus = this._context.createGain();

  // Group W and Y, then Z and X.
  this._splitterWYZX.connect(this._mergerWY, 0, 0);
  this._splitterWYZX.connect(this._mergerWY, 1, 1);
  this._splitterWYZX.connect(this._mergerZX, 2, 0);
  this._splitterWYZX.connect(this._mergerZX, 3, 1);

  // Create a network of convolvers using splitter/merger.
  this._mergerWY.connect(this._convolverWY);
  this._mergerZX.connect(this._convolverZX);
  this._convolverWY.connect(this._splitterWY);
  this._convolverZX.connect(this._splitterZX);
  this._splitterWY.connect(this._mergerBinaural, 0, 0);
  this._splitterWY.connect(this._mergerBinaural, 0, 1);
  this._splitterWY.connect(this._mergerBinaural, 1, 0);
  this._splitterWY.connect(this._inverter, 1, 0);
  this._inverter.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 0, 0);
  this._splitterZX.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 1, 0);
  this._splitterZX.connect(this._mergerBinaural, 1, 1);

  // By default, WebAudio's convolver does the normalization based on IR's
  // energy. For the precise convolution, it must be disabled before the buffer
  // assignment.
  this._convolverWY.normalize = false;
  this._convolverZX.normalize = false;

  // For asymmetric degree.
  this._inverter.gain.value = -1;

  // Input/output proxy.
  this.input = this._splitterWYZX;
  this.output = this._summingBus;
};


/**
 * Assigns 2 HRIR AudioBuffers to 2 convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
FOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  this._convolverWY.buffer = hrirBufferList[0];
  this._convolverZX.buffer = hrirBufferList[1];
  this._isBufferLoaded = true;
};


/**
 * Enable FOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
FOAConvolver.prototype.enable = function() {
  this._mergerBinaural.connect(this._summingBus);
  this._active = true;
};


/**
 * Disable FOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
FOAConvolver.prototype.disable = function() {
  this._mergerBinaural.disconnect();
  this._active = false;
};


module.exports = FOAConvolver;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_178724__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileOverview DEPRECATED at V1. Audio buffer loading utility.
 */



const Utils = __nested_webpack_require_178724__(0);

/**
 * Streamlined audio file loader supports Promise.
 * @param {Object} context          AudioContext
 * @param {Object} audioFileData    Audio file info as [{name, url}]
 * @param {Function} resolve        Resolution handler for promise.
 * @param {Function} reject         Rejection handler for promise.
 * @param {Function} progress       Progress event handler.
 */
function AudioBufferManager(context, audioFileData, resolve, reject, progress) {
  this._context = context;

  this._buffers = new Map();
  this._loadingTasks = {};

  this._resolve = resolve;
  this._reject = reject;
  this._progress = progress;

  // Iterating file loading.
  for (let i = 0; i < audioFileData.length; i++) {
    const fileInfo = audioFileData[i];

    // Check for duplicates filename and quit if it happens.
    if (this._loadingTasks.hasOwnProperty(fileInfo.name)) {
      Utils.log('Duplicated filename when loading: ' + fileInfo.name);
      return;
    }

    // Mark it as pending (0)
    this._loadingTasks[fileInfo.name] = 0;
    this._loadAudioFile(fileInfo);
  }
}

AudioBufferManager.prototype._loadAudioFile = function(fileInfo) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', fileInfo.url);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(xhr.response,
        function(buffer) {
          // Utils.log('File loaded: ' + fileInfo.url);
          that._done(fileInfo.name, buffer);
        },
        function(message) {
          Utils.log('Decoding failure: '
            + fileInfo.url + ' (' + message + ')');
          that._done(fileInfo.name, null);
        });
    } else {
      Utils.log('XHR Error: ' + fileInfo.url + ' (' + xhr.statusText
        + ')');
      that._done(fileInfo.name, null);
    }
  };

  // TODO: fetch local resources if XHR fails.
  xhr.onerror = function(event) {
    Utils.log('XHR Network failure: ' + fileInfo.url);
    that._done(fileInfo.name, null);
  };

  xhr.send();
};

AudioBufferManager.prototype._done = function(filename, buffer) {
  // Label the loading task.
  this._loadingTasks[filename] = buffer !== null ? 'loaded' : 'failed';

  // A failed task will be a null buffer.
  this._buffers.set(filename, buffer);

  this._updateProgress(filename);
};

AudioBufferManager.prototype._updateProgress = function(filename) {
  let numberOfFinishedTasks = 0;
  let numberOfFailedTask = 0;
  let numberOfTasks = 0;

  for (const task in this._loadingTasks) {
    if (Object.prototype.hasOwnProperty.call(this._loadingTasks, task)) {
      numberOfTasks++;
      if (this._loadingTasks[task] === 'loaded') {
        numberOfFinishedTasks++;
      } else if (this._loadingTasks[task] === 'failed') {
        numberOfFailedTask++;
      }
    }
  }

  if (typeof this._progress === 'function') {
    this._progress(filename, numberOfFinishedTasks, numberOfTasks);
    return;
  }

  if (numberOfFinishedTasks === numberOfTasks) {
    this._resolve(this._buffers);
    return;
  }

  if (numberOfFinishedTasks + numberOfFailedTask === numberOfTasks) {
    this._reject(this._buffers);
    return;
  }
};

module.exports = AudioBufferManager;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_182743__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Phase matched filter for first-order-ambisonics decoding.
 */



const Utils = __nested_webpack_require_182743__(0);


// Static parameters.
const CROSSOVER_FREQUENCY = 690;
const GAIN_COEFFICIENTS = [1.4142, 0.8166, 0.8166, 0.8166];


/**
 * Generate the coefficients for dual band filter.
 * @param {Number} crossoverFrequency
 * @param {Number} sampleRate
 * @return {Object} Filter coefficients.
 */
function generateDualBandCoefficients(crossoverFrequency, sampleRate) {
  const k = Math.tan(Math.PI * crossoverFrequency / sampleRate);
  const k2 = k * k;
  const denominator = k2 + 2 * k + 1;

  return {
    lowpassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    lowpassB: [k2 / denominator, 2 * k2 / denominator, k2 / denominator],
    hipassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    hipassB: [1 / denominator, -2 * 1 / denominator, 1 / denominator],
  };
}


/**
 * FOAPhaseMatchedFilter: A set of filters (LP/HP) with a crossover frequency to
 * compensate the gain of high frequency contents without a phase difference.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOAPhaseMatchedFilter(context) {
  this._context = context;

  this._input = this._context.createGain();

  if (!this._context.createIIRFilter) {
    Utils.log('IIR filter is missing. Using Biquad filter instead.');
    this._lpf = this._context.createBiquadFilter();
    this._hpf = this._context.createBiquadFilter();
    this._lpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.type = 'highpass';
  } else {
    const coef = generateDualBandCoefficients(CROSSOVER_FREQUENCY,
                                              this._context.sampleRate);
    this._lpf = this._context.createIIRFilter(coef.lowpassB, coef.lowpassA);
    this._hpf = this._context.createIIRFilter(coef.hipassB, coef.hipassA);
  }

  this._splitterLow = this._context.createChannelSplitter(4);
  this._splitterHigh = this._context.createChannelSplitter(4);
  this._gainHighW = this._context.createGain();
  this._gainHighY = this._context.createGain();
  this._gainHighZ = this._context.createGain();
  this._gainHighX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  this._input.connect(this._hpf);
  this._hpf.connect(this._splitterHigh);
  this._splitterHigh.connect(this._gainHighW, 0);
  this._splitterHigh.connect(this._gainHighY, 1);
  this._splitterHigh.connect(this._gainHighZ, 2);
  this._splitterHigh.connect(this._gainHighX, 3);
  this._gainHighW.connect(this._merger, 0, 0);
  this._gainHighY.connect(this._merger, 0, 1);
  this._gainHighZ.connect(this._merger, 0, 2);
  this._gainHighX.connect(this._merger, 0, 3);

  this._input.connect(this._lpf);
  this._lpf.connect(this._splitterLow);
  this._splitterLow.connect(this._merger, 0, 0);
  this._splitterLow.connect(this._merger, 1, 1);
  this._splitterLow.connect(this._merger, 2, 2);
  this._splitterLow.connect(this._merger, 3, 3);

  // Apply gain correction to hi-passed pressure and velocity components:
  // Inverting sign is necessary as the low-passed and high-passed portion are
  // out-of-phase after the filtering.
  const now = this._context.currentTime;
  this._gainHighW.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[0], now);
  this._gainHighY.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[1], now);
  this._gainHighZ.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[2], now);
  this._gainHighX.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[3], now);

  // Input/output Proxy.
  this.input = this._input;
  this.output = this._merger;
}


module.exports = FOAPhaseMatchedFilter;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Virtual speaker abstraction for first-order-ambisonics decoding.
 */




/**
 * DEPRECATED at V1: A virtual speaker with ambisonic decoding gain coefficients
 * and HRTF convolution for first-order-ambisonics stream. Note that the
 * subgraph directly connects to context's destination.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options for speaker.
 * @param {Number[]} options.coefficients - Decoding coefficients for (W,Y,Z,X).
 * @param {AudioBuffer} options.IR - Stereo IR buffer for HRTF convolution.
 * @param {Number} options.gain - Post-gain for the speaker.
 */
function FOAVirtualSpeaker(context, options) {
  if (options.IR.numberOfChannels !== 2) {
    throw new Error('IR does not have 2 channels. cannot proceed.');
  }

  this._active = false;
  this._context = context;

  this._input = this._context.createChannelSplitter(4);
  this._cW = this._context.createGain();
  this._cY = this._context.createGain();
  this._cZ = this._context.createGain();
  this._cX = this._context.createGain();
  this._convolver = this._context.createConvolver();
  this._gain = this._context.createGain();

  this._input.connect(this._cW, 0);
  this._input.connect(this._cY, 1);
  this._input.connect(this._cZ, 2);
  this._input.connect(this._cX, 3);
  this._cW.connect(this._convolver);
  this._cY.connect(this._convolver);
  this._cZ.connect(this._convolver);
  this._cX.connect(this._convolver);
  this._convolver.connect(this._gain);
  this._gain.connect(this._context.destination);

  this.enable();

  this._convolver.normalize = false;
  this._convolver.buffer = options.IR;
  this._gain.gain.value = options.gain;

  // Set gain coefficients for FOA ambisonic streams.
  this._cW.gain.value = options.coefficients[0];
  this._cY.gain.value = options.coefficients[1];
  this._cZ.gain.value = options.coefficients[2];
  this._cX.gain.value = options.coefficients[3];

  // Input proxy. Output directly connects to the destination.
  this.input = this._input;
}


FOAVirtualSpeaker.prototype.enable = function() {
  this._gain.connect(this._context.destination);
  this._active = true;
};


FOAVirtualSpeaker.prototype.disable = function() {
  this._gain.disconnect();
  this._active = false;
};


module.exports = FOAVirtualSpeaker;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized HOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * A convolver network for N-channel HOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 */
function HOAConvolver(context, ambisonicOrder, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  // The number of channels K based on the ambisonic order N where K = (N+1)^2.
  this._ambisonicOrder = ambisonicOrder;
  this._numberOfChannels =
      (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);

  this._buildAudioGraph();
  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 * For TOA convolution:
 *   input -> splitter(16) -[0,1]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[2,3]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[4,5]-> ... (6 more, 8 branches total)
 * @private
 */
HOAConvolver.prototype._buildAudioGraph = function() {
  const numberOfStereoChannels = Math.ceil(this._numberOfChannels / 2);

  this._inputSplitter =
      this._context.createChannelSplitter(this._numberOfChannels);
  this._stereoMergers = [];
  this._convolvers = [];
  this._stereoSplitters = [];
  this._positiveIndexSphericalHarmonics = this._context.createGain();
  this._negativeIndexSphericalHarmonics = this._context.createGain();
  this._inverter = this._context.createGain();
  this._binauralMerger = this._context.createChannelMerger(2);
  this._outputGain = this._context.createGain();

  for (let i = 0; i < numberOfStereoChannels; ++i) {
    this._stereoMergers[i] = this._context.createChannelMerger(2);
    this._convolvers[i] = this._context.createConvolver();
    this._stereoSplitters[i] = this._context.createChannelSplitter(2);
    this._convolvers[i].normalize = false;
  }

  for (let l = 0; l <= this._ambisonicOrder; ++l) {
    for (let m = -l; m <= l; m++) {
      // We compute the ACN index (k) of ambisonics channel using the degree (l)
      // and index (m): k = l^2 + l + m
      const acnIndex = l * l + l + m;
      const stereoIndex = Math.floor(acnIndex / 2);

      // Split channels from input into array of stereo convolvers.
      // Then create a network of mergers that produces the stereo output.
      this._inputSplitter.connect(
          this._stereoMergers[stereoIndex], acnIndex, acnIndex % 2);
      this._stereoMergers[stereoIndex].connect(this._convolvers[stereoIndex]);
      this._convolvers[stereoIndex].connect(this._stereoSplitters[stereoIndex]);

      // Positive index (m >= 0) spherical harmonics are symmetrical around the
      // front axis, while negative index (m < 0) spherical harmonics are
      // anti-symmetrical around the front axis. We will exploit this symmetry
      // to reduce the number of convolutions required when rendering to a
      // symmetrical binaural renderer.
      if (m >= 0) {
        this._stereoSplitters[stereoIndex].connect(
            this._positiveIndexSphericalHarmonics, acnIndex % 2);
      } else {
        this._stereoSplitters[stereoIndex].connect(
            this._negativeIndexSphericalHarmonics, acnIndex % 2);
      }
    }
  }

  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 1);
  this._negativeIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._negativeIndexSphericalHarmonics.connect(this._inverter);
  this._inverter.connect(this._binauralMerger, 0, 1);

  // For asymmetric index.
  this._inverter.gain.value = -1;

  // Input/Output proxy.
  this.input = this._inputSplitter;
  this.output = this._outputGain;
};


/**
 * Assigns N HRIR AudioBuffers to N convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
HOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  for (let i = 0; i < hrirBufferList.length; ++i) {
    this._convolvers[i].buffer = hrirBufferList[i];
  }

  this._isBufferLoaded = true;
};


/**
 * Enable HOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
HOAConvolver.prototype.enable = function() {
  this._binauralMerger.connect(this._outputGain);
  this._active = true;
};


/**
 * Disable HOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
HOAConvolver.prototype.disable = function() {
  this._binauralMerger.disconnect();
  this._active = false;
};


module.exports = HOAConvolver;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for higher-order-ambisonics decoding.
 */




/**
 * Kronecker Delta function.
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getKroneckerDelta(i, j) {
  return i === j ? 1 : 0;
}


/**
 * A helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1)x(2l+1) matrix. [2] uses an odd convention of
 * referring to the rows and columns using centered indices, so the middle row
 * and column are (0, 0) and the upper left would have negative coordinates.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @param {Number} gainValue
 */
function setCenteredElement(matrix, l, i, j, gainValue) {
  const index = (j + l) * (2 * l + 1) + (i + l);
  // Row-wise indexing.
  matrix[l - 1][index].gain.value = gainValue;
}


/**
 * This is a helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1) x (2l+1) matrix.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getCenteredElement(matrix, l, i, j) {
  // Row-wise indexing.
  const index = (j + l) * (2 * l + 1) + (i + l);
  return matrix[l - 1][index].gain.value;
}


/**
 * Helper function defined in [2] that is used by the functions U, V, W.
 * This should not be called on its own, as U, V, and W (and their coefficients)
 * select the appropriate matrix elements to access arguments |a| and |b|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} i
 * @param {Number} a
 * @param {Number} b
 * @param {Number} l
 * @return {Number}
 */
function getP(matrix, i, a, b, l) {
  if (b === l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, l - 1) -
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, -l + 1);
  } else if (b === -l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, -l + 1) +
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, l - 1);
  } else {
    return getCenteredElement(matrix, 1, i, 0) *
        getCenteredElement(matrix, l - 1, a, b);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getU(matrix, m, n, l) {
  // Although [1, 2] split U into three cases for m == 0, m < 0, m > 0
  // the actual values are the same for all three cases.
  return getP(matrix, 0, m, n, l);
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getV(matrix, m, n, l) {
  if (m === 0) {
    return getP(matrix, 1, 1, n, l) + getP(matrix, -1, -1, n, l);
  } else if (m > 0) {
    const d = getKroneckerDelta(m, 1);
    return getP(matrix, 1, m - 1, n, l) * Math.sqrt(1 + d) -
        getP(matrix, -1, -m + 1, n, l) * (1 - d);
  } else {
    // Note there is apparent errata in [1,2,2b] dealing with this particular
    // case. [2b] writes it should be P*(1-d)+P*(1-d)^0.5
    // [1] writes it as P*(1+d)+P*(1-d)^0.5, but going through the math by hand,
    // you must have it as P*(1-d)+P*(1+d)^0.5 to form a 2^.5 term, which
    // parallels the case where m > 0.
    const d = getKroneckerDelta(m, -1);
    return getP(matrix, 1, m + 1, n, l) * (1 - d) +
        getP(matrix, -1, -m - 1, n, l) * Math.sqrt(1 + d);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getW(matrix, m, n, l) {
  // Whenever this happens, w is also 0 so W can be anything.
  if (m === 0) {
    return 0;
  }

  return m > 0 ? getP(matrix, 1, m + 1, n, l) + getP(matrix, -1, -m - 1, n, l) :
                 getP(matrix, 1, m - 1, n, l) - getP(matrix, -1, -m + 1, n, l);
}


/**
 * Calculates the coefficients applied to the U, V, and W functions. Because
 * their equations share many common terms they are computed simultaneously.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Array} 3 coefficients for U, V and W functions.
 */
function computeUVWCoeff(m, n, l) {
  const d = getKroneckerDelta(m, 0);
  const reciprocalDenominator =
      Math.abs(n) === l ? 1 / (2 * l * (2 * l - 1)) : 1 / ((l + n) * (l - n));

  return [
    Math.sqrt((l + m) * (l - m) * reciprocalDenominator),
    0.5 * (1 - 2 * d) * Math.sqrt((1 + d) *
                                  (l + Math.abs(m) - 1) *
                                  (l + Math.abs(m)) *
                                  reciprocalDenominator),
    -0.5 * (1 - d) * Math.sqrt((l - Math.abs(m) - 1) * (l - Math.abs(m))) *
        reciprocalDenominator,
  ];
}


/**
 * Calculates the (2l+1) x (2l+1) rotation matrix for the band l.
 * This uses the matrices computed for band 1 and band l-1 to compute the
 * matrix for band l. |rotations| must contain the previously computed l-1
 * rotation matrices.
 * This implementation comes from p. 5 (6346), Table 1 and 2 in [2] taking
 * into account the corrections from [2b].
 * @param {Number[]} matrix - N matrices of gainNodes, each with where
 * n=1,2,...,N.
 * @param {Number} l
 */
function computeBandRotation(matrix, l) {
  // The lth band rotation matrix has rows and columns equal to the number of
  // coefficients within that band (-l <= m <= l implies 2l + 1 coefficients).
  for (let m = -l; m <= l; m++) {
    for (let n = -l; n <= l; n++) {
      const uvwCoefficients = computeUVWCoeff(m, n, l);

      // The functions U, V, W are only safe to call if the coefficients
      // u, v, w are not zero.
      if (Math.abs(uvwCoefficients[0]) > 0) {
        uvwCoefficients[0] *= getU(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[1]) > 0) {
        uvwCoefficients[1] *= getV(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[2]) > 0) {
        uvwCoefficients[2] *= getW(matrix, m, n, l);
      }

      setCenteredElement(
          matrix, l, m, n,
          uvwCoefficients[0] + uvwCoefficients[1] + uvwCoefficients[2]);
    }
  }
}


/**
 * Compute the HOA rotation matrix after setting the transform matrix.
 * @param {Array} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 */
function computeHOAMatrices(matrix) {
  // We start by computing the 2nd-order matrix from the 1st-order matrix.
  for (let i = 2; i <= matrix.length; i++) {
    computeBandRotation(matrix, i);
  }
}


/**
 * Higher-order-ambisonic decoder based on gain node network. We expect
 * the order of the channels to conform to ACN ordering. Below are the helper
 * methods to compute SH rotation using recursion. The code uses maths described
 * in the following papers:
 *  [1] R. Green, "Spherical Harmonic Lighting: The Gritty Details", GDC 2003,
 *      http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf
 *  [2] J. Ivanic and K. Ruedenberg, "Rotation Matrices for Real
 *      Spherical Harmonics. Direct Determination by Recursion", J. Phys.
 *      Chem., vol. 100, no. 15, pp. 6342-6347, 1996.
 *      http://pubs.acs.org/doi/pdf/10.1021/jp953350u
 *  [2b] Corrections to initial publication:
 *       http://pubs.acs.org/doi/pdf/10.1021/jp9833350
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 */
function HOARotator(context, ambisonicOrder) {
  this._context = context;
  this._ambisonicOrder = ambisonicOrder;

  // We need to determine the number of channels K based on the ambisonic order
  // N where K = (N + 1)^2.
  const numberOfChannels = (ambisonicOrder + 1) * (ambisonicOrder + 1);

  this._splitter = this._context.createChannelSplitter(numberOfChannels);
  this._merger = this._context.createChannelMerger(numberOfChannels);

  // Create a set of per-order rotation matrices using gain nodes.
  this._gainNodeMatrix = [];
  let orderOffset;
  let rows;
  let inputIndex;
  let outputIndex;
  let matrixIndex;
  for (let i = 1; i <= ambisonicOrder; i++) {
    // Each ambisonic order requires a separate (2l + 1) x (2l + 1) rotation
    // matrix. We compute the offset value as the first channel index of the
    // current order where
    //   k_last = l^2 + l + m,
    // and m = -l
    //   k_last = l^2
    orderOffset = i * i;

    // Uses row-major indexing.
    rows = (2 * i + 1);

    this._gainNodeMatrix[i - 1] = [];
    for (let j = 0; j < rows; j++) {
      inputIndex = orderOffset + j;
      for (let k = 0; k < rows; k++) {
        outputIndex = orderOffset + k;
        matrixIndex = j * rows + k;
        this._gainNodeMatrix[i - 1][matrixIndex] = this._context.createGain();
        this._splitter.connect(
            this._gainNodeMatrix[i - 1][matrixIndex], inputIndex);
        this._gainNodeMatrix[i - 1][matrixIndex].connect(
            this._merger, 0, outputIndex);
      }
    }
  }

  // W-channel is not involved in rotation, skip straight to ouput.
  this._splitter.connect(this._merger, 0, 0);

  // Default Identity matrix.
  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // Input/Output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  for (let i = 0; i < 9; ++i) {
    this._gainNodeMatrix[0][i].gain.value = rotationMatrix3[i];
  }
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._gainNodeMatrix[0][0].gain.value = rotationMatrix4[0];
  this._gainNodeMatrix[0][1].gain.value = rotationMatrix4[1];
  this._gainNodeMatrix[0][2].gain.value = rotationMatrix4[2];
  this._gainNodeMatrix[0][3].gain.value = rotationMatrix4[4];
  this._gainNodeMatrix[0][4].gain.value = rotationMatrix4[5];
  this._gainNodeMatrix[0][5].gain.value = rotationMatrix4[6];
  this._gainNodeMatrix[0][6].gain.value = rotationMatrix4[8];
  this._gainNodeMatrix[0][7].gain.value = rotationMatrix4[9];
  this._gainNodeMatrix[0][8].gain.value = rotationMatrix4[10];
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix3 = function() {
  let rotationMatrix3 = new Float32Array(9);
  for (let i = 0; i < 9; ++i) {
    rotationMatrix3[i] = this._gainNodeMatrix[0][i].gain.value;
  }
  return rotationMatrix3;
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._gainNodeMatrix[0][0].gain.value;
  rotationMatrix4[1] = this._gainNodeMatrix[0][1].gain.value;
  rotationMatrix4[2] = this._gainNodeMatrix[0][2].gain.value;
  rotationMatrix4[4] = this._gainNodeMatrix[0][3].gain.value;
  rotationMatrix4[5] = this._gainNodeMatrix[0][4].gain.value;
  rotationMatrix4[6] = this._gainNodeMatrix[0][5].gain.value;
  rotationMatrix4[8] = this._gainNodeMatrix[0][6].gain.value;
  rotationMatrix4[9] = this._gainNodeMatrix[0][7].gain.value;
  rotationMatrix4[10] = this._gainNodeMatrix[0][8].gain.value;
  return rotationMatrix4;
};


/**
 * Get the current ambisonic order.
 * @return {Number}
 */
HOARotator.prototype.getAmbisonicOrder = function() {
  return this._ambisonicOrder;
};


module.exports = HOARotator;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_210444__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Namespace for Omnitone library.
 */




exports.Omnitone = __nested_webpack_require_210444__(11);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_211260__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library name space and user-facing APIs.
 */




const BufferList = __nested_webpack_require_211260__(1);
const FOAConvolver = __nested_webpack_require_211260__(4);
const FOADecoder = __nested_webpack_require_211260__(12);
const FOAPhaseMatchedFilter = __nested_webpack_require_211260__(6);
const FOARenderer = __nested_webpack_require_211260__(14);
const FOARotator = __nested_webpack_require_211260__(3);
const FOARouter = __nested_webpack_require_211260__(2);
const FOAVirtualSpeaker = __nested_webpack_require_211260__(7);
const HOAConvolver = __nested_webpack_require_211260__(8);
const HOARenderer = __nested_webpack_require_211260__(16);
const HOARotator = __nested_webpack_require_211260__(9);
const Polyfill = __nested_webpack_require_211260__(19);
const Utils = __nested_webpack_require_211260__(0);
const Version = __nested_webpack_require_211260__(20);

// DEPRECATED in V1, in favor of BufferList.
const AudioBufferManager = __nested_webpack_require_211260__(5);


/**
 * Omnitone namespace.
 * @namespace
 */
let Omnitone = {};


/**
 * @typedef {Object} BrowserInfo
 * @property {string} name - Browser name.
 * @property {string} version - Browser version.
 */

/**
 * An object contains the detected browser name and version.
 * @memberOf Omnitone
 * @static {BrowserInfo}
 */
Omnitone.browserInfo = Polyfill.getBrowserInfo();


// DEPRECATED in V1. DO. NOT. USE.
Omnitone.loadAudioBuffers = function(context, speakerData) {
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(context, speakerData, function(buffers) {
      resolve(buffers);
    }, reject);
  });
};


/**
 * Performs the async loading/decoding of multiple AudioBuffers from multiple
 * URLs.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} [options] - BufferList options.
 * @param {String} [options.dataType='url'] - BufferList data type.
 * @return {Promise<AudioBuffer[]>} - The promise resolves with an array of
 * AudioBuffer.
 */
Omnitone.createBufferList = function(context, bufferData, options) {
  const bufferList =
      new BufferList(context, bufferData, options || {dataType: 'url'});
  return bufferList.load();
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
Omnitone.mergeBufferListByChannel = Utils.mergeBufferListByChannel;


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
Omnitone.splitBufferbyChannel = Utils.splitBufferbyChannel;


/**
 * Creates an instance of FOA Convolver.
 * @see FOAConvolver
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * @return {FOAConvolver}
 */
Omnitone.createFOAConvolver = function(context, hrirBufferList) {
  return new FOAConvolver(context, hrirBufferList);
};


/**
 * Create an instance of FOA Router.
 * @see FOARouter
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 * @return {FOARouter}
 */
Omnitone.createFOARouter = function(context, channelMap) {
  return new FOARouter(context, channelMap);
};


/**
 * Create an instance of FOA Rotator.
 * @see FOARotator
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOARotator}
 */
Omnitone.createFOARotator = function(context) {
  return new FOARotator(context);
};


/**
 * Create an instance of FOAPhaseMatchedFilter.
 * @ignore
 * @see FOAPhaseMatchedFilter
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOAPhaseMatchedFilter}
 */
Omnitone.createFOAPhaseMatchedFilter = function(context) {
  return new FOAPhaseMatchedFilter(context);
};


/**
 * Create an instance of FOAVirtualSpeaker. For parameters, refer the
 * definition of VirtualSpeaker class.
 * @ignore
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options.
 * @return {FOAVirtualSpeaker}
 */
Omnitone.createFOAVirtualSpeaker = function(context, options) {
  return new FOAVirtualSpeaker(context, options);
};


/**
 * DEPRECATED. Use FOARenderer instance.
 * @see FOARenderer
 * @param {AudioContext} context - Associated AudioContext.
 * @param {DOMElement} videoElement - Video or Audio DOM element to be streamed.
 * @param {Object} options - Options for FOA decoder.
 * @param {String} options.baseResourceUrl - Base URL for resources.
 * (base path for HRIR files)
 * @param {Number} [options.postGain=26.0] - Post-decoding gain compensation.
 * @param {Array} [options.routingDestination]  Custom channel layout.
 * @return {FOADecoder}
 */
Omnitone.createFOADecoder = function(context, videoElement, options) {
  Utils.log('WARNING: FOADecoder is deprecated in favor of FOARenderer.');
  return new FOADecoder(context, videoElement, options);
};


/**
 * Create a FOARenderer, the first-order ambisonic decoder and the optimized
 * binaural renderer.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {FOARenderer}
 */
Omnitone.createFOARenderer = function(context, config) {
  return new FOARenderer(context, config);
};


/**
 * Creates HOARotator for higher-order ambisonics rotation.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 * @return {HOARotator}
 */
Omnitone.createHOARotator = function(context, ambisonicOrder) {
  return new HOARotator(context, ambisonicOrder);
};


/**
 * Creates HOAConvolver performs the multi-channel convolution for the optmized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 * @return {HOAConvovler}
 */
Omnitone.createHOAConvolver = function(
    context, ambisonicOrder, hrirBufferList) {
  return new HOAConvolver(context, ambisonicOrder, hrirBufferList);
};


/**
 * Creates HOARenderer for higher-order ambisonic decoding and the optimized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {HOARenderer}
 */
Omnitone.createHOARenderer = function(context, config) {
  return new HOARenderer(context, config);
};


// Handler Preload Tasks.
// - Detects the browser information.
// - Prints out the version number.
(function() {
  Utils.log('Version ' + Version + ' (running ' +
      Omnitone.browserInfo.name + ' ' + Omnitone.browserInfo.version +
      ' on ' + Omnitone.browserInfo.platform +')');
  if (Omnitone.browserInfo.name.toLowerCase() === 'safari') {
    Polyfill.patchSafari();
    Utils.log(Omnitone.browserInfo.name + ' detected. Appliying polyfill...');
  }
})();


module.exports = Omnitone;


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_219960__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOA decoder, DEPRECATED in favor of FOARenderer.
 */



const AudioBufferManager = __nested_webpack_require_219960__(5);
const FOARouter = __nested_webpack_require_219960__(2);
const FOARotator = __nested_webpack_require_219960__(3);
const FOAPhaseMatchedFilter = __nested_webpack_require_219960__(6);
const FOAVirtualSpeaker = __nested_webpack_require_219960__(7);
const FOASpeakerData = __nested_webpack_require_219960__(13);
const Utils = __nested_webpack_require_219960__(0);

// By default, Omnitone fetches IR from the spatial media repository.
const HRTFSET_URL = 'https://raw.githubusercontent.com/GoogleChrome/omnitone/master/build/resources/';

// Post gain compensation value.
let POST_GAIN_DB = 0;


/**
 * Omnitone FOA decoder.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {VideoElement} videoElement - Target video (or audio) element for
 * streaming.
 * @param {Object} options
 * @param {String} options.HRTFSetUrl - Base URL for the cube HRTF sets.
 * @param {Number} options.postGainDB - Post-decoding gain compensation in dB.
 * @param {Number[]} options.channelMap - Custom channel map.
 */
function FOADecoder(context, videoElement, options) {
  this._isDecoderReady = false;
  this._context = context;
  this._videoElement = videoElement;
  this._decodingMode = 'ambisonic';

  this._postGainDB = POST_GAIN_DB;
  this._HRTFSetUrl = HRTFSET_URL;
  this._channelMap = FOARouter.ChannelMap.DEFAULT; // ACN

  if (options) {
    if (options.postGainDB) {
      this._postGainDB = options.postGainDB;
    }
    if (options.HRTFSetUrl) {
      this._HRTFSetUrl = options.HRTFSetUrl;
    }
    if (options.channelMap) {
      this._channelMap = options.channelMap;
    }
  }

  // Rearrange speaker data based on |options.HRTFSetUrl|.
  this._speakerData = [];
  for (let i = 0; i < FOASpeakerData.length; ++i) {
    this._speakerData.push({
      name: FOASpeakerData[i].name,
      url: this._HRTFSetUrl + '/' + FOASpeakerData[i].url,
      coef: FOASpeakerData[i].coef,
    });
  }

  this._tempMatrix4 = new Float32Array(16);
}


/**
 * Initialize and load the resources for the decode.
 * @return {Promise}
 */
FOADecoder.prototype.initialize = function() {
  Utils.log('Initializing... (mode: ' + this._decodingMode + ')');

  // Rerouting channels if necessary.
  let channelMapString = this._channelMap.toString();
  let defaultChannelMapString = FOARouter.ChannelMap.DEFAULT.toString();
  if (channelMapString !== defaultChannelMapString) {
    Utils.log('Remapping channels ([' + defaultChannelMapString + '] -> ['
      + channelMapString + '])');
  }

  this._audioElementSource =
      this._context.createMediaElementSource(this._videoElement);
  this._foaRouter = new FOARouter(this._context, this._channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaPhaseMatchedFilter = new FOAPhaseMatchedFilter(this._context);

  this._audioElementSource.connect(this._foaRouter.input);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaPhaseMatchedFilter.input);

  this._foaVirtualSpeakers = [];

  // Bypass signal path.
  this._bypass = this._context.createGain();
  this._audioElementSource.connect(this._bypass);

  // Get the linear amplitude from the post gain option, which is in decibel.
  const postGainLinear = Math.pow(10, this._postGainDB/20);
  Utils.log('Gain compensation: ' + postGainLinear + ' (' + this._postGainDB
    + 'dB)');

  // This returns a promise so developers can use the decoder when it is ready.
  const that = this;
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(that._context, that._speakerData,
      function(buffers) {
        for (let i = 0; i < that._speakerData.length; ++i) {
          that._foaVirtualSpeakers[i] = new FOAVirtualSpeaker(that._context, {
            coefficients: that._speakerData[i].coef,
            IR: buffers.get(that._speakerData[i].name),
            gain: postGainLinear,
          });

          that._foaPhaseMatchedFilter.output.connect(
            that._foaVirtualSpeakers[i].input);
        }

        // Set the decoding mode.
        that.setMode(that._decodingMode);
        that._isDecoderReady = true;
        Utils.log('HRTF IRs are loaded successfully. The decoder is ready.');
        resolve();
      }, reject);
  });
};

/**
 * Set the rotation matrix for the sound field rotation.
 * @param {Array} rotationMatrix      3x3 rotation matrix (row-major
 *                                    representation)
 */
FOADecoder.prototype.setRotationMatrix = function(rotationMatrix) {
  this._foaRotator.setRotationMatrix(rotationMatrix);
};


/**
 * Update the rotation matrix from a Three.js camera object.
 * @param  {Object} cameraMatrix      The Matrix4 obejct of Three.js the camera.
 */
FOADecoder.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};

/**
 * Set the decoding mode.
 * @param {String} mode               Decoding mode. When the mode is 'bypass'
 *                                    the decoder is disabled and bypass the
 *                                    input stream to the output. Setting the
 *                                    mode to 'ambisonic' activates the decoder.
 *                                    When the mode is 'off', all the
 *                                    processing is completely turned off saving
 *                                    the CPU power.
 */
FOADecoder.prototype.setMode = function(mode) {
  if (mode === this._decodingMode) {
    return;
  }

  switch (mode) {
    case 'bypass':
      this._decodingMode = 'bypass';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.connect(this._context.destination);
      break;

    case 'ambisonic':
      this._decodingMode = 'ambisonic';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].enable();
      }
      this._bypass.disconnect();
      break;

    case 'off':
      this._decodingMode = 'off';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.disconnect();
      break;

    default:
      break;
  }

  Utils.log('Decoding mode changed. (' + mode + ')');
};

module.exports = FOADecoder;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data for FOAVirtualSpeaker. Each entry contains the URL for IR files and
 * the gain coefficients for the associated IR files. Note that the order of
 * coefficients follows the ACN channel ordering. (W,Y,Z,X)
 * @type {Object[]}
 */
const FOASpeakerData = [{
  name: 'E35_A135',
  url: 'E35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, -0.216495],
}, {
  name: 'E35_A-135',
  url: 'E35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, -0.216495],
}, {
  name: 'E-35_A135',
  url: 'E-35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, -0.216495],
}, {
  name: 'E-35_A-135',
  url: 'E-35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, -0.216495],
}, {
  name: 'E35_A45',
  url: 'E35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, 0.216495],
}, {
  name: 'E35_A-45',
  url: 'E35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, 0.216495],
}, {
  name: 'E-35_A45',
  url: 'E-35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, 0.216495],
}, {
  name: 'E-35_A-45',
  url: 'E-35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, 0.216495],
}];


module.exports = FOASpeakerData;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_229122__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOARenderer. This is user-facing API for the first-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_229122__(1);
const FOAConvolver = __nested_webpack_require_229122__(4);
const FOAHrirBase64 = __nested_webpack_require_229122__(15);
const FOARotator = __nested_webpack_require_229122__(3);
const FOARouter = __nested_webpack_require_229122__(2);
const Utils = __nested_webpack_require_229122__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


/**
 * Omnitone FOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function FOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('FOARenderer: Invalid BaseAudioContext.');

  this._config = {
    channelMap: FOARouter.ChannelMap.DEFAULT,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config) {
    if (config.channelMap) {
      if (Array.isArray(config.channelMap) && config.channelMap.length === 4) {
        this._config.channelMap = config.channelMap;
      } else {
        Utils.throw(
            'FOARenderer: Invalid channel map. (got ' + config.channelMap
            + ')');
      }
    }

    if (config.hrirPathList) {
      if (Array.isArray(config.hrirPathList) &&
          config.hrirPathList.length === 2) {
        this._config.pathList = config.hrirPathList;
      } else {
        Utils.throw(
            'FOARenderer: Invalid HRIR URLs. It must be an array with ' +
            '2 URLs to HRIR files. (got ' + config.hrirPathList + ')');
      }
    }

    if (config.renderingMode) {
      if (Object.values(RenderingMode).includes(config.renderingMode)) {
        this._config.renderingMode = config.renderingMode;
      } else {
        Utils.log(
            'FOARenderer: Invalid rendering mode order. (got' +
            config.renderingMode + ') Fallbacks to the mode "ambisonic".');
      }
    }
  }

  this._buildAudioGraph();

  this._tempMatrix4 = new Float32Array(16);
  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
FOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._foaRouter = new FOARouter(this._context, this._config.channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaConvolver = new FOAConvolver(this._context);
  this.input.connect(this._foaRouter.input);
  this.input.connect(this._bypass);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaConvolver.input);
  this._foaConvolver.output.connect(this.output);

  this.input.channelCount = 4;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
FOARenderer.prototype._initializeCallback = function(resolve, reject) {
  const bufferList = this._config.pathList
      ? new BufferList(this._context, this._config.pathList, {dataType: 'url'})
      : new BufferList(this._context, FOAHrirBase64);
  bufferList.load().then(
      function(hrirBufferList) {
        this._foaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('FOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'FOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
FOARenderer.prototype.initialize = function() {
  Utils.log(
      'FOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('FOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Set the channel map.
 * @param {Number[]} channelMap - Custom channel routing for FOA stream.
 */
FOARenderer.prototype.setChannelMap = function(channelMap) {
  if (!this._isRendererReady) {
    return;
  }

  if (channelMap.toString() !== this._config.channelMap.toString()) {
    Utils.log(
        'Remapping channels ([' + this._config.channelMap.toString() +
        '] -> [' + channelMap.toString() + ']).');
    this._config.channelMap = channelMap.slice();
    this._foaRouter.setChannelMap(this._config.channelMap);
  }
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the rotation matrix from a Three.js camera object. Depreated in V1, and
 * this exists only for the backward compatiblity. Instead, use
 * |setRotatationMatrix4()| with Three.js |camera.worldMatrix.elements|.
 * @deprecated
 * @param {Object} cameraMatrix - Matrix4 from Three.js |camera.matrix|.
 */
FOARenderer.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  if (!this._isRendererReady) {
    return;
  }

  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};


/**
 * Set the rendering mode.
 * @param {RenderingMode} mode - Rendering mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
FOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._foaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._foaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._foaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'FOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('FOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = FOARenderer;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

const OmnitoneFOAHrirBase64 = [
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD+/wIA9v8QAPv/CwD+/wcA/v8MAP//AQD7/wEACAAEAPj/+v8YABAA7v/n//v/9P/M/8D//f34/R38EvzxAfEBtA2lDTcBJQFJ9T71FP0D/cD1tfVo/Wv9uPTO9PPmOufc/U/+agL3Aisc/RxuGKEZBv3j/iYMzQ2gAzsEQQUABiQFrASzA5cB2QmyCy0AtgR4AeYGtfgAA2j5OQHP+scArPsMBJgEggIEBtz6+QVq/pj/aPg8BPP3gQEi+jEAof0fA1v9+/7S+8IBjvwd/xD4IADL/Pf9zvs+/l3+wgB7/+L+7fzFADH9kf6A+n3+DP6+/TP9xP68/pn+w/26/i39YgA0/u790Pt9/kD+7v1s/Wb+8f4C/1P+pf/x/cT+6/3p/Xz9ff5F/0f9G/4r/6v/4P5L/sL+ff7c/pj+Ov7X/UT+9P5G/oz+6v6A/2D+9/6P/8r/bP7m/ij+C//e/tj/Gf4e/9v+FwDP/lz/sP7F/2H+rv/G/s7/Hf7y/4P+NAD9/k0AK/6w/zP/hACh/sX/gf44AOP+dgCm/iUAk/5qAOD+PwC+/jEAWP4CAAr/bQBw/vv/zf5iACD/OgCS/uD/Cv9oAAb/CgDK/kwA//5tACH/TgCg/h4AHP9aABP/JADP/hEAYv9gAAj/3f8m/ysAYv8gACX/8/8k/ysAXv8bABH//v8j/ygAa/8qAAD/9f9g/1YAWf8JACH/AgB2/z4AXP/w/z3/FgB2/ykAX//9/z//EwCV/zUAS//n/1T/GACK/x4ATv/0/4P/QQB4//v/WP/2/3X/HAB8//P/V//3/2f/AQBh/9v/Tf/x/5P/IwCI/wMAf/8hAKP/JACZ/xUAiv8nAK//HgCr/yMAm/8uAMz/OACi/yQAqf87AMT/MwCY/yUAtP9FAMH/KgCu/ycAyP85AMv/IwCz/xoA1f8qAMn/FgC8/xQA4/8nAMX/CwDJ/xQA4f8ZAMH/BgDO/xQA4f8WAMP/BwDU/xQA4P8QAMH/AQDb/xQA3P8JAMP/AgDh/xIA2v8EAMj/AgDk/w0A1f/+/8v/AwDm/wwA0v/+/9H/BgDl/wkAzv/8/9T/BwDk/wcAzv/8/9r/CQDi/wQAzf/8/9//CADf////0P/9/+L/BwDd//7/0////+T/BgDb//z/1f8AAOf/BQDZ//v/2v8CAOb/AwDY//v/3v8EAOb/AgDY//3/4f8FAOX/AQDZ//7/5P8GAOP/AADb/wAA5/8GAOH////d/wIA5/8FAOD////f/wMA6P8FAOD////h/wQA6P8EAN7////h/wUA4v8DANv/AQDd/wQA3P8CANn/AgDb/wMA2/8CANv/AgDd/wIA3v8CAOH/AQDj/wEA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAAAA/f8CAP//AQD//wEA//8BAP3/AAACAP7/+f8AAAIA/P8FAAQA8/8AABoA+f/V/wQAHQDO/xoAQQBO/ocA0Px1/ucHW/4UCm8HLO6kAjv8/fCRDdAAYfPiBIgFXveUCM0GBvh6/nz7rf0J/QcQSRVdBgoBSgFR62r9NP8m+LoEAvriBVAAiAPmABEGMf2l+SwBjva6/G4A//8P/CYDMgXm/R0CKAE6/fcBBwAtAND+kQA0A5UDhwFs/8IB8fydAEP/A/8v/e7/mP8j/2YBIwE3Av0AYv+uAOD8lgAg/wwAIf/L/n0Ae//OAJMB3P/XAF//XwCM/08AB/8NAEf/rf4jAT3/lgAJAP4AHgDpAO8AUf9L/07/Qf8KAOD/x/+D/3sATQCDAMoA0f79/+L/EQDt/7EAqv+S/7IAuv/o/wgAc//X//H/SwCm/+3/Yf/B/yoAAADI/7X/AwBg/5EATgCX/xYA/P+q/00AVACY/6v/BADD/zwALQCN/8z/KQDu/ygAEgCZ/6f/VQDC//T/KQCs/7P/UgAfAO7/NgC8/57/awAZAPP/+P/V/8z/bQBBAL//DgD0/+T/TABBAMz/CwAxAPz/SQBqALn/BgALAPz/EAA7AIz/3/8iAAUA//8kALf/y/9VABQA+v81AOj/0P9cAB4A+f8WAOr/vv83ABgAw/8JAOj/4f8nACIAsf/y/w4A3v8gACQAxP/n/ycA7P8WAC0Ayf/U/ycA9v/7/yUA0P/P/zUABADc/xUA5P/J/zcACwDS/xUA9P/m/zAACQDX/+3/9v/2/yQACgDZ/+P/AwAKABYA///b/9j/EQALABkADgD6/+7/GwD4/w4A8P/w//j/EgAEAAUA9f/1/wQAGgD4/wAA5////wAAGQD1////7f8FAAUAFQDv/wAA6v8LAAcAFQDs/wEA9P8SAAYACwDr//7/AQASAAYABQDv/wIAAwAWAAIAAgDv/wAABgATAAEA/f/u/wQABgAQAPr/+P/z/wUACQALAPj/9//4/wgABwAKAPT/+f/5/w4ABwAIAPT/+//9/w4AAwADAPH//f///w8A//8BAPP///8BAA0A/f/+//X/AgACAA0A+//8//b/BAADAAoA+f/7//n/BgADAAcA+P/7//v/BwABAAQA+P/8//3/CQABAAIA9//9////CQD/////+P///wAACAD9//7/+f8AAAAABwD8//3/+v8CAAAABgD7//z//P8EAAAABAD6//3//P8FAP//AgD6//7//v8FAP7/AQD7//////8GAP7/AAD7/wEA//8EAP3/AAD9/wEA/v8DAP3/AAD9/wIA/v8CAP3/AQD9/wIA/v8CAP7/AQD+/wEA",
];

module.exports = OmnitoneFOAHrirBase64;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_240610__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone HOARenderer. This is user-facing API for the higher-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_240610__(1);
const HOAConvolver = __nested_webpack_require_240610__(8);
const HOARotator = __nested_webpack_require_240610__(9);
const TOAHrirBase64 = __nested_webpack_require_240610__(17);
const SOAHrirBase64 = __nested_webpack_require_240610__(18);
const Utils = __nested_webpack_require_240610__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


// Currently SOA and TOA are only supported.
const SupportedAmbisonicOrder = [2, 3];


/**
 * Omnitone HOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function HOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('HOARenderer: Invalid BaseAudioContext.');

  this._config = {
    ambisonicOrder: 3,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config && config.ambisonicOrder) {
    if (SupportedAmbisonicOrder.includes(config.ambisonicOrder)) {
      this._config.ambisonicOrder = config.ambisonicOrder;
    } else {
      Utils.log(
          'HOARenderer: Invalid ambisonic order. (got ' +
          config.ambisonicOrder + ') Fallbacks to 3rd-order ambisonic.');
    }
  }

  this._config.numberOfChannels =
      (this._config.ambisonicOrder + 1) * (this._config.ambisonicOrder + 1);
  this._config.numberOfStereoChannels =
      Math.ceil(this._config.numberOfChannels / 2);

  if (config && config.hrirPathList) {
    if (Array.isArray(config.hrirPathList) &&
        config.hrirPathList.length === this._config.numberOfStereoChannels) {
      this._config.pathList = config.hrirPathList;
    } else {
      Utils.throw(
          'HOARenderer: Invalid HRIR URLs. It must be an array with ' +
          this._config.numberOfStereoChannels + ' URLs to HRIR files.' +
          ' (got ' + config.hrirPathList + ')');
    }
  }

  if (config && config.renderingMode) {
    if (Object.values(RenderingMode).includes(config.renderingMode)) {
      this._config.renderingMode = config.renderingMode;
    } else {
      Utils.log(
          'HOARenderer: Invalid rendering mode. (got ' +
          config.renderingMode + ') Fallbacks to "ambisonic".');
    }
  }

  this._buildAudioGraph();

  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
HOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._hoaRotator = new HOARotator(this._context, this._config.ambisonicOrder);
  this._hoaConvolver =
      new HOAConvolver(this._context, this._config.ambisonicOrder);
  this.input.connect(this._hoaRotator.input);
  this.input.connect(this._bypass);
  this._hoaRotator.output.connect(this._hoaConvolver.input);
  this._hoaConvolver.output.connect(this.output);

  this.input.channelCount = this._config.numberOfChannels;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
HOARenderer.prototype._initializeCallback = function(resolve, reject) {
  let bufferList;
  if (this._config.pathList) {
    bufferList =
        new BufferList(this._context, this._config.pathList, {dataType: 'url'});
  } else {
    bufferList = this._config.ambisonicOrder === 2
        ? new BufferList(this._context, SOAHrirBase64)
        : new BufferList(this._context, TOAHrirBase64);
  }

  bufferList.load().then(
      function(hrirBufferList) {
        this._hoaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('HOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'HOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
HOARenderer.prototype.initialize = function() {
  Utils.log(
      'HOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ', ambisonic order: ' + this._config.ambisonicOrder + ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('HOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the decoding mode.
 * @param {RenderingMode} mode - Decoding mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
HOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._hoaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._hoaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._hoaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'HOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('HOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = HOARenderer;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

const OmnitoneTOAHrirBase64 = [
"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AAD7/wEAAgD7//7/AQD8/wAAAwD8//3/AwD9/wAAAgD9//z/AwD/////AgD+//z/AwAAAP7/AQD///3/AgABAP3/AAAAAP3/AgACAPz///8BAP3/AQACAP3//v8BAP7/AAABAP3//v8CAP7///8BAP7//f8CAP////8AAAAA/v8CAAAAAAAAAAAA/v8BAAAAAAD//wAA//8AAP//AAD//wAA//8AAP//",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA/////wAAAQD+////AAAGAP3/OAABAIIAAwBv//f/E/0QAK0ADQCzA/7/8P4u/0cBDQCJA6ABbQDg/w7/z/9o+Vn/SPnL/1//Ef+2+jr9RfZgA5QFZwILDFj+PAb2/nEFKgKk/R0Dlv6b/FUDsP6YAoj9SgAT/iL/tAPwAv8A0P6zAr7/dwAnAf39uP22/skA2v///2YCoP4UAUsAZgF2AJH+4P70/rz9+f+U/Xv/8v7CAcb+TACS/kwAv/+x/tX9oP71/oL/1f8nAEUAZwGtAAgAIgC/AD4BaP8GAGH/dQDF/64Arf8nAakAhAH9/+kAQQD3AFb/q/8p/yIAR/8FAPD/ZAA/AIYA3v8tADQADQBp/3f/CwABAP3/Wf8OANj/WwDH/xoAe/8DAKz/zv96/z8A3f/J/5X/IAD5//j/q//c/+//RADq//D/vv8pADUAFQDI/y8ACAAbANb/OwD3/+3/9f/e/wcAIAAeAMH/8/8xAC0AEADW/+3/HAADAPv/8P8DAOL/OwD3/xcACQAHAM//5f8XAAcAz//T/9D/HgD9////yf/e//v/AgD//9H/6/////H/+/8hAAIA9//7/w0AFgAQAPL/2v/8/xsAGQABANz/9P8YAAQA/v/y/wMA5v8YAAkAAAAAAAMA7/8KABgADwDs//j/BwATABsA8P/1//z/BAAMAAAA9P/s/xAA/v8GAAkA/v/p/wMACwALAP7/9P/p/wcADQAFAPb/7//4/w0ACAD8//b//v/1/wMACwD1//T/8P/8/wAACQDz/+f/5P8GAAkABQD5//D/+v8FAA0AAwD///T/AgACABAA/v8CAPD/+/8FAAoA9f/3//f//v8GAP7/9v/t//z/+f8AAPj/+v/3/wEA+v8HAPr//P/5/wQA//8DAPr/+P/3/wYA///+//X/+//5/wQA/f/7//X/+//4/wMA/f/8//j//v/9/wYA///8//f/AgAAAAUA/f/6//n/AwACAAIA/f/7//z/AwACAAAA/f/6//3/AgADAP7//f/7/wAAAwAFAPz////8/wMAAgAEAPv//v/+/wMAAgADAPv//v///wMAAQABAPv//f8AAAIAAAD///v//f8BAAIA///+//z//v8CAAIA/v/9//3///8CAAEA/v/9//7/AAACAAAA/v/9////AAABAAAA/f/9/wAAAQABAP///f/+/wEAAQAAAP///v/+/wEAAQD///7//v///wEAAQD///7//v///wEAAAD+//7///8AAAAAAAD+//7///8AAAAA///+//7///8AAAAA////////AAAAAP////////////8AAP//////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAAAAAAABAAAAAAD//////////////v////3/////////+//8////AQD9//z/9f8BAAIA+f8dACgAWQBxAJX/qv+Y/uz9aP9k/7UDUQQBAiQA4Pgi/AkB0gKaBsD/+fxp/vz9CQSp/I/+ywDO+vMD0fzK/PABcgBeBfoBv/+uAuH9Sf5gAy39awMmBWUBuP9fA9/9fgDj/2/+EACaACcCSv9Z/2j/rv7hAA0AWf55/7L84P7E/SIAT/67AMv/tf+FAA7/1v+7/gv/IP+E/sQA+P5aAXz/tP9XAFX/tP8o/4r/j//e/yQAMv9mAJT/rgCr/9X/EwCb//H/9f7F/6D/EAAoAK3//v+e/zsAh/+B/7r/if/C/2r/4P/z/6//HwCy/0IA7/9ZALT/y/80ACgA9v/J/9//DgA5ADUALQARADIACwAfAOf/NgArACMACQBBAEcAGAAjAC4AWQBUAHcAAAAfACEAIAAcAPj/CADk/yQA7v89AEEAFwD5/xYA6f8aAOX/AADF/zQADwAUAOT/BQDr/yUA6P8XAOf/HADR/0AA8P8nAAgACQDt/ycAKAAHAPH/IQDz/xsACADn//n/DgADAA4A8P///8z/GgDN/yMA/f8QANj/MwACAC0ACwAOAO3/JgAZAAUACgAAAA4AIgAaAAkADwACAAAAHQATAAUABQACAAgACwAjAO////8AAA8ABQAPAPL//f8GAAsABgAGAPD/8v8GAPz/CAD6//H/6v8PAAgABgD4//3/9v8aAAgABwD1//7//v8QAAoACAD//wUA9v8QAAoABAAFAAgAAgAJAAoAAwD//w0AAgD//wcA/v8DAAoABQAFABUABAAKAAYABwAHAA8ACgAGAAwADwAMAAkAEAAJAAgADwAMAAgADgAJAAUACQAPAAUACwAHAAEABgAIAAEABAAGAP//AgAJAAAAAgAEAP7///8IAAIA//8GAAEAAQAJAAIA/v8EAAMA//8JAAEA/v8DAAMA/v8HAAMA/f8BAAUA/v8FAAMA/v8BAAcA//8DAAMA/v8BAAYA//8CAAMA/////wcAAAAAAAMAAAD//wYAAQD+/wMAAQD//wUAAQD+/wIAAgD//wQAAgD+/wEAAwD//wMAAwD+/wEAAwD//wIAAwD//wEABAAAAAEABAD//wAABAABAAAAAwAAAAAABAABAP//AwABAAAAAwACAP//AgACAAAAAwACAP//AgACAAAAAgACAAAAAQADAAAAAQACAAAAAQADAAAAAQACAAAAAAACAAEAAAACAAEAAAACAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAAAAAAAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA//8AAP//AAACAAAA+f8BAAYA///4/wIA//8AAA8A/v/V/wEAEwA9AAEBRwA2AF7/kfog/3gBwv99CDYBU/qtAUX/AP7OAfkAX/o9B38FSfwaAuT14/60BAr8CQAI/tfyIQTzAXP+egdUBBwBof7TBMT8bAWi/5EEWwBRAAAKyfxE/8b88vp6ACP+PAF4/qD8MQNM/ygCJ/2XAPD9kP5gAVT/iP9I/lEB4P8qAD0BFAGa/+7/DgB2AOP98gFm/u/+Vv5/AG8ASP9gAM//qv9w//oAcv+2/jIBHgA7/6D/oAAGAKH/lADT/wAAggC8AAYAkP9yAEcAkf8BAOD/RAAr/zUANwDt/xQAJQAkAMT/zwA/AOH/xv9zAGsANQBTAIcALAAvACIATACy/xMADADg/xcAWABvAJL/7f9VAPb/EgDt/wcA4f8kAPP/5P+h/wgACQDy//r/LgAQAMn/8/9CAOX/5v/S/9//3P8pABYAuP/s/w8AFgDt/+3/7v/w/9j/5/8GAOf/2P/2//P//v8kABMAuf/m/xoADADZ/+r/3P8KAAUAKwDe/wsA3P8VAAAADgAfAB0ACAAMAF4AGgAhAPL/MwDz/0kABAAKAPX/LwAbAAkA9v/s/+3/8/8CABAAAADm//n/BQALAAUAAQDj//n/JQAVAPX/9v/+/wIAEQABAPP/8P/1/wAABgD6/+3/7//o//j/DAD8/+b/8P8IAAkABgD4//D/8P8UAAoAAwD4/wAA+f8OAAcAAAAFAPX/9v8TAAkA8v8EAPb/9/8dAA0A7/8CAPn/+f8SAAQA8/8CAOf/+v8DAAgA9P////H//P8IAAUA8//0/wIAAQAGAAgA9//7/wAA+/8EAP//+P/+////AgACAAsA8v/+/wIABQD7/wgA9v/7/wMABAD5/wAA/P/3/wEAAQD7//7//P/1/wQA///3//r////3/wMAAwD1//r/AwD6////AgD4//n/AwD8//7/AgD4//n/AwD+//3/AQD4//n/BQD///n/AAD6//j/BAABAPj/AAD9//v/AwADAPj//v/+//z/AwAEAPj//v8BAP7/AQADAPj//f8CAP////8EAPr//P8DAAAA/v8CAPv//P8DAAEA/f8BAP3//f8DAAIA/P8AAP7//f8DAAIA/P///wAA/f8BAAIA+//+/wEA//8AAAEA+//+/wEA/////wEA/P/+/wEA///+/wAA/f/9/wEAAAD9/wAA/f/+/wEAAQD8/////v/+/wAAAQD8////////////AQD9////AAD/////AAD+////AAAAAP//AAD///////8AAP//AAD//wAA//8AAP//",
];

module.exports = OmnitoneTOAHrirBase64;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

const OmnitoneSOAHrirBase64 = [
"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/P////v//P8CAAQA+//+//3//f8CAAUA+v/9//////8AAAQA+v/8////AAD//wIA+//8/wAAAQD+/wEA+//8/wAAAgD9/////P/9/wEAAgD8//7//f/9/wAAAgD8//3//v/+////AQD8//z/////////AAD8//3///8AAP7/AAD9//7///8AAP7////+//////8AAP7////+////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD//////v8AAP///////wAAAAAAAP7/AQABAAAABwD///X/BQAjAPL/CQDb/9D/GAAb/7sAYwCW/z0BcP/X/7T/2QDW+wH8yANCCCUJ5QT++UXmhPwhA78FuAxH+p78ifudBlAG9vmu/lAK2fdlB///cfjoCa0E7Akn9Yb/zvba+AkAHPywBGEBFwUNAL8AXAAGA20DFvmR/kz+F/06Ag/+GwHl/5EEKgJd/q0AP/ym/9n6EfxY/2H+/QFtAC4C6QBDAaMCo/20/+3/3f/p/fL9rv9V/6cBhQHuAX4AcwJYAaH/IP/P/gsApP0LAe7/sQBuAI0AAgGDAE4BzACe/5X//v+v/+f+Zf+gAOv/5QBhAOIApAANASYAuP+h/8b/HQBr/9//bACWAGEAFAB5AD0AWQDU/+D/Yf/p//D/s/+R/4QAMQBvABEAkQBfABQAJgDW/wwA8/8XALz/vf8zAFAAKwD1/zEAPwDJ/x0A7/8LAOX/FwDR//H/EQAdAO//6P8QAFEA2f8WABEAMgDy/xIA+f/s/xAALgDv////HQAvAPT/+f8iAAYAEgAFABoAGgD//w0A+f/0/xsAHgDx/9f/GAACAPH/8f8JAPf/GwALABEA7/8cAPT/CgD2//j/BQD8/+3/OgAgAAYA9f8PAN7/DgD9/9r/1//3/+3/9//1//b/8//5//f/AgAJAOf/+v8OAAMACwD9/+7/5f8eAAEA9//q//7/8P8WAP7/+//4/wIA+f8TAAIA9f/5/wcA+P8iAAgA9v/n/xoA//8gAAUABwDj/wAA9v8BAAUAFQDn/wMA7v8QABAAEQDm/wwA8f8aAAAABwDu/wcACgASAAEA7//w//f/BgARAAkA6P/3/wcADgAKAAYA4f/4/wYADgAAAPr/8P/9/xQACgAHAPn/7//9/xEAAgD+//L/8v/8/xUAAwDw//H/9f8CAAsA/v/q//L/+f8FAAYA/P/r//j///8GAAkA+//o//j/AQAIAP//+v/o//v/CAAIAPv/+P/w/wEACQAHAPj/+f/0/wIACwAFAPb/+f/4/wQACwACAPP/+f/+/wYACAD///L/+/8BAAYABQD9//P//P8FAAUAAgD7//T//f8HAAQA///7//f///8IAAMA/P/6//r/AQAIAAEA+v/6//3/AgAHAAAA+f/7/wAAAwAFAP7/+P/8/wIAAgACAP3/+f/9/wMAAwAAAPz/+v/+/wQAAgD+//z/+/8AAAQAAQD8//z//f8BAAQAAAD7//3///8BAAMA///7//3/AAACAAEA/v/7//7/AQABAAAA/v/9////AQAAAP///v/+////AAD/////////////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD////////+//////8AAAAA/v/+/wAAAQD8//3/CQAJAP3/+v8PAAcApABlABkBkwCO/i//lfqa/HQAcf/3BdkCzwJcBCMC0wMN/9/9wgI7AaECYfxV/Tf83vhn/xrt8Owx/8n7cgHABYb43QcZDh4WugNrA7P74gHu/9z/zv0t/acCiQHY/iv4qQOl/ysCE/0//XT9Sf4O//j9xfupAn394gHO+rsCXAFIAxQC9wIXBgcD2AQuAnb/9gJh/6wAVfxEAI4Bvf7oAFv/bALsAMQBe/88/joAT/4dAH39/v9LAXn/gwDI//QBdABcAA0A7f4lAMn///+9/tv/iABp/13/pP/dALv/w/8MAHv//f+y/6////7U/5AAZP+Z/8r/nQDR/5r/DwDr/xAA4v+s/3z/+P9uAOv/t/82AGcAHgCb/yQAFQBGAM7/CgD3/xoAegAaAOz/CgBHAA8Adv8/AAAABQC2/xIAAAA7ABQAKgCj/z4AAQAXAJz/JAADAAcA8f/1/2AAAQAlAPD/NgDx/1wA7v/4/wMAZADv//3/HQAkAFoA8P9FAPv/FgBIAPf/WQAHAEUACQD0/xIAQwDu/wMAwP9VALn/XwCw/yEA5f8sAPj/FgDD/1YAyv8rAOX/HQDo//j/IQAQACAAHwD9/yQAHQBAABgABQAiAAUAKAD3/wkACwAKAAMABwAJAPb/+f8GAOr/JQAHABMA6P8TAA4AGgD//woA8/8ZAP//GADu/w0A9v8SAAMABwD4/wQA5P8XAAQACgDq/wUA+/8VAAcACADs/xIAAAATAPH/+v/1//T/7f///+z/+v/y/+//9/8KAAcACgAJAPT/BAAKAAAABgAIAPL/9v8KAAMABAACAPr/9v8OAAIA+P/x//v/+f8MAPb/+P/w/wQA9f8MAPn////7/woA/v8PAAEAAgD1/xAAAQAPAP//AwD//xQABwALAAAABgADABAAAgAHAAAACAABAA8ABQAFAAMABwAEAA4ABwADAAEACQAFAAoAAwD//wAACQADAAUAAQD/////CAABAAMAAAD/////BwACAAEAAAD/////BwACAP7///8BAAAABgABAP7///8CAAAABAAAAP7///8DAAAAAwAAAP3///8DAAAAAQAAAP3//v8EAAAAAAD+//////8EAP/////+/wAA/v8EAP/////+/wEA/v8EAP///v/+/wIA//8DAP///v/+/wIA//8BAP///v/+/wMA//8BAP/////+/wMA//8AAP//AAD+/wQA//8AAP7/AQD//wIA////////AQD//wIA////////AQAAAAEAAAAAAP//AQD//wEAAAAAAP//AQAAAAEAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD+/wAA+v8AAPz/AAD//wAA/f8AAAEAAAD+/wAACQAAAAQAAAAZAAAAtgAAAFsBAABW/gAAH/oAAGcBAABoBwAAlAAAAO3/AAARAQAA+wIAAEoEAACe/gAAiv4AALD0AADJ8wAAkQQAAF34AABi8QAAPQAAAAH2AAD19AAADAMAAJwGAACTEAAA0AwAAJkHAACOBwAAuQEAANcDAAC6AgAAHwUAAHEFAAB0AwAAbgEAADz+AADYAQAAGAAAAJwCAADgAAAA//0AAMn+AAAT/AAAwP8AAOn9AAAJAAAAewEAAOn+AACN/wAAOv0AAO3+AADN/gAAcP8AACj/AACq/gAA+f4AAML9AACa/wAA/f4AAN7/AABo/wAA6/4AAE//AAAC/wAAEQAAAHX/AAB0AAAA5f8AAEwAAAB3AAAA5/8AAMIAAABCAAAAzgAAAE8AAAB3AAAAKAAAADMAAACqAAAALwAAAK4AAAASAAAAVgAAACgAAAAtAAAATAAAAP3/AAA7AAAA2/8AACQAAADw/wAALQAAADEAAAAlAAAAbAAAADMAAABUAAAAEAAAACgAAAD1/wAA9v8AAPr/AADu/wAALgAAABIAAABUAAAARAAAAGUAAABGAAAAOAAAAGAAAAAuAAAARQAAACEAAAAfAAAAAAAAAAkAAAAQAAAAAwAAABIAAADs/wAAEAAAAAYAAAASAAAAIgAAABEAAAADAAAABAAAAA8AAAD4/wAAHQAAAAsAAAAIAAAADgAAAP//AAAcAAAADwAAAAYAAAASAAAAFwAAAAMAAAAYAAAAEgAAAPr/AAAQAAAADQAAAAoAAAD3/wAABgAAAPb/AADf/wAA/v8AAPL/AAD6/wAAFAAAAAQAAAAEAAAAGwAAAAEAAAAMAAAAIAAAAAIAAAAdAAAAGAAAAAIAAAAcAAAAEgAAAAcAAAAeAAAADwAAAAQAAAAeAAAABAAAAAYAAAAZAAAAAQAAAA4AAAATAAAA/v8AAAoAAAAOAAAA+/8AAAsAAAAJAAAA+f8AAAsAAAABAAAA+f8AAAoAAAD9/wAA+v8AAAcAAAD5/wAA+v8AAAUAAAD3/wAA/f8AAAQAAAD2/wAAAAAAAAEAAAD3/wAAAgAAAAAAAAD4/wAAAwAAAP7/AAD6/wAABAAAAP3/AAD8/wAABAAAAPv/AAD+/wAAAwAAAPv/AAD//wAAAQAAAPv/AAAAAAAAAAAAAPv/AAACAAAA//8AAPz/AAACAAAA/v8AAP3/AAACAAAA/f8AAP7/AAABAAAA/f8AAP//AAABAAAA/f8AAAAAAAAAAAAA/v8AAAEAAAAAAAAA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
];

module.exports = OmnitoneSOAHrirBase64;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Cross-browser support polyfill for Omnitone library.
 */




/**
 * Detects browser type and version.
 * @return {string[]} - An array contains the detected browser name and version.
 */
exports.getBrowserInfo = function() {
  const ua = navigator.userAgent;
  let M = ua.match(
      /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) ||
      [];
  let tem;

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return {name: 'IE', version: (tem[1] || '')};
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\bOPR|Edge\/(\d+)/);
    if (tem != null) {
      return {name: 'Opera', version: tem[1]};
    }
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/([\d.]+)/i)) != null) {
    M.splice(1, 1, tem[1]);
  }

  let platform = ua.match(/android|ipad|iphone/i);
  if (!platform) {
    platform = ua.match(/cros|linux|mac os x|windows/i);
  }

  return {
    name: M[0],
    version: M[1],
    platform: platform ? platform[0] : 'unknown',
  };
};


/**
 * Patches AudioContext if the prefixed API is found.
 */
exports.patchSafari = function() {
  if (window.webkitAudioContext && window.webkitOfflineAudioContext) {
    window.AudioContext = window.webkitAudioContext;
    window.OfflineAudioContext = window.webkitOfflineAudioContext;
  }
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone version.
 */




/**
 * Omnitone library version
 * @type {String}
 */
module.exports = '1.0.6';


/***/ })
/******/ ]);
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio version.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * ResonanceAudio library version
 * @type {String}
 */
module.exports = '0.0.4';


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/three/src/math/Euler.js":
/*!**********************************************!*\
  !*** ./node_modules/three/src/math/Euler.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Euler": function() { return /* binding */ Euler; }
/* harmony export */ });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");





const _matrix = /*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_3__.Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];




/***/ }),

/***/ "./node_modules/three/src/math/MathUtils.js":
/*!**************************************************!*\
  !*** ./node_modules/three/src/math/MathUtils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEG2RAD": function() { return /* binding */ DEG2RAD; },
/* harmony export */   "RAD2DEG": function() { return /* binding */ RAD2DEG; },
/* harmony export */   "generateUUID": function() { return /* binding */ generateUUID; },
/* harmony export */   "clamp": function() { return /* binding */ clamp; },
/* harmony export */   "euclideanModulo": function() { return /* binding */ euclideanModulo; },
/* harmony export */   "mapLinear": function() { return /* binding */ mapLinear; },
/* harmony export */   "inverseLerp": function() { return /* binding */ inverseLerp; },
/* harmony export */   "lerp": function() { return /* binding */ lerp; },
/* harmony export */   "damp": function() { return /* binding */ damp; },
/* harmony export */   "pingpong": function() { return /* binding */ pingpong; },
/* harmony export */   "smoothstep": function() { return /* binding */ smoothstep; },
/* harmony export */   "smootherstep": function() { return /* binding */ smootherstep; },
/* harmony export */   "randInt": function() { return /* binding */ randInt; },
/* harmony export */   "randFloat": function() { return /* binding */ randFloat; },
/* harmony export */   "randFloatSpread": function() { return /* binding */ randFloatSpread; },
/* harmony export */   "seededRandom": function() { return /* binding */ seededRandom; },
/* harmony export */   "degToRad": function() { return /* binding */ degToRad; },
/* harmony export */   "radToDeg": function() { return /* binding */ radToDeg; },
/* harmony export */   "isPowerOfTwo": function() { return /* binding */ isPowerOfTwo; },
/* harmony export */   "ceilPowerOfTwo": function() { return /* binding */ ceilPowerOfTwo; },
/* harmony export */   "floorPowerOfTwo": function() { return /* binding */ floorPowerOfTwo; },
/* harmony export */   "setQuaternionFromProperEuler": function() { return /* binding */ setQuaternionFromProperEuler; }
/* harmony export */ });
const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toUpperCase() here flattens concatenated strings to save heap memory space.
	return uuid.toUpperCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

		 } else {

		return 0;

		 }

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s % 2147483647;

	// Park-Miller algorithm

	_seed = _seed * 16807 % 2147483647;

	return ( _seed - 1 ) / 2147483646;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}







/***/ }),

/***/ "./node_modules/three/src/math/Matrix4.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix4.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix4": function() { return /* binding */ Matrix4; }
/* harmony export */ });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _y = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _z = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();




/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quaternion": function() { return /* binding */ Quaternion; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");


class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;




/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector3": function() { return /* binding */ Vector3; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();




/***/ }),

/***/ "./src/global.ts":
/*!***********************!*\
  !*** ./src/global.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! detect-browser */ "./node_modules/detect-browser/es/index.js");
/* harmony import */ var _isIos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isIos */ "./src/isIos.ts");


window.addEventListener("load", function () {
    var browser = (0,detect_browser__WEBPACK_IMPORTED_MODULE_1__.detect)();
    console.log(browser);
    console.log(navigator.userAgent);
    //iOS we will redirect to non ar version anyway
    if (_isIos__WEBPACK_IMPORTED_MODULE_0__.isIos)
        return;
    if (browser.os !== "Android OS" && browser.os !== "android")
        return;
    if (browser.name !== "chrome" && browser.name !== "chromium-webview") {
        document.querySelector("#error-overlay").innerHTML = "\n    <div>This site only supports the <a href='https://play.google.com/store/apps/details?id=com.android.chrome'>Chrome web browser on Android.</a></div>;\n    ";
        document.querySelector("#error-overlay").style.display = "flex";
    }
});
window.addEventListener("error", function (event) {
    document.querySelector("#error-overlay").innerHTML = "<div>Oops! An error<br><br>Please refresh the page and try again.<br><br><span style=\"font-size: 0.5em\">" + event.message + "</span></div>";
    document.querySelector("#error-overlay").style.display = "flex";
    var id = window.localStorage.getItem("aid");
    if (id) {
        fetch("https://spatialstats.lucas-levin.com/" + id + "/error/" + encodeURI(event.message.substr(0, 100))).catch();
    }
});


/***/ }),

/***/ "./src/isIos.ts":
/*!**********************!*\
  !*** ./src/isIos.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIos": function() { return /* binding */ isIos; }
/* harmony export */ });
var isIos = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document);


/***/ }),

/***/ "./src/loadMedia.ts":
/*!**************************!*\
  !*** ./src/loadMedia.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadMedia": function() { return /* binding */ loadMedia; }
/* harmony export */ });
function loadMedia(state, params) {
    var _this = this;
    state.loaded = false;
    state.numLoaded = 0;
    state.numItems = params.el.children.length;
    state.bufferSources = [];
    console.log(params.audioContext.sampleRate);
    state.requests = [];
    console.log("Loading " + state.numItems + " audio elements");
    var sampleRate = params.audioContext.sampleRate;
    state.progress = Array(params.el.children.length).fill(0);
    Array.from(params.el.children).forEach(function (anchorEl, index) {
        if (anchorEl.tagName !== "A") {
            console.error("The loader should only have <a> children");
        }
        var originalUrl = anchorEl.getAttribute("href");
        var url = sampleRate === 48000
            ? originalUrl.slice(0, -3) + "48." + originalUrl.slice(-3)
            : sampleRate === 44100
                ? originalUrl.slice(0, -3) + "44." + originalUrl.slice(-3)
                : null;
        if (!url)
            throw Error("Unsupported sample rate " + sampleRate);
        state.bufferSources.push(params.audioContext.createBufferSource());
        var request = new XMLHttpRequest();
        state.requests.push(request);
        request.addEventListener("progress", childProgress.bind(_this, state, params, index));
        request.addEventListener("load", childLoadSuccess.bind(_this, state, params, index));
        request.addEventListener("error", childError.bind(_this, index));
        request.addEventListener("abort", childAbort.bind(_this, index));
        request.open("GET", url);
        request.responseType = "arraybuffer";
        request.send();
    });
}
function childProgress(state, params, index, event) {
    var percent = event.total ? event.loaded / event.total : 0;
    state.progress[index] = percent;
    var totalPercent = state.progress.reduce(function (prev, cur) { return prev + cur; }) / state.progress.length;
    params.onProgress(totalPercent);
}
function childLoadSuccess(state, params, index) {
    var _a;
    console.log("Loaded " + index);
    var data = (_a = state.requests[index]) === null || _a === void 0 ? void 0 : _a.response;
    //guard against race conditions
    if (!data)
        return;
    //safari doesn't support promise based decode
    params.audioContext.decodeAudioData(data, function (buffer) {
        if (!state.bufferSources[index])
            state.bufferSources[index] = params.audioContext.createBufferSource();
        state.bufferSources[index].buffer = buffer;
        state.numLoaded += 1;
        if (state.numLoaded >= state.numItems) {
            console.log("Loaded all items");
            state.loaded = true;
            params.onSuccess(params.barcodeData, state.bufferSources);
        }
    }, function () {
        childError(index);
    });
}
function childError(index, event) {
    throw Error("Couldn't load piece " + index + ".");
}
function childAbort(index) {
    console.log("Aborting load item " + index);
}


/***/ }),

/***/ "./src/loadResonance.ts":
/*!******************************!*\
  !*** ./src/loadResonance.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadResonance": function() { return /* binding */ loadResonance; }
/* harmony export */ });
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resonance-audio */ "./node_modules/resonance-audio/build/resonance-audio.js");
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(resonance_audio__WEBPACK_IMPORTED_MODULE_0__);

function loadResonance(audioContext) {
    console.log("Loading resonance");
    var ambisonicOrder = 1;
    var resonanceAudioScene = new resonance_audio__WEBPACK_IMPORTED_MODULE_0__.ResonanceAudio(audioContext, { ambisonicOrder: ambisonicOrder });
    resonanceAudioScene.setRoomProperties({ width: 6, height: 5, depth: 6 }, {
        back: "wood-panel",
        left: "brick-bare",
        right: "brick-bare",
        front: "wood-panel",
        down: "plywood-panel",
        up: "acoustic-ceiling-tiles",
    });
    resonanceAudioScene.output.connect(audioContext.destination);
    return resonanceAudioScene;
}


/***/ }),

/***/ "./src/p.ts":
/*!******************!*\
  !*** ./src/p.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/src/math/Euler */ "./node_modules/three/src/math/Euler.js");
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nunjucks */ "./node_modules/nunjucks/browser/nunjucks.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nunjucks__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./src/global.ts");
/* harmony import */ var _loadResonance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadResonance */ "./src/loadResonance.ts");
/* harmony import */ var _loadMedia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadMedia */ "./src/loadMedia.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var index = Number.parseInt(window.location.pathname.match(/\/?(\d+)\.html/)[1]);
nunjucks__WEBPACK_IMPORTED_MODULE_0__.configure("templates", { autoescape: true });
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("loader-" + index + ".njk"));
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("scene-" + index + ".njk"));
var loadMediaState = {};
var resonanceAudioScene;
var audioContext;
var orientationPermission = undefined;
var degtorad = Math.PI / 180;
var xAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0);
var yAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var zAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var upAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, -1, 0);
var forwardAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var initialDirection = undefined;
var q0 = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var quaternion = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var alphaOffset = 0;
var forward = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -1);
var up = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var eulerOrigin = new three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__.Euler(Math.PI / 2, 0, 0, "YZX");
var freezeCheckboxEl = document.getElementById("freeze-checkbox");
var animationTimeline = [];
var timelineLoop = null;
var animationTimelineIndex = -1;
var animationStartTime = 0;
var entities = [];
window.addEventListener("load", function () {
    document.body.querySelector("#play-overlay").classList.remove("fade-out");
    audioContext = new window.AudioContext();
    resonanceAudioScene = (0,_loadResonance__WEBPACK_IMPORTED_MODULE_2__.loadResonance)(audioContext);
    var loaderEl = document.querySelector("[loader]");
    (0,_loadMedia__WEBPACK_IMPORTED_MODULE_3__.loadMedia)(loadMediaState, {
        el: loaderEl,
        audioContext: audioContext,
        onSuccess: mediaLoaded,
        onProgress: function (percent) {
            var loadingButton = document.querySelector("#play-button");
            if (loadingButton)
                loadingButton.innerText = "Loading " + Math.round(percent * 98) + "%...";
        },
        barcodeData: index.toString(),
        loadingBarcodeContainer: { loadingBarcode: index },
    });
    loadEntities();
});
function loadEntities() {
    document.body.querySelectorAll("[resonance-source]").forEach(function (e) {
        var _a;
        var index = Number.parseInt(e.getAttribute("resonance-source"));
        var position = e
            .getAttribute("position")
            .split(" ")
            .map(function (i) { return Number.parseFloat(i); });
        var bufferSource = (_a = loadMediaState.bufferSources) === null || _a === void 0 ? void 0 : _a[index];
        var resonanceSource = resonanceAudioScene.createSource();
        bufferSource.connect(resonanceSource.input);
        resonanceSource.setPosition(position[0], -position[2], position[1]);
        var animations = extractAnimations(e);
        var mixinAnimations = e.hasAttribute("mixin")
            ? extractAnimations(document.getElementById(e.getAttribute("mixin")))
            : {};
        var entity = {
            el: e,
            position: position,
            index: index,
            bufferSource: bufferSource,
            resonanceSource: resonanceSource,
            animations: __assign(__assign({}, mixinAnimations), animations),
        };
        entities.push(entity);
    });
    document.querySelectorAll("a-entity").forEach(function (e) {
        var attr = Array.from(e.attributes).find(function (attr) { return attr.name.startsWith("animation-timeline"); });
        if (attr) {
            if (timelineLoop !== null)
                throw Error("Found more than one entity with animation-timeline attribute");
            if (attr.value.match(/loop:\s?true/))
                timelineLoop = true;
            else
                timelineLoop = false;
        }
    });
    console.log("loop: " + timelineLoop);
    var t = document.querySelector("a-timeline");
    if (!t)
        throw Error("No animation timeline found");
    var time = 0;
    Array.from(t.children).forEach(function (child) {
        var _a;
        if (child.tagName === "A-TIMELINE-ANIMATION") {
            var name_1 = child.getAttribute("name");
            var offset = Number.parseInt(child.getAttribute("offset")) || 0;
            var target_1 = child.getAttribute("select");
            var entity = entities.find(function (e) { return e.el === document.querySelector(target_1); });
            if (!entity)
                throw Error("Couldn't find entity " + target_1);
            var animation = entity.animations[name_1];
            var startTime = time + ((_a = animation.delay) !== null && _a !== void 0 ? _a : 0) + offset;
            var finishTime = startTime + animation.dur;
            animationTimeline.push({
                animation: animation,
                entity: entity,
                offset: offset,
                startTime: startTime,
                finishTime: finishTime,
            });
            time = finishTime;
        }
        else if (child.tagName === "A-TIMELINE-GROUP") {
            var groupOffset_1 = Number.parseInt(child.getAttribute("offset")) || 0;
            var group_1 = { items: [], offset: groupOffset_1, finishTime: 0 };
            Array.from(child.children).forEach(function (grandchild) {
                var _a;
                if (grandchild.tagName === "A-TIMELINE-ANIMATION") {
                    var name_2 = grandchild.getAttribute("name");
                    var offset = Number.parseInt(grandchild.getAttribute("offset")) || 0;
                    var target_2 = grandchild.getAttribute("select");
                    var entity = entities.find(function (e) { return e.el === document.querySelector(target_2); });
                    if (!entity)
                        throw Error("Couldn't find entity " + target_2);
                    var animation = entity.animations[name_2];
                    var startTime = time + ((_a = animation.delay) !== null && _a !== void 0 ? _a : 0) + groupOffset_1 + offset;
                    var finishTime = startTime + animation.dur;
                    group_1.items.push({
                        animation: animation,
                        entity: entity,
                        offset: offset,
                        startTime: startTime,
                        finishTime: finishTime,
                    });
                    group_1.finishTime = Math.max(group_1.finishTime, finishTime);
                }
                else
                    throw Error("Unsupported timeline tag " + grandchild.tagName);
            });
            animationTimeline.push(group_1);
            time = group_1.finishTime;
        }
        else
            throw Error("Unsupported timeline tag " + child.tagName);
    });
    console.log(animationTimeline);
}
function mediaLoaded() {
    var _this = this;
    var button = document.body.querySelector("#play-button");
    button.disabled = false;
    button.innerText = "Play";
    button.addEventListener("click", function () { return __awaiter(_this, void 0, void 0, function () {
        var startTime, message;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    audioContext.resume();
                    startTime = audioContext.currentTime + 1;
                    animationStartTime = Date.now();
                    entities.forEach(function (entity) { return entity.bufferSource.start(startTime); });
                    window.setInterval(mainLoop, 50);
                    document.getElementById("title").innerText = "You are listening to the spatial experience.";
                    button.remove();
                    if (!window.DeviceOrientationEvent) return [3 /*break*/, 3];
                    if (!(DeviceOrientationEvent.requestPermission &&
                        orientationPermission !== "denied" &&
                        orientationPermission !== "granted")) return [3 /*break*/, 2];
                    return [4 /*yield*/, DeviceOrientationEvent.requestPermission()];
                case 1:
                    orientationPermission = _a.sent();
                    if (orientationPermission === "denied") {
                        message = document.createElement("p");
                        message.innerText = "You did not give permission to use device motion. Your viewpoint will remain static.";
                        document.body.appendChild(message);
                    }
                    _a.label = 2;
                case 2:
                    window.addEventListener("deviceorientation", throttle(updateListener, 50));
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); });
}
function mainLoop() {
    updateEntities();
}
function updateEntities() {
    var _a, _b, _c, _d, _e, _f;
    var now = Date.now();
    if (!animationTimeline[0])
        return;
    //increment the timeline if necessary
    while (now > ((_b = (_a = animationTimeline === null || animationTimeline === void 0 ? void 0 : animationTimeline[animationTimelineIndex]) === null || _a === void 0 ? void 0 : _a.finishTime) !== null && _b !== void 0 ? _b : 0) + animationStartTime) {
        if (
        //waiting for offset only applies to the start of the animation, and timeline groups
        //since startTime factors it in later
        ((animationTimeline[animationTimelineIndex + 1] && "items" in animationTimeline[animationTimelineIndex + 1]) ||
            animationTimelineIndex < 0) &&
            now <=
                ((_d = (_c = animationTimeline === null || animationTimeline === void 0 ? void 0 : animationTimeline[animationTimelineIndex]) === null || _c === void 0 ? void 0 : _c.finishTime) !== null && _d !== void 0 ? _d : 0) +
                    animationStartTime +
                    ((_f = (_e = animationTimeline === null || animationTimeline === void 0 ? void 0 : animationTimeline[animationTimelineIndex + 1]) === null || _e === void 0 ? void 0 : _e.offset) !== null && _f !== void 0 ? _f : 0)) {
            //don't go to next animation if now isn't bigger than the offset yet
            return;
        }
        animationTimelineIndex++;
        if (animationTimelineIndex >= animationTimeline.length) {
            if (!timelineLoop)
                return;
            animationStartTime = animationStartTime + animationTimeline[animationTimelineIndex - 1].finishTime;
            animationTimelineIndex = 0;
        }
    }
    //index is less than zero at the start because the audio plays after 1 sec
    if (animationTimelineIndex < 0)
        return;
    //place items
    var a = animationTimeline[animationTimelineIndex];
    //is array
    if ("items" in a) {
        a.items.forEach(function (item) {
            if (now - animationStartTime <= item.startTime)
                return;
            interpolate(item.entity.resonanceSource, Math.max(0, (now - animationStartTime - item.startTime) / (item.finishTime - item.startTime)), item.animation.from, item.animation.to);
        });
    }
    else {
        if (now - animationStartTime <= a.startTime)
            return;
        //single item, not array
        interpolate(a.entity.resonanceSource, Math.max(0, (now - animationStartTime - a.startTime) / (a.finishTime - a.startTime)), a.animation.from, a.animation.to);
    }
}
function updateListener(e) {
    if (freezeCheckboxEl.checked)
        return;
    var alpha = e.alpha ? e.alpha * degtorad + alphaOffset : 0; // Z
    var beta = e.beta ? e.beta * degtorad : 0; // X'
    var gamma = e.gamma ? e.gamma * degtorad : 0; // Y''
    quaternion.setFromEuler(eulerOrigin);
    q0.setFromAxisAngle(zAxis, alpha);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(xAxis, beta);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(yAxis, gamma);
    quaternion.multiply(q0);
    up.copy(upAxis).applyQuaternion(quaternion);
    forward.copy(forwardAxis).applyQuaternion(quaternion);
    if (!initialDirection) {
        initialDirection = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3().projectOnPlane(upAxis).normalize();
        var angle = initialDirection.angleTo(forwardAxis);
        eulerOrigin.y = angle;
    }
    /*document.querySelector("#debug").innerHTML = `${forward.x.toFixed(2)} ${forward.y.toFixed(2)} ${forward.z.toFixed(
      2,
    )}<br>${up.x.toFixed(2)} ${up.y.toFixed(2)} ${up.z.toFixed(2)}<br>
    ${alpha.toFixed(2)} ${beta.toFixed(2)} ${gamma.toFixed(2)}<br>
    ${eulerOrigin.x.toFixed(2)} ${eulerOrigin.y.toFixed(2)} ${eulerOrigin.z.toFixed(2)}`;*/
    //@ts-expect-error - bad typing
    resonanceAudioScene.setListenerOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
}
function throttle(callback, delay) {
    var prev = 0;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var now = new Date().getTime();
        if (now - prev < delay)
            return;
        prev = now;
        return callback.apply(void 0, args);
    };
}
function extractAnimations(element) {
    var result = {};
    for (var i = 0; i < element.attributes.length; i++) {
        var attr = element.attributes[i];
        if (attr.name.startsWith("animation__") || attr.name === "animation") {
            var name_3 = attr.name.startsWith("animation__") ? attr.name.split("__")[1] : attr.name;
            result[name_3] = parseAnimation(attr.value);
        }
    }
    return result;
}
function parseAnimation(a) {
    var result = {};
    var data = a.split(";").map(function (e) {
        return e
            .trim()
            .split(":")
            .map(function (e2) { return e2.trim(); });
    });
    for (var i = 0; i < data.length; i++) {
        if (data[i].length < 2)
            continue;
        if (data[i][0] === "delay")
            throw Error("Don't use delay, use timeline offset");
        if (data[i][0] === "from" || data[i][0] === "to") {
            result[data[i][0]] = data[i][1].split(" ").map(function (n) { return Number.parseFloat(n); });
        }
        else if (data[i][0] === "dur") {
            result[data[i][0]] = Number.parseInt(data[i][1]);
        }
        else if (data[i][1] === "true") {
            result[data[i][0]] = true;
        }
        else if (data[i][1] === "false") {
            result[data[i][0]] = false;
        }
        else {
            result[data[i][0]] = data[i][1];
        }
    }
    return result;
}
function interpolate(resonanceSource, t, from, to, easing) {
    if (easing === void 0) { easing = "linear"; }
    switch (easing) {
        case "linear":
            resonanceSource.setPosition(from[0] + t * (to[0] - from[0]), from[1] + t * (to[1] - from[1]), from[2] + t * (to[2] - from[2]));
            // resonanceSource.setPosition(
            //   from[0] + t * (to[0] - from[0]),
            //   -(from[2] + t * (to[2] - from[2])),
            //   from[1] + t * (to[1] - from[1]),
            // );
            break;
        default:
            throw Error("Unhandled easing " + easing);
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/p.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9ub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL251bmp1Y2tzL2Jyb3dzZXIvbnVuanVja3MuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3Jlc29uYW5jZS1hdWRpby9idWlsZC9yZXNvbmFuY2UtYXVkaW8uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0V1bGVyLmpzIiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDQuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1F1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1ZlY3RvcjMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2dsb2JhbC50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvaXNJb3MudHMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2xvYWRNZWRpYS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvbG9hZFJlc29uYW5jZS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvcC50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svc3RhcnR1cCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNCQUFzQixTQUFJLElBQUksU0FBSTtBQUNsQyxpREFBaUQsUUFBUTtBQUN6RCx3Q0FBd0MsUUFBUTtBQUNoRCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzhCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUMwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1CQUFt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NEJBQTRCLHFCQUFxQjtBQUNqRCw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQixnQkFBZ0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0EsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTCxlQUFlLGdDQUFtQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDLE1BQU07OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxPQUFPOzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELG9FQUFvRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7OztBQUdwQyw4Q0FBOEM7QUFDOUM7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztB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Qy9CO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEU7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4Qyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0EsK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTCxZQUFZLGdDQUFtQjs7QUFFL0IsWUFBWSxnQ0FBbUI7O0FBRS9CLFVBQVUsZ0NBQW1COztBQUU3QixVQUFVLGdDQUFtQjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxNQUFNO0FBQzlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HOztBQUVuRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBLEtBQUs7OztBQUdMLHNDQUFzQzs7QUFFdEM7QUFDQSw2REFBNkQ7O0FBRTdELCtCQUErQjs7QUFFL0I7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQSxLQUFLLHdDQUF3Qzs7O0FBRzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyxpREFBaUQsa0RBQWtELEdBQUc7QUFDdEc7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLHNDQUFzQzs7QUFFdEMsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGVBQWUsaUNBQW1COztBQUU5RCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMLHFHQUFxRztBQUNyRyxHQUFHLE1BQU0sRUFJTjtBQUNILENBQUM7OztBQUdELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7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SDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0EsT0FBTztBQUNQLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNM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QUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsV0FBVyxPQUFPO0FBQ2xCOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMs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QUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdGxPNEM7QUFDTjtBQUNBO0FBQ0E7O0FBRXZDLGtDQUFrQyxnREFBTztBQUN6QyxzQ0FBc0Msc0RBQVU7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCLG9EQUFLOztBQUU5Qjs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsb0RBQUs7O0FBRWhDOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5QixvREFBSzs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLG9EQUFLOztBQUVoQzs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsb0RBQUs7O0FBRTlCOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixvREFBSzs7QUFFaEM7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxjQUFjLGdEQUFPOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25VakI7O0FBRUEsZ0JBQWdCLFNBQVM7O0FBRXpCOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUE0QkU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalFxQzs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGVBQWUsZUFBZTtBQUM5QyxnQkFBZ0IsZUFBZSxlQUFlO0FBQzlDLGdCQUFnQixlQUFlLGdCQUFnQjtBQUMvQyxnQkFBZ0IsZUFBZSxnQkFBZ0I7O0FBRS9DOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDMUQsb0JBQW9CLG1CQUFtQixtQkFBbUI7QUFDMUQsb0JBQW9CLG1CQUFtQixxQkFBcUI7QUFDNUQsc0JBQXNCLHFCQUFxQixxQkFBcUI7O0FBRWhFOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGlCQUFpQixnQkFBZ0I7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGVBQWUsY0FBYyxjQUFjO0FBQzNDLGVBQWUsY0FBYyxjQUFjO0FBQzNDLGVBQWUsY0FBYyxlQUFlO0FBQzVDLGVBQWUsY0FBYyxlQUFlOztBQUU1Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsbUJBQW1COztBQUVuQyxnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQixvQkFBb0I7QUFDcEMsaUJBQWlCLHFCQUFxQjs7QUFFdEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLGNBQWM7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQWEsYUFBYTtBQUN4QyxjQUFjLGFBQWEsYUFBYTtBQUN4QyxjQUFjLGFBQWEsY0FBYztBQUN6QyxjQUFjLGFBQWEsZ0JBQWdCOztBQUUzQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWEsYUFBYTtBQUM1QyxjQUFjLGlCQUFpQixhQUFhO0FBQzVDLGNBQWMsYUFBYSxvQkFBb0I7QUFDL0MsY0FBYyxhQUFhLGNBQWM7O0FBRXpDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQixRQUFROztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw4QkFBOEIsZ0RBQU87QUFDckM7QUFDQSxnQ0FBZ0MsZ0RBQU87QUFDdkMsK0JBQStCLGdEQUFPO0FBQ3RDLDZCQUE2QixnREFBTztBQUNwQyw2QkFBNkIsZ0RBQU87QUFDcEMsNkJBQTZCLGdEQUFPOztBQUVqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwM0J5Qjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLGdEQUFlOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFc0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pwQnNCO0FBQ0M7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0RBQWU7O0FBRW5DOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUMvQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoQyxDQUFDO1lBQ0YsK0JBQStCO1lBQy9CLHFDQUFxQztZQUNyQyx3Q0FBd0M7WUFDeEMscUNBQXFDO1lBQ3JDLEtBQUs7WUFDTCxNQUFNO1FBQ1I7WUFDRSxNQUFNLEtBQUssQ0FBQyxzQkFBb0IsTUFBUSxDQUFDLENBQUM7S0FDN0M7QUFDSCxDQUFDOzs7Ozs7O1VDbFhEO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3JCQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLDBCQUEwQixFQUFFO1dBQzFDLGNBQWMsZUFBZTtXQUM3QixnQ0FBZ0MsWUFBWTtXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx3Q0FBd0MseUNBQXlDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBLDZDQUE2Qyx3REFBd0QsRTs7Ozs7V0NBckc7V0FDQTtXQUNBO1dBQ0Esc0RBQXNELGtCQUFrQjtXQUN4RTtXQUNBLCtDQUErQyxjQUFjO1dBQzdELEU7Ozs7VUNOQTtVQUNBO1VBQ0E7VUFDQSIsImZpbGUiOiJwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG52YXIgQnJvd3NlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYnJvd3Nlcic7XG4gICAgfVxuICAgIHJldHVybiBCcm93c2VySW5mbztcbn0oKSk7XG5leHBvcnQgeyBCcm93c2VySW5mbyB9O1xudmFyIE5vZGVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVJbmZvKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZUluZm87XG59KCkpO1xuZXhwb3J0IHsgTm9kZUluZm8gfTtcbnZhciBTZWFyY2hCb3REZXZpY2VJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaEJvdERldmljZUluZm8obmFtZSwgdmVyc2lvbiwgb3MsIGJvdCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm9zID0gb3M7XG4gICAgICAgIHRoaXMuYm90ID0gYm90O1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm90LWRldmljZSc7XG4gICAgfVxuICAgIHJldHVybiBTZWFyY2hCb3REZXZpY2VJbmZvO1xufSgpKTtcbmV4cG9ydCB7IFNlYXJjaEJvdERldmljZUluZm8gfTtcbnZhciBCb3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdEluZm8oKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdib3QnO1xuICAgICAgICB0aGlzLmJvdCA9IHRydWU7IC8vIE5PVEU6IGRlcHJlY2F0ZWQgdGVzdCBuYW1lIGluc3RlYWRcbiAgICAgICAgdGhpcy5uYW1lID0gJ2JvdCc7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQm90SW5mbztcbn0oKSk7XG5leHBvcnQgeyBCb3RJbmZvIH07XG52YXIgUmVhY3ROYXRpdmVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlYWN0TmF0aXZlSW5mbygpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlYWN0LW5hdGl2ZSc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdyZWFjdC1uYXRpdmUnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0TmF0aXZlSW5mbztcbn0oKSk7XG5leHBvcnQgeyBSZWFjdE5hdGl2ZUluZm8gfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbnZhciBTRUFSQ0hCT1hfVUFfUkVHRVggPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC87XG52YXIgU0VBUkNIQk9UX09TX1JFR0VYID0gLyhudWhrfEdvb2dsZWJvdHxZYW1teWJvdHxPcGVuYm90fFNsdXJwfE1TTkJvdHxBc2tcXCBKZWV2ZXNcXC9UZW9tYXxpYV9hcmNoaXZlcikvO1xudmFyIFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMgPSAzO1xudmFyIHVzZXJBZ2VudFJ1bGVzID0gW1xuICAgIFsnYW9sJywgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZScsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydlZGdlLWlvcycsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ3lhbmRleGJyb3dzZXInLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydrYWthb3RhbGsnLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ3NhbXN1bmcnLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnc2lsaycsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSxcbiAgICBbJ21pdWknLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSxcbiAgICBbJ2JlYWtlcicsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2VkZ2UtY2hyb21pdW0nLCAvRWRnQT9cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbl07XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0KHVzZXJBZ2VudCkge1xuICAgIGlmICghIXVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vZGVWZXJzaW9uKCk7XG59XG5mdW5jdGlvbiBtYXRjaFVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgcmV0dXJuICh1YSAhPT0gJycgJiZcbiAgICAgICAgdXNlckFnZW50UnVsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVkLCBfYSkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICAgICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gICAgICAgIH0sIGZhbHNlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnJvd3Nlck5hbWUodWEpIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoVXNlckFnZW50KHVhKTtcbiAgICByZXR1cm4gZGF0YSA/IGRhdGFbMF0gOiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXNlckFnZW50KHVhKSB7XG4gICAgdmFyIG1hdGNoZWRSdWxlID0gbWF0Y2hVc2VyQWdlbnQodWEpO1xuICAgIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFJ1bGVbMF0sIG1hdGNoID0gbWF0Y2hlZFJ1bGVbMV07XG4gICAgaWYgKG5hbWUgPT09ICdzZWFyY2hib3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm90SW5mbygpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvblBhcnRzID0gbWF0Y2hbMV0gJiYgbWF0Y2hbMV0uc3BsaXQoL1suX10vKS5zbGljZSgwLCAzKTtcbiAgICBpZiAodmVyc2lvblBhcnRzKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uUGFydHMubGVuZ3RoIDwgUkVRVUlSRURfVkVSU0lPTl9QQVJUUykge1xuICAgICAgICAgICAgdmVyc2lvblBhcnRzID0gX19zcHJlYWRBcnJheXModmVyc2lvblBhcnRzLCBjcmVhdGVWZXJzaW9uUGFydHMoUkVRVUlSRURfVkVSU0lPTl9QQVJUUyAtIHZlcnNpb25QYXJ0cy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmVyc2lvblBhcnRzID0gW107XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmVyc2lvblBhcnRzLmpvaW4oJy4nKTtcbiAgICB2YXIgb3MgPSBkZXRlY3RPUyh1YSk7XG4gICAgdmFyIHNlYXJjaEJvdE1hdGNoID0gU0VBUkNIQk9UX09TX1JFR0VYLmV4ZWModWEpO1xuICAgIGlmIChzZWFyY2hCb3RNYXRjaCAmJiBzZWFyY2hCb3RNYXRjaFsxXSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaEJvdERldmljZUluZm8obmFtZSwgdmVyc2lvbiwgb3MsIHNlYXJjaEJvdE1hdGNoWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uLCBvcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVWZXJzaW9uKCkge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uO1xuICAgIHJldHVybiBpc05vZGUgPyBuZXcgTm9kZUluZm8ocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpKSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uUGFydHMoY291bnQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcwJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKiEgQnJvd3NlciBidW5kbGUgb2YgbnVuanVja3MgMy4yLjIgICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJudW5qdWNrc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJudW5qdWNrc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgZXNjYXBlTWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjMzk7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnXG59O1xudmFyIGVzY2FwZVJlZ2V4ID0gL1smXCInPD5dL2c7XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBrKSB7XG4gIHJldHVybiBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgayk7XG59XG5cbmV4cG9ydHMuaGFzT3duUHJvcCA9IGhhc093blByb3A7XG5cbmZ1bmN0aW9uIGxvb2t1cEVzY2FwZShjaCkge1xuICByZXR1cm4gZXNjYXBlTWFwW2NoXTtcbn1cblxuZnVuY3Rpb24gX3ByZXR0aWZ5RXJyb3IocGF0aCwgd2l0aEludGVybmFscywgZXJyKSB7XG4gIGlmICghZXJyLlVwZGF0ZSkge1xuICAgIC8vIG5vdCBvbmUgb2Ygb3VycywgY2FzdCBpdFxuICAgIGVyciA9IG5ldyBleHBvcnRzLlRlbXBsYXRlRXJyb3IoZXJyKTtcbiAgfVxuXG4gIGVyci5VcGRhdGUocGF0aCk7IC8vIFVubGVzcyB0aGV5IG1hcmtlZCB0aGUgZGV2IGZsYWcsIHNob3cgdGhlbSBhIHRyYWNlIGZyb20gaGVyZVxuXG4gIGlmICghd2l0aEludGVybmFscykge1xuICAgIHZhciBvbGQgPSBlcnI7XG4gICAgZXJyID0gbmV3IEVycm9yKG9sZC5tZXNzYWdlKTtcbiAgICBlcnIubmFtZSA9IG9sZC5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuZXhwb3J0cy5fcHJldHRpZnlFcnJvciA9IF9wcmV0dGlmeUVycm9yO1xuXG5mdW5jdGlvbiBUZW1wbGF0ZUVycm9yKG1lc3NhZ2UsIGxpbmVubywgY29sbm8pIHtcbiAgdmFyIGVycjtcbiAgdmFyIGNhdXNlO1xuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjYXVzZSA9IG1lc3NhZ2U7XG4gICAgbWVzc2FnZSA9IGNhdXNlLm5hbWUgKyBcIjogXCIgKyBjYXVzZS5tZXNzYWdlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZXJyLCBUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbWVzc2FnZVxuICAgIH0pO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdUZW1wbGF0ZSByZW5kZXIgZXJyb3InXG4gIH0pO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cblxuICB2YXIgZ2V0U3RhY2s7XG5cbiAgaWYgKGNhdXNlKSB7XG4gICAgdmFyIHN0YWNrRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2F1c2UsICdzdGFjaycpO1xuXG4gICAgZ2V0U3RhY2sgPSBzdGFja0Rlc2NyaXB0b3IgJiYgKHN0YWNrRGVzY3JpcHRvci5nZXQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YWNrRGVzY3JpcHRvci52YWx1ZTtcbiAgICB9KTtcblxuICAgIGlmICghZ2V0U3RhY2spIHtcbiAgICAgIGdldFN0YWNrID0gZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG4gICAgICAgIHJldHVybiBjYXVzZS5zdGFjaztcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcblxuICAgIGdldFN0YWNrID0gZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdzdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRTdGFjay5jYWxsKGVycik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NhdXNlJywge1xuICAgIHZhbHVlOiBjYXVzZVxuICB9KTtcbiAgZXJyLmxpbmVubyA9IGxpbmVubztcbiAgZXJyLmNvbG5vID0gY29sbm87XG4gIGVyci5maXJzdFVwZGF0ZSA9IHRydWU7XG5cbiAgZXJyLlVwZGF0ZSA9IGZ1bmN0aW9uIFVwZGF0ZShwYXRoKSB7XG4gICAgdmFyIG1zZyA9ICcoJyArIChwYXRoIHx8ICd1bmtub3duIHBhdGgnKSArICcpJzsgLy8gb25seSBzaG93IGxpbmVubyArIGNvbG5vIG5leHQgdG8gcGF0aCBvZiB0ZW1wbGF0ZVxuICAgIC8vIHdoZXJlIGVycm9yIG9jY3VycmVkXG5cbiAgICBpZiAodGhpcy5maXJzdFVwZGF0ZSkge1xuICAgICAgaWYgKHRoaXMubGluZW5vICYmIHRoaXMuY29sbm8pIHtcbiAgICAgICAgbXNnICs9IFwiIFtMaW5lIFwiICsgdGhpcy5saW5lbm8gKyBcIiwgQ29sdW1uIFwiICsgdGhpcy5jb2xubyArIFwiXVwiO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxpbmVubykge1xuICAgICAgICBtc2cgKz0gXCIgW0xpbmUgXCIgKyB0aGlzLmxpbmVubyArIFwiXVwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1zZyArPSAnXFxuICc7XG5cbiAgICBpZiAodGhpcy5maXJzdFVwZGF0ZSkge1xuICAgICAgbXNnICs9ICcgJztcbiAgICB9XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2cgKyAodGhpcy5tZXNzYWdlIHx8ICcnKTtcbiAgICB0aGlzLmZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoVGVtcGxhdGVFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG59IGVsc2Uge1xuICBUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBUZW1wbGF0ZUVycm9yXG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5UZW1wbGF0ZUVycm9yID0gVGVtcGxhdGVFcnJvcjtcblxuZnVuY3Rpb24gZXNjYXBlKHZhbCkge1xuICByZXR1cm4gdmFsLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGxvb2t1cEVzY2FwZSk7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIE9ialByb3RvLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmpQcm90by50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXR0clxuICogQHJldHVybnMgeyhzdHJpbmd8bnVtYmVyKVtdfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfcHJlcGFyZUF0dHJpYnV0ZVBhcnRzKGF0dHIpIHtcbiAgaWYgKCFhdHRyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdHRyLnNwbGl0KCcuJyk7XG4gIH1cblxuICByZXR1cm4gW2F0dHJdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBhdHRyaWJ1dGUgICAgICBBdHRyaWJ1dGUgdmFsdWUuIERvdHMgYWxsb3dlZC5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihPYmplY3QpOiAqfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXR0ckdldHRlcihhdHRyaWJ1dGUpIHtcbiAgdmFyIHBhcnRzID0gX3ByZXBhcmVBdHRyaWJ1dGVQYXJ0cyhhdHRyaWJ1dGUpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBhdHRyR2V0dGVyKGl0ZW0pIHtcbiAgICB2YXIgX2l0ZW0gPSBpdGVtO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTsgLy8gSWYgaXRlbSBpcyBub3QgYW4gb2JqZWN0LCBhbmQgd2Ugc3RpbGwgZ290IHBhcnRzIHRvIGhhbmRsZSwgaXQgbWVhbnNcbiAgICAgIC8vIHRoYXQgc29tZXRoaW5nIGdvZXMgd3JvbmcuIEp1c3Qgcm9sbCBvdXQgdG8gdW5kZWZpbmVkIGluIHRoYXQgY2FzZS5cblxuICAgICAgaWYgKGhhc093blByb3AoX2l0ZW0sIHBhcnQpKSB7XG4gICAgICAgIF9pdGVtID0gX2l0ZW1bcGFydF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfaXRlbTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBCeShvYmosIHZhbCwgdGhyb3dPblVuZGVmaW5lZCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpdGVyYXRvciA9IGlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGdldEF0dHJHZXR0ZXIodmFsKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IG9ialtpXTtcbiAgICB2YXIga2V5ID0gaXRlcmF0b3IodmFsdWUsIGkpO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIHRocm93T25VbmRlZmluZWQgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJncm91cGJ5OiBhdHRyaWJ1dGUgXFxcIlwiICsgdmFsICsgXCJcXFwiIHJlc29sdmVkIHRvIHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG5cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xufVxuXG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIWFycmF5KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBjb250YWlucyA9IHRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgdmFyIGluZGV4ID0gLTE7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaW5kZXhPZihjb250YWlucywgYXJyYXlbaW5kZXhdKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy53aXRob3V0ID0gd2l0aG91dDtcblxuZnVuY3Rpb24gcmVwZWF0KGNoYXJfLCBuKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHN0ciArPSBjaGFyXztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuXG5mdW5jdGlvbiBlYWNoKG9iaiwgZnVuYywgY29udGV4dCkge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXlQcm90by5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBcnJheVByb3RvLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnVuYy5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5lYWNoID0gZWFjaDtcblxuZnVuY3Rpb24gbWFwKG9iaiwgZnVuYykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgaWYgKEFycmF5UHJvdG8ubWFwICYmIG9iai5tYXAgPT09IEFycmF5UHJvdG8ubWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuYyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gZnVuYyhvYmpbaV0sIGkpO1xuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgcmVzdWx0cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydHMubWFwID0gbWFwO1xuXG5mdW5jdGlvbiBhc3luY0l0ZXIoYXJyLCBpdGVyLCBjYikge1xuICB2YXIgaSA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaSsrO1xuXG4gICAgaWYgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBpdGVyKGFycltpXSwgaSwgbmV4dCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZXhwb3J0cy5hc3luY0l0ZXIgPSBhc3luY0l0ZXI7XG5cbmZ1bmN0aW9uIGFzeW5jRm9yKG9iaiwgaXRlciwgY2IpIHtcbiAgdmFyIGtleXMgPSBrZXlzXyhvYmogfHwge30pO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpKys7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuXG4gICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgIGl0ZXIoaywgb2JqW2tdLCBpLCBsZW4sIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZXhwb3J0cy5hc3luY0ZvciA9IGFzeW5jRm9yO1xuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFyciB8fCBbXSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbn1cblxuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcblxuZnVuY3Rpb24ga2V5c18ob2JqKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4gIHZhciBhcnIgPSBbXTtcblxuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgIGFyci5wdXNoKGspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydHMua2V5cyA9IGtleXNfO1xuXG5mdW5jdGlvbiBfZW50cmllcyhvYmopIHtcbiAgcmV0dXJuIGtleXNfKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIFtrLCBvYmpba11dO1xuICB9KTtcbn1cblxuZXhwb3J0cy5fZW50cmllcyA9IF9lbnRyaWVzO1xuXG5mdW5jdGlvbiBfdmFsdWVzKG9iaikge1xuICByZXR1cm4ga2V5c18ob2JqKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gb2JqW2tdO1xuICB9KTtcbn1cblxuZXhwb3J0cy5fdmFsdWVzID0gX3ZhbHVlcztcblxuZnVuY3Rpb24gZXh0ZW5kKG9iajEsIG9iajIpIHtcbiAgb2JqMSA9IG9iajEgfHwge307XG4gIGtleXNfKG9iajIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBvYmoxW2tdID0gb2JqMltrXTtcbiAgfSk7XG4gIHJldHVybiBvYmoxO1xufVxuXG5leHBvcnRzLl9hc3NpZ24gPSBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxuZnVuY3Rpb24gaW5PcGVyYXRvcihrZXksIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpIHx8IGlzU3RyaW5nKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIHJldHVybiBrZXkgaW4gdmFsO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIFwiaW5cIiBvcGVyYXRvciB0byBzZWFyY2ggZm9yIFwiJyArIGtleSArICdcIiBpbiB1bmV4cGVjdGVkIHR5cGVzLicpO1xufVxuXG5leHBvcnRzLmluT3BlcmF0b3IgPSBpbk9wZXJhdG9yO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4gLy8gQSBzaW1wbGUgY2xhc3Mgc3lzdGVtLCBtb3JlIGRvY3VtZW50YXRpb24gdG8gY29tZVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRXZlbnRFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBwYXJlbnRXcmFwKHBhcmVudCwgcHJvcCkge1xuICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBwYXJlbnQgbWV0aG9kXG4gICAgdmFyIHRtcCA9IHRoaXMucGFyZW50OyAvLyBTZXQgcGFyZW50IHRvIHRoZSBwcmV2aW91cyBtZXRob2QsIGNhbGwsIGFuZCByZXN0b3JlXG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB2YXIgcmVzID0gcHJvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucGFyZW50ID0gdG1wO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZENsYXNzKGNscywgbmFtZSwgcHJvcHMpIHtcbiAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgbGliLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBwcm9wc1trXSA9IHBhcmVudFdyYXAoY2xzLnByb3RvdHlwZVtrXSwgcHJvcHNba10pO1xuICB9KTtcblxuICB2YXIgc3ViY2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9jbHMpIHtcbiAgICBfaW5oZXJpdHNMb29zZShzdWJjbGFzcywgX2Nscyk7XG5cbiAgICBmdW5jdGlvbiBzdWJjbGFzcygpIHtcbiAgICAgIHJldHVybiBfY2xzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3Moc3ViY2xhc3MsIFt7XG4gICAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gc3ViY2xhc3M7XG4gIH0oY2xzKTtcblxuICBsaWIuX2Fzc2lnbihzdWJjbGFzcy5wcm90b3R5cGUsIHByb3BzKTtcblxuICByZXR1cm4gc3ViY2xhc3M7XG59XG5cbnZhciBPYmogPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmooKSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSBuZWNlc3NhcnkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JqLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7fTtcblxuICBPYmouZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvcHMgPSBuYW1lO1xuICAgICAgbmFtZSA9ICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBuYW1lLCBwcm9wcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9iaiwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iajtcbn0oKTtcblxudmFyIEVtaXR0ZXJPYmogPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRW1pdHRlck9iaiwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gRW1pdHRlck9iaigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykgfHwgdGhpczsgLy8gVW5mb3J0dW5hdGVseSBuZWNlc3NhcnkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAoX3RoaXMyID0gX3RoaXMpLmluaXQuYXBwbHkoX3RoaXMyLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBFbWl0dGVyT2JqLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge307XG5cbiAgRW1pdHRlck9iai5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQobmFtZSwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9wcyA9IG5hbWU7XG4gICAgICBuYW1lID0gJ2Fub255bW91cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZENsYXNzKHRoaXMsIG5hbWUsIHByb3BzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRW1pdHRlck9iaiwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtaXR0ZXJPYmo7XG59KEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBPYmo6IE9iaixcbiAgRW1pdHRlck9iajogRW1pdHRlck9ialxufTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgYXJyYXlGcm9tID0gQXJyYXkuZnJvbTtcbnZhciBzdXBwb3J0c0l0ZXJhdG9ycyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yICYmIHR5cGVvZiBhcnJheUZyb20gPT09ICdmdW5jdGlvbic7IC8vIEZyYW1lcyBrZWVwIHRyYWNrIG9mIHNjb3BpbmcgYm90aCBhdCBjb21waWxlLXRpbWUgYW5kIHJ1bi10aW1lIHNvXG4vLyB3ZSBrbm93IGhvdyB0byBhY2Nlc3MgdmFyaWFibGVzLiBCbG9jayB0YWdzIGNhbiBpbnRyb2R1Y2Ugc3BlY2lhbFxuLy8gdmFyaWFibGVzLCBmb3IgZXhhbXBsZS5cblxudmFyIEZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhbWUocGFyZW50LCBpc29sYXRlV3JpdGVzKSB7XG4gICAgdGhpcy52YXJpYWJsZXMgPSB7fTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnRvcExldmVsID0gZmFsc2U7IC8vIGlmIHRoaXMgaXMgdHJ1ZSwgd3JpdGVzIChzZXQpIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXB3YXJkcyBwYXN0XG4gICAgLy8gdGhpcyBmcmFtZSB0byBpdHMgcGFyZW50ICh0aG91Z2ggcmVhZHMgbWF5KS5cblxuICAgIHRoaXMuaXNvbGF0ZVdyaXRlcyA9IGlzb2xhdGVXcml0ZXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsLCByZXNvbHZlVXApIHtcbiAgICAvLyBBbGxvdyB2YXJpYWJsZXMgd2l0aCBkb3RzIGJ5IGF1dG9tYXRpY2FsbHkgY3JlYXRpbmcgdGhlXG4gICAgLy8gbmVzdGVkIHN0cnVjdHVyZVxuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gdGhpcy52YXJpYWJsZXM7XG4gICAgdmFyIGZyYW1lID0gdGhpcztcblxuICAgIGlmIChyZXNvbHZlVXApIHtcbiAgICAgIGlmIChmcmFtZSA9IHRoaXMucmVzb2x2ZShwYXJ0c1swXSwgdHJ1ZSkpIHtcbiAgICAgICAgZnJhbWUuc2V0KG5hbWUsIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIGlkID0gcGFydHNbaV07XG5cbiAgICAgIGlmICghb2JqW2lkXSkge1xuICAgICAgICBvYmpbaWRdID0ge307XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialtpZF07XG4gICAgfVxuXG4gICAgb2JqW3BhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChuYW1lKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAgJiYgcC5sb29rdXAobmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKG5hbWUsIGZvcldyaXRlKSB7XG4gICAgdmFyIHAgPSBmb3JXcml0ZSAmJiB0aGlzLmlzb2xhdGVXcml0ZXMgPyB1bmRlZmluZWQgOiB0aGlzLnBhcmVudDtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBwICYmIHAucmVzb2x2ZShuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goaXNvbGF0ZVdyaXRlcykge1xuICAgIHJldHVybiBuZXcgRnJhbWUodGhpcywgaXNvbGF0ZVdyaXRlcyk7XG4gIH07XG5cbiAgX3Byb3RvLnBvcCA9IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH07XG5cbiAgcmV0dXJuIEZyYW1lO1xufSgpO1xuXG5mdW5jdGlvbiBtYWtlTWFjcm8oYXJnTmFtZXMsIGt3YXJnTmFtZXMsIGZ1bmMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtYWNyb0FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBtYWNyb0FyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0NvdW50ID0gbnVtQXJncyhtYWNyb0FyZ3MpO1xuICAgIHZhciBhcmdzO1xuICAgIHZhciBrd2FyZ3MgPSBnZXRLZXl3b3JkQXJncyhtYWNyb0FyZ3MpO1xuXG4gICAgaWYgKGFyZ0NvdW50ID4gYXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICBhcmdzID0gbWFjcm9BcmdzLnNsaWNlKDAsIGFyZ05hbWVzLmxlbmd0aCk7IC8vIFBvc2l0aW9uYWwgYXJndW1lbnRzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBpbiBhc1xuICAgICAgLy8ga2V5d29yZCBhcmd1bWVudHMgKGVzc2VudGlhbGx5IGRlZmF1bHQgdmFsdWVzKVxuXG4gICAgICBtYWNyb0FyZ3Muc2xpY2UoYXJncy5sZW5ndGgsIGFyZ0NvdW50KS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGkpIHtcbiAgICAgICAgaWYgKGkgPCBrd2FyZ05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIGt3YXJnc1trd2FyZ05hbWVzW2ldXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhcmdzLnB1c2goa3dhcmdzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ0NvdW50IDwgYXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICBhcmdzID0gbWFjcm9BcmdzLnNsaWNlKDAsIGFyZ0NvdW50KTtcblxuICAgICAgZm9yICh2YXIgaSA9IGFyZ0NvdW50OyBpIDwgYXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ05hbWVzW2ldOyAvLyBLZXl3b3JkIGFyZ3VtZW50cyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgYXNcbiAgICAgICAgLy8gcG9zaXRpb25hbCBhcmd1bWVudHMsIGkuZS4gdGhlIGNhbGxlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHVzZWQgdGhlIG5hbWUgb2YgYSBwb3NpdGlvbmFsIGFyZ1xuXG4gICAgICAgIGFyZ3MucHVzaChrd2FyZ3NbYXJnXSk7XG4gICAgICAgIGRlbGV0ZSBrd2FyZ3NbYXJnXTtcbiAgICAgIH1cblxuICAgICAgYXJncy5wdXNoKGt3YXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MgPSBtYWNyb0FyZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBtYWtlS2V5d29yZEFyZ3Mob2JqKSB7XG4gIG9iai5fX2tleXdvcmRzID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gaXNLZXl3b3JkQXJncyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCAnX19rZXl3b3JkcycpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXl3b3JkQXJncyhhcmdzKSB7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcblxuICBpZiAobGVuKSB7XG4gICAgdmFyIGxhc3RBcmcgPSBhcmdzW2xlbiAtIDFdO1xuXG4gICAgaWYgKGlzS2V5d29yZEFyZ3MobGFzdEFyZykpIHtcbiAgICAgIHJldHVybiBsYXN0QXJnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbnVtQXJncyhhcmdzKSB7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcblxuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgbGFzdEFyZyA9IGFyZ3NbbGVuIC0gMV07XG5cbiAgaWYgKGlzS2V5d29yZEFyZ3MobGFzdEFyZykpIHtcbiAgICByZXR1cm4gbGVuIC0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGVuO1xuICB9XG59IC8vIEEgU2FmZVN0cmluZyBvYmplY3QgaW5kaWNhdGVzIHRoYXQgdGhlIHN0cmluZyBzaG91bGQgbm90IGJlXG4vLyBhdXRvZXNjYXBlZC4gVGhpcyBoYXBwZW5zIG1hZ2ljYWxseSBiZWNhdXNlIGF1dG9lc2NhcGluZyBvbmx5XG4vLyBvY2N1cnMgb24gcHJpbWl0aXZlIHN0cmluZyBvYmplY3RzLlxuXG5cbmZ1bmN0aW9uIFNhZmVTdHJpbmcodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB0aGlzLnZhbCA9IHZhbDtcbiAgdGhpcy5sZW5ndGggPSB2YWwubGVuZ3RoO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyaW5nLnByb3RvdHlwZSwge1xuICBsZW5ndGg6IHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IDBcbiAgfVxufSk7XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICByZXR1cm4gdGhpcy52YWw7XG59O1xuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy52YWw7XG59O1xuXG5mdW5jdGlvbiBjb3B5U2FmZW5lc3MoZGVzdCwgdGFyZ2V0KSB7XG4gIGlmIChkZXN0IGluc3RhbmNlb2YgU2FmZVN0cmluZykge1xuICAgIHJldHVybiBuZXcgU2FmZVN0cmluZyh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBtYXJrU2FmZSh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgU2FmZVN0cmluZyh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwU2FmZShhcmdzKSB7XG4gICAgICB2YXIgcmV0ID0gdmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdHJpbmcocmV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHByZXNzVmFsdWUodmFsLCBhdXRvZXNjYXBlKSB7XG4gIHZhbCA9IHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCA/IHZhbCA6ICcnO1xuXG4gIGlmIChhdXRvZXNjYXBlICYmICEodmFsIGluc3RhbmNlb2YgU2FmZVN0cmluZykpIHtcbiAgICB2YWwgPSBsaWIuZXNjYXBlKHZhbC50b1N0cmluZygpKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZURlZmluZWQodmFsLCBsaW5lbm8sIGNvbG5vKSB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoJ2F0dGVtcHRlZCB0byBvdXRwdXQgbnVsbCBvciB1bmRlZmluZWQgdmFsdWUnLCBsaW5lbm8gKyAxLCBjb2xubyArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gbWVtYmVyTG9va3VwKG9iaiwgdmFsKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpbdmFsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqW3ZhbF0uYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG9ialt2YWxdO1xufVxuXG5mdW5jdGlvbiBjYWxsV3JhcChvYmosIG5hbWUsIGNvbnRleHQsIGFyZ3MpIHtcbiAgaWYgKCFvYmopIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjYWxsIGAnICsgbmFtZSArICdgLCB3aGljaCBpcyB1bmRlZmluZWQgb3IgZmFsc2V5Jyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNhbGwgYCcgKyBuYW1lICsgJ2AsIHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gb2JqLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjb250ZXh0T3JGcmFtZUxvb2t1cChjb250ZXh0LCBmcmFtZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZnJhbWUubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBjb250ZXh0Lmxvb2t1cChuYW1lKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IsIGxpbmVubywgY29sbm8pIHtcbiAgaWYgKGVycm9yLmxpbmVubykge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IGxpYi5UZW1wbGF0ZUVycm9yKGVycm9yLCBsaW5lbm8sIGNvbG5vKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3luY0VhY2goYXJyLCBkaW1lbiwgaXRlciwgY2IpIHtcbiAgaWYgKGxpYi5pc0FycmF5KGFycikpIHtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBsaWIuYXN5bmNJdGVyKGFyciwgZnVuY3Rpb24gaXRlckNhbGxiYWNrKGl0ZW0sIGksIG5leHQpIHtcbiAgICAgIHN3aXRjaCAoZGltZW4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGl0ZXIoaXRlbSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaXRlcihpdGVtWzBdLCBpdGVtWzFdLCBpLCBsZW4sIG5leHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBpdGVyKGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGksIGxlbiwgbmV4dCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpdGVtLnB1c2goaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBpdGVyLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBsaWIuYXN5bmNGb3IoYXJyLCBmdW5jdGlvbiBpdGVyQ2FsbGJhY2soa2V5LCB2YWwsIGksIGxlbiwgbmV4dCkge1xuICAgICAgaXRlcihrZXksIHZhbCwgaSwgbGVuLCBuZXh0KTtcbiAgICB9LCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNBbGwoYXJyLCBkaW1lbiwgZnVuYywgY2IpIHtcbiAgdmFyIGZpbmlzaGVkID0gMDtcbiAgdmFyIGxlbjtcbiAgdmFyIG91dHB1dEFycjtcblxuICBmdW5jdGlvbiBkb25lKGksIG91dHB1dCkge1xuICAgIGZpbmlzaGVkKys7XG4gICAgb3V0cHV0QXJyW2ldID0gb3V0cHV0O1xuXG4gICAgaWYgKGZpbmlzaGVkID09PSBsZW4pIHtcbiAgICAgIGNiKG51bGwsIG91dHB1dEFyci5qb2luKCcnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpYi5pc0FycmF5KGFycikpIHtcbiAgICBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIG91dHB1dEFyciA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgY2IobnVsbCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFycltpXTtcblxuICAgICAgICBzd2l0Y2ggKGRpbWVuKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZnVuYyhpdGVtLCBpLCBsZW4sIGRvbmUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBmdW5jKGl0ZW1bMF0sIGl0ZW1bMV0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGZ1bmMoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSwgaSwgbGVuLCBkb25lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGl0ZW0ucHVzaChpLCBsZW4sIGRvbmUpO1xuICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5cyA9IGxpYi5rZXlzKGFyciB8fCB7fSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgb3V0cHV0QXJyID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBjYihudWxsLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgayA9IGtleXNbX2ldO1xuICAgICAgICBmdW5jKGssIGFycltrXSwgX2ksIGxlbiwgZG9uZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21JdGVyYXRvcihhcnIpIHtcbiAgaWYgKHR5cGVvZiBhcnIgIT09ICdvYmplY3QnIHx8IGFyciA9PT0gbnVsbCB8fCBsaWIuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChzdXBwb3J0c0l0ZXJhdG9ycyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJyKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbShhcnIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZyYW1lOiBGcmFtZSxcbiAgbWFrZU1hY3JvOiBtYWtlTWFjcm8sXG4gIG1ha2VLZXl3b3JkQXJnczogbWFrZUtleXdvcmRBcmdzLFxuICBudW1BcmdzOiBudW1BcmdzLFxuICBzdXBwcmVzc1ZhbHVlOiBzdXBwcmVzc1ZhbHVlLFxuICBlbnN1cmVEZWZpbmVkOiBlbnN1cmVEZWZpbmVkLFxuICBtZW1iZXJMb29rdXA6IG1lbWJlckxvb2t1cCxcbiAgY29udGV4dE9yRnJhbWVMb29rdXA6IGNvbnRleHRPckZyYW1lTG9va3VwLFxuICBjYWxsV3JhcDogY2FsbFdyYXAsXG4gIGhhbmRsZUVycm9yOiBoYW5kbGVFcnJvcixcbiAgaXNBcnJheTogbGliLmlzQXJyYXksXG4gIGtleXM6IGxpYi5rZXlzLFxuICBTYWZlU3RyaW5nOiBTYWZlU3RyaW5nLFxuICBjb3B5U2FmZW5lc3M6IGNvcHlTYWZlbmVzcyxcbiAgbWFya1NhZmU6IG1hcmtTYWZlLFxuICBhc3luY0VhY2g6IGFzeW5jRWFjaCxcbiAgYXN5bmNBbGw6IGFzeW5jQWxsLFxuICBpbk9wZXJhdG9yOiBsaWIuaW5PcGVyYXRvcixcbiAgZnJvbUl0ZXJhdG9yOiBmcm9tSXRlcmF0b3Jcbn07XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIE9iaiA9IF9yZXF1aXJlLk9iajtcblxuZnVuY3Rpb24gdHJhdmVyc2VBbmRDaGVjayhvYmosIHR5cGUsIHJlc3VsdHMpIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICByZXN1bHRzLnB1c2gob2JqKTtcbiAgfVxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgb2JqLmZpbmRBbGwodHlwZSwgcmVzdWx0cyk7XG4gIH1cbn1cblxudmFyIE5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoTm9kZSwgX09iaik7XG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICByZXR1cm4gX09iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KGxpbmVubywgY29sbm8pIHtcbiAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG4gICAgdGhpcy5jb2xubyA9IGNvbG5vO1xuICAgIHRoaXMuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgICAvLyBUaGUgZmlyc3QgdHdvIGFyZ3MgYXJlIGxpbmUvY29sIG51bWJlcnMsIHNvIG9mZnNldCBieSAyXG4gICAgICB2YXIgdmFsID0gX2FyZ3VtZW50c1tpICsgMl07IC8vIEZpZWxkcyBzaG91bGQgbmV2ZXIgYmUgdW5kZWZpbmVkLCBidXQgbnVsbC4gSXQgbWFrZXNcbiAgICAgIC8vIHRlc3RpbmcgZWFzaWVyIHRvIG5vcm1hbGl6ZSB2YWx1ZXMuXG5cbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBfdGhpc1tmaWVsZF0gPSB2YWw7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmZpbmRBbGwgPSBmdW5jdGlvbiBmaW5kQWxsKHR5cGUsIHJlc3VsdHMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gdHJhdmVyc2VBbmRDaGVjayhjaGlsZCwgdHlwZSwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQ2hlY2soX3RoaXMyW2ZpZWxkXSwgdHlwZSwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBfcHJvdG8uaXRlckZpZWxkcyA9IGZ1bmN0aW9uIGl0ZXJGaWVsZHMoZnVuYykge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIGZ1bmMoX3RoaXMzW2ZpZWxkXSwgZmllbGQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBOb2RlO1xufShPYmopOyAvLyBBYnN0cmFjdCBub2Rlc1xuXG5cbnZhciBWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoVmFsdWUsIF9Ob2RlKTtcblxuICBmdW5jdGlvbiBWYWx1ZSgpIHtcbiAgICByZXR1cm4gX05vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZhbHVlLCBbe1xuICAgIGtleTogXCJ0eXBlbmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdWYWx1ZSc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFsndmFsdWUnXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmFsdWU7XG59KE5vZGUpOyAvLyBDb25jcmV0ZSBub2Rlc1xuXG5cbnZhciBOb2RlTGlzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUyKSB7XG4gIF9pbmhlcml0c0xvb3NlKE5vZGVMaXN0LCBfTm9kZTIpO1xuXG4gIGZ1bmN0aW9uIE5vZGVMaXN0KCkge1xuICAgIHJldHVybiBfTm9kZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBOb2RlTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pbml0ID0gZnVuY3Rpb24gaW5pdChsaW5lbm8sIGNvbG5vLCBub2Rlcykge1xuICAgIF9Ob2RlMi5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGxpbmVubywgY29sbm8sIG5vZGVzIHx8IFtdKTtcbiAgfTtcblxuICBfcHJvdG8yLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQobm9kZSkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoTm9kZUxpc3QsIFt7XG4gICAga2V5OiBcInR5cGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ05vZGVMaXN0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmllbGRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gWydjaGlsZHJlbiddO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlTGlzdDtcbn0oTm9kZSk7XG5cbnZhciBSb290ID0gTm9kZUxpc3QuZXh0ZW5kKCdSb290Jyk7XG52YXIgTGl0ZXJhbCA9IFZhbHVlLmV4dGVuZCgnTGl0ZXJhbCcpO1xudmFyIFN5bWJvbCA9IFZhbHVlLmV4dGVuZCgnU3ltYm9sJyk7XG52YXIgR3JvdXAgPSBOb2RlTGlzdC5leHRlbmQoJ0dyb3VwJyk7XG52YXIgQXJyYXlOb2RlID0gTm9kZUxpc3QuZXh0ZW5kKCdBcnJheScpO1xudmFyIFBhaXIgPSBOb2RlLmV4dGVuZCgnUGFpcicsIHtcbiAgZmllbGRzOiBbJ2tleScsICd2YWx1ZSddXG59KTtcbnZhciBEaWN0ID0gTm9kZUxpc3QuZXh0ZW5kKCdEaWN0Jyk7XG52YXIgTG9va3VwVmFsID0gTm9kZS5leHRlbmQoJ0xvb2t1cFZhbCcsIHtcbiAgZmllbGRzOiBbJ3RhcmdldCcsICd2YWwnXVxufSk7XG52YXIgSWYgPSBOb2RlLmV4dGVuZCgnSWYnLCB7XG4gIGZpZWxkczogWydjb25kJywgJ2JvZHknLCAnZWxzZV8nXVxufSk7XG52YXIgSWZBc3luYyA9IElmLmV4dGVuZCgnSWZBc3luYycpO1xudmFyIElubGluZUlmID0gTm9kZS5leHRlbmQoJ0lubGluZUlmJywge1xuICBmaWVsZHM6IFsnY29uZCcsICdib2R5JywgJ2Vsc2VfJ11cbn0pO1xudmFyIEZvciA9IE5vZGUuZXh0ZW5kKCdGb3InLCB7XG4gIGZpZWxkczogWydhcnInLCAnbmFtZScsICdib2R5JywgJ2Vsc2VfJ11cbn0pO1xudmFyIEFzeW5jRWFjaCA9IEZvci5leHRlbmQoJ0FzeW5jRWFjaCcpO1xudmFyIEFzeW5jQWxsID0gRm9yLmV4dGVuZCgnQXN5bmNBbGwnKTtcbnZhciBNYWNybyA9IE5vZGUuZXh0ZW5kKCdNYWNybycsIHtcbiAgZmllbGRzOiBbJ25hbWUnLCAnYXJncycsICdib2R5J11cbn0pO1xudmFyIENhbGxlciA9IE1hY3JvLmV4dGVuZCgnQ2FsbGVyJyk7XG52YXIgSW1wb3J0ID0gTm9kZS5leHRlbmQoJ0ltcG9ydCcsIHtcbiAgZmllbGRzOiBbJ3RlbXBsYXRlJywgJ3RhcmdldCcsICd3aXRoQ29udGV4dCddXG59KTtcblxudmFyIEZyb21JbXBvcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlMykge1xuICBfaW5oZXJpdHNMb29zZShGcm9tSW1wb3J0LCBfTm9kZTMpO1xuXG4gIGZ1bmN0aW9uIEZyb21JbXBvcnQoKSB7XG4gICAgcmV0dXJuIF9Ob2RlMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IEZyb21JbXBvcnQucHJvdG90eXBlO1xuXG4gIF9wcm90bzMuaW5pdCA9IGZ1bmN0aW9uIGluaXQobGluZW5vLCBjb2xubywgdGVtcGxhdGUsIG5hbWVzLCB3aXRoQ29udGV4dCkge1xuICAgIF9Ob2RlMy5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGxpbmVubywgY29sbm8sIHRlbXBsYXRlLCBuYW1lcyB8fCBuZXcgTm9kZUxpc3QoKSwgd2l0aENvbnRleHQpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhGcm9tSW1wb3J0LCBbe1xuICAgIGtleTogXCJ0eXBlbmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdGcm9tSW1wb3J0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmllbGRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gWyd0ZW1wbGF0ZScsICduYW1lcycsICd3aXRoQ29udGV4dCddO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcm9tSW1wb3J0O1xufShOb2RlKTtcblxudmFyIEZ1bkNhbGwgPSBOb2RlLmV4dGVuZCgnRnVuQ2FsbCcsIHtcbiAgZmllbGRzOiBbJ25hbWUnLCAnYXJncyddXG59KTtcbnZhciBGaWx0ZXIgPSBGdW5DYWxsLmV4dGVuZCgnRmlsdGVyJyk7XG52YXIgRmlsdGVyQXN5bmMgPSBGaWx0ZXIuZXh0ZW5kKCdGaWx0ZXJBc3luYycsIHtcbiAgZmllbGRzOiBbJ25hbWUnLCAnYXJncycsICdzeW1ib2wnXVxufSk7XG52YXIgS2V5d29yZEFyZ3MgPSBEaWN0LmV4dGVuZCgnS2V5d29yZEFyZ3MnKTtcbnZhciBCbG9jayA9IE5vZGUuZXh0ZW5kKCdCbG9jaycsIHtcbiAgZmllbGRzOiBbJ25hbWUnLCAnYm9keSddXG59KTtcbnZhciBTdXBlciA9IE5vZGUuZXh0ZW5kKCdTdXBlcicsIHtcbiAgZmllbGRzOiBbJ2Jsb2NrTmFtZScsICdzeW1ib2wnXVxufSk7XG52YXIgVGVtcGxhdGVSZWYgPSBOb2RlLmV4dGVuZCgnVGVtcGxhdGVSZWYnLCB7XG4gIGZpZWxkczogWyd0ZW1wbGF0ZSddXG59KTtcbnZhciBFeHRlbmRzID0gVGVtcGxhdGVSZWYuZXh0ZW5kKCdFeHRlbmRzJyk7XG52YXIgSW5jbHVkZSA9IE5vZGUuZXh0ZW5kKCdJbmNsdWRlJywge1xuICBmaWVsZHM6IFsndGVtcGxhdGUnLCAnaWdub3JlTWlzc2luZyddXG59KTtcbnZhciBTZXQgPSBOb2RlLmV4dGVuZCgnU2V0Jywge1xuICBmaWVsZHM6IFsndGFyZ2V0cycsICd2YWx1ZSddXG59KTtcbnZhciBTd2l0Y2ggPSBOb2RlLmV4dGVuZCgnU3dpdGNoJywge1xuICBmaWVsZHM6IFsnZXhwcicsICdjYXNlcycsICdkZWZhdWx0J11cbn0pO1xudmFyIENhc2UgPSBOb2RlLmV4dGVuZCgnQ2FzZScsIHtcbiAgZmllbGRzOiBbJ2NvbmQnLCAnYm9keSddXG59KTtcbnZhciBPdXRwdXQgPSBOb2RlTGlzdC5leHRlbmQoJ091dHB1dCcpO1xudmFyIENhcHR1cmUgPSBOb2RlLmV4dGVuZCgnQ2FwdHVyZScsIHtcbiAgZmllbGRzOiBbJ2JvZHknXVxufSk7XG52YXIgVGVtcGxhdGVEYXRhID0gTGl0ZXJhbC5leHRlbmQoJ1RlbXBsYXRlRGF0YScpO1xudmFyIFVuYXJ5T3AgPSBOb2RlLmV4dGVuZCgnVW5hcnlPcCcsIHtcbiAgZmllbGRzOiBbJ3RhcmdldCddXG59KTtcbnZhciBCaW5PcCA9IE5vZGUuZXh0ZW5kKCdCaW5PcCcsIHtcbiAgZmllbGRzOiBbJ2xlZnQnLCAncmlnaHQnXVxufSk7XG52YXIgSW4gPSBCaW5PcC5leHRlbmQoJ0luJyk7XG52YXIgSXMgPSBCaW5PcC5leHRlbmQoJ0lzJyk7XG52YXIgT3IgPSBCaW5PcC5leHRlbmQoJ09yJyk7XG52YXIgQW5kID0gQmluT3AuZXh0ZW5kKCdBbmQnKTtcbnZhciBOb3QgPSBVbmFyeU9wLmV4dGVuZCgnTm90Jyk7XG52YXIgQWRkID0gQmluT3AuZXh0ZW5kKCdBZGQnKTtcbnZhciBDb25jYXQgPSBCaW5PcC5leHRlbmQoJ0NvbmNhdCcpO1xudmFyIFN1YiA9IEJpbk9wLmV4dGVuZCgnU3ViJyk7XG52YXIgTXVsID0gQmluT3AuZXh0ZW5kKCdNdWwnKTtcbnZhciBEaXYgPSBCaW5PcC5leHRlbmQoJ0RpdicpO1xudmFyIEZsb29yRGl2ID0gQmluT3AuZXh0ZW5kKCdGbG9vckRpdicpO1xudmFyIE1vZCA9IEJpbk9wLmV4dGVuZCgnTW9kJyk7XG52YXIgUG93ID0gQmluT3AuZXh0ZW5kKCdQb3cnKTtcbnZhciBOZWcgPSBVbmFyeU9wLmV4dGVuZCgnTmVnJyk7XG52YXIgUG9zID0gVW5hcnlPcC5leHRlbmQoJ1BvcycpO1xudmFyIENvbXBhcmUgPSBOb2RlLmV4dGVuZCgnQ29tcGFyZScsIHtcbiAgZmllbGRzOiBbJ2V4cHInLCAnb3BzJ11cbn0pO1xudmFyIENvbXBhcmVPcGVyYW5kID0gTm9kZS5leHRlbmQoJ0NvbXBhcmVPcGVyYW5kJywge1xuICBmaWVsZHM6IFsnZXhwcicsICd0eXBlJ11cbn0pO1xudmFyIENhbGxFeHRlbnNpb24gPSBOb2RlLmV4dGVuZCgnQ2FsbEV4dGVuc2lvbicsIHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChleHQsIHByb3AsIGFyZ3MsIGNvbnRlbnRBcmdzKSB7XG4gICAgdGhpcy5wYXJlbnQoKTtcbiAgICB0aGlzLmV4dE5hbWUgPSBleHQuX19uYW1lIHx8IGV4dDtcbiAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgIHRoaXMuYXJncyA9IGFyZ3MgfHwgbmV3IE5vZGVMaXN0KCk7XG4gICAgdGhpcy5jb250ZW50QXJncyA9IGNvbnRlbnRBcmdzIHx8IFtdO1xuICAgIHRoaXMuYXV0b2VzY2FwZSA9IGV4dC5hdXRvZXNjYXBlO1xuICB9LFxuICBmaWVsZHM6IFsnZXh0TmFtZScsICdwcm9wJywgJ2FyZ3MnLCAnY29udGVudEFyZ3MnXVxufSk7XG52YXIgQ2FsbEV4dGVuc2lvbkFzeW5jID0gQ2FsbEV4dGVuc2lvbi5leHRlbmQoJ0NhbGxFeHRlbnNpb25Bc3luYycpOyAvLyBUaGlzIGlzIGhhY2t5LCBidXQgdGhpcyBpcyBqdXN0IGEgZGVidWdnaW5nIGZ1bmN0aW9uIGFueXdheVxuXG5mdW5jdGlvbiBwcmludChzdHIsIGluZGVudCwgaW5saW5lKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICBpZiAobGluZSAmJiAoaW5saW5lICYmIGkgPiAwIHx8ICFpbmxpbmUpKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnICcucmVwZWF0KGluZGVudCkpO1xuICAgIH1cblxuICAgIHZhciBubCA9IGkgPT09IGxpbmVzLmxlbmd0aCAtIDEgPyAnJyA6ICdcXG4nO1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKFwiXCIgKyBsaW5lICsgbmwpO1xuICB9KTtcbn0gLy8gUHJpbnQgdGhlIEFTVCBpbiBhIG5pY2VseSBmb3JtYXR0ZWQgdHJlZSBmb3JtYXQgZm9yIGRlYnVnZ2luXG5cblxuZnVuY3Rpb24gcHJpbnROb2Rlcyhub2RlLCBpbmRlbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDA7XG4gIHByaW50KG5vZGUudHlwZW5hbWUgKyAnOiAnLCBpbmRlbnQpO1xuXG4gIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZUxpc3QpIHtcbiAgICBwcmludCgnXFxuJyk7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICBwcmludE5vZGVzKG4sIGluZGVudCArIDIpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBDYWxsRXh0ZW5zaW9uKSB7XG4gICAgcHJpbnQobm9kZS5leHROYW1lICsgXCIuXCIgKyBub2RlLnByb3AgKyBcIlxcblwiKTtcblxuICAgIGlmIChub2RlLmFyZ3MpIHtcbiAgICAgIHByaW50Tm9kZXMobm9kZS5hcmdzLCBpbmRlbnQgKyAyKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jb250ZW50QXJncykge1xuICAgICAgbm9kZS5jb250ZW50QXJncy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHByaW50Tm9kZXMobiwgaW5kZW50ICsgMik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHByb3BzID0gbnVsbDtcbiAgICBub2RlLml0ZXJGaWVsZHMoZnVuY3Rpb24gKHZhbCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBub2Rlcy5wdXNoKFtmaWVsZE5hbWUsIHZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgICAgcHJvcHNbZmllbGROYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm9wcykge1xuICAgICAgcHJpbnQoSlNPTi5zdHJpbmdpZnkocHJvcHMsIG51bGwsIDIpICsgJ1xcbicsIG51bGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmludCgnXFxuJyk7XG4gICAgfVxuXG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGZpZWxkTmFtZSA9IF9yZWZbMF0sXG4gICAgICAgICAgbiA9IF9yZWZbMV07XG4gICAgICBwcmludChcIltcIiArIGZpZWxkTmFtZSArIFwiXSA9PlwiLCBpbmRlbnQgKyAyKTtcbiAgICAgIHByaW50Tm9kZXMobiwgaW5kZW50ICsgNCk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE5vZGU6IE5vZGUsXG4gIFJvb3Q6IFJvb3QsXG4gIE5vZGVMaXN0OiBOb2RlTGlzdCxcbiAgVmFsdWU6IFZhbHVlLFxuICBMaXRlcmFsOiBMaXRlcmFsLFxuICBTeW1ib2w6IFN5bWJvbCxcbiAgR3JvdXA6IEdyb3VwLFxuICBBcnJheTogQXJyYXlOb2RlLFxuICBQYWlyOiBQYWlyLFxuICBEaWN0OiBEaWN0LFxuICBPdXRwdXQ6IE91dHB1dCxcbiAgQ2FwdHVyZTogQ2FwdHVyZSxcbiAgVGVtcGxhdGVEYXRhOiBUZW1wbGF0ZURhdGEsXG4gIElmOiBJZixcbiAgSWZBc3luYzogSWZBc3luYyxcbiAgSW5saW5lSWY6IElubGluZUlmLFxuICBGb3I6IEZvcixcbiAgQXN5bmNFYWNoOiBBc3luY0VhY2gsXG4gIEFzeW5jQWxsOiBBc3luY0FsbCxcbiAgTWFjcm86IE1hY3JvLFxuICBDYWxsZXI6IENhbGxlcixcbiAgSW1wb3J0OiBJbXBvcnQsXG4gIEZyb21JbXBvcnQ6IEZyb21JbXBvcnQsXG4gIEZ1bkNhbGw6IEZ1bkNhbGwsXG4gIEZpbHRlcjogRmlsdGVyLFxuICBGaWx0ZXJBc3luYzogRmlsdGVyQXN5bmMsXG4gIEtleXdvcmRBcmdzOiBLZXl3b3JkQXJncyxcbiAgQmxvY2s6IEJsb2NrLFxuICBTdXBlcjogU3VwZXIsXG4gIEV4dGVuZHM6IEV4dGVuZHMsXG4gIEluY2x1ZGU6IEluY2x1ZGUsXG4gIFNldDogU2V0LFxuICBTd2l0Y2g6IFN3aXRjaCxcbiAgQ2FzZTogQ2FzZSxcbiAgTG9va3VwVmFsOiBMb29rdXBWYWwsXG4gIEJpbk9wOiBCaW5PcCxcbiAgSW46IEluLFxuICBJczogSXMsXG4gIE9yOiBPcixcbiAgQW5kOiBBbmQsXG4gIE5vdDogTm90LFxuICBBZGQ6IEFkZCxcbiAgQ29uY2F0OiBDb25jYXQsXG4gIFN1YjogU3ViLFxuICBNdWw6IE11bCxcbiAgRGl2OiBEaXYsXG4gIEZsb29yRGl2OiBGbG9vckRpdixcbiAgTW9kOiBNb2QsXG4gIFBvdzogUG93LFxuICBOZWc6IE5lZyxcbiAgUG9zOiBQb3MsXG4gIENvbXBhcmU6IENvbXBhcmUsXG4gIENvbXBhcmVPcGVyYW5kOiBDb21wYXJlT3BlcmFuZCxcbiAgQ2FsbEV4dGVuc2lvbjogQ2FsbEV4dGVuc2lvbixcbiAgQ2FsbEV4dGVuc2lvbkFzeW5jOiBDYWxsRXh0ZW5zaW9uQXN5bmMsXG4gIHByaW50Tm9kZXM6IHByaW50Tm9kZXNcbn07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIHRyYW5zZm9ybWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBub2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCksXG4gICAgVGVtcGxhdGVFcnJvciA9IF9yZXF1aXJlLlRlbXBsYXRlRXJyb3I7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuICAgIEZyYW1lID0gX3JlcXVpcmUyLkZyYW1lO1xuXG52YXIgX3JlcXVpcmUzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSxcbiAgICBPYmogPSBfcmVxdWlyZTMuT2JqOyAvLyBUaGVzZSBhcmUgYWxsIHRoZSBzYW1lIGZvciBub3csIGJ1dCBzaG91bGRuJ3QgYmUgcGFzc2VkIHN0cmFpZ2h0XG4vLyB0aHJvdWdoXG5cblxudmFyIGNvbXBhcmVPcHMgPSB7XG4gICc9PSc6ICc9PScsXG4gICc9PT0nOiAnPT09JyxcbiAgJyE9JzogJyE9JyxcbiAgJyE9PSc6ICchPT0nLFxuICAnPCc6ICc8JyxcbiAgJz4nOiAnPicsXG4gICc8PSc6ICc8PScsXG4gICc+PSc6ICc+PSdcbn07XG5cbnZhciBDb21waWxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iaikge1xuICBfaW5oZXJpdHNMb29zZShDb21waWxlciwgX09iaik7XG5cbiAgZnVuY3Rpb24gQ29tcGlsZXIoKSB7XG4gICAgcmV0dXJuIF9PYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENvbXBpbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQodGVtcGxhdGVOYW1lLCB0aHJvd09uVW5kZWZpbmVkKSB7XG4gICAgdGhpcy50ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG4gICAgdGhpcy5jb2RlYnVmID0gW107XG4gICAgdGhpcy5sYXN0SWQgPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ1ZmZlclN0YWNrID0gW107XG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzID0gJyc7XG4gICAgdGhpcy5pbkJsb2NrID0gZmFsc2U7XG4gICAgdGhpcy50aHJvd09uVW5kZWZpbmVkID0gdGhyb3dPblVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8uZmFpbCA9IGZ1bmN0aW9uIGZhaWwobXNnLCBsaW5lbm8sIGNvbG5vKSB7XG4gICAgaWYgKGxpbmVubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaW5lbm8gKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbm8gKz0gMTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVGVtcGxhdGVFcnJvcihtc2csIGxpbmVubywgY29sbm8pO1xuICB9O1xuXG4gIF9wcm90by5fcHVzaEJ1ZmZlciA9IGZ1bmN0aW9uIF9wdXNoQnVmZmVyKCkge1xuICAgIHZhciBpZCA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB0aGlzLmJ1ZmZlclN0YWNrLnB1c2godGhpcy5idWZmZXIpO1xuICAgIHRoaXMuYnVmZmVyID0gaWQ7XG5cbiAgICB0aGlzLl9lbWl0KFwidmFyIFwiICsgdGhpcy5idWZmZXIgKyBcIiA9IFxcXCJcXFwiO1wiKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICBfcHJvdG8uX3BvcEJ1ZmZlciA9IGZ1bmN0aW9uIF9wb3BCdWZmZXIoKSB7XG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlclN0YWNrLnBvcCgpO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdCA9IGZ1bmN0aW9uIF9lbWl0KGNvZGUpIHtcbiAgICB0aGlzLmNvZGVidWYucHVzaChjb2RlKTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXRMaW5lID0gZnVuY3Rpb24gX2VtaXRMaW5lKGNvZGUpIHtcbiAgICB0aGlzLl9lbWl0KGNvZGUgKyAnXFxuJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0TGluZXMgPSBmdW5jdGlvbiBfZW1pdExpbmVzKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbGluZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBsaW5lc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2VtaXRMaW5lKGxpbmUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdEZ1bmNCZWdpbiA9IGZ1bmN0aW9uIF9lbWl0RnVuY0JlZ2luKG5vZGUsIG5hbWUpIHtcbiAgICB0aGlzLmJ1ZmZlciA9ICdvdXRwdXQnO1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9ICcnO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJmdW5jdGlvbiBcIiArIG5hbWUgKyBcIihlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYikge1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIGxpbmVubyA9IFwiICsgbm9kZS5saW5lbm8gKyBcIjtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcInZhciBjb2xubyA9IFwiICsgbm9kZS5jb2xubyArIFwiO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgdGhpcy5idWZmZXIgKyBcIiA9IFxcXCJcXFwiO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd0cnkgeycpO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdEZ1bmNFbmQgPSBmdW5jdGlvbiBfZW1pdEZ1bmNFbmQobm9SZXR1cm4pIHtcbiAgICBpZiAoIW5vUmV0dXJuKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnY2IobnVsbCwgJyArIHRoaXMuYnVmZmVyICsgJyk7Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VTY29wZUxldmVscygpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30gY2F0Y2ggKGUpIHsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCcgIGNiKHJ1bnRpbWUuaGFuZGxlRXJyb3IoZSwgbGluZW5vLCBjb2xubykpOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGRTY29wZUxldmVsID0gZnVuY3Rpb24gX2FkZFNjb3BlTGV2ZWwoKSB7XG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzICs9ICd9KSc7XG4gIH07XG5cbiAgX3Byb3RvLl9jbG9zZVNjb3BlTGV2ZWxzID0gZnVuY3Rpb24gX2Nsb3NlU2NvcGVMZXZlbHMoKSB7XG4gICAgdGhpcy5fZW1pdExpbmUodGhpcy5fc2NvcGVDbG9zZXJzICsgJzsnKTtcblxuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9ICcnO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aFNjb3BlZFN5bnRheCA9IGZ1bmN0aW9uIF93aXRoU2NvcGVkU3ludGF4KGZ1bmMpIHtcbiAgICB2YXIgX3Njb3BlQ2xvc2VycyA9IHRoaXMuX3Njb3BlQ2xvc2VycztcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcbiAgICBmdW5jLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9jbG9zZVNjb3BlTGV2ZWxzKCk7XG5cbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSBfc2NvcGVDbG9zZXJzO1xuICB9O1xuXG4gIF9wcm90by5fbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gX21ha2VDYWxsYmFjayhyZXMpIHtcbiAgICB2YXIgZXJyID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHJldHVybiAnZnVuY3Rpb24oJyArIGVyciArIChyZXMgPyAnLCcgKyByZXMgOiAnJykgKyAnKSB7XFxuJyArICdpZignICsgZXJyICsgJykgeyBjYignICsgZXJyICsgJyk7IHJldHVybjsgfSc7XG4gIH07XG5cbiAgX3Byb3RvLl90bXBpZCA9IGZ1bmN0aW9uIF90bXBpZCgpIHtcbiAgICB0aGlzLmxhc3RJZCsrO1xuICAgIHJldHVybiAndF8nICsgdGhpcy5sYXN0SWQ7XG4gIH07XG5cbiAgX3Byb3RvLl90ZW1wbGF0ZU5hbWUgPSBmdW5jdGlvbiBfdGVtcGxhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRlbXBsYXRlTmFtZSA9PSBudWxsID8gJ3VuZGVmaW5lZCcgOiBKU09OLnN0cmluZ2lmeSh0aGlzLnRlbXBsYXRlTmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlQ2hpbGRyZW4gPSBmdW5jdGlvbiBfY29tcGlsZUNoaWxkcmVuKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBfdGhpczIuY29tcGlsZShjaGlsZCwgZnJhbWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZUFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIF9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCBzdGFydENoYXIsIGVuZENoYXIpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGlmIChzdGFydENoYXIpIHtcbiAgICAgIHRoaXMuX2VtaXQoc3RhcnRDaGFyKTtcbiAgICB9XG5cbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgX3RoaXMzLl9lbWl0KCcsJyk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMy5jb21waWxlKGNoaWxkLCBmcmFtZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZW5kQ2hhcikge1xuICAgICAgdGhpcy5fZW1pdChlbmRDaGFyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIF9jb21waWxlRXhwcmVzc2lvbihub2RlLCBmcmFtZSkge1xuICAgIC8vIFRPRE86IEknbSBub3QgcmVhbGx5IHN1cmUgaWYgdGhpcyB0eXBlIGNoZWNrIGlzIHdvcnRoIGl0IG9yXG4gICAgLy8gbm90LlxuICAgIHRoaXMuYXNzZXJ0VHlwZShub2RlLCBub2Rlcy5MaXRlcmFsLCBub2Rlcy5TeW1ib2wsIG5vZGVzLkdyb3VwLCBub2Rlcy5BcnJheSwgbm9kZXMuRGljdCwgbm9kZXMuRnVuQ2FsbCwgbm9kZXMuQ2FsbGVyLCBub2Rlcy5GaWx0ZXIsIG5vZGVzLkxvb2t1cFZhbCwgbm9kZXMuQ29tcGFyZSwgbm9kZXMuSW5saW5lSWYsIG5vZGVzLkluLCBub2Rlcy5Jcywgbm9kZXMuQW5kLCBub2Rlcy5Pciwgbm9kZXMuTm90LCBub2Rlcy5BZGQsIG5vZGVzLkNvbmNhdCwgbm9kZXMuU3ViLCBub2Rlcy5NdWwsIG5vZGVzLkRpdiwgbm9kZXMuRmxvb3JEaXYsIG5vZGVzLk1vZCwgbm9kZXMuUG93LCBub2Rlcy5OZWcsIG5vZGVzLlBvcywgbm9kZXMuQ29tcGFyZSwgbm9kZXMuTm9kZUxpc3QpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmFzc2VydFR5cGUgPSBmdW5jdGlvbiBhc3NlcnRUeXBlKG5vZGUpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHR5cGVzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHR5cGVzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGlmICghdHlwZXMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0O1xuICAgIH0pKSB7XG4gICAgICB0aGlzLmZhaWwoXCJhc3NlcnRUeXBlOiBpbnZhbGlkIHR5cGU6IFwiICsgbm9kZS50eXBlbmFtZSwgbm9kZS5saW5lbm8sIG5vZGUuY29sbm8pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNhbGxFeHRlbnNpb24gPSBmdW5jdGlvbiBjb21waWxlQ2FsbEV4dGVuc2lvbihub2RlLCBmcmFtZSwgYXN5bmMpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBhcmdzID0gbm9kZS5hcmdzO1xuICAgIHZhciBjb250ZW50QXJncyA9IG5vZGUuY29udGVudEFyZ3M7XG4gICAgdmFyIGF1dG9lc2NhcGUgPSB0eXBlb2Ygbm9kZS5hdXRvZXNjYXBlID09PSAnYm9vbGVhbicgPyBub2RlLmF1dG9lc2NhcGUgOiB0cnVlO1xuXG4gICAgaWYgKCFhc3luYykge1xuICAgICAgdGhpcy5fZW1pdCh0aGlzLmJ1ZmZlciArIFwiICs9IHJ1bnRpbWUuc3VwcHJlc3NWYWx1ZShcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdChcImVudi5nZXRFeHRlbnNpb24oXFxcIlwiICsgbm9kZS5leHROYW1lICsgXCJcXFwiKVtcXFwiXCIgKyBub2RlLnByb3AgKyBcIlxcXCJdKFwiKTtcblxuICAgIHRoaXMuX2VtaXQoJ2NvbnRleHQnKTtcblxuICAgIGlmIChhcmdzIHx8IGNvbnRlbnRBcmdzKSB7XG4gICAgICB0aGlzLl9lbWl0KCcsJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgIGlmICghKGFyZ3MgaW5zdGFuY2VvZiBub2Rlcy5Ob2RlTGlzdCkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdjb21waWxlQ2FsbEV4dGVuc2lvbjogYXJndW1lbnRzIG11c3QgYmUgYSBOb2RlTGlzdCwgJyArICd1c2UgYHBhcnNlci5wYXJzZVNpZ25hdHVyZWAnKTtcbiAgICAgIH1cblxuICAgICAgYXJncy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgICAgLy8gVGFnIGFyZ3VtZW50cyBhcmUgcGFzc2VkIG5vcm1hbGx5IHRvIHRoZSBjYWxsLiBOb3RlXG4gICAgICAgIC8vIHRoYXQga2V5d29yZCBhcmd1bWVudHMgYXJlIHR1cm5lZCBpbnRvIGEgc2luZ2xlIGpzXG4gICAgICAgIC8vIG9iamVjdCBhcyB0aGUgbGFzdCBhcmd1bWVudCwgaWYgdGhleSBleGlzdC5cbiAgICAgICAgX3RoaXM0Ll9jb21waWxlRXhwcmVzc2lvbihhcmcsIGZyYW1lKTtcblxuICAgICAgICBpZiAoaSAhPT0gYXJncy5jaGlsZHJlbi5sZW5ndGggLSAxIHx8IGNvbnRlbnRBcmdzLmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzNC5fZW1pdCgnLCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudEFyZ3MubGVuZ3RoKSB7XG4gICAgICBjb250ZW50QXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgX3RoaXM0Ll9lbWl0KCcsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgX3RoaXM0Ll9lbWl0TGluZSgnZnVuY3Rpb24oY2IpIHsnKTtcblxuICAgICAgICAgIF90aGlzNC5fZW1pdExpbmUoJ2lmKCFjYikgeyBjYiA9IGZ1bmN0aW9uKGVycikgeyBpZihlcnIpIHsgdGhyb3cgZXJyOyB9fX0nKTtcblxuICAgICAgICAgIHZhciBpZCA9IF90aGlzNC5fcHVzaEJ1ZmZlcigpO1xuXG4gICAgICAgICAgX3RoaXM0Ll93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzNC5jb21waWxlKGFyZywgZnJhbWUpO1xuXG4gICAgICAgICAgICBfdGhpczQuX2VtaXRMaW5lKFwiY2IobnVsbCwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczQuX3BvcEJ1ZmZlcigpO1xuXG4gICAgICAgICAgX3RoaXM0Ll9lbWl0TGluZShcInJldHVybiBcIiArIGlkICsgXCI7XCIpO1xuXG4gICAgICAgICAgX3RoaXM0Ll9lbWl0TGluZSgnfScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzNC5fZW1pdCgnbnVsbCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKHJlcykpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSh0aGlzLmJ1ZmZlciArIFwiICs9IHJ1bnRpbWUuc3VwcHJlc3NWYWx1ZShcIiArIHJlcyArIFwiLCBcIiArIGF1dG9lc2NhcGUgKyBcIiAmJiBlbnYub3B0cy5hdXRvZXNjYXBlKTtcIik7XG5cbiAgICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdCgnKScpO1xuXG4gICAgICB0aGlzLl9lbWl0KFwiLCBcIiArIGF1dG9lc2NhcGUgKyBcIiAmJiBlbnYub3B0cy5hdXRvZXNjYXBlKTtcXG5cIik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ2FsbEV4dGVuc2lvbkFzeW5jID0gZnVuY3Rpb24gY29tcGlsZUNhbGxFeHRlbnNpb25Bc3luYyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuY29tcGlsZUNhbGxFeHRlbnNpb24obm9kZSwgZnJhbWUsIHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTm9kZUxpc3QgPSBmdW5jdGlvbiBjb21waWxlTm9kZUxpc3Qobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQ2hpbGRyZW4obm9kZSwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTGl0ZXJhbCA9IGZ1bmN0aW9uIGNvbXBpbGVMaXRlcmFsKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG5vZGUudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdmFsID0gbm9kZS52YWx1ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxyL2csICdcXFxccicpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0KFwiXFxcIlwiICsgdmFsICsgXCJcXFwiXCIpO1xuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdCgnbnVsbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KG5vZGUudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlU3ltYm9sID0gZnVuY3Rpb24gY29tcGlsZVN5bWJvbChub2RlLCBmcmFtZSkge1xuICAgIHZhciBuYW1lID0gbm9kZS52YWx1ZTtcbiAgICB2YXIgdiA9IGZyYW1lLmxvb2t1cChuYW1lKTtcblxuICAgIGlmICh2KSB7XG4gICAgICB0aGlzLl9lbWl0KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KCdydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwKCcgKyAnY29udGV4dCwgZnJhbWUsIFwiJyArIG5hbWUgKyAnXCIpJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlR3JvdXAgPSBmdW5jdGlvbiBjb21waWxlR3JvdXAobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCAnKCcsICcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVBcnJheSA9IGZ1bmN0aW9uIGNvbXBpbGVBcnJheShub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZSwgZnJhbWUsICdbJywgJ10nKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZURpY3QgPSBmdW5jdGlvbiBjb21waWxlRGljdChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZSwgZnJhbWUsICd7JywgJ30nKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVBhaXIgPSBmdW5jdGlvbiBjb21waWxlUGFpcihub2RlLCBmcmFtZSkge1xuICAgIHZhciBrZXkgPSBub2RlLmtleTtcbiAgICB2YXIgdmFsID0gbm9kZS52YWx1ZTtcblxuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBub2Rlcy5TeW1ib2wpIHtcbiAgICAgIGtleSA9IG5ldyBub2Rlcy5MaXRlcmFsKGtleS5saW5lbm8sIGtleS5jb2xubywga2V5LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEoa2V5IGluc3RhbmNlb2Ygbm9kZXMuTGl0ZXJhbCAmJiB0eXBlb2Yga2V5LnZhbHVlID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHRoaXMuZmFpbCgnY29tcGlsZVBhaXI6IERpY3Qga2V5cyBtdXN0IGJlIHN0cmluZ3Mgb3IgbmFtZXMnLCBrZXkubGluZW5vLCBrZXkuY29sbm8pO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGlsZShrZXksIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJzogJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbih2YWwsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUlubGluZUlmID0gZnVuY3Rpb24gY29tcGlsZUlubGluZUlmKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnKCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUuY29uZCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnPycpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnOicpO1xuXG4gICAgaWYgKG5vZGUuZWxzZV8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoJ1wiXCInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJbiA9IGZ1bmN0aW9uIGNvbXBpbGVJbihub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUuaW5PcGVyYXRvcignKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJywnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJcyA9IGZ1bmN0aW9uIGNvbXBpbGVJcyhub2RlLCBmcmFtZSkge1xuICAgIC8vIGZpcnN0LCB3ZSBuZWVkIHRvIHRyeSB0byBnZXQgdGhlIG5hbWUgb2YgdGhlIHRlc3QgZnVuY3Rpb24sIGlmIGl0J3MgYVxuICAgIC8vIGNhbGxhYmxlIChpLmUuLCBoYXMgYXJncykgYW5kIG5vdCBhIHN5bWJvbC5cbiAgICB2YXIgcmlnaHQgPSBub2RlLnJpZ2h0Lm5hbWUgPyBub2RlLnJpZ2h0Lm5hbWUudmFsdWUgLy8gb3RoZXJ3aXNlIGdvIHdpdGggdGhlIHN5bWJvbCB2YWx1ZVxuICAgIDogbm9kZS5yaWdodC52YWx1ZTtcblxuICAgIHRoaXMuX2VtaXQoJ2Vudi5nZXRUZXN0KFwiJyArIHJpZ2h0ICsgJ1wiKS5jYWxsKGNvbnRleHQsICcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpOyAvLyBjb21waWxlIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBjYWxsYWJsZSBpZiB0aGV5IGV4aXN0XG5cbiAgICBpZiAobm9kZS5yaWdodC5hcmdzKSB7XG4gICAgICB0aGlzLl9lbWl0KCcsJyk7XG5cbiAgICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LmFyZ3MsIGZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0KCcpID09PSB0cnVlJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9iaW5PcEVtaXR0ZXIgPSBmdW5jdGlvbiBfYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCBzdHIpIHtcbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KHN0cik7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5yaWdodCwgZnJhbWUpO1xuICB9IC8vIGVuc3VyZSBjb25jYXRlbmF0aW9uIGluc3RlYWQgb2YgYWRkaXRpb25cbiAgLy8gYnkgYWRkaW5nIGVtcHR5IHN0cmluZyBpbiBiZXR3ZWVuXG4gIDtcblxuICBfcHJvdG8uY29tcGlsZU9yID0gZnVuY3Rpb24gY29tcGlsZU9yKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyB8fCAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUFuZCA9IGZ1bmN0aW9uIGNvbXBpbGVBbmQobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnICYmICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQWRkID0gZnVuY3Rpb24gY29tcGlsZUFkZChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgKyAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNvbmNhdCA9IGZ1bmN0aW9uIGNvbXBpbGVDb25jYXQobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnICsgXCJcIiArICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlU3ViID0gZnVuY3Rpb24gY29tcGlsZVN1Yihub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgLSAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU11bCA9IGZ1bmN0aW9uIGNvbXBpbGVNdWwobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnICogJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVEaXYgPSBmdW5jdGlvbiBjb21waWxlRGl2KG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAvICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTW9kID0gZnVuY3Rpb24gY29tcGlsZU1vZChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgJSAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU5vdCA9IGZ1bmN0aW9uIGNvbXBpbGVOb3Qobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCchJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS50YXJnZXQsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZsb29yRGl2ID0gZnVuY3Rpb24gY29tcGlsZUZsb29yRGl2KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnTWF0aC5mbG9vcignKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyAvICcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVBvdyA9IGZ1bmN0aW9uIGNvbXBpbGVQb3cobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCdNYXRoLnBvdygnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJywgJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5yaWdodCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTmVnID0gZnVuY3Rpb24gY29tcGlsZU5lZyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJy0nKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnRhcmdldCwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlUG9zID0gZnVuY3Rpb24gY29tcGlsZVBvcyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJysnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnRhcmdldCwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBpbGVDb21wYXJlKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5leHByLCBmcmFtZSk7XG4gICAgbm9kZS5vcHMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgIF90aGlzNS5fZW1pdChcIiBcIiArIGNvbXBhcmVPcHNbb3AudHlwZV0gKyBcIiBcIik7XG5cbiAgICAgIF90aGlzNS5jb21waWxlKG9wLmV4cHIsIGZyYW1lKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUxvb2t1cFZhbCA9IGZ1bmN0aW9uIGNvbXBpbGVMb29rdXBWYWwobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCdydW50aW1lLm1lbWJlckxvb2t1cCgoJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnRhcmdldCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKSwnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudmFsLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXROb2RlTmFtZSA9IGZ1bmN0aW9uIF9nZXROb2RlTmFtZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGVuYW1lKSB7XG4gICAgICBjYXNlICdTeW1ib2wnOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcblxuICAgICAgY2FzZSAnRnVuQ2FsbCc6XG4gICAgICAgIHJldHVybiAndGhlIHJldHVybiB2YWx1ZSBvZiAoJyArIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUubmFtZSkgKyAnKSc7XG5cbiAgICAgIGNhc2UgJ0xvb2t1cFZhbCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlTmFtZShub2RlLnRhcmdldCkgKyAnW1wiJyArIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUudmFsKSArICdcIl0nO1xuXG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICctLWV4cHJlc3Npb24tLSc7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlRnVuQ2FsbCA9IGZ1bmN0aW9uIGNvbXBpbGVGdW5DYWxsKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gS2VlcCB0cmFjayBvZiBsaW5lL2NvbCBpbmZvIGF0IHJ1bnRpbWUgYnkgc2V0dGluZ3NcbiAgICAvLyB2YXJpYWJsZXMgd2l0aGluIGFuIGV4cHJlc3Npb24uIEFuIGV4cHJlc3Npb24gaW4gamF2YXNjcmlwdFxuICAgIC8vIGxpa2UgKHgsIHksIHopIHJldHVybnMgdGhlIGxhc3QgdmFsdWUsIGFuZCB4IGFuZCB5IGNhbiBiZVxuICAgIC8vIGFueXRoaW5nXG4gICAgdGhpcy5fZW1pdCgnKGxpbmVubyA9ICcgKyBub2RlLmxpbmVubyArICcsIGNvbG5vID0gJyArIG5vZGUuY29sbm8gKyAnLCAnKTtcblxuICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUuY2FsbFdyYXAoJyk7IC8vIENvbXBpbGUgaXQgYXMgbm9ybWFsLlxuXG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLm5hbWUsIGZyYW1lKTsgLy8gT3V0cHV0IHRoZSBuYW1lIG9mIHdoYXQgd2UncmUgY2FsbGluZyBzbyB3ZSBjYW4gZ2V0IGZyaWVuZGx5IGVycm9yc1xuICAgIC8vIGlmIHRoZSBsb29rdXAgZmFpbHMuXG5cblxuICAgIHRoaXMuX2VtaXQoJywgXCInICsgdGhpcy5fZ2V0Tm9kZU5hbWUobm9kZS5uYW1lKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCIsIGNvbnRleHQsICcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLmFyZ3MsIGZyYW1lLCAnWycsICddKScpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRmlsdGVyID0gZnVuY3Rpb24gY29tcGlsZUZpbHRlcihub2RlLCBmcmFtZSkge1xuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIHRoaXMuYXNzZXJ0VHlwZShuYW1lLCBub2Rlcy5TeW1ib2wpO1xuXG4gICAgdGhpcy5fZW1pdCgnZW52LmdldEZpbHRlcihcIicgKyBuYW1lLnZhbHVlICsgJ1wiKS5jYWxsKGNvbnRleHQsICcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLmFyZ3MsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZpbHRlckFzeW5jID0gZnVuY3Rpb24gY29tcGlsZUZpbHRlckFzeW5jKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgdmFyIHN5bWJvbCA9IG5vZGUuc3ltYm9sLnZhbHVlO1xuICAgIHRoaXMuYXNzZXJ0VHlwZShuYW1lLCBub2Rlcy5TeW1ib2wpO1xuICAgIGZyYW1lLnNldChzeW1ib2wsIHN5bWJvbCk7XG5cbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0RmlsdGVyKFwiJyArIG5hbWUudmFsdWUgKyAnXCIpLmNhbGwoY29udGV4dCwgJyk7XG5cbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUuYXJncywgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJywgJyArIHRoaXMuX21ha2VDYWxsYmFjayhzeW1ib2wpKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUtleXdvcmRBcmdzID0gZnVuY3Rpb24gY29tcGlsZUtleXdvcmRBcmdzKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5tYWtlS2V5d29yZEFyZ3MoJyk7XG5cbiAgICB0aGlzLmNvbXBpbGVEaWN0KG5vZGUsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVNldCA9IGZ1bmN0aW9uIGNvbXBpbGVTZXQobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIHZhciBpZHMgPSBbXTsgLy8gTG9va3VwIHRoZSB2YXJpYWJsZSBuYW1lcyBmb3IgZWFjaCBpZGVudGlmaWVyIGFuZCBjcmVhdGVcbiAgICAvLyBuZXcgb25lcyBpZiBuZWNlc3NhcnlcblxuICAgIG5vZGUudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciBuYW1lID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgdmFyIGlkID0gZnJhbWUubG9va3VwKG5hbWUpO1xuXG4gICAgICBpZiAoaWQgPT09IG51bGwgfHwgaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZCA9IF90aGlzNi5fdG1waWQoKTsgLy8gTm90ZTogVGhpcyByZWxpZXMgb24ganMgYWxsb3dpbmcgc2NvcGUgYWNyb3NzXG4gICAgICAgIC8vIGJsb2NrcywgaW4gY2FzZSB0aGlzIGlzIGNyZWF0ZWQgaW5zaWRlIGFuIGBpZmBcblxuICAgICAgICBfdGhpczYuX2VtaXRMaW5lKCd2YXIgJyArIGlkICsgJzsnKTtcbiAgICAgIH1cblxuICAgICAgaWRzLnB1c2goaWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUudmFsdWUpIHtcbiAgICAgIHRoaXMuX2VtaXQoaWRzLmpvaW4oJyA9ICcpICsgJyA9ICcpO1xuXG4gICAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnZhbHVlLCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCc7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoaWRzLmpvaW4oJyA9ICcpICsgJyA9ICcpO1xuXG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCc7Jyk7XG4gICAgfVxuXG4gICAgbm9kZS50YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCwgaSkge1xuICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgdmFyIG5hbWUgPSB0YXJnZXQudmFsdWU7IC8vIFdlIGFyZSBydW5uaW5nIHRoaXMgZm9yIGV2ZXJ5IHZhciwgYnV0IGl0J3MgdmVyeVxuICAgICAgLy8gdW5jb21tb24gdG8gYXNzaWduIHRvIG11bHRpcGxlIHZhcnMgYW55d2F5XG5cbiAgICAgIF90aGlzNi5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyBpZCArIFwiLCB0cnVlKTtcIik7XG5cbiAgICAgIF90aGlzNi5fZW1pdExpbmUoJ2lmKGZyYW1lLnRvcExldmVsKSB7Jyk7XG5cbiAgICAgIF90aGlzNi5fZW1pdExpbmUoXCJjb250ZXh0LnNldFZhcmlhYmxlKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuXG4gICAgICBfdGhpczYuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gJ18nKSB7XG4gICAgICAgIF90aGlzNi5fZW1pdExpbmUoJ2lmKGZyYW1lLnRvcExldmVsKSB7Jyk7XG5cbiAgICAgICAgX3RoaXM2Ll9lbWl0TGluZShcImNvbnRleHQuYWRkRXhwb3J0KFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuXG4gICAgICAgIF90aGlzNi5fZW1pdExpbmUoJ30nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVN3aXRjaCA9IGZ1bmN0aW9uIGNvbXBpbGVTd2l0Y2gobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgIHRoaXMuX2VtaXQoJ3N3aXRjaCAoJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5leHByLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpIHsnKTtcblxuICAgIG5vZGUuY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgX3RoaXM3Ll9lbWl0KCdjYXNlICcpO1xuXG4gICAgICBfdGhpczcuY29tcGlsZShjLmNvbmQsIGZyYW1lKTtcblxuICAgICAgX3RoaXM3Ll9lbWl0KCc6ICcpO1xuXG4gICAgICBfdGhpczcuY29tcGlsZShjLmJvZHksIGZyYW1lKTsgLy8gcHJlc2VydmUgZmFsbC10aHJvdWdoc1xuXG5cbiAgICAgIGlmIChjLmJvZHkuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIF90aGlzNy5fZW1pdExpbmUoJ2JyZWFrOycpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUuZGVmYXVsdCkge1xuICAgICAgdGhpcy5fZW1pdCgnZGVmYXVsdDonKTtcblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUuZGVmYXVsdCwgZnJhbWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXQoJ30nKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUlmID0gZnVuY3Rpb24gY29tcGlsZUlmKG5vZGUsIGZyYW1lLCBhc3luYykge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgdGhpcy5fZW1pdCgnaWYoJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLmNvbmQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCcpIHsnKTtcblxuICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM4LmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBfdGhpczguX2VtaXQoJ2NiKCknKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub2RlLmVsc2VfKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfVxcbmVsc2UgeycpO1xuXG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM4LmNvbXBpbGUobm9kZS5lbHNlXywgZnJhbWUpO1xuXG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgIF90aGlzOC5fZW1pdCgnY2IoKScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfVxcbmVsc2UgeycpO1xuXG4gICAgICB0aGlzLl9lbWl0KCdjYigpJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUlmQXN5bmMgPSBmdW5jdGlvbiBjb21waWxlSWZBc3luYyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJyhmdW5jdGlvbihjYikgeycpO1xuXG4gICAgdGhpcy5jb21waWxlSWYobm9kZSwgZnJhbWUsIHRydWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnfSkoJyArIHRoaXMuX21ha2VDYWxsYmFjaygpKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXRMb29wQmluZGluZ3MgPSBmdW5jdGlvbiBfZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbikge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgdmFyIGJpbmRpbmdzID0gW3tcbiAgICAgIG5hbWU6ICdpbmRleCcsXG4gICAgICB2YWw6IGkgKyBcIiArIDFcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdpbmRleDAnLFxuICAgICAgdmFsOiBpXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3JldmluZGV4JyxcbiAgICAgIHZhbDogbGVuICsgXCIgLSBcIiArIGlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncmV2aW5kZXgwJyxcbiAgICAgIHZhbDogbGVuICsgXCIgLSBcIiArIGkgKyBcIiAtIDFcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmaXJzdCcsXG4gICAgICB2YWw6IGkgKyBcIiA9PT0gMFwiXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xhc3QnLFxuICAgICAgdmFsOiBpICsgXCIgPT09IFwiICsgbGVuICsgXCIgLSAxXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIHZhbDogbGVuXG4gICAgfV07XG4gICAgYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgX3RoaXM5Ll9lbWl0TGluZShcImZyYW1lLnNldChcXFwibG9vcC5cIiArIGIubmFtZSArIFwiXFxcIiwgXCIgKyBiLnZhbCArIFwiKTtcIik7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGb3IgPSBmdW5jdGlvbiBjb21waWxlRm9yKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgLy8gU29tZSBvZiB0aGlzIGNvZGUgaXMgdWdseSwgYnV0IGl0IGtlZXBzIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFzIGZhc3QgYXMgcG9zc2libGUuIEZvckFzeW5jIGFsc28gc2hhcmVzIHNvbWUgb2YgdGhpcywgYnV0XG4gICAgLy8gbm90IG11Y2guXG4gICAgdmFyIGkgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGxlbiA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgYXJyID0gdGhpcy5fdG1waWQoKTtcblxuICAgIGZyYW1lID0gZnJhbWUucHVzaCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucHVzaCgpOycpO1xuXG4gICAgdGhpcy5fZW1pdChcInZhciBcIiArIGFyciArIFwiID0gXCIpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5hcnIsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCc7Jyk7XG5cbiAgICB0aGlzLl9lbWl0KFwiaWYoXCIgKyBhcnIgKyBcIikge1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKGFyciArICcgPSBydW50aW1lLmZyb21JdGVyYXRvcignICsgYXJyICsgJyk7Jyk7IC8vIElmIG11bHRpcGxlIG5hbWVzIGFyZSBwYXNzZWQsIHdlIG5lZWQgdG8gYmluZCB0aGVtXG4gICAgLy8gYXBwcm9wcmlhdGVseVxuXG5cbiAgICBpZiAobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuQXJyYXkpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgaSArIFwiO1wiKTsgLy8gVGhlIG9iamVjdCBjb3VsZCBiZSBhbiBhcnJveSBvciBvYmplY3QuIE5vdGUgdGhhdCB0aGVcbiAgICAgIC8vIGJvZHkgb2YgdGhlIGxvb3AgaXMgZHVwbGljYXRlZCBmb3IgZWFjaCBjb25kaXRpb24sIGJ1dFxuICAgICAgLy8gd2UgYXJlIG9wdGltaXppbmcgZm9yIHNwZWVkIG92ZXIgc2l6ZS5cblxuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImlmKHJ1bnRpbWUuaXNBcnJheShcIiArIGFyciArIFwiKSkge1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBsZW4gKyBcIiA9IFwiICsgYXJyICsgXCIubGVuZ3RoO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmb3IoXCIgKyBpICsgXCI9MDsgXCIgKyBpICsgXCIgPCBcIiArIGFyciArIFwiLmxlbmd0aDsgXCIgKyBpICsgXCIrKykge1wiKTsgLy8gQmluZCBlYWNoIGRlY2xhcmVkIHZhclxuXG5cbiAgICAgIG5vZGUubmFtZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgdSkge1xuICAgICAgICB2YXIgdGlkID0gX3RoaXMxMC5fdG1waWQoKTtcblxuICAgICAgICBfdGhpczEwLl9lbWl0TGluZShcInZhciBcIiArIHRpZCArIFwiID0gXCIgKyBhcnIgKyBcIltcIiArIGkgKyBcIl1bXCIgKyB1ICsgXCJdO1wiKTtcblxuICAgICAgICBfdGhpczEwLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBjaGlsZCArIFwiXFxcIiwgXCIgKyBhcnIgKyBcIltcIiArIGkgKyBcIl1bXCIgKyB1ICsgXCJdKTtcIik7XG5cbiAgICAgICAgZnJhbWUuc2V0KG5vZGUubmFtZS5jaGlsZHJlblt1XS52YWx1ZSwgdGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0TG9vcEJpbmRpbmdzKG5vZGUsIGFyciwgaSwgbGVuKTtcblxuICAgICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfSBlbHNlIHsnKTsgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXkvdmFsdWVzIG9mIGFuIG9iamVjdFxuXG5cbiAgICAgIHZhciBfbm9kZSRuYW1lJGNoaWxkcmVuID0gbm9kZS5uYW1lLmNoaWxkcmVuLFxuICAgICAgICAgIGtleSA9IF9ub2RlJG5hbWUkY2hpbGRyZW5bMF0sXG4gICAgICAgICAgdmFsID0gX25vZGUkbmFtZSRjaGlsZHJlblsxXTtcblxuICAgICAgdmFyIGsgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgICB2YXIgdiA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICAgIGZyYW1lLnNldChrZXkudmFsdWUsIGspO1xuICAgICAgZnJhbWUuc2V0KHZhbC52YWx1ZSwgdik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKGkgKyBcIiA9IC0xO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBsZW4gKyBcIiA9IHJ1bnRpbWUua2V5cyhcIiArIGFyciArIFwiKS5sZW5ndGg7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZvcih2YXIgXCIgKyBrICsgXCIgaW4gXCIgKyBhcnIgKyBcIikge1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoaSArIFwiKys7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIHYgKyBcIiA9IFwiICsgYXJyICsgXCJbXCIgKyBrICsgXCJdO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsga2V5LnZhbHVlICsgXCJcXFwiLCBcIiArIGsgKyBcIik7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyB2YWwudmFsdWUgKyBcIlxcXCIsIFwiICsgdiArIFwiKTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdlbmVyYXRlIGEgdHlwaWNhbCBhcnJheSBpdGVyYXRpb25cbiAgICAgIHZhciBfdiA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICAgIGZyYW1lLnNldChub2RlLm5hbWUudmFsdWUsIF92KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBsZW4gKyBcIiA9IFwiICsgYXJyICsgXCIubGVuZ3RoO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmb3IodmFyIFwiICsgaSArIFwiPTA7IFwiICsgaSArIFwiIDwgXCIgKyBhcnIgKyBcIi5sZW5ndGg7IFwiICsgaSArIFwiKyspIHtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgX3YgKyBcIiA9IFwiICsgYXJyICsgXCJbXCIgKyBpICsgXCJdO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgbm9kZS5uYW1lLnZhbHVlICsgXCJcXFwiLCBcIiArIF92ICsgXCIpO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG5cbiAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEwLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgaWYgKG5vZGUuZWxzZV8pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCdpZiAoIScgKyBsZW4gKyAnKSB7Jyk7XG5cbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucG9wKCk7Jyk7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlQXN5bmNMb29wID0gZnVuY3Rpb24gX2NvbXBpbGVBc3luY0xvb3Aobm9kZSwgZnJhbWUsIHBhcmFsbGVsKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgLy8gVGhpcyBzaGFyZXMgc29tZSBjb2RlIHdpdGggdGhlIEZvciB0YWcsIGJ1dCBub3QgZW5vdWdoIHRvXG4gICAgLy8gd29ycnkgYWJvdXQuIFRoaXMgaXRlcmF0ZXMgYWNyb3NzIGFuIG9iamVjdCBhc3luY2hyb25vdXNseSxcbiAgICAvLyBidXQgbm90IGluIHBhcmFsbGVsLlxuICAgIHZhciBpID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBsZW4gPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGFyciA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgYXN5bmNNZXRob2QgPSBwYXJhbGxlbCA/ICdhc3luY0FsbCcgOiAnYXN5bmNFYWNoJztcbiAgICBmcmFtZSA9IGZyYW1lLnB1c2goKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9IGZyYW1lLnB1c2goKTsnKTtcblxuICAgIHRoaXMuX2VtaXQoJ3ZhciAnICsgYXJyICsgJyA9IHJ1bnRpbWUuZnJvbUl0ZXJhdG9yKCcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5hcnIsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCcpOycpO1xuXG4gICAgaWYgKG5vZGUubmFtZSBpbnN0YW5jZW9mIG5vZGVzLkFycmF5KSB7XG4gICAgICB2YXIgYXJyYXlMZW4gPSBub2RlLm5hbWUuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9lbWl0KFwicnVudGltZS5cIiArIGFzeW5jTWV0aG9kICsgXCIoXCIgKyBhcnIgKyBcIiwgXCIgKyBhcnJheUxlbiArIFwiLCBmdW5jdGlvbihcIik7XG5cbiAgICAgIG5vZGUubmFtZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIF90aGlzMTEuX2VtaXQobmFtZS52YWx1ZSArIFwiLFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0KGkgKyAnLCcgKyBsZW4gKyAnLG5leHQpIHsnKTtcblxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGlkID0gbmFtZS52YWx1ZTtcbiAgICAgICAgZnJhbWUuc2V0KGlkLCBpZCk7XG5cbiAgICAgICAgX3RoaXMxMS5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgaWQgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpZCA9IG5vZGUubmFtZS52YWx1ZTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJydW50aW1lLlwiICsgYXN5bmNNZXRob2QgKyBcIihcIiArIGFyciArIFwiLCAxLCBmdW5jdGlvbihcIiArIGlkICsgXCIsIFwiICsgaSArIFwiLCBcIiArIGxlbiArIFwiLG5leHQpIHtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZS5zZXQoXCInICsgaWQgKyAnXCIsICcgKyBpZCArICcpOycpO1xuXG4gICAgICBmcmFtZS5zZXQoaWQsIGlkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TG9vcEJpbmRpbmdzKG5vZGUsIGFyciwgaSwgbGVuKTtcblxuICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJ1ZjtcblxuICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgIGJ1ZiA9IF90aGlzMTEuX3B1c2hCdWZmZXIoKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMxMS5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuXG4gICAgICBfdGhpczExLl9lbWl0TGluZSgnbmV4dCgnICsgaSArIChidWYgPyAnLCcgKyBidWYgOiAnJykgKyAnKTsnKTtcblxuICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgIF90aGlzMTEuX3BvcEJ1ZmZlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIG91dHB1dCA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSwgJyArIHRoaXMuX21ha2VDYWxsYmFjayhvdXRwdXQpKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIGlmIChwYXJhbGxlbCkge1xuICAgICAgdGhpcy5fZW1pdExpbmUodGhpcy5idWZmZXIgKyAnICs9ICcgKyBvdXRwdXQgKyAnOycpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmVsc2VfKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnaWYgKCEnICsgYXJyICsgJy5sZW5ndGgpIHsnKTtcblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUuZWxzZV8sIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUgPSBmcmFtZS5wb3AoKTsnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUFzeW5jRWFjaCA9IGZ1bmN0aW9uIGNvbXBpbGVBc3luY0VhY2gobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQXN5bmNMb29wKG5vZGUsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUFzeW5jQWxsID0gZnVuY3Rpb24gY29tcGlsZUFzeW5jQWxsKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFzeW5jTG9vcChub2RlLCBmcmFtZSwgdHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21waWxlTWFjcm8gPSBmdW5jdGlvbiBfY29tcGlsZU1hY3JvKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIga3dhcmdzID0gbnVsbDtcblxuICAgIHZhciBmdW5jSWQgPSAnbWFjcm9fJyArIHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIga2VlcEZyYW1lID0gZnJhbWUgIT09IHVuZGVmaW5lZDsgLy8gVHlwZSBjaGVjayB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgYXJnc1xuXG4gICAgbm9kZS5hcmdzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGFyZywgaSkge1xuICAgICAgaWYgKGkgPT09IG5vZGUuYXJncy5jaGlsZHJlbi5sZW5ndGggLSAxICYmIGFyZyBpbnN0YW5jZW9mIG5vZGVzLkRpY3QpIHtcbiAgICAgICAga3dhcmdzID0gYXJnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMxMi5hc3NlcnRUeXBlKGFyZywgbm9kZXMuU3ltYm9sKTtcblxuICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcmVhbE5hbWVzID0gW10uY29uY2F0KGFyZ3MubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gXCJsX1wiICsgbi52YWx1ZTtcbiAgICB9KSwgWydrd2FyZ3MnXSk7IC8vIFF1b3RlZCBhcmd1bWVudCBuYW1lc1xuXG4gICAgdmFyIGFyZ05hbWVzID0gYXJncy5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBcIlxcXCJcIiArIG4udmFsdWUgKyBcIlxcXCJcIjtcbiAgICB9KTtcbiAgICB2YXIga3dhcmdOYW1lcyA9IChrd2FyZ3MgJiYga3dhcmdzLmNoaWxkcmVuIHx8IFtdKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBcIlxcXCJcIiArIG4ua2V5LnZhbHVlICsgXCJcXFwiXCI7XG4gICAgfSk7IC8vIFdlIHBhc3MgYSBmdW5jdGlvbiB0byBtYWtlTWFjcm8gd2hpY2ggZGVzdHJ1Y3R1cmVzIHRoZVxuICAgIC8vIGFyZ3VtZW50cyBzbyBzdXBwb3J0IHNldHRpbmcgcG9zaXRpb25hbCBhcmdzIHdpdGgga2V5d29yZHNcbiAgICAvLyBhcmdzIGFuZCBwYXNzaW5nIGtleXdvcmQgYXJncyBhcyBwb3NpdGlvbmFsIGFyZ3NcbiAgICAvLyAoZXNzZW50aWFsbHkgZGVmYXVsdCB2YWx1ZXMpLiBTZWUgcnVudGltZS5qcy5cblxuICAgIHZhciBjdXJyRnJhbWU7XG5cbiAgICBpZiAoa2VlcEZyYW1lKSB7XG4gICAgICBjdXJyRnJhbWUgPSBmcmFtZS5wdXNoKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyRnJhbWUgPSBuZXcgRnJhbWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZXMoXCJ2YXIgXCIgKyBmdW5jSWQgKyBcIiA9IHJ1bnRpbWUubWFrZU1hY3JvKFwiLCBcIltcIiArIGFyZ05hbWVzLmpvaW4oJywgJykgKyBcIl0sIFwiLCBcIltcIiArIGt3YXJnTmFtZXMuam9pbignLCAnKSArIFwiXSwgXCIsIFwiZnVuY3Rpb24gKFwiICsgcmVhbE5hbWVzLmpvaW4oJywgJykgKyBcIikge1wiLCAndmFyIGNhbGxlckZyYW1lID0gZnJhbWU7JywgJ2ZyYW1lID0gJyArIChrZWVwRnJhbWUgPyAnZnJhbWUucHVzaCh0cnVlKTsnIDogJ25ldyBydW50aW1lLkZyYW1lKCk7JyksICdrd2FyZ3MgPSBrd2FyZ3MgfHwge307JywgJ2lmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa3dhcmdzLCBcImNhbGxlclwiKSkgeycsICdmcmFtZS5zZXQoXCJjYWxsZXJcIiwga3dhcmdzLmNhbGxlcik7IH0nKTsgLy8gRXhwb3NlIHRoZSBhcmd1bWVudHMgdG8gdGhlIHRlbXBsYXRlLiBEb24ndCBuZWVkIHRvIHVzZVxuICAgIC8vIHJhbmRvbSBuYW1lcyBiZWNhdXNlIHRoZSBmdW5jdGlvblxuICAgIC8vIHdpbGwgY3JlYXRlIGEgbmV3IHJ1bi10aW1lIHNjb3BlIGZvciB1c1xuXG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgX3RoaXMxMi5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgYXJnLnZhbHVlICsgXCJcXFwiLCBsX1wiICsgYXJnLnZhbHVlICsgXCIpO1wiKTtcblxuICAgICAgY3VyckZyYW1lLnNldChhcmcudmFsdWUsIFwibF9cIiArIGFyZy52YWx1ZSk7XG4gICAgfSk7IC8vIEV4cG9zZSB0aGUga2V5d29yZCBhcmd1bWVudHNcblxuICAgIGlmIChrd2FyZ3MpIHtcbiAgICAgIGt3YXJncy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFpci5rZXkudmFsdWU7XG5cbiAgICAgICAgX3RoaXMxMi5fZW1pdChcImZyYW1lLnNldChcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIik7XG5cbiAgICAgICAgX3RoaXMxMi5fZW1pdChcIk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrd2FyZ3MsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpXCIpO1xuXG4gICAgICAgIF90aGlzMTIuX2VtaXQoXCIgPyBrd2FyZ3NbXFxcIlwiICsgbmFtZSArIFwiXFxcIl0gOiBcIik7XG5cbiAgICAgICAgX3RoaXMxMi5fY29tcGlsZUV4cHJlc3Npb24ocGFpci52YWx1ZSwgY3VyckZyYW1lKTtcblxuICAgICAgICBfdGhpczEyLl9lbWl0KCcpOycpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcklkID0gdGhpcy5fcHVzaEJ1ZmZlcigpO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczEyLmNvbXBpbGUobm9kZS5ib2R5LCBjdXJyRnJhbWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gJyArIChrZWVwRnJhbWUgPyAnZnJhbWUucG9wKCk7JyA6ICdjYWxsZXJGcmFtZTsnKSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcInJldHVybiBuZXcgcnVudGltZS5TYWZlU3RyaW5nKFwiICsgYnVmZmVySWQgKyBcIik7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuXG4gICAgdGhpcy5fcG9wQnVmZmVyKCk7XG5cbiAgICByZXR1cm4gZnVuY0lkO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlTWFjcm8gPSBmdW5jdGlvbiBjb21waWxlTWFjcm8obm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgZnVuY0lkID0gdGhpcy5fY29tcGlsZU1hY3JvKG5vZGUpOyAvLyBFeHBvc2UgdGhlIG1hY3JvIHRvIHRoZSB0ZW1wbGF0ZXNcblxuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgZnJhbWUuc2V0KG5hbWUsIGZ1bmNJZCk7XG5cbiAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGZ1bmNJZCArIFwiKTtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChub2RlLm5hbWUudmFsdWUuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgICAgdGhpcy5fZW1pdExpbmUoXCJjb250ZXh0LmFkZEV4cG9ydChcXFwiXCIgKyBuYW1lICsgXCJcXFwiKTtcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiY29udGV4dC5zZXRWYXJpYWJsZShcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGZ1bmNJZCArIFwiKTtcIik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ2FsbGVyID0gZnVuY3Rpb24gY29tcGlsZUNhbGxlcihub2RlLCBmcmFtZSkge1xuICAgIC8vIGJhc2ljYWxseSBhbiBhbm9ueW1vdXMgXCJtYWNybyBleHByZXNzaW9uXCJcbiAgICB0aGlzLl9lbWl0KCcoZnVuY3Rpb24gKCl7Jyk7XG5cbiAgICB2YXIgZnVuY0lkID0gdGhpcy5fY29tcGlsZU1hY3JvKG5vZGUsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoXCJyZXR1cm4gXCIgKyBmdW5jSWQgKyBcIjt9KSgpXCIpO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZUdldFRlbXBsYXRlID0gZnVuY3Rpb24gX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZWFnZXJDb21waWxlLCBpZ25vcmVNaXNzaW5nKSB7XG4gICAgdmFyIHBhcmVudFRlbXBsYXRlSWQgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIHBhcmVudE5hbWUgPSB0aGlzLl90ZW1wbGF0ZU5hbWUoKTtcblxuICAgIHZhciBjYiA9IHRoaXMuX21ha2VDYWxsYmFjayhwYXJlbnRUZW1wbGF0ZUlkKTtcblxuICAgIHZhciBlYWdlckNvbXBpbGVBcmcgPSBlYWdlckNvbXBpbGUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIHZhciBpZ25vcmVNaXNzaW5nQXJnID0gaWdub3JlTWlzc2luZyA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0VGVtcGxhdGUoJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnRlbXBsYXRlLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcIiwgXCIgKyBlYWdlckNvbXBpbGVBcmcgKyBcIiwgXCIgKyBwYXJlbnROYW1lICsgXCIsIFwiICsgaWdub3JlTWlzc2luZ0FyZyArIFwiLCBcIiArIGNiKTtcblxuICAgIHJldHVybiBwYXJlbnRUZW1wbGF0ZUlkO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSW1wb3J0ID0gZnVuY3Rpb24gY29tcGlsZUltcG9ydChub2RlLCBmcmFtZSkge1xuICAgIHZhciB0YXJnZXQgPSBub2RlLnRhcmdldC52YWx1ZTtcblxuICAgIHZhciBpZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKGlkICsgJy5nZXRFeHBvcnRlZCgnICsgKG5vZGUud2l0aENvbnRleHQgPyAnY29udGV4dC5nZXRWYXJpYWJsZXMoKSwgZnJhbWUsICcgOiAnJykgKyB0aGlzLl9tYWtlQ2FsbGJhY2soaWQpKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIGZyYW1lLnNldCh0YXJnZXQsIGlkKTtcblxuICAgIGlmIChmcmFtZS5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIHRhcmdldCArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiY29udGV4dC5zZXRWYXJpYWJsZShcXFwiXCIgKyB0YXJnZXQgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZyb21JbXBvcnQgPSBmdW5jdGlvbiBjb21waWxlRnJvbUltcG9ydChub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgIHZhciBpbXBvcnRlZElkID0gdGhpcy5fY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoaW1wb3J0ZWRJZCArICcuZ2V0RXhwb3J0ZWQoJyArIChub2RlLndpdGhDb250ZXh0ID8gJ2NvbnRleHQuZ2V0VmFyaWFibGVzKCksIGZyYW1lLCAnIDogJycpICsgdGhpcy5fbWFrZUNhbGxiYWNrKGltcG9ydGVkSWQpKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIG5vZGUubmFtZXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobmFtZU5vZGUpIHtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgdmFyIGFsaWFzO1xuXG4gICAgICB2YXIgaWQgPSBfdGhpczEzLl90bXBpZCgpO1xuXG4gICAgICBpZiAobmFtZU5vZGUgaW5zdGFuY2VvZiBub2Rlcy5QYWlyKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lTm9kZS5rZXkudmFsdWU7XG4gICAgICAgIGFsaWFzID0gbmFtZU5vZGUudmFsdWUudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gbmFtZU5vZGUudmFsdWU7XG4gICAgICAgIGFsaWFzID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMxMy5fZW1pdExpbmUoXCJpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXCIgKyBpbXBvcnRlZElkICsgXCIsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKSB7XCIpO1xuXG4gICAgICBfdGhpczEzLl9lbWl0TGluZShcInZhciBcIiArIGlkICsgXCIgPSBcIiArIGltcG9ydGVkSWQgKyBcIi5cIiArIG5hbWUgKyBcIjtcIik7XG5cbiAgICAgIF90aGlzMTMuX2VtaXRMaW5lKCd9IGVsc2UgeycpO1xuXG4gICAgICBfdGhpczEzLl9lbWl0TGluZShcImNiKG5ldyBFcnJvcihcXFwiY2Fubm90IGltcG9ydCAnXCIgKyBuYW1lICsgXCInXFxcIikpOyByZXR1cm47XCIpO1xuXG4gICAgICBfdGhpczEzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgICBmcmFtZS5zZXQoYWxpYXMsIGlkKTtcblxuICAgICAgaWYgKGZyYW1lLnBhcmVudCkge1xuICAgICAgICBfdGhpczEzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyBhbGlhcyArIFwiXFxcIiwgXCIgKyBpZCArIFwiKTtcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczEzLl9lbWl0TGluZShcImNvbnRleHQuc2V0VmFyaWFibGUoXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQmxvY2sgPSBmdW5jdGlvbiBjb21waWxlQmxvY2sobm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuX3RtcGlkKCk7IC8vIElmIHdlIGFyZSBleGVjdXRpbmcgb3V0c2lkZSBhIGJsb2NrIChjcmVhdGluZyBhIHRvcC1sZXZlbFxuICAgIC8vIGJsb2NrKSwgd2UgcmVhbGx5IGRvbid0IHdhbnQgdG8gZXhlY3V0ZSBpdHMgY29kZSBiZWNhdXNlIGl0XG4gICAgLy8gd2lsbCBleGVjdXRlIHR3aWNlOiBvbmNlIHdoZW4gdGhlIGNoaWxkIHRlbXBsYXRlIHJ1bnMgYW5kXG4gICAgLy8gYWdhaW4gd2hlbiB0aGUgcGFyZW50IHRlbXBsYXRlIHJ1bnMuIE5vdGUgdGhhdCBibG9ja3NcbiAgICAvLyB3aXRoaW4gYmxvY2tzIHdpbGwgKmFsd2F5cyogZXhlY3V0ZSBpbW1lZGlhdGVseSAqYW5kKlxuICAgIC8vIHdoZXJldmVyIGVsc2UgdGhleSBhcmUgaW52b2tlZCAobGlrZSB1c2VkIGluIGEgcGFyZW50XG4gICAgLy8gdGVtcGxhdGUpLiBUaGlzIG1heSBoYXZlIGJlaGF2aW9yYWwgZGlmZmVyZW5jZXMgZnJvbSBqaW5qYVxuICAgIC8vIGJlY2F1c2UgYmxvY2tzIGNhbiBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGl0IHNlZW1zIGxpa2UgYVxuICAgIC8vIHdhc3RlIG9mIHBlcmZvcm1hbmNlIHRvIGFsd2F5cyBleGVjdXRlIGh1Z2UgdG9wLWxldmVsXG4gICAgLy8gYmxvY2tzIHR3aWNlXG5cblxuICAgIGlmICghdGhpcy5pbkJsb2NrKSB7XG4gICAgICB0aGlzLl9lbWl0KCcocGFyZW50VGVtcGxhdGUgPyBmdW5jdGlvbihlLCBjLCBmLCByLCBjYikgeyBjYihcIlwiKTsgfSA6ICcpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXQoXCJjb250ZXh0LmdldEJsb2NrKFxcXCJcIiArIG5vZGUubmFtZS52YWx1ZSArIFwiXFxcIilcIik7XG5cbiAgICBpZiAoIXRoaXMuaW5CbG9jaykge1xuICAgICAgdGhpcy5fZW1pdCgnKScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCcoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgJyArIHRoaXMuX21ha2VDYWxsYmFjayhpZCkpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUodGhpcy5idWZmZXIgKyBcIiArPSBcIiArIGlkICsgXCI7XCIpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlU3VwZXIgPSBmdW5jdGlvbiBjb21waWxlU3VwZXIobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUuYmxvY2tOYW1lLnZhbHVlO1xuICAgIHZhciBpZCA9IG5vZGUuc3ltYm9sLnZhbHVlO1xuXG4gICAgdmFyIGNiID0gdGhpcy5fbWFrZUNhbGxiYWNrKGlkKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiY29udGV4dC5nZXRTdXBlcihlbnYsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIGJfXCIgKyBuYW1lICsgXCIsIGZyYW1lLCBydW50aW1lLCBcIiArIGNiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKGlkICsgXCIgPSBydW50aW1lLm1hcmtTYWZlKFwiICsgaWQgKyBcIik7XCIpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgZnJhbWUuc2V0KGlkLCBpZCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVFeHRlbmRzID0gZnVuY3Rpb24gY29tcGlsZUV4dGVuZHMobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgayA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgcGFyZW50VGVtcGxhdGVJZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgdHJ1ZSwgZmFsc2UpOyAvLyBleHRlbmRzIGlzIGEgZHluYW1pYyB0YWcgYW5kIGNhbiBvY2N1ciB3aXRoaW4gYSBibG9jayBsaWtlXG4gICAgLy8gYGlmYCwgc28gaWYgdGhpcyBoYXBwZW5zIHdlIG5lZWQgdG8gY2FwdHVyZSB0aGUgcGFyZW50XG4gICAgLy8gdGVtcGxhdGUgaW4gdGhlIHRvcC1sZXZlbCBzY29wZVxuXG5cbiAgICB0aGlzLl9lbWl0TGluZShcInBhcmVudFRlbXBsYXRlID0gXCIgKyBwYXJlbnRUZW1wbGF0ZUlkKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiZm9yKHZhciBcIiArIGsgKyBcIiBpbiBwYXJlbnRUZW1wbGF0ZS5ibG9ja3MpIHtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImNvbnRleHQuYWRkQmxvY2soXCIgKyBrICsgXCIsIHBhcmVudFRlbXBsYXRlLmJsb2Nrc1tcIiArIGsgKyBcIl0pO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJbmNsdWRlID0gZnVuY3Rpb24gY29tcGlsZUluY2x1ZGUobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0TGluZSgndmFyIHRhc2tzID0gW107Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndGFza3MucHVzaCgnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmdW5jdGlvbihjYWxsYmFjaykgeycpO1xuXG4gICAgdmFyIGlkID0gdGhpcy5fY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCBmYWxzZSwgbm9kZS5pZ25vcmVNaXNzaW5nKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiY2FsbGJhY2sobnVsbCxcIiArIGlkICsgXCIpO30pO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9KTsnKTtcblxuICAgIHZhciBpZDIgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3Rhc2tzLnB1c2goJyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnVuY3Rpb24odGVtcGxhdGUsIGNhbGxiYWNrKXsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd0ZW1wbGF0ZS5yZW5kZXIoY29udGV4dC5nZXRWYXJpYWJsZXMoKSwgZnJhbWUsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2soaWQyKSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnY2FsbGJhY2sobnVsbCwnICsgaWQyICsgJyk7fSk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndGFza3MucHVzaCgnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmdW5jdGlvbihyZXN1bHQsIGNhbGxiYWNrKXsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKHRoaXMuYnVmZmVyICsgXCIgKz0gcmVzdWx0O1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdjYWxsYmFjayhudWxsKTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9KTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdlbnYud2F0ZXJmYWxsKHRhc2tzLCBmdW5jdGlvbigpeycpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlVGVtcGxhdGVEYXRhID0gZnVuY3Rpb24gY29tcGlsZVRlbXBsYXRlRGF0YShub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuY29tcGlsZUxpdGVyYWwobm9kZSwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQ2FwdHVyZSA9IGZ1bmN0aW9uIGNvbXBpbGVDYXB0dXJlKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgLy8gd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBvdmVycmlkZSB0aGUgY3VycmVudCBidWZmZXIgaWQgYXMgJ291dHB1dCdcbiAgICAvLyBzbyB0aGUgc2V0IGJsb2NrIHdyaXRlcyB0byB0aGUgY2FwdHVyZSBvdXRwdXQgaW5zdGVhZCBvZiB0aGUgYnVmZmVyXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHRoaXMuYnVmZmVyID0gJ291dHB1dCc7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnKGZ1bmN0aW9uKCkgeycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3ZhciBvdXRwdXQgPSBcIlwiOycpO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczE0LmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgncmV0dXJuIG91dHB1dDsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9KSgpJyk7IC8vIGFuZCBvZiBjb3Vyc2UsIHJldmVydCBiYWNrIHRvIHRoZSBvbGQgYnVmZmVyIGlkXG5cblxuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlT3V0cHV0ID0gZnVuY3Rpb24gY29tcGlsZU91dHB1dChub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczE1ID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIC8vIFRlbXBsYXRlRGF0YSBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIGl0IGlzIG5ldmVyXG4gICAgICAvLyBhdXRvZXNjYXBlZCwgc28gc2ltcGx5IG91dHB1dCBpdCBmb3Igb3B0aW1pemF0aW9uXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5UZW1wbGF0ZURhdGEpIHtcbiAgICAgICAgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgICAgX3RoaXMxNS5fZW1pdChfdGhpczE1LmJ1ZmZlciArIFwiICs9IFwiKTtcblxuICAgICAgICAgIF90aGlzMTUuY29tcGlsZUxpdGVyYWwoY2hpbGQsIGZyYW1lKTtcblxuICAgICAgICAgIF90aGlzMTUuX2VtaXRMaW5lKCc7Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzMTUuX2VtaXQoX3RoaXMxNS5idWZmZXIgKyBcIiArPSBydW50aW1lLnN1cHByZXNzVmFsdWUoXCIpO1xuXG4gICAgICAgIGlmIChfdGhpczE1LnRocm93T25VbmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczE1Ll9lbWl0KCdydW50aW1lLmVuc3VyZURlZmluZWQoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczE1LmNvbXBpbGUoY2hpbGQsIGZyYW1lKTtcblxuICAgICAgICBpZiAoX3RoaXMxNS50aHJvd09uVW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMxNS5fZW1pdChcIixcIiArIG5vZGUubGluZW5vICsgXCIsXCIgKyBub2RlLmNvbG5vICsgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxNS5fZW1pdCgnLCBlbnYub3B0cy5hdXRvZXNjYXBlKTtcXG4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVJvb3QgPSBmdW5jdGlvbiBjb21waWxlUm9vdChub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczE2ID0gdGhpcztcblxuICAgIGlmIChmcmFtZSkge1xuICAgICAgdGhpcy5mYWlsKCdjb21waWxlUm9vdDogcm9vdCBub2RlIGNhblxcJ3QgaGF2ZSBmcmFtZScpO1xuICAgIH1cblxuICAgIGZyYW1lID0gbmV3IEZyYW1lKCk7XG5cbiAgICB0aGlzLl9lbWl0RnVuY0JlZ2luKG5vZGUsICdyb290Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndmFyIHBhcmVudFRlbXBsYXRlID0gbnVsbDsnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVDaGlsZHJlbihub2RlLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnaWYocGFyZW50VGVtcGxhdGUpIHsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdwYXJlbnRUZW1wbGF0ZS5yb290UmVuZGVyRnVuYyhlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYik7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSBlbHNlIHsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiY2IobnVsbCwgXCIgKyB0aGlzLmJ1ZmZlciArIFwiKTtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgdGhpcy5fZW1pdEZ1bmNFbmQodHJ1ZSk7XG5cbiAgICB0aGlzLmluQmxvY2sgPSB0cnVlO1xuICAgIHZhciBibG9ja05hbWVzID0gW107XG4gICAgdmFyIGJsb2NrcyA9IG5vZGUuZmluZEFsbChub2Rlcy5CbG9jayk7XG4gICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBpKSB7XG4gICAgICB2YXIgbmFtZSA9IGJsb2NrLm5hbWUudmFsdWU7XG5cbiAgICAgIGlmIChibG9ja05hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZGVmaW5lZCBtb3JlIHRoYW4gb25jZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrTmFtZXMucHVzaChuYW1lKTtcblxuICAgICAgX3RoaXMxNi5fZW1pdEZ1bmNCZWdpbihibG9jaywgXCJiX1wiICsgbmFtZSk7XG5cbiAgICAgIHZhciB0bXBGcmFtZSA9IG5ldyBGcmFtZSgpO1xuXG4gICAgICBfdGhpczE2Ll9lbWl0TGluZSgndmFyIGZyYW1lID0gZnJhbWUucHVzaCh0cnVlKTsnKTtcblxuICAgICAgX3RoaXMxNi5jb21waWxlKGJsb2NrLmJvZHksIHRtcEZyYW1lKTtcblxuICAgICAgX3RoaXMxNi5fZW1pdEZ1bmNFbmQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdyZXR1cm4geycpO1xuXG4gICAgYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBpKSB7XG4gICAgICB2YXIgYmxvY2tOYW1lID0gXCJiX1wiICsgYmxvY2submFtZS52YWx1ZTtcblxuICAgICAgX3RoaXMxNi5fZW1pdExpbmUoYmxvY2tOYW1lICsgXCI6IFwiICsgYmxvY2tOYW1lICsgXCIsXCIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3Jvb3Q6IHJvb3RcXG59OycpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZShub2RlLCBmcmFtZSkge1xuICAgIHZhciBfY29tcGlsZSA9IHRoaXNbJ2NvbXBpbGUnICsgbm9kZS50eXBlbmFtZV07XG5cbiAgICBpZiAoX2NvbXBpbGUpIHtcbiAgICAgIF9jb21waWxlLmNhbGwodGhpcywgbm9kZSwgZnJhbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhaWwoXCJjb21waWxlOiBDYW5ub3QgY29tcGlsZSBub2RlOiBcIiArIG5vZGUudHlwZW5hbWUsIG5vZGUubGluZW5vLCBub2RlLmNvbG5vKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldENvZGUgPSBmdW5jdGlvbiBnZXRDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvZGVidWYuam9pbignJyk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXBpbGVyO1xufShPYmopO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShzcmMsIGFzeW5jRmlsdGVycywgZXh0ZW5zaW9ucywgbmFtZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IG5ldyBDb21waWxlcihuYW1lLCBvcHRzLnRocm93T25VbmRlZmluZWQpOyAvLyBSdW4gdGhlIGV4dGVuc2lvbiBwcmVwcm9jZXNzb3JzIGFnYWluc3QgdGhlIHNvdXJjZS5cblxuICAgIHZhciBwcmVwcm9jZXNzb3JzID0gKGV4dGVuc2lvbnMgfHwgW10pLm1hcChmdW5jdGlvbiAoZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LnByZXByb2Nlc3M7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gISFmO1xuICAgIH0pO1xuICAgIHZhciBwcm9jZXNzZWRTcmMgPSBwcmVwcm9jZXNzb3JzLnJlZHVjZShmdW5jdGlvbiAocywgcHJvY2Vzc29yKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc29yKHMpO1xuICAgIH0sIHNyYyk7XG4gICAgYy5jb21waWxlKHRyYW5zZm9ybWVyLnRyYW5zZm9ybShwYXJzZXIucGFyc2UocHJvY2Vzc2VkU3JjLCBleHRlbnNpb25zLCBvcHRzKSwgYXN5bmNGaWx0ZXJzLCBuYW1lKSk7XG4gICAgcmV0dXJuIGMuZ2V0Q29kZSgpO1xuICB9LFxuICBDb21waWxlcjogQ29tcGlsZXJcbn07XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIEVtaXR0ZXJPYmogPSBfcmVxdWlyZS5FbWl0dGVyT2JqO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXJPYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9hZGVyLCBfRW1pdHRlck9iaik7XG5cbiAgZnVuY3Rpb24gTG9hZGVyKCkge1xuICAgIHJldHVybiBfRW1pdHRlck9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShmcm9tKSwgdG8pO1xuICB9O1xuXG4gIF9wcm90by5pc1JlbGF0aXZlID0gZnVuY3Rpb24gaXNSZWxhdGl2ZShmaWxlbmFtZSkge1xuICAgIHJldHVybiBmaWxlbmFtZS5pbmRleE9mKCcuLycpID09PSAwIHx8IGZpbGVuYW1lLmluZGV4T2YoJy4uLycpID09PSAwO1xuICB9O1xuXG4gIHJldHVybiBMb2FkZXI7XG59KEVtaXR0ZXJPYmopO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBhc2FwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBfd2F0ZXJmYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgY29tcGlsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgZmlsdGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSxcbiAgICBGaWxlU3lzdGVtTG9hZGVyID0gX3JlcXVpcmUuRmlsZVN5c3RlbUxvYWRlcixcbiAgICBXZWJMb2FkZXIgPSBfcmVxdWlyZS5XZWJMb2FkZXIsXG4gICAgUHJlY29tcGlsZWRMb2FkZXIgPSBfcmVxdWlyZS5QcmVjb21waWxlZExvYWRlcjtcblxudmFyIHRlc3RzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBnbG9iYWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIE9iaiA9IF9yZXF1aXJlMi5PYmosXG4gICAgRW1pdHRlck9iaiA9IF9yZXF1aXJlMi5FbWl0dGVyT2JqO1xuXG52YXIgZ2xvYmFsUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBoYW5kbGVFcnJvciA9IGdsb2JhbFJ1bnRpbWUuaGFuZGxlRXJyb3IsXG4gICAgRnJhbWUgPSBnbG9iYWxSdW50aW1lLkZyYW1lO1xuXG52YXIgZXhwcmVzc0FwcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpOyAvLyBJZiB0aGUgdXNlciBpcyB1c2luZyB0aGUgYXN5bmMgQVBJLCAqYWx3YXlzKiBjYWxsIGl0XG4vLyBhc3luY2hyb25vdXNseSBldmVuIGlmIHRoZSB0ZW1wbGF0ZSB3YXMgc3luY2hyb25vdXMuXG5cblxuZnVuY3Rpb24gY2FsbGJhY2tBc2FwKGNiLCBlcnIsIHJlcykge1xuICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICBjYihlcnIsIHJlcyk7XG4gIH0pO1xufVxuLyoqXG4gKiBBIG5vLW9wIHRlbXBsYXRlLCBmb3IgdXNlIHdpdGggeyUgaW5jbHVkZSBpZ25vcmUgbWlzc2luZyAlfVxuICovXG5cblxudmFyIG5vb3BUbXBsU3JjID0ge1xuICB0eXBlOiAnY29kZScsXG4gIG9iajoge1xuICAgIHJvb3Q6IGZ1bmN0aW9uIHJvb3QoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKG51bGwsICcnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2IoaGFuZGxlRXJyb3IoZSwgbnVsbCwgbnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIEVudmlyb25tZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1pdHRlck9iaikge1xuICBfaW5oZXJpdHNMb29zZShFbnZpcm9ubWVudCwgX0VtaXR0ZXJPYmopO1xuXG4gIGZ1bmN0aW9uIEVudmlyb25tZW50KCkge1xuICAgIHJldHVybiBfRW1pdHRlck9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRW52aXJvbm1lbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChsb2FkZXJzLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIFRoZSBkZXYgZmxhZyBkZXRlcm1pbmVzIHRoZSB0cmFjZSB0aGF0J2xsIGJlIHNob3duIG9uIGVycm9ycy5cbiAgICAvLyBJZiBzZXQgdG8gdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCB0cmFjZSBmcm9tIHRoZSBlcnJvciBwb2ludCxcbiAgICAvLyBvdGhlcndpc2Ugd2lsbCByZXR1cm4gdHJhY2Ugc3RhcnRpbmcgZnJvbSBUZW1wbGF0ZS5yZW5kZXJcbiAgICAvLyAodGhlIGZ1bGwgdHJhY2UgZnJvbSB3aXRoaW4gbnVuanVja3MgbWF5IGNvbmZ1c2UgZGV2ZWxvcGVycyB1c2luZ1xuICAgIC8vICB0aGUgbGlicmFyeSlcbiAgICAvLyBkZWZhdWx0cyB0byBmYWxzZVxuICAgIG9wdHMgPSB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMub3B0cy5kZXYgPSAhIW9wdHMuZGV2OyAvLyBUaGUgYXV0b2VzY2FwZSBmbGFnIHNldHMgZ2xvYmFsIGF1dG9lc2NhcGluZy4gSWYgdHJ1ZSxcbiAgICAvLyBldmVyeSBzdHJpbmcgdmFyaWFibGUgd2lsbCBiZSBlc2NhcGVkIGJ5IGRlZmF1bHQuXG4gICAgLy8gSWYgZmFsc2UsIHN0cmluZ3MgY2FuIGJlIG1hbnVhbGx5IGVzY2FwZWQgdXNpbmcgdGhlIGBlc2NhcGVgIGZpbHRlci5cbiAgICAvLyBkZWZhdWx0cyB0byB0cnVlXG5cbiAgICB0aGlzLm9wdHMuYXV0b2VzY2FwZSA9IG9wdHMuYXV0b2VzY2FwZSAhPSBudWxsID8gb3B0cy5hdXRvZXNjYXBlIDogdHJ1ZTsgLy8gSWYgdHJ1ZSwgdGhpcyB3aWxsIG1ha2UgdGhlIHN5c3RlbSB0aHJvdyBlcnJvcnMgaWYgdHJ5aW5nXG4gICAgLy8gdG8gb3V0cHV0IGEgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVcblxuICAgIHRoaXMub3B0cy50aHJvd09uVW5kZWZpbmVkID0gISFvcHRzLnRocm93T25VbmRlZmluZWQ7XG4gICAgdGhpcy5vcHRzLnRyaW1CbG9ja3MgPSAhIW9wdHMudHJpbUJsb2NrcztcbiAgICB0aGlzLm9wdHMubHN0cmlwQmxvY2tzID0gISFvcHRzLmxzdHJpcEJsb2NrcztcbiAgICB0aGlzLmxvYWRlcnMgPSBbXTtcblxuICAgIGlmICghbG9hZGVycykge1xuICAgICAgLy8gVGhlIGZpbGVzeXN0ZW0gbG9hZGVyIGlzIG9ubHkgYXZhaWxhYmxlIHNlcnZlci1zaWRlXG4gICAgICBpZiAoRmlsZVN5c3RlbUxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlcnMgPSBbbmV3IEZpbGVTeXN0ZW1Mb2FkZXIoJ3ZpZXdzJyldO1xuICAgICAgfSBlbHNlIGlmIChXZWJMb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJzID0gW25ldyBXZWJMb2FkZXIoJy92aWV3cycpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2FkZXJzID0gbGliLmlzQXJyYXkobG9hZGVycykgPyBsb2FkZXJzIDogW2xvYWRlcnNdO1xuICAgIH0gLy8gSXQncyBlYXN5IHRvIHVzZSBwcmVjb21waWxlZCB0ZW1wbGF0ZXM6IGp1c3QgaW5jbHVkZSB0aGVtXG4gICAgLy8gYmVmb3JlIHlvdSBjb25maWd1cmUgbnVuanVja3MgYW5kIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gcGljayBpdCB1cCBhbmQgdXNlIGl0XG5cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubnVuanVja3NQcmVjb21waWxlZCkge1xuICAgICAgdGhpcy5sb2FkZXJzLnVuc2hpZnQobmV3IFByZWNvbXBpbGVkTG9hZGVyKHdpbmRvdy5udW5qdWNrc1ByZWNvbXBpbGVkKSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdExvYWRlcnMoKTtcblxuICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHMoKTtcbiAgICB0aGlzLmZpbHRlcnMgPSB7fTtcbiAgICB0aGlzLnRlc3RzID0ge307XG4gICAgdGhpcy5hc3luY0ZpbHRlcnMgPSBbXTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLmV4dGVuc2lvbnNMaXN0ID0gW107XG5cbiAgICBsaWIuX2VudHJpZXMoZmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIGZpbHRlciA9IF9yZWZbMV07XG4gICAgICByZXR1cm4gX3RoaXMuYWRkRmlsdGVyKG5hbWUsIGZpbHRlcik7XG4gICAgfSk7XG5cbiAgICBsaWIuX2VudHJpZXModGVzdHMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWYyWzBdLFxuICAgICAgICAgIHRlc3QgPSBfcmVmMlsxXTtcbiAgICAgIHJldHVybiBfdGhpcy5hZGRUZXN0KG5hbWUsIHRlc3QpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5faW5pdExvYWRlcnMgPSBmdW5jdGlvbiBfaW5pdExvYWRlcnMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLmxvYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICAvLyBDYWNoaW5nIGFuZCBjYWNoZSBidXN0aW5nXG4gICAgICBsb2FkZXIuY2FjaGUgPSB7fTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2FkZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbG9hZGVyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAobmFtZSwgZnVsbG5hbWUpIHtcbiAgICAgICAgICBsb2FkZXIuY2FjaGVbbmFtZV0gPSBudWxsO1xuXG4gICAgICAgICAgX3RoaXMyLmVtaXQoJ3VwZGF0ZScsIG5hbWUsIGZ1bGxuYW1lLCBsb2FkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9hZGVyLm9uKCdsb2FkJywgZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSkge1xuICAgICAgICAgIF90aGlzMi5lbWl0KCdsb2FkJywgbmFtZSwgc291cmNlLCBsb2FkZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uaW52YWxpZGF0ZUNhY2hlID0gZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlKCkge1xuICAgIHRoaXMubG9hZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5jYWNoZSA9IHt9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5hZGRFeHRlbnNpb24gPSBmdW5jdGlvbiBhZGRFeHRlbnNpb24obmFtZSwgZXh0ZW5zaW9uKSB7XG4gICAgZXh0ZW5zaW9uLl9fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5leHRlbnNpb25zW25hbWVdID0gZXh0ZW5zaW9uO1xuICAgIHRoaXMuZXh0ZW5zaW9uc0xpc3QucHVzaChleHRlbnNpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmVFeHRlbnNpb24gPSBmdW5jdGlvbiByZW1vdmVFeHRlbnNpb24obmFtZSkge1xuICAgIHZhciBleHRlbnNpb24gPSB0aGlzLmdldEV4dGVuc2lvbihuYW1lKTtcblxuICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5leHRlbnNpb25zTGlzdCA9IGxpYi53aXRob3V0KHRoaXMuZXh0ZW5zaW9uc0xpc3QsIGV4dGVuc2lvbik7XG4gICAgZGVsZXRlIHRoaXMuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5oYXNFeHRlbnNpb24gPSBmdW5jdGlvbiBoYXNFeHRlbnNpb24obmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uYWRkR2xvYmFsID0gZnVuY3Rpb24gYWRkR2xvYmFsKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5nbG9iYWxzW25hbWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbChuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmdsb2JhbHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsb2JhbCBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbG9iYWxzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5hZGRGaWx0ZXIgPSBmdW5jdGlvbiBhZGRGaWx0ZXIobmFtZSwgZnVuYywgYXN5bmMpIHtcbiAgICB2YXIgd3JhcHBlZCA9IGZ1bmM7XG5cbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIHRoaXMuYXN5bmNGaWx0ZXJzLnB1c2gobmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5maWx0ZXJzW25hbWVdID0gd3JhcHBlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RmlsdGVyID0gZnVuY3Rpb24gZ2V0RmlsdGVyKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uYWRkVGVzdCA9IGZ1bmN0aW9uIGFkZFRlc3QobmFtZSwgZnVuYykge1xuICAgIHRoaXMudGVzdHNbbmFtZV0gPSBmdW5jO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nZXRUZXN0ID0gZnVuY3Rpb24gZ2V0VGVzdChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnRlc3RzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rlc3Qgbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudGVzdHNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLnJlc29sdmVUZW1wbGF0ZSA9IGZ1bmN0aW9uIHJlc29sdmVUZW1wbGF0ZShsb2FkZXIsIHBhcmVudE5hbWUsIGZpbGVuYW1lKSB7XG4gICAgdmFyIGlzUmVsYXRpdmUgPSBsb2FkZXIuaXNSZWxhdGl2ZSAmJiBwYXJlbnROYW1lID8gbG9hZGVyLmlzUmVsYXRpdmUoZmlsZW5hbWUpIDogZmFsc2U7XG4gICAgcmV0dXJuIGlzUmVsYXRpdmUgJiYgbG9hZGVyLnJlc29sdmUgPyBsb2FkZXIucmVzb2x2ZShwYXJlbnROYW1lLCBmaWxlbmFtZSkgOiBmaWxlbmFtZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGVtcGxhdGUgPSBmdW5jdGlvbiBnZXRUZW1wbGF0ZShuYW1lLCBlYWdlckNvbXBpbGUsIHBhcmVudE5hbWUsIGlnbm9yZU1pc3NpbmcsIGNiKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHRtcGwgPSBudWxsO1xuXG4gICAgaWYgKG5hbWUgJiYgbmFtZS5yYXcpIHtcbiAgICAgIC8vIHRoaXMgZml4ZXMgYXV0b2VzY2FwZSBmb3IgdGVtcGxhdGVzIHJlZmVyZW5jZWQgaW4gc3ltYm9sc1xuICAgICAgbmFtZSA9IG5hbWUucmF3O1xuICAgIH1cblxuICAgIGlmIChsaWIuaXNGdW5jdGlvbihwYXJlbnROYW1lKSkge1xuICAgICAgY2IgPSBwYXJlbnROYW1lO1xuICAgICAgcGFyZW50TmFtZSA9IG51bGw7XG4gICAgICBlYWdlckNvbXBpbGUgPSBlYWdlckNvbXBpbGUgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKGVhZ2VyQ29tcGlsZSkpIHtcbiAgICAgIGNiID0gZWFnZXJDb21waWxlO1xuICAgICAgZWFnZXJDb21waWxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgdG1wbCA9IG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVtcGxhdGUgbmFtZXMgbXVzdCBiZSBhIHN0cmluZzogJyArIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9hZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2ldO1xuICAgICAgICB0bXBsID0gbG9hZGVyLmNhY2hlW3RoaXMucmVzb2x2ZVRlbXBsYXRlKGxvYWRlciwgcGFyZW50TmFtZSwgbmFtZSldO1xuXG4gICAgICAgIGlmICh0bXBsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG1wbCkge1xuICAgICAgaWYgKGVhZ2VyQ29tcGlsZSkge1xuICAgICAgICB0bXBsLmNvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKG51bGwsIHRtcGwpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN5bmNSZXN1bHQ7XG5cbiAgICB2YXIgY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZShlcnIsIGluZm8pIHtcbiAgICAgIGlmICghaW5mbyAmJiAhZXJyICYmICFpZ25vcmVNaXNzaW5nKSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcigndGVtcGxhdGUgbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdUbXBsO1xuXG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgbmV3VG1wbCA9IG5ldyBUZW1wbGF0ZShub29wVG1wbFNyYywgX3RoaXMzLCAnJywgZWFnZXJDb21waWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1RtcGwgPSBuZXcgVGVtcGxhdGUoaW5mby5zcmMsIF90aGlzMywgaW5mby5wYXRoLCBlYWdlckNvbXBpbGUpO1xuXG4gICAgICAgIGlmICghaW5mby5ub0NhY2hlKSB7XG4gICAgICAgICAgaW5mby5sb2FkZXIuY2FjaGVbbmFtZV0gPSBuZXdUbXBsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYihudWxsLCBuZXdUbXBsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bmNSZXN1bHQgPSBuZXdUbXBsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIuYXN5bmNJdGVyKHRoaXMubG9hZGVycywgZnVuY3Rpb24gKGxvYWRlciwgaSwgbmV4dCwgZG9uZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGVyciwgc3JjKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjKSB7XG4gICAgICAgICAgc3JjLmxvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgICBkb25lKG51bGwsIHNyYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlc29sdmUgbmFtZSByZWxhdGl2ZSB0byBwYXJlbnROYW1lXG5cblxuICAgICAgbmFtZSA9IHRoYXQucmVzb2x2ZVRlbXBsYXRlKGxvYWRlciwgcGFyZW50TmFtZSwgbmFtZSk7XG5cbiAgICAgIGlmIChsb2FkZXIuYXN5bmMpIHtcbiAgICAgICAgbG9hZGVyLmdldFNvdXJjZShuYW1lLCBoYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlKG51bGwsIGxvYWRlci5nZXRTb3VyY2UobmFtZSkpO1xuICAgICAgfVxuICAgIH0sIGNyZWF0ZVRlbXBsYXRlKTtcbiAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8uZXhwcmVzcyA9IGZ1bmN0aW9uIGV4cHJlc3MoYXBwKSB7XG4gICAgcmV0dXJuIGV4cHJlc3NBcHAodGhpcywgYXBwKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKG5hbWUsIGN0eCwgY2IpIHtcbiAgICBpZiAobGliLmlzRnVuY3Rpb24oY3R4KSkge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSBudWxsO1xuICAgIH0gLy8gV2Ugc3VwcG9ydCBhIHN5bmNocm9ub3VzIEFQSSB0byBtYWtlIGl0IGVhc2llciB0byBtaWdyYXRlXG4gICAgLy8gZXhpc3RpbmcgY29kZSB0byBhc3luYy4gVGhpcyB3b3JrcyBiZWNhdXNlIGlmIHlvdSBkb24ndCBkb1xuICAgIC8vIGFueXRoaW5nIGFzeW5jIHdvcmssIHRoZSB3aG9sZSB0aGluZyBpcyBhY3R1YWxseSBydW5cbiAgICAvLyBzeW5jaHJvbm91c2x5LlxuXG5cbiAgICB2YXIgc3luY1Jlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5nZXRUZW1wbGF0ZShuYW1lLCBmdW5jdGlvbiAoZXJyLCB0bXBsKSB7XG4gICAgICBpZiAoZXJyICYmIGNiKSB7XG4gICAgICAgIGNhbGxiYWNrQXNhcChjYiwgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN5bmNSZXN1bHQgPSB0bXBsLnJlbmRlcihjdHgsIGNiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3luY1Jlc3VsdDtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyU3RyaW5nID0gZnVuY3Rpb24gcmVuZGVyU3RyaW5nKHNyYywgY3R4LCBvcHRzLCBjYikge1xuICAgIGlmIChsaWIuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgY2IgPSBvcHRzO1xuICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciB0bXBsID0gbmV3IFRlbXBsYXRlKHNyYywgdGhpcywgb3B0cy5wYXRoKTtcbiAgICByZXR1cm4gdG1wbC5yZW5kZXIoY3R4LCBjYik7XG4gIH07XG5cbiAgX3Byb3RvLndhdGVyZmFsbCA9IGZ1bmN0aW9uIHdhdGVyZmFsbCh0YXNrcywgY2FsbGJhY2ssIGZvcmNlQXN5bmMpIHtcbiAgICByZXR1cm4gX3dhdGVyZmFsbCh0YXNrcywgY2FsbGJhY2ssIGZvcmNlQXN5bmMpO1xuICB9O1xuXG4gIHJldHVybiBFbnZpcm9ubWVudDtcbn0oRW1pdHRlck9iaik7XG5cbnZhciBDb250ZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbnRleHQsIF9PYmopO1xuXG4gIGZ1bmN0aW9uIENvbnRleHQoKSB7XG4gICAgcmV0dXJuIF9PYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBDb250ZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmluaXQgPSBmdW5jdGlvbiBpbml0KGN0eCwgYmxvY2tzLCBlbnYpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIC8vIEhhcyB0byBiZSB0aWVkIHRvIGFuIGVudmlyb25tZW50IHNvIHdlIGNhbiB0YXAgaW50byBpdHMgZ2xvYmFscy5cbiAgICB0aGlzLmVudiA9IGVudiB8fCBuZXcgRW52aXJvbm1lbnQoKTsgLy8gTWFrZSBhIGR1cGxpY2F0ZSBvZiBjdHhcblxuICAgIHRoaXMuY3R4ID0gbGliLmV4dGVuZCh7fSwgY3R4KTtcbiAgICB0aGlzLmJsb2NrcyA9IHt9O1xuICAgIHRoaXMuZXhwb3J0ZWQgPSBbXTtcbiAgICBsaWIua2V5cyhibG9ja3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzNC5hZGRCbG9jayhuYW1lLCBibG9ja3NbbmFtZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzIubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKG5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjYWxsZWQgZnVuY3Rpb25zLCBzbyBvcHRpbWl6ZSBmb3JcbiAgICAvLyB0aGUgdHlwaWNhbCBjYXNlIHdoZXJlIHRoZSBuYW1lIGlzbid0IGluIHRoZSBnbG9iYWxzXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5lbnYuZ2xvYmFscyAmJiAhKG5hbWUgaW4gdGhpcy5jdHgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnYuZ2xvYmFsc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY3R4W25hbWVdO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnNldFZhcmlhYmxlID0gZnVuY3Rpb24gc2V0VmFyaWFibGUobmFtZSwgdmFsKSB7XG4gICAgdGhpcy5jdHhbbmFtZV0gPSB2YWw7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRWYXJpYWJsZXMgPSBmdW5jdGlvbiBnZXRWYXJpYWJsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4O1xuICB9O1xuXG4gIF9wcm90bzIuYWRkQmxvY2sgPSBmdW5jdGlvbiBhZGRCbG9jayhuYW1lLCBibG9jaykge1xuICAgIHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5ibG9ja3NbbmFtZV0gfHwgW107XG4gICAgdGhpcy5ibG9ja3NbbmFtZV0ucHVzaChibG9jayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRCbG9jayA9IGZ1bmN0aW9uIGdldEJsb2NrKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuYmxvY2tzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gYmxvY2sgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJsb2Nrc1tuYW1lXVswXTtcbiAgfTtcblxuICBfcHJvdG8yLmdldFN1cGVyID0gZnVuY3Rpb24gZ2V0U3VwZXIoZW52LCBuYW1lLCBibG9jaywgZnJhbWUsIHJ1bnRpbWUsIGNiKSB7XG4gICAgdmFyIGlkeCA9IGxpYi5pbmRleE9mKHRoaXMuYmxvY2tzW25hbWVdIHx8IFtdLCBibG9jayk7XG4gICAgdmFyIGJsayA9IHRoaXMuYmxvY2tzW25hbWVdW2lkeCArIDFdO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgIGlmIChpZHggPT09IC0xIHx8ICFibGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gc3VwZXIgYmxvY2sgYXZhaWxhYmxlIGZvciBcIicgKyBuYW1lICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgYmxrKGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsIGNiKTtcbiAgfTtcblxuICBfcHJvdG8yLmFkZEV4cG9ydCA9IGZ1bmN0aW9uIGFkZEV4cG9ydChuYW1lKSB7XG4gICAgdGhpcy5leHBvcnRlZC5wdXNoKG5hbWUpO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0RXhwb3J0ZWQgPSBmdW5jdGlvbiBnZXRFeHBvcnRlZCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuICAgIHRoaXMuZXhwb3J0ZWQuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgZXhwb3J0ZWRbbmFtZV0gPSBfdGhpczUuY3R4W25hbWVdO1xuICAgIH0pO1xuICAgIHJldHVybiBleHBvcnRlZDtcbiAgfTtcblxuICByZXR1cm4gQ29udGV4dDtcbn0oT2JqKTtcblxudmFyIFRlbXBsYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqMikge1xuICBfaW5oZXJpdHNMb29zZShUZW1wbGF0ZSwgX09iajIpO1xuXG4gIGZ1bmN0aW9uIFRlbXBsYXRlKCkge1xuICAgIHJldHVybiBfT2JqMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFRlbXBsYXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmluaXQgPSBmdW5jdGlvbiBpbml0KHNyYywgZW52LCBwYXRoLCBlYWdlckNvbXBpbGUpIHtcbiAgICB0aGlzLmVudiA9IGVudiB8fCBuZXcgRW52aXJvbm1lbnQoKTtcblxuICAgIGlmIChsaWIuaXNPYmplY3Qoc3JjKSkge1xuICAgICAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICB0aGlzLnRtcGxQcm9wcyA9IHNyYy5vYmo7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICB0aGlzLnRtcGxTdHIgPSBzcmMub2JqO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0ZW1wbGF0ZSBvYmplY3QgdHlwZSBcIiArIHNyYy50eXBlICsgXCI7IGV4cGVjdGVkICdjb2RlJywgb3IgJ3N0cmluZydcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaWIuaXNTdHJpbmcoc3JjKSkge1xuICAgICAgdGhpcy50bXBsU3RyID0gc3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NyYyBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBzb3VyY2UnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gICAgaWYgKGVhZ2VyQ29tcGlsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGxpYi5fcHJldHRpZnlFcnJvcih0aGlzLnBhdGgsIHRoaXMuZW52Lm9wdHMuZGV2LCBlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbXBpbGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGN0eCwgcGFyZW50RnJhbWUsIGNiKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJlbnRGcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBwYXJlbnRGcmFtZTtcbiAgICAgIHBhcmVudEZyYW1lID0gbnVsbDtcbiAgICB9IC8vIElmIHRoZXJlIGlzIGEgcGFyZW50IGZyYW1lLCB3ZSBhcmUgYmVpbmcgY2FsbGVkIGZyb20gaW50ZXJuYWxcbiAgICAvLyBjb2RlIG9mIGFub3RoZXIgdGVtcGxhdGUsIGFuZCB0aGUgaW50ZXJuYWwgc3lzdGVtXG4gICAgLy8gZGVwZW5kcyBvbiB0aGUgc3luYy9hc3luYyBuYXR1cmUgb2YgdGhlIHBhcmVudCB0ZW1wbGF0ZVxuICAgIC8vIHRvIGJlIGluaGVyaXRlZCwgc28gZm9yY2UgYW4gYXN5bmMgY2FsbGJhY2tcblxuXG4gICAgdmFyIGZvcmNlQXN5bmMgPSAhcGFyZW50RnJhbWU7IC8vIENhdGNoIGNvbXBpbGUgZXJyb3JzIGZvciBhc3luYyByZW5kZXJpbmdcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgZXJyID0gbGliLl9wcmV0dGlmeUVycm9yKHRoaXMucGF0aCwgdGhpcy5lbnYub3B0cy5kZXYsIGUpO1xuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrQXNhcChjYiwgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KGN0eCB8fCB7fSwgdGhpcy5ibG9ja3MsIHRoaXMuZW52KTtcbiAgICB2YXIgZnJhbWUgPSBwYXJlbnRGcmFtZSA/IHBhcmVudEZyYW1lLnB1c2godHJ1ZSkgOiBuZXcgRnJhbWUoKTtcbiAgICBmcmFtZS50b3BMZXZlbCA9IHRydWU7XG4gICAgdmFyIHN5bmNSZXN1bHQgPSBudWxsO1xuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMucm9vdFJlbmRlckZ1bmModGhpcy5lbnYsIGNvbnRleHQsIGZyYW1lLCBnbG9iYWxSdW50aW1lLCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgYWN0dWFsbHkgYSBidWcgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlIChiZWNhdXNlIHdhdGVyZmFsbFxuICAgICAgLy8gdGFza3MgYXJlIGJvdGggbm90IHBhc3NpbmcgZXJyb3JzIHVwIHRoZSBjaGFpbiBvZiBjYWxsYmFja3MgQU5EIGFyZSBub3RcbiAgICAgIC8vIGNhdXNpbmcgYSByZXR1cm4gZnJvbSB0aGUgdG9wLW1vc3QgcmVuZGVyIGZ1bmN0aW9uKS4gQnV0IGZpeGluZyB0aGF0XG4gICAgICAvLyB3aWxsIHJlcXVpcmUgYSBtb3JlIHN1YnN0YW50aWFsIGNoYW5nZSB0byB0aGUgY29tcGlsZXIuXG4gICAgICBpZiAoZGlkRXJyb3IgJiYgY2IgJiYgdHlwZW9mIHJlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBjYWxscyB0byBjYlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyID0gbGliLl9wcmV0dGlmeUVycm9yKF90aGlzNi5wYXRoLCBfdGhpczYuZW52Lm9wdHMuZGV2LCBlcnIpO1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICBpZiAoZm9yY2VBc3luYykge1xuICAgICAgICAgIGNhbGxiYWNrQXNhcChjYiwgZXJyLCByZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKGVyciwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN5bmNSZXN1bHQgPSByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvMy5nZXRFeHBvcnRlZCA9IGZ1bmN0aW9uIGdldEV4cG9ydGVkKGN0eCwgcGFyZW50RnJhbWUsIGNiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgIGlmICh0eXBlb2YgY3R4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGN0eDtcbiAgICAgIGN0eCA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyZW50RnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gcGFyZW50RnJhbWU7XG4gICAgICBwYXJlbnRGcmFtZSA9IG51bGw7XG4gICAgfSAvLyBDYXRjaCBjb21waWxlIGVycm9ycyBmb3IgYXN5bmMgcmVuZGVyaW5nXG5cblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJhbWUgPSBwYXJlbnRGcmFtZSA/IHBhcmVudEZyYW1lLnB1c2goKSA6IG5ldyBGcmFtZSgpO1xuICAgIGZyYW1lLnRvcExldmVsID0gdHJ1ZTsgLy8gUnVuIHRoZSByb290UmVuZGVyRnVuYyB0byBwb3B1bGF0ZSB0aGUgY29udGV4dCB3aXRoIGV4cG9ydGVkIHZhcnNcblxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoY3R4IHx8IHt9LCB0aGlzLmJsb2NrcywgdGhpcy5lbnYpO1xuICAgIHRoaXMucm9vdFJlbmRlckZ1bmModGhpcy5lbnYsIGNvbnRleHQsIGZyYW1lLCBnbG9iYWxSdW50aW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGNiKGVyciwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsLCBjb250ZXh0LmdldEV4cG9ydGVkKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzMuX2NvbXBpbGUgPSBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAodGhpcy50bXBsUHJvcHMpIHtcbiAgICAgIHByb3BzID0gdGhpcy50bXBsUHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2UgPSBjb21waWxlci5jb21waWxlKHRoaXMudG1wbFN0ciwgdGhpcy5lbnYuYXN5bmNGaWx0ZXJzLCB0aGlzLmVudi5leHRlbnNpb25zTGlzdCwgdGhpcy5wYXRoLCB0aGlzLmVudi5vcHRzKTtcbiAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKHNvdXJjZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcblxuICAgICAgcHJvcHMgPSBmdW5jKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9ja3MgPSB0aGlzLl9nZXRCbG9ja3MocHJvcHMpO1xuICAgIHRoaXMucm9vdFJlbmRlckZ1bmMgPSBwcm9wcy5yb290O1xuICAgIHRoaXMuY29tcGlsZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90bzMuX2dldEJsb2NrcyA9IGZ1bmN0aW9uIF9nZXRCbG9ja3MocHJvcHMpIHtcbiAgICB2YXIgYmxvY2tzID0ge307XG4gICAgbGliLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrLnNsaWNlKDAsIDIpID09PSAnYl8nKSB7XG4gICAgICAgIGJsb2Nrc1trLnNsaWNlKDIpXSA9IHByb3BzW2tdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBsYXRlO1xufShPYmopO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LFxuICBUZW1wbGF0ZTogVGVtcGxhdGVcbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGxleGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIG5vZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIE9iaiA9IF9fd2VicGFja19yZXF1aXJlX18oMSkuT2JqO1xuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iaikge1xuICBfaW5oZXJpdHNMb29zZShQYXJzZXIsIF9PYmopO1xuXG4gIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICByZXR1cm4gX09iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQodG9rZW5zKSB7XG4gICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy5wZWVrZWQgPSBudWxsO1xuICAgIHRoaXMuYnJlYWtPbkJsb2NrcyA9IG51bGw7XG4gICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBbXTtcbiAgfTtcblxuICBfcHJvdG8ubmV4dFRva2VuID0gZnVuY3Rpb24gbmV4dFRva2VuKHdpdGhXaGl0ZXNwYWNlKSB7XG4gICAgdmFyIHRvaztcblxuICAgIGlmICh0aGlzLnBlZWtlZCkge1xuICAgICAgaWYgKCF3aXRoV2hpdGVzcGFjZSAmJiB0aGlzLnBlZWtlZC50eXBlID09PSBsZXhlci5UT0tFTl9XSElURVNQQUNFKSB7XG4gICAgICAgIHRoaXMucGVla2VkID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvayA9IHRoaXMucGVla2VkO1xuICAgICAgICB0aGlzLnBlZWtlZCA9IG51bGw7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9rID0gdGhpcy50b2tlbnMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAoIXdpdGhXaGl0ZXNwYWNlKSB7XG4gICAgICB3aGlsZSAodG9rICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9XSElURVNQQUNFKSB7XG4gICAgICAgIHRvayA9IHRoaXMudG9rZW5zLm5leHRUb2tlbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2s7XG4gIH07XG5cbiAgX3Byb3RvLnBlZWtUb2tlbiA9IGZ1bmN0aW9uIHBlZWtUb2tlbigpIHtcbiAgICB0aGlzLnBlZWtlZCA9IHRoaXMucGVla2VkIHx8IHRoaXMubmV4dFRva2VuKCk7XG4gICAgcmV0dXJuIHRoaXMucGVla2VkO1xuICB9O1xuXG4gIF9wcm90by5wdXNoVG9rZW4gPSBmdW5jdGlvbiBwdXNoVG9rZW4odG9rKSB7XG4gICAgaWYgKHRoaXMucGVla2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1c2hUb2tlbjogY2FuIG9ubHkgcHVzaCBvbmUgdG9rZW4gb24gYmV0d2VlbiByZWFkcycpO1xuICAgIH1cblxuICAgIHRoaXMucGVla2VkID0gdG9rO1xuICB9O1xuXG4gIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1zZywgbGluZW5vLCBjb2xubykge1xuICAgIGlmIChsaW5lbm8gPT09IHVuZGVmaW5lZCB8fCBjb2xubyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKSB8fCB7fTtcbiAgICAgIGxpbmVubyA9IHRvay5saW5lbm87XG4gICAgICBjb2xubyA9IHRvay5jb2xubztcbiAgICB9XG5cbiAgICBpZiAobGluZW5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpbmVubyArPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xubyArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbGliLlRlbXBsYXRlRXJyb3IobXNnLCBsaW5lbm8sIGNvbG5vKTtcbiAgfTtcblxuICBfcHJvdG8uZmFpbCA9IGZ1bmN0aW9uIGZhaWwobXNnLCBsaW5lbm8sIGNvbG5vKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcihtc2csIGxpbmVubywgY29sbm8pO1xuICB9O1xuXG4gIF9wcm90by5za2lwID0gZnVuY3Rpb24gc2tpcCh0eXBlKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAoIXRvayB8fCB0b2sudHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZXhwZWN0ID0gZnVuY3Rpb24gZXhwZWN0KHR5cGUpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICh0b2sudHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdG9rLnR5cGUsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvaztcbiAgfTtcblxuICBfcHJvdG8uc2tpcFZhbHVlID0gZnVuY3Rpb24gc2tpcFZhbHVlKHR5cGUsIHZhbCkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKCF0b2sgfHwgdG9rLnR5cGUgIT09IHR5cGUgfHwgdG9rLnZhbHVlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnNraXBTeW1ib2wgPSBmdW5jdGlvbiBza2lwU3ltYm9sKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9TWU1CT0wsIHZhbCk7XG4gIH07XG5cbiAgX3Byb3RvLmFkdmFuY2VBZnRlckJsb2NrRW5kID0gZnVuY3Rpb24gYWR2YW5jZUFmdGVyQmxvY2tFbmQobmFtZSkge1xuICAgIHZhciB0b2s7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICAgIGlmICghdG9rKSB7XG4gICAgICAgIHRoaXMuZmFpbCgndW5leHBlY3RlZCBlbmQgb2YgZmlsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rLnR5cGUgIT09IGxleGVyLlRPS0VOX1NZTUJPTCkge1xuICAgICAgICB0aGlzLmZhaWwoJ2FkdmFuY2VBZnRlckJsb2NrRW5kOiBleHBlY3RlZCBzeW1ib2wgdG9rZW4gb3IgJyArICdleHBsaWNpdCBuYW1lIHRvIGJlIHBhc3NlZCcpO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcbiAgICB9XG5cbiAgICB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKHRvayAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfRU5EKSB7XG4gICAgICBpZiAodG9rLnZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBibG9jayBlbmQgaW4gJyArIG5hbWUgKyAnIHN0YXRlbWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2s7XG4gIH07XG5cbiAgX3Byb3RvLmFkdmFuY2VBZnRlclZhcmlhYmxlRW5kID0gZnVuY3Rpb24gYWR2YW5jZUFmdGVyVmFyaWFibGVFbmQoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAodG9rICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9WQVJJQUJMRV9FTkQpIHtcbiAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdG9rLnZhbHVlLmNoYXJBdCh0b2sudmFsdWUubGVuZ3RoIC0gdGhpcy50b2tlbnMudGFncy5WQVJJQUJMRV9FTkQubGVuZ3RoIC0gMSkgPT09ICctJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgdmFyaWFibGUgZW5kJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYXJzZUZvciA9IGZ1bmN0aW9uIHBhcnNlRm9yKCkge1xuICAgIHZhciBmb3JUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBlbmRCbG9jaztcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2ZvcicpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkZvcihmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgICAgZW5kQmxvY2sgPSAnZW5kZm9yJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFN5bWJvbCgnYXN5bmNFYWNoJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQXN5bmNFYWNoKGZvclRvay5saW5lbm8sIGZvclRvay5jb2xubyk7XG4gICAgICBlbmRCbG9jayA9ICdlbmRlYWNoJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFN5bWJvbCgnYXN5bmNBbGwnKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Bc3luY0FsbChmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgICAgZW5kQmxvY2sgPSAnZW5kYWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZvcjogZXhwZWN0ZWQgZm9ye0FzeW5jfScsIGZvclRvay5saW5lbm8sIGZvclRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgbm9kZS5uYW1lID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcblxuICAgIGlmICghKG5vZGUubmFtZSBpbnN0YW5jZW9mIG5vZGVzLlN5bWJvbCkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGb3I6IHZhcmlhYmxlIG5hbWUgZXhwZWN0ZWQgZm9yIGxvb3AnKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMucGVla1Rva2VuKCkudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBsZXhlci5UT0tFTl9DT01NQSkge1xuICAgICAgLy8ga2V5L3ZhbHVlIGl0ZXJhdGlvblxuICAgICAgdmFyIGtleSA9IG5vZGUubmFtZTtcbiAgICAgIG5vZGUubmFtZSA9IG5ldyBub2Rlcy5BcnJheShrZXkubGluZW5vLCBrZXkuY29sbm8pO1xuICAgICAgbm9kZS5uYW1lLmFkZENoaWxkKGtleSk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIHZhciBwcmltID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgICAgbm9kZS5uYW1lLmFkZENoaWxkKHByaW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdpbicpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRm9yOiBleHBlY3RlZCBcImluXCIga2V5d29yZCBmb3IgbG9vcCcsIGZvclRvay5saW5lbm8sIGZvclRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgbm9kZS5hcnIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoZm9yVG9rLnZhbHVlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoZW5kQmxvY2ssICdlbHNlJyk7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdlbHNlJykpIHtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoJ2Vsc2UnKTtcbiAgICAgIG5vZGUuZWxzZV8gPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoZW5kQmxvY2spO1xuICAgIH1cblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VNYWNybyA9IGZ1bmN0aW9uIHBhcnNlTWFjcm8oKSB7XG4gICAgdmFyIG1hY3JvVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdtYWNybycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIG1hY3JvJyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlUHJpbWFyeSh0cnVlKTtcbiAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VTaWduYXR1cmUoKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5NYWNybyhtYWNyb1Rvay5saW5lbm8sIG1hY3JvVG9rLmNvbG5vLCBuYW1lLCBhcmdzKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKG1hY3JvVG9rLnZhbHVlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZG1hY3JvJyk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUNhbGwgPSBmdW5jdGlvbiBwYXJzZUNhbGwoKSB7XG4gICAgLy8gYSBjYWxsIGJsb2NrIGlzIHBhcnNlZCBhcyBhIG5vcm1hbCBGdW5DYWxsLCBidXQgd2l0aCBhbiBhZGRlZFxuICAgIC8vICdjYWxsZXInIGt3YXJnIHdoaWNoIGlzIGEgQ2FsbGVyIG5vZGUuXG4gICAgdmFyIGNhbGxUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2NhbGwnKSkge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBjYWxsJyk7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxlckFyZ3MgPSB0aGlzLnBhcnNlU2lnbmF0dXJlKHRydWUpIHx8IG5ldyBub2Rlcy5Ob2RlTGlzdCgpO1xuICAgIHZhciBtYWNyb0NhbGwgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoY2FsbFRvay52YWx1ZSk7XG4gICAgdmFyIGJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGNhbGwnKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgdmFyIGNhbGxlck5hbWUgPSBuZXcgbm9kZXMuU3ltYm9sKGNhbGxUb2subGluZW5vLCBjYWxsVG9rLmNvbG5vLCAnY2FsbGVyJyk7XG4gICAgdmFyIGNhbGxlck5vZGUgPSBuZXcgbm9kZXMuQ2FsbGVyKGNhbGxUb2subGluZW5vLCBjYWxsVG9rLmNvbG5vLCBjYWxsZXJOYW1lLCBjYWxsZXJBcmdzLCBib2R5KTsgLy8gYWRkIHRoZSBhZGRpdGlvbmFsIGNhbGxlciBrd2FyZywgYWRkaW5nIGt3YXJncyBpZiBuZWNlc3NhcnlcblxuICAgIHZhciBhcmdzID0gbWFjcm9DYWxsLmFyZ3MuY2hpbGRyZW47XG5cbiAgICBpZiAoIShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBub2Rlcy5LZXl3b3JkQXJncykpIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgbm9kZXMuS2V5d29yZEFyZ3MoKSk7XG4gICAgfVxuXG4gICAgdmFyIGt3YXJncyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBrd2FyZ3MuYWRkQ2hpbGQobmV3IG5vZGVzLlBhaXIoY2FsbFRvay5saW5lbm8sIGNhbGxUb2suY29sbm8sIGNhbGxlck5hbWUsIGNhbGxlck5vZGUpKTtcbiAgICByZXR1cm4gbmV3IG5vZGVzLk91dHB1dChjYWxsVG9rLmxpbmVubywgY2FsbFRvay5jb2xubywgW21hY3JvQ2FsbF0pO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVdpdGhDb250ZXh0ID0gZnVuY3Rpb24gcGFyc2VXaXRoQ29udGV4dCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgd2l0aENvbnRleHQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnd2l0aCcpKSB7XG4gICAgICB3aXRoQ29udGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ3dpdGhvdXQnKSkge1xuICAgICAgd2l0aENvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAod2l0aENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdjb250ZXh0JykpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IGV4cGVjdGVkIGNvbnRleHQgYWZ0ZXIgd2l0aC93aXRob3V0JywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2l0aENvbnRleHQ7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24gcGFyc2VJbXBvcnQoKSB7XG4gICAgdmFyIGltcG9ydFRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnaW1wb3J0JykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VJbXBvcnQ6IGV4cGVjdGVkIGltcG9ydCcsIGltcG9ydFRvay5saW5lbm8sIGltcG9ydFRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdhcycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlSW1wb3J0OiBleHBlY3RlZCBcImFzXCIga2V5d29yZCcsIGltcG9ydFRvay5saW5lbm8sIGltcG9ydFRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdmFyIHdpdGhDb250ZXh0ID0gdGhpcy5wYXJzZVdpdGhDb250ZXh0KCk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuSW1wb3J0KGltcG9ydFRvay5saW5lbm8sIGltcG9ydFRvay5jb2xubywgdGVtcGxhdGUsIHRhcmdldCwgd2l0aENvbnRleHQpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoaW1wb3J0VG9rLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGcm9tID0gZnVuY3Rpb24gcGFyc2VGcm9tKCkge1xuICAgIHZhciBmcm9tVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdmcm9tJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBleHBlY3RlZCBmcm9tJyk7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdpbXBvcnQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IGV4cGVjdGVkIGltcG9ydCcsIGZyb21Ub2subGluZW5vLCBmcm9tVG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSBuZXcgbm9kZXMuTm9kZUxpc3QoKTtcbiAgICB2YXIgd2l0aENvbnRleHQ7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHZhciBuZXh0VG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgICAgaWYgKG5leHRUb2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfRU5EKSB7XG4gICAgICAgIGlmICghbmFtZXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IEV4cGVjdGVkIGF0IGxlYXN0IG9uZSBpbXBvcnQgbmFtZScsIGZyb21Ub2subGluZW5vLCBmcm9tVG9rLmNvbG5vKTtcbiAgICAgICAgfSAvLyBTaW5jZSB3ZSBhcmUgbWFudWFsbHkgYWR2YW5jaW5nIHBhc3QgdGhlIGJsb2NrIGVuZCxcbiAgICAgICAgLy8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoaXRlc3BhY2UgY29udHJvbCAobm9ybWFsbHlcbiAgICAgICAgLy8gdGhpcyBpcyBkb25lIGluIGBhZHZhbmNlQWZ0ZXJCbG9ja0VuZGBcblxuXG4gICAgICAgIGlmIChuZXh0VG9rLnZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lcy5jaGlsZHJlbi5sZW5ndGggPiAwICYmICF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBleHBlY3RlZCBjb21tYScsIGZyb21Ub2subGluZW5vLCBmcm9tVG9rLmNvbG5vKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuXG4gICAgICBpZiAobmFtZS52YWx1ZS5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogbmFtZXMgc3RhcnRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlIGNhbm5vdCBiZSBpbXBvcnRlZCcsIG5hbWUubGluZW5vLCBuYW1lLmNvbG5vKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnYXMnKSkge1xuICAgICAgICB2YXIgYWxpYXMgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICBuYW1lcy5hZGRDaGlsZChuZXcgbm9kZXMuUGFpcihuYW1lLmxpbmVubywgbmFtZS5jb2xubywgbmFtZSwgYWxpYXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVzLmFkZENoaWxkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3aXRoQ29udGV4dCA9IHRoaXMucGFyc2VXaXRoQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbm9kZXMuRnJvbUltcG9ydChmcm9tVG9rLmxpbmVubywgZnJvbVRvay5jb2xubywgdGVtcGxhdGUsIG5hbWVzLCB3aXRoQ29udGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQmxvY2sgPSBmdW5jdGlvbiBwYXJzZUJsb2NrKCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2Jsb2NrJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VCbG9jazogZXhwZWN0ZWQgYmxvY2snLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkJsb2NrKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgbm9kZS5uYW1lID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcblxuICAgIGlmICghKG5vZGUubmFtZSBpbnN0YW5jZW9mIG5vZGVzLlN5bWJvbCkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VCbG9jazogdmFyaWFibGUgbmFtZSBleHBlY3RlZCcsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0YWcudmFsdWUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kYmxvY2snKTtcbiAgICB0aGlzLnNraXBTeW1ib2woJ2VuZGJsb2NrJyk7XG4gICAgdGhpcy5za2lwU3ltYm9sKG5vZGUubmFtZS52YWx1ZSk7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRvaykge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUJsb2NrOiBleHBlY3RlZCBlbmRibG9jaywgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0b2sudmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUV4dGVuZHMgPSBmdW5jdGlvbiBwYXJzZUV4dGVuZHMoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSAnZXh0ZW5kcyc7XG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCh0YWdOYW1lKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZVRlbXBsYXRlUmVmOiBleHBlY3RlZCAnICsgdGFnTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuRXh0ZW5kcyh0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIG5vZGUudGVtcGxhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJbmNsdWRlID0gZnVuY3Rpb24gcGFyc2VJbmNsdWRlKCkge1xuICAgIHZhciB0YWdOYW1lID0gJ2luY2x1ZGUnO1xuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2wodGFnTmFtZSkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VJbmNsdWRlOiBleHBlY3RlZCAnICsgdGFnTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuSW5jbHVkZSh0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIG5vZGUudGVtcGxhdGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaWdub3JlJykgJiYgdGhpcy5za2lwU3ltYm9sKCdtaXNzaW5nJykpIHtcbiAgICAgIG5vZGUuaWdub3JlTWlzc2luZyA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0YWcudmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUlmID0gZnVuY3Rpb24gcGFyc2VJZigpIHtcbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2lmJykgfHwgdGhpcy5za2lwU3ltYm9sKCdlbGlmJykgfHwgdGhpcy5za2lwU3ltYm9sKCdlbHNlaWYnKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5JZih0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwU3ltYm9sKCdpZkFzeW5jJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSWZBc3luYyh0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlSWY6IGV4cGVjdGVkIGlmLCBlbGlmLCBvciBlbHNlaWYnLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIG5vZGUuY29uZCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0YWcudmFsdWUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZWxpZicsICdlbHNlaWYnLCAnZWxzZScsICdlbmRpZicpO1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgc3dpdGNoICh0b2sgJiYgdG9rLnZhbHVlKSB7XG4gICAgICBjYXNlICdlbHNlaWYnOlxuICAgICAgY2FzZSAnZWxpZic6XG4gICAgICAgIG5vZGUuZWxzZV8gPSB0aGlzLnBhcnNlSWYoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vsc2UnOlxuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIG5vZGUuZWxzZV8gPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGlmJyk7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuZGlmJzpcbiAgICAgICAgbm9kZS5lbHNlXyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VJZjogZXhwZWN0ZWQgZWxpZiwgZWxzZSwgb3IgZW5kaWYsIGdvdCBlbmQgb2YgZmlsZScpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVNldCA9IGZ1bmN0aW9uIHBhcnNlU2V0KCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ3NldCcpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlU2V0OiBleHBlY3RlZCBzZXQnLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLlNldCh0YWcubGluZW5vLCB0YWcuY29sbm8sIFtdKTtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgd2hpbGUgKHRhcmdldCA9IHRoaXMucGFyc2VQcmltYXJ5KCkpIHtcbiAgICAgIG5vZGUudGFyZ2V0cy5wdXNoKHRhcmdldCk7XG5cbiAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnPScpKSB7XG4gICAgICBpZiAoIXRoaXMuc2tpcChsZXhlci5UT0tFTl9CTE9DS19FTkQpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VTZXQ6IGV4cGVjdGVkID0gb3IgYmxvY2sgZW5kIGluIHNldCB0YWcnLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5ib2R5ID0gbmV3IG5vZGVzLkNhcHR1cmUodGFnLmxpbmVubywgdGFnLmNvbG5vLCB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZHNldCcpKTtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlU3dpdGNoID0gZnVuY3Rpb24gcGFyc2VTd2l0Y2goKSB7XG4gICAgLypcbiAgICAgKiBTdG9yZSB0aGUgdGFnIG5hbWVzIGluIHZhcmlhYmxlcyBpbiBjYXNlIHNvbWVvbmUgZXZlciB3YW50cyB0b1xuICAgICAqIGN1c3RvbWl6ZSB0aGlzLlxuICAgICAqL1xuICAgIHZhciBzd2l0Y2hTdGFydCA9ICdzd2l0Y2gnO1xuICAgIHZhciBzd2l0Y2hFbmQgPSAnZW5kc3dpdGNoJztcbiAgICB2YXIgY2FzZVN0YXJ0ID0gJ2Nhc2UnO1xuICAgIHZhciBjYXNlRGVmYXVsdCA9ICdkZWZhdWx0JzsgLy8gR2V0IHRoZSBzd2l0Y2ggdGFnLlxuXG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7IC8vIGZhaWwgZWFybHkgaWYgd2UgZ2V0IHNvbWUgdW5leHBlY3RlZCB0YWcuXG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbChzd2l0Y2hTdGFydCkgJiYgIXRoaXMuc2tpcFN5bWJvbChjYXNlU3RhcnQpICYmICF0aGlzLnNraXBTeW1ib2woY2FzZURlZmF1bHQpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlU3dpdGNoOiBleHBlY3RlZCBcInN3aXRjaCxcIiBcImNhc2VcIiBvciBcImRlZmF1bHRcIicsIHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgfSAvLyBwYXJzZSB0aGUgc3dpdGNoIGV4cHJlc3Npb25cblxuXG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpOyAvLyBhZHZhbmNlIHVudGlsIGEgc3RhcnQgb2YgYSBjYXNlLCBhIGRlZmF1bHQgY2FzZSBvciBhbiBlbmRzd2l0Y2guXG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHN3aXRjaFN0YXJ0KTtcbiAgICB0aGlzLnBhcnNlVW50aWxCbG9ja3MoY2FzZVN0YXJ0LCBjYXNlRGVmYXVsdCwgc3dpdGNoRW5kKTsgLy8gdGhpcyBpcyB0aGUgZmlyc3QgY2FzZS4gaXQgY291bGQgYWxzbyBiZSBhbiBlbmRzd2l0Y2gsIHdlJ2xsIGNoZWNrLlxuXG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7IC8vIGNyZWF0ZSBuZXcgdmFyaWFibGVzIGZvciBvdXIgY2FzZXMgYW5kIGRlZmF1bHQgY2FzZS5cblxuICAgIHZhciBjYXNlcyA9IFtdO1xuICAgIHZhciBkZWZhdWx0Q2FzZTsgLy8gd2hpbGUgd2UncmUgZGVhbGluZyB3aXRoIG5ldyBjYXNlcyBub2Rlcy4uLlxuXG4gICAgZG8ge1xuICAgICAgLy8gc2tpcCB0aGUgc3RhcnQgc3ltYm9sIGFuZCBnZXQgdGhlIGNhc2UgZXhwcmVzc2lvblxuICAgICAgdGhpcy5za2lwU3ltYm9sKGNhc2VTdGFydCk7XG4gICAgICB2YXIgY29uZCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHN3aXRjaFN0YXJ0KTsgLy8gZ2V0IHRoZSBib2R5IG9mIHRoZSBjYXNlIG5vZGUgYW5kIGFkZCBpdCB0byB0aGUgYXJyYXkgb2YgY2FzZXMuXG5cbiAgICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKGNhc2VTdGFydCwgY2FzZURlZmF1bHQsIHN3aXRjaEVuZCk7XG4gICAgICBjYXNlcy5wdXNoKG5ldyBub2Rlcy5DYXNlKHRvay5saW5lLCB0b2suY29sLCBjb25kLCBib2R5KSk7IC8vIGdldCBvdXIgbmV4dCBjYXNlXG5cbiAgICAgIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgfSB3aGlsZSAodG9rICYmIHRvay52YWx1ZSA9PT0gY2FzZVN0YXJ0KTsgLy8gd2UgZWl0aGVyIGhhdmUgYSBkZWZhdWx0IGNhc2Ugb3IgYSBzd2l0Y2ggZW5kLlxuXG5cbiAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgY2FzZSBjYXNlRGVmYXVsdDpcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBkZWZhdWx0Q2FzZSA9IHRoaXMucGFyc2VVbnRpbEJsb2Nrcyhzd2l0Y2hFbmQpO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHN3aXRjaEVuZDpcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGJhaWwgYmVjYXVzZSBFT0ZcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZVN3aXRjaDogZXhwZWN0ZWQgXCJjYXNlLFwiIFwiZGVmYXVsdFwiIG9yIFwiZW5kc3dpdGNoLFwiIGdvdCBFT0YuJyk7XG4gICAgfSAvLyBhbmQgcmV0dXJuIHRoZSBzd2l0Y2ggbm9kZS5cblxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Td2l0Y2godGFnLmxpbmVubywgdGFnLmNvbG5vLCBleHByLCBjYXNlcywgZGVmYXVsdENhc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKHRvay50eXBlICE9PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgIHRoaXMuZmFpbCgndGFnIG5hbWUgZXhwZWN0ZWQnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJyZWFrT25CbG9ja3MgJiYgbGliLmluZGV4T2YodGhpcy5icmVha09uQmxvY2tzLCB0b2sudmFsdWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2sudmFsdWUpIHtcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmF3KCk7XG5cbiAgICAgIGNhc2UgJ3ZlcmJhdGltJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYXcoJ3ZlcmJhdGltJyk7XG5cbiAgICAgIGNhc2UgJ2lmJzpcbiAgICAgIGNhc2UgJ2lmQXN5bmMnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlmKCk7XG5cbiAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICBjYXNlICdhc3luY0VhY2gnOlxuICAgICAgY2FzZSAnYXN5bmNBbGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcigpO1xuXG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcblxuICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXh0ZW5kcygpO1xuXG4gICAgICBjYXNlICdpbmNsdWRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbmNsdWRlKCk7XG5cbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2V0KCk7XG5cbiAgICAgIGNhc2UgJ21hY3JvJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNYWNybygpO1xuXG4gICAgICBjYXNlICdjYWxsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYWxsKCk7XG5cbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0KCk7XG5cbiAgICAgIGNhc2UgJ2Zyb20nOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZyb20oKTtcblxuICAgICAgY2FzZSAnZmlsdGVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGaWx0ZXJTdGF0ZW1lbnQoKTtcblxuICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2goKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKGxpYi5pbmRleE9mKGV4dC50YWdzIHx8IFtdLCB0b2sudmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0LnBhcnNlKHRoaXMsIG5vZGVzLCBsZXhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mYWlsKCd1bmtub3duIGJsb2NrIHRhZzogJyArIHRvay52YWx1ZSwgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VSYXcgPSBmdW5jdGlvbiBwYXJzZVJhdyh0YWdOYW1lKSB7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUgfHwgJ3Jhdyc7XG4gICAgdmFyIGVuZFRhZ05hbWUgPSAnZW5kJyArIHRhZ05hbWU7IC8vIExvb2sgZm9yIHVwY29taW5nIHJhdyBibG9ja3MgKGlnbm9yZSBhbGwgb3RoZXIga2luZHMgb2YgYmxvY2tzKVxuXG4gICAgdmFyIHJhd0Jsb2NrUmVnZXggPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8peyVcXFxccyooJyArIHRhZ05hbWUgKyAnfCcgKyBlbmRUYWdOYW1lICsgJylcXFxccyooPz0lfSklfScpO1xuICAgIHZhciByYXdMZXZlbCA9IDE7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBtYXRjaGVzID0gbnVsbDsgLy8gU2tpcCBvcGVuaW5nIHJhdyB0b2tlblxuICAgIC8vIEtlZXAgdGhpcyB0b2tlbiB0byB0cmFjayBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuXG4gICAgdmFyIGJlZ3VuID0gdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpOyAvLyBFeGl0IHdoZW4gdGhlcmUncyBub3RoaW5nIHRvIG1hdGNoXG4gICAgLy8gb3Igd2hlbiB3ZSd2ZSBmb3VuZCB0aGUgbWF0Y2hpbmcgXCJlbmRyYXdcIiBibG9ja1xuXG4gICAgd2hpbGUgKChtYXRjaGVzID0gdGhpcy50b2tlbnMuX2V4dHJhY3RSZWdleChyYXdCbG9ja1JlZ2V4KSkgJiYgcmF3TGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgYWxsID0gbWF0Y2hlc1swXTtcbiAgICAgIHZhciBwcmUgPSBtYXRjaGVzWzFdO1xuICAgICAgdmFyIGJsb2NrTmFtZSA9IG1hdGNoZXNbMl07IC8vIEFkanVzdCByYXdsZXZlbFxuXG4gICAgICBpZiAoYmxvY2tOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHJhd0xldmVsICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrTmFtZSA9PT0gZW5kVGFnTmFtZSkge1xuICAgICAgICByYXdMZXZlbCAtPSAxO1xuICAgICAgfSAvLyBBZGQgdG8gc3RyXG5cblxuICAgICAgaWYgKHJhd0xldmVsID09PSAwKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZXhjbHVkZSB0aGUgbGFzdCBcImVuZHJhd1wiXG4gICAgICAgIHN0ciArPSBwcmU7IC8vIE1vdmUgdG9rZW5pemVyIHRvIGJlZ2lubmluZyBvZiBlbmRyYXcgYmxvY2tcblxuICAgICAgICB0aGlzLnRva2Vucy5iYWNrTihhbGwubGVuZ3RoIC0gcHJlLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gYWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgbm9kZXMuT3V0cHV0KGJlZ3VuLmxpbmVubywgYmVndW4uY29sbm8sIFtuZXcgbm9kZXMuVGVtcGxhdGVEYXRhKGJlZ3VuLmxpbmVubywgYmVndW4uY29sbm8sIHN0cildKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VQb3N0Zml4ID0gZnVuY3Rpb24gcGFyc2VQb3N0Zml4KG5vZGUpIHtcbiAgICB2YXIgbG9va3VwO1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgd2hpbGUgKHRvaykge1xuICAgICAgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9MRUZUX1BBUkVOKSB7XG4gICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5GdW5DYWxsKHRvay5saW5lbm8sIHRvay5jb2xubywgbm9kZSwgdGhpcy5wYXJzZVNpZ25hdHVyZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0xFRlRfQlJBQ0tFVCkge1xuICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgbG9va3VwID0gdGhpcy5wYXJzZUFnZ3JlZ2F0ZSgpO1xuXG4gICAgICAgIGlmIChsb29rdXAuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgnaW52YWxpZCBpbmRleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Mb29rdXBWYWwodG9rLmxpbmVubywgdG9rLmNvbG5vLCBub2RlLCBsb29rdXAuY2hpbGRyZW5bMF0pO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fT1BFUkFUT1IgJiYgdG9rLnZhbHVlID09PSAnLicpIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgICAgIGlmICh2YWwudHlwZSAhPT0gbGV4ZXIuVE9LRU5fU1lNQk9MKSB7XG4gICAgICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBuYW1lIGFzIGxvb2t1cCB2YWx1ZSwgZ290ICcgKyB2YWwudmFsdWUsIHZhbC5saW5lbm8sIHZhbC5jb2xubyk7XG4gICAgICAgIH0gLy8gTWFrZSBhIGxpdGVyYWwgc3RyaW5nIGJlY2F1c2UgaXQncyBub3QgYSB2YXJpYWJsZVxuICAgICAgICAvLyByZWZlcmVuY2VcblxuXG4gICAgICAgIGxvb2t1cCA9IG5ldyBub2Rlcy5MaXRlcmFsKHZhbC5saW5lbm8sIHZhbC5jb2xubywgdmFsLnZhbHVlKTtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Mb29rdXBWYWwodG9rLmxpbmVubywgdG9rLmNvbG5vLCBub2RlLCBsb29rdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VJbmxpbmVJZigpO1xuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUlubGluZUlmID0gZnVuY3Rpb24gcGFyc2VJbmxpbmVJZigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VPcigpO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaWYnKSkge1xuICAgICAgdmFyIGNvbmROb2RlID0gdGhpcy5wYXJzZU9yKCk7XG4gICAgICB2YXIgYm9keU5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5JbmxpbmVJZihub2RlLmxpbmVubywgbm9kZS5jb2xubyk7XG4gICAgICBub2RlLmJvZHkgPSBib2R5Tm9kZTtcbiAgICAgIG5vZGUuY29uZCA9IGNvbmROb2RlO1xuXG4gICAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdlbHNlJykpIHtcbiAgICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VPcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5lbHNlXyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlT3IgPSBmdW5jdGlvbiBwYXJzZU9yKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUFuZCgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFN5bWJvbCgnb3InKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZUFuZCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Pcihub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUFuZCA9IGZ1bmN0aW9uIHBhcnNlQW5kKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZU5vdCgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFN5bWJvbCgnYW5kJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VOb3QoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQW5kKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTm90ID0gZnVuY3Rpb24gcGFyc2VOb3QoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdub3QnKSkge1xuICAgICAgcmV0dXJuIG5ldyBub2Rlcy5Ob3QodG9rLmxpbmVubywgdG9rLmNvbG5vLCB0aGlzLnBhcnNlTm90KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlSW4oKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJbiA9IGZ1bmN0aW9uIHBhcnNlSW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlSXMoKTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgdG9rZW4gaXMgJ25vdCdcbiAgICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgICBpZiAoIXRvaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGludmVydCA9IHRvay50eXBlID09PSBsZXhlci5UT0tFTl9TWU1CT0wgJiYgdG9rLnZhbHVlID09PSAnbm90JzsgLy8gaWYgaXQgd2Fzbid0ICdub3QnLCBwdXQgaXQgYmFja1xuXG4gICAgICBpZiAoIWludmVydCkge1xuICAgICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpbicpKSB7XG4gICAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VJcygpO1xuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkluKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTm90KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UnZCBmb3VuZCBhICdub3QnIGJ1dCB0aGlzIHdhc24ndCBhbiAnaW4nLCBwdXQgYmFjayB0aGUgJ25vdCdcbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSAvLyBJIHB1dCB0aGlzIHJpZ2h0IGFmdGVyIFwiaW5cIiBpbiB0aGUgb3BlcmF0b3IgcHJlY2VkZW5jZSBzdGFjay4gVGhhdCBjYW5cbiAgLy8gb2J2aW91c2x5IGJlIGNoYW5nZWQgdG8gYmUgY2xvc2VyIHRvIEppbmphLlxuICA7XG5cbiAgX3Byb3RvLnBhcnNlSXMgPSBmdW5jdGlvbiBwYXJzZUlzKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUNvbXBhcmUoKTsgLy8gbG9vayBmb3IgYW4gaXNcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2lzJykpIHtcbiAgICAgIC8vIGxvb2sgZm9yIGEgbm90XG4gICAgICB2YXIgbm90ID0gdGhpcy5za2lwU3ltYm9sKCdub3QnKTsgLy8gZ2V0IHRoZSBuZXh0IG5vZGVcblxuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZUNvbXBhcmUoKTsgLy8gY3JlYXRlIGFuIElzIG5vZGUgdXNpbmcgdGhlIG5leHQgbm9kZSBhbmQgdGhlIGluZm8gZnJvbSBvdXIgSXMgbm9kZS5cblxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Jcyhub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpOyAvLyBpZiB3ZSBoYXZlIGEgTm90LCBjcmVhdGUgYSBOb3Qgbm9kZSBmcm9tIG91ciBJcyBub2RlLlxuXG4gICAgICBpZiAobm90KSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTm90KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlKTtcbiAgICAgIH1cbiAgICB9IC8vIHJldHVybiB0aGUgbm9kZS5cblxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQ29tcGFyZSA9IGZ1bmN0aW9uIHBhcnNlQ29tcGFyZSgpIHtcbiAgICB2YXIgY29tcGFyZU9wcyA9IFsnPT0nLCAnPT09JywgJyE9JywgJyE9PScsICc8JywgJz4nLCAnPD0nLCAnPj0nXTtcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VDb25jYXQoKTtcbiAgICB2YXIgb3BzID0gW107XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgICBpZiAoIXRvaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyZU9wcy5pbmRleE9mKHRvay52YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgIG9wcy5wdXNoKG5ldyBub2Rlcy5Db21wYXJlT3BlcmFuZCh0b2subGluZW5vLCB0b2suY29sbm8sIHRoaXMucGFyc2VDb25jYXQoKSwgdG9rLnZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3BzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBub2Rlcy5Db21wYXJlKG9wc1swXS5saW5lbm8sIG9wc1swXS5jb2xubywgZXhwciwgb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICB9IC8vIGZpbmRzIHRoZSAnficgZm9yIHN0cmluZyBjb25jYXRlbmF0aW9uXG4gIDtcblxuICBfcHJvdG8ucGFyc2VDb25jYXQgPSBmdW5jdGlvbiBwYXJzZUNvbmNhdCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VBZGQoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9USUxERSwgJ34nKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZUFkZCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Db25jYXQobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBZGQgPSBmdW5jdGlvbiBwYXJzZUFkZCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VTdWIoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJysnKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZVN1YigpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5BZGQobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTdWIgPSBmdW5jdGlvbiBwYXJzZVN1YigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VNdWwoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy0nKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZU11bCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TdWIobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VNdWwgPSBmdW5jdGlvbiBwYXJzZU11bCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VEaXYoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJyonKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZURpdigpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5NdWwobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VEaXYgPSBmdW5jdGlvbiBwYXJzZURpdigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VGbG9vckRpdigpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLycpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlRmxvb3JEaXYoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRGl2KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRmxvb3JEaXYgPSBmdW5jdGlvbiBwYXJzZUZsb29yRGl2KCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZU1vZCgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLy8nKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZU1vZCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5GbG9vckRpdihub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU1vZCA9IGZ1bmN0aW9uIHBhcnNlTW9kKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZVBvdygpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnJScpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlUG93KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLk1vZChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVBvdyA9IGZ1bmN0aW9uIHBhcnNlUG93KCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZVVuYXJ5KCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcqKicpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlVW5hcnkoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuUG93KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlVW5hcnkgPSBmdW5jdGlvbiBwYXJzZVVuYXJ5KG5vRmlsdGVycykge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLScpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLk5lZyh0b2subGluZW5vLCB0b2suY29sbm8sIHRoaXMucGFyc2VVbmFyeSh0cnVlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJysnKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Qb3ModG9rLmxpbmVubywgdG9rLmNvbG5vLCB0aGlzLnBhcnNlVW5hcnkodHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vRmlsdGVycykge1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VGaWx0ZXIobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUHJpbWFyeSA9IGZ1bmN0aW9uIHBhcnNlUHJpbWFyeShub1Bvc3RmaXgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBub2RlID0gbnVsbDtcblxuICAgIGlmICghdG9rKSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIGV4cHJlc3Npb24sIGdvdCBlbmQgb2YgZmlsZScpO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1NUUklORykge1xuICAgICAgdmFsID0gdG9rLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0lOVCkge1xuICAgICAgdmFsID0gcGFyc2VJbnQodG9rLnZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fRkxPQVQpIHtcbiAgICAgIHZhbCA9IHBhcnNlRmxvYXQodG9rLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9CT09MRUFOKSB7XG4gICAgICBpZiAodG9rLnZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgdmFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHZhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mYWlsKCdpbnZhbGlkIGJvb2xlYW46ICcgKyB0b2sudmFsdWUsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTk9ORSkge1xuICAgICAgdmFsID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9SRUdFWCkge1xuICAgICAgdmFsID0gbmV3IFJlZ0V4cCh0b2sudmFsdWUuYm9keSwgdG9rLnZhbHVlLmZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTGl0ZXJhbCh0b2subGluZW5vLCB0b2suY29sbm8sIHZhbCk7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fU1lNQk9MKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlN5bWJvbCh0b2subGluZW5vLCB0b2suY29sbm8sIHRvay52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZSBpZiBpdCdzIGFuIGFnZ3JlZ2F0ZSB0eXBlLCB3ZSBuZWVkIHRvIHB1c2ggdGhlXG4gICAgICAvLyBjdXJyZW50IGRlbGltaXRlciB0b2tlbiBiYWNrIG9uXG4gICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VBZ2dyZWdhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vUG9zdGZpeCkge1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VQb3N0Zml4KG5vZGUpO1xuICAgIH1cblxuICAgIGlmIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy5lcnJvcihcInVuZXhwZWN0ZWQgdG9rZW46IFwiICsgdG9rLnZhbHVlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGaWx0ZXJOYW1lID0gZnVuY3Rpb24gcGFyc2VGaWx0ZXJOYW1lKCkge1xuICAgIHZhciB0b2sgPSB0aGlzLmV4cGVjdChsZXhlci5UT0tFTl9TWU1CT0wpO1xuICAgIHZhciBuYW1lID0gdG9rLnZhbHVlO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLicpKSB7XG4gICAgICBuYW1lICs9ICcuJyArIHRoaXMuZXhwZWN0KGxleGVyLlRPS0VOX1NZTUJPTCkudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5TeW1ib2wodG9rLmxpbmVubywgdG9rLmNvbG5vLCBuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGaWx0ZXJBcmdzID0gZnVuY3Rpb24gcGFyc2VGaWx0ZXJBcmdzKG5vZGUpIHtcbiAgICBpZiAodGhpcy5wZWVrVG9rZW4oKS50eXBlID09PSBsZXhlci5UT0tFTl9MRUZUX1BBUkVOKSB7XG4gICAgICAvLyBHZXQgYSBGdW5DYWxsIG5vZGUgYW5kIGFkZCB0aGUgcGFyYW1ldGVycyB0byB0aGVcbiAgICAgIC8vIGZpbHRlclxuICAgICAgdmFyIGNhbGwgPSB0aGlzLnBhcnNlUG9zdGZpeChub2RlKTtcbiAgICAgIHJldHVybiBjYWxsLmFyZ3MuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUZpbHRlciA9IGZ1bmN0aW9uIHBhcnNlRmlsdGVyKG5vZGUpIHtcbiAgICB3aGlsZSAodGhpcy5za2lwKGxleGVyLlRPS0VOX1BJUEUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VGaWx0ZXJOYW1lKCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkZpbHRlcihuYW1lLmxpbmVubywgbmFtZS5jb2xubywgbmFtZSwgbmV3IG5vZGVzLk5vZGVMaXN0KG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBbbm9kZV0uY29uY2F0KHRoaXMucGFyc2VGaWx0ZXJBcmdzKG5vZGUpKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUZpbHRlclN0YXRlbWVudCA9IGZ1bmN0aW9uIHBhcnNlRmlsdGVyU3RhdGVtZW50KCkge1xuICAgIHZhciBmaWx0ZXJUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2ZpbHRlcicpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRmlsdGVyU3RhdGVtZW50OiBleHBlY3RlZCBmaWx0ZXInKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VGaWx0ZXJOYW1lKCk7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlRmlsdGVyQXJncyhuYW1lKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGZpbHRlclRvay52YWx1ZSk7XG4gICAgdmFyIGJvZHkgPSBuZXcgbm9kZXMuQ2FwdHVyZShuYW1lLmxpbmVubywgbmFtZS5jb2xubywgdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRmaWx0ZXInKSk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkZpbHRlcihuYW1lLmxpbmVubywgbmFtZS5jb2xubywgbmFtZSwgbmV3IG5vZGVzLk5vZGVMaXN0KG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBbYm9keV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgcmV0dXJuIG5ldyBub2Rlcy5PdXRwdXQobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIFtub2RlXSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQWdncmVnYXRlID0gZnVuY3Rpb24gcGFyc2VBZ2dyZWdhdGUoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBzd2l0Y2ggKHRvay50eXBlKSB7XG4gICAgICBjYXNlIGxleGVyLlRPS0VOX0xFRlRfUEFSRU46XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuR3JvdXAodG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUOlxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkFycmF5KHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGxleGVyLlRPS0VOX0xFRlRfQ1VSTFk6XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRGljdCh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB2YXIgdHlwZSA9IHRoaXMucGVla1Rva2VuKCkudHlwZTtcblxuICAgICAgaWYgKHR5cGUgPT09IGxleGVyLlRPS0VOX1JJR0hUX1BBUkVOIHx8IHR5cGUgPT09IGxleGVyLlRPS0VOX1JJR0hUX0JSQUNLRVQgfHwgdHlwZSA9PT0gbGV4ZXIuVE9LRU5fUklHSFRfQ1VSTFkpIHtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUFnZ3JlZ2F0ZTogZXhwZWN0ZWQgY29tbWEgYWZ0ZXIgZXhwcmVzc2lvbicsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5EaWN0KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBlcnJvcnNcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7IC8vIFdlIGV4cGVjdCBhIGtleS92YWx1ZSBwYWlyIGZvciBkaWN0cywgc2VwYXJhdGVkIGJ5IGFcbiAgICAgICAgLy8gY29sb25cblxuICAgICAgICBpZiAoIXRoaXMuc2tpcChsZXhlci5UT0tFTl9DT0xPTikpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlQWdncmVnYXRlOiBleHBlY3RlZCBjb2xvbiBhZnRlciBkaWN0IGtleScsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIH0gLy8gVE9ETzogY2hlY2sgZm9yIGVycm9yc1xuXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgbm9kZS5hZGRDaGlsZChuZXcgbm9kZXMuUGFpcihrZXkubGluZW5vLCBrZXkuY29sbm8sIGtleSwgdmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBlcnJvcnNcbiAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBub2RlLmFkZENoaWxkKGV4cHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVNpZ25hdHVyZSA9IGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHRvbGVyYW50LCBub1BhcmVucykge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCFub1BhcmVucyAmJiB0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgaWYgKHRvbGVyYW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBhcmd1bWVudHMnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IG5ldyBub2Rlcy5Ob2RlTGlzdCh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIHZhciBrd2FyZ3MgPSBuZXcgbm9kZXMuS2V5d29yZEFyZ3ModG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB2YXIgY2hlY2tDb21tYSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgICBpZiAoIW5vUGFyZW5zICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9QQVJFTikge1xuICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAobm9QYXJlbnMgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX0VORCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ29tbWEgJiYgIXRoaXMuc2tpcChsZXhlci5UT0tFTl9DT01NQSkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZVNpZ25hdHVyZTogZXhwZWN0ZWQgY29tbWEgYWZ0ZXIgZXhwcmVzc2lvbicsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJnID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgICBpZiAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICc9JykpIHtcbiAgICAgICAgICBrd2FyZ3MuYWRkQ2hpbGQobmV3IG5vZGVzLlBhaXIoYXJnLmxpbmVubywgYXJnLmNvbG5vLCBhcmcsIHRoaXMucGFyc2VFeHByZXNzaW9uKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzLmFkZENoaWxkKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tDb21tYSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGt3YXJncy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGFyZ3MuYWRkQ2hpbGQoa3dhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VVbnRpbEJsb2NrcyA9IGZ1bmN0aW9uIHBhcnNlVW50aWxCbG9ja3MoKSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLmJyZWFrT25CbG9ja3M7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmxvY2tOYW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGJsb2NrTmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5icmVha09uQmxvY2tzID0gYmxvY2tOYW1lcztcbiAgICB2YXIgcmV0ID0gdGhpcy5wYXJzZSgpO1xuICAgIHRoaXMuYnJlYWtPbkJsb2NrcyA9IHByZXY7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VOb2RlcyA9IGZ1bmN0aW9uIHBhcnNlTm9kZXMoKSB7XG4gICAgdmFyIHRvaztcbiAgICB2YXIgYnVmID0gW107XG5cbiAgICB3aGlsZSAodG9rID0gdGhpcy5uZXh0VG9rZW4oKSkge1xuICAgICAgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9EQVRBKSB7XG4gICAgICAgIHZhciBkYXRhID0gdG9rLnZhbHVlO1xuICAgICAgICB2YXIgbmV4dFRva2VuID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICAgICAgdmFyIG5leHRWYWwgPSBuZXh0VG9rZW4gJiYgbmV4dFRva2VuLnZhbHVlOyAvLyBJZiB0aGUgbGFzdCB0b2tlbiBoYXMgXCItXCIgd2UgbmVlZCB0byB0cmltIHRoZVxuICAgICAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIGRhdGEuIFRoaXMgaXMgbWFya2VkIHdpdGhcbiAgICAgICAgLy8gdGhlIGBkcm9wTGVhZGluZ1doaXRlc3BhY2VgIHZhcmlhYmxlLlxuXG4gICAgICAgIGlmICh0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgY291bGQgYmUgb3B0aW1pemVkIChkb24ndCB1c2UgcmVnZXgpXG4gICAgICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXlxccyovLCAnJyk7XG4gICAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBTYW1lIGZvciB0aGUgc3VjY2VlZGluZyBibG9jayBzdGFydCB0b2tlblxuXG5cbiAgICAgICAgaWYgKG5leHRUb2tlbiAmJiAobmV4dFRva2VuLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX1NUQVJUICYmIG5leHRWYWwuY2hhckF0KG5leHRWYWwubGVuZ3RoIC0gMSkgPT09ICctJyB8fCBuZXh0VG9rZW4udHlwZSA9PT0gbGV4ZXIuVE9LRU5fVkFSSUFCTEVfU1RBUlQgJiYgbmV4dFZhbC5jaGFyQXQodGhpcy50b2tlbnMudGFncy5WQVJJQUJMRV9TVEFSVC5sZW5ndGgpID09PSAnLScgfHwgbmV4dFRva2VuLnR5cGUgPT09IGxleGVyLlRPS0VOX0NPTU1FTlQgJiYgbmV4dFZhbC5jaGFyQXQodGhpcy50b2tlbnMudGFncy5DT01NRU5UX1NUQVJULmxlbmd0aCkgPT09ICctJykpIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIG9wdGltaXplZCAoZG9uJ3QgdXNlIHJlZ2V4KVxuICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL1xccyokLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmLnB1c2gobmV3IG5vZGVzLk91dHB1dCh0b2subGluZW5vLCB0b2suY29sbm8sIFtuZXcgbm9kZXMuVGVtcGxhdGVEYXRhKHRvay5saW5lbm8sIHRvay5jb2xubywgZGF0YSldKSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19TVEFSVCkge1xuICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICB2YXIgbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcblxuICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Zi5wdXNoKG4pO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fVkFSSUFCTEVfU1RBUlQpIHtcbiAgICAgICAgdmFyIGUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlclZhcmlhYmxlRW5kKCk7XG4gICAgICAgIGJ1Zi5wdXNoKG5ldyBub2Rlcy5PdXRwdXQodG9rLmxpbmVubywgdG9rLmNvbG5vLCBbZV0pKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0NPTU1FTlQpIHtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSB0b2sudmFsdWUuY2hhckF0KHRvay52YWx1ZS5sZW5ndGggLSB0aGlzLnRva2Vucy50YWdzLkNPTU1FTlRfRU5ELmxlbmd0aCAtIDEpID09PSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZ25vcmUgY29tbWVudHMsIG90aGVyd2lzZSB0aGlzIHNob3VsZCBiZSBhbiBlcnJvclxuICAgICAgICB0aGlzLmZhaWwoJ1VuZXhwZWN0ZWQgdG9rZW4gYXQgdG9wLWxldmVsOiAnICsgdG9rLnR5cGUsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICByZXR1cm4gbmV3IG5vZGVzLk5vZGVMaXN0KDAsIDAsIHRoaXMucGFyc2VOb2RlcygpKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBc1Jvb3QgPSBmdW5jdGlvbiBwYXJzZUFzUm9vdCgpIHtcbiAgICByZXR1cm4gbmV3IG5vZGVzLlJvb3QoMCwgMCwgdGhpcy5wYXJzZU5vZGVzKCkpO1xuICB9O1xuXG4gIHJldHVybiBQYXJzZXI7XG59KE9iaik7IC8vIHZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuLy8gdmFyIGwgPSBsZXhlci5sZXgoJ3slLSBpZiB4IC0lfVxcbiBoZWxsbyB7JSBlbmRpZiAlfScpO1xuLy8gdmFyIHQ7XG4vLyB3aGlsZSgodCA9IGwubmV4dFRva2VuKCkpKSB7XG4vLyAgICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KHQpKTtcbi8vIH1cbi8vIHZhciBwID0gbmV3IFBhcnNlcihsZXhlci5sZXgoJ2hlbGxvIHslIGZpbHRlciB0aXRsZSAlfScgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSGVsbG8gbWFkYW0gaG93IGFyZSB5b3UnICtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3slIGVuZGZpbHRlciAlfScpKTtcbi8vIHZhciBuID0gcC5wYXJzZUFzUm9vdCgpO1xuLy8gbm9kZXMucHJpbnROb2RlcyhuKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHNyYywgZXh0ZW5zaW9ucywgb3B0cykge1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihsZXhlci5sZXgoc3JjLCBvcHRzKSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIHJldHVybiBwLnBhcnNlQXNSb290KCk7XG4gIH0sXG4gIFBhcnNlcjogUGFyc2VyXG59O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciB3aGl0ZXNwYWNlQ2hhcnMgPSBcIiBcXG5cXHRcXHJcXHhBMFwiO1xudmFyIGRlbGltQ2hhcnMgPSAnKClbXXt9JSotK34vIyw6fC48Pj0hJztcbnZhciBpbnRDaGFycyA9ICcwMTIzNDU2Nzg5JztcbnZhciBCTE9DS19TVEFSVCA9ICd7JSc7XG52YXIgQkxPQ0tfRU5EID0gJyV9JztcbnZhciBWQVJJQUJMRV9TVEFSVCA9ICd7eyc7XG52YXIgVkFSSUFCTEVfRU5EID0gJ319JztcbnZhciBDT01NRU5UX1NUQVJUID0gJ3sjJztcbnZhciBDT01NRU5UX0VORCA9ICcjfSc7XG52YXIgVE9LRU5fU1RSSU5HID0gJ3N0cmluZyc7XG52YXIgVE9LRU5fV0hJVEVTUEFDRSA9ICd3aGl0ZXNwYWNlJztcbnZhciBUT0tFTl9EQVRBID0gJ2RhdGEnO1xudmFyIFRPS0VOX0JMT0NLX1NUQVJUID0gJ2Jsb2NrLXN0YXJ0JztcbnZhciBUT0tFTl9CTE9DS19FTkQgPSAnYmxvY2stZW5kJztcbnZhciBUT0tFTl9WQVJJQUJMRV9TVEFSVCA9ICd2YXJpYWJsZS1zdGFydCc7XG52YXIgVE9LRU5fVkFSSUFCTEVfRU5EID0gJ3ZhcmlhYmxlLWVuZCc7XG52YXIgVE9LRU5fQ09NTUVOVCA9ICdjb21tZW50JztcbnZhciBUT0tFTl9MRUZUX1BBUkVOID0gJ2xlZnQtcGFyZW4nO1xudmFyIFRPS0VOX1JJR0hUX1BBUkVOID0gJ3JpZ2h0LXBhcmVuJztcbnZhciBUT0tFTl9MRUZUX0JSQUNLRVQgPSAnbGVmdC1icmFja2V0JztcbnZhciBUT0tFTl9SSUdIVF9CUkFDS0VUID0gJ3JpZ2h0LWJyYWNrZXQnO1xudmFyIFRPS0VOX0xFRlRfQ1VSTFkgPSAnbGVmdC1jdXJseSc7XG52YXIgVE9LRU5fUklHSFRfQ1VSTFkgPSAncmlnaHQtY3VybHknO1xudmFyIFRPS0VOX09QRVJBVE9SID0gJ29wZXJhdG9yJztcbnZhciBUT0tFTl9DT01NQSA9ICdjb21tYSc7XG52YXIgVE9LRU5fQ09MT04gPSAnY29sb24nO1xudmFyIFRPS0VOX1RJTERFID0gJ3RpbGRlJztcbnZhciBUT0tFTl9QSVBFID0gJ3BpcGUnO1xudmFyIFRPS0VOX0lOVCA9ICdpbnQnO1xudmFyIFRPS0VOX0ZMT0FUID0gJ2Zsb2F0JztcbnZhciBUT0tFTl9CT09MRUFOID0gJ2Jvb2xlYW4nO1xudmFyIFRPS0VOX05PTkUgPSAnbm9uZSc7XG52YXIgVE9LRU5fU1lNQk9MID0gJ3N5bWJvbCc7XG52YXIgVE9LRU5fU1BFQ0lBTCA9ICdzcGVjaWFsJztcbnZhciBUT0tFTl9SRUdFWCA9ICdyZWdleCc7XG5cbmZ1bmN0aW9uIHRva2VuKHR5cGUsIHZhbHVlLCBsaW5lbm8sIGNvbG5vKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgbGluZW5vOiBsaW5lbm8sXG4gICAgY29sbm86IGNvbG5vXG4gIH07XG59XG5cbnZhciBUb2tlbml6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb2tlbml6ZXIoc3RyLCBvcHRzKSB7XG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5sZW4gPSBzdHIubGVuZ3RoO1xuICAgIHRoaXMubGluZW5vID0gMDtcbiAgICB0aGlzLmNvbG5vID0gMDtcbiAgICB0aGlzLmluX2NvZGUgPSBmYWxzZTtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgdGFncyA9IG9wdHMudGFncyB8fCB7fTtcbiAgICB0aGlzLnRhZ3MgPSB7XG4gICAgICBCTE9DS19TVEFSVDogdGFncy5ibG9ja1N0YXJ0IHx8IEJMT0NLX1NUQVJULFxuICAgICAgQkxPQ0tfRU5EOiB0YWdzLmJsb2NrRW5kIHx8IEJMT0NLX0VORCxcbiAgICAgIFZBUklBQkxFX1NUQVJUOiB0YWdzLnZhcmlhYmxlU3RhcnQgfHwgVkFSSUFCTEVfU1RBUlQsXG4gICAgICBWQVJJQUJMRV9FTkQ6IHRhZ3MudmFyaWFibGVFbmQgfHwgVkFSSUFCTEVfRU5ELFxuICAgICAgQ09NTUVOVF9TVEFSVDogdGFncy5jb21tZW50U3RhcnQgfHwgQ09NTUVOVF9TVEFSVCxcbiAgICAgIENPTU1FTlRfRU5EOiB0YWdzLmNvbW1lbnRFbmQgfHwgQ09NTUVOVF9FTkRcbiAgICB9O1xuICAgIHRoaXMudHJpbUJsb2NrcyA9ICEhb3B0cy50cmltQmxvY2tzO1xuICAgIHRoaXMubHN0cmlwQmxvY2tzID0gISFvcHRzLmxzdHJpcEJsb2NrcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5uZXh0VG9rZW4gPSBmdW5jdGlvbiBuZXh0VG9rZW4oKSB7XG4gICAgdmFyIGxpbmVubyA9IHRoaXMubGluZW5vO1xuICAgIHZhciBjb2xubyA9IHRoaXMuY29sbm87XG4gICAgdmFyIHRvaztcblxuICAgIGlmICh0aGlzLmluX2NvZGUpIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgaWYgd2UgYXJlIGluIGEgYmxvY2sgcGFyc2UgaXQgYXMgY29kZVxuICAgICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBub3RoaW5nIGVsc2UgdG8gcGFyc2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1wiJyB8fCBjdXIgPT09ICdcXCcnKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGhpdCBhIHN0cmluZ1xuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fU1RSSU5HLCB0aGlzLl9wYXJzZVN0cmluZyhjdXIpLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rID0gdGhpcy5fZXh0cmFjdCh3aGl0ZXNwYWNlQ2hhcnMpKSB7XG4gICAgICAgIC8vIFdlIGhpdCBzb21lIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1dISVRFU1BBQ0UsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19FTkQpKSB8fCAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZygnLScgKyB0aGlzLnRhZ3MuQkxPQ0tfRU5EKSkpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjaGVjayBmb3IgdGhlIGJsb2NrIGVuZCB0YWdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQgaXMgYSByZXF1aXJlbWVudCB0aGF0IHN0YXJ0IGFuZCBlbmQgdGFncyBhcmUgY29tcG9zZWQgb2ZcbiAgICAgICAgLy8gZGVsaW1pdGVyIGNoYXJhY3RlcnMgKCV7fVtdIGV0YyksIGFuZCBvdXIgY29kZSBhbHdheXNcbiAgICAgICAgLy8gYnJlYWtzIG9uIGRlbGltaXRlcnMgc28gd2UgY2FuIGFzc3VtZSB0aGUgdG9rZW4gcGFyc2luZ1xuICAgICAgICAvLyBkb2Vzbid0IGNvbnN1bWUgdGhlc2UgZWxzZXdoZXJlXG4gICAgICAgIHRoaXMuaW5fY29kZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaW1CbG9ja3MpIHtcbiAgICAgICAgICBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcblxuICAgICAgICAgIGlmIChjdXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG5ld2xpbmVcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnXFxyJykge1xuICAgICAgICAgICAgLy8gU2tpcCBDUkxGIG5ld2xpbmVcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgY3VyID0gdGhpcy5jdXJyZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjdXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2FzIG5vdCBhIENSTEYsIHNvIGdvIGJhY2tcbiAgICAgICAgICAgICAgdGhpcy5iYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0JMT0NLX0VORCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLlZBUklBQkxFX0VORCkpIHx8ICh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKCctJyArIHRoaXMudGFncy5WQVJJQUJMRV9FTkQpKSkge1xuICAgICAgICAvLyBTcGVjaWFsIGNoZWNrIGZvciB2YXJpYWJsZSBlbmQgdGFnIChzZWUgYWJvdmUpXG4gICAgICAgIHRoaXMuaW5fY29kZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fVkFSSUFCTEVfRU5ELCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdyJyAmJiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pbmRleCArIDEpID09PSAnLycpIHtcbiAgICAgICAgLy8gU2tpcCBwYXN0ICdyLycuXG4gICAgICAgIHRoaXMuZm9yd2FyZE4oMik7IC8vIEV4dHJhY3QgdW50aWwgdGhlIGVuZCBvZiB0aGUgcmVnZXggLS0gLyBlbmRzIGl0LCBcXC8gZG9lcyBub3QuXG5cbiAgICAgICAgdmFyIHJlZ2V4Qm9keSA9ICcnO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50KCkgPT09ICcvJyAmJiB0aGlzLnByZXZpb3VzKCkgIT09ICdcXFxcJykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVnZXhCb2R5ICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENoZWNrIGZvciBmbGFncy5cbiAgICAgICAgLy8gVGhlIHBvc3NpYmxlIGZsYWdzIGFyZSBhY2NvcmRpbmcgdG8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwKVxuXG5cbiAgICAgICAgdmFyIFBPU1NJQkxFX0ZMQUdTID0gWydnJywgJ2knLCAnbScsICd5J107XG4gICAgICAgIHZhciByZWdleEZsYWdzID0gJyc7XG5cbiAgICAgICAgd2hpbGUgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICAgIHZhciBpc0N1cnJlbnRBRmxhZyA9IFBPU1NJQkxFX0ZMQUdTLmluZGV4T2YodGhpcy5jdXJyZW50KCkpICE9PSAtMTtcblxuICAgICAgICAgIGlmIChpc0N1cnJlbnRBRmxhZykge1xuICAgICAgICAgICAgcmVnZXhGbGFncyArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fUkVHRVgsIHtcbiAgICAgICAgICBib2R5OiByZWdleEJvZHksXG4gICAgICAgICAgZmxhZ3M6IHJlZ2V4RmxhZ3NcbiAgICAgICAgfSwgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbGltQ2hhcnMuaW5kZXhPZihjdXIpICE9PSAtMSkge1xuICAgICAgICAvLyBXZSd2ZSBoaXQgYSBkZWxpbWl0ZXIgKGEgc3BlY2lhbCBjaGFyIGxpa2UgYSBicmFja2V0KVxuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgdmFyIGNvbXBsZXhPcHMgPSBbJz09JywgJz09PScsICchPScsICchPT0nLCAnPD0nLCAnPj0nLCAnLy8nLCAnKionXTtcbiAgICAgICAgdmFyIGN1ckNvbXBsZXggPSBjdXIgKyB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgdmFyIHR5cGU7XG5cbiAgICAgICAgaWYgKGxpYi5pbmRleE9mKGNvbXBsZXhPcHMsIGN1ckNvbXBsZXgpICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIGN1ciA9IGN1ckNvbXBsZXg7IC8vIFNlZSBpZiB0aGlzIGlzIGEgc3RyaWN0IGVxdWFsaXR5L2luZXF1YWxpdHkgY29tcGFyYXRvclxuXG4gICAgICAgICAgaWYgKGxpYi5pbmRleE9mKGNvbXBsZXhPcHMsIGN1ckNvbXBsZXggKyB0aGlzLmN1cnJlbnQoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXJDb21wbGV4ICsgdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGN1cikge1xuICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0xFRlRfUEFSRU47XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1JJR0hUX1BBUkVOO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9MRUZUX0JSQUNLRVQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1JJR0hUX0JSQUNLRVQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0xFRlRfQ1VSTFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1JJR0hUX0NVUkxZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9DT01NQTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fQ09MT047XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1RJTERFO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9QSVBFO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX09QRVJBVE9SO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKHR5cGUsIGN1ciwgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBhcmUgbm90IGF0IHdoaXRlc3BhY2Ugb3IgYSBkZWxpbWl0ZXIsIHNvIGV4dHJhY3QgdGhlXG4gICAgICAgIC8vIHRleHQgYW5kIHBhcnNlIGl0XG4gICAgICAgIHRvayA9IHRoaXMuX2V4dHJhY3RVbnRpbCh3aGl0ZXNwYWNlQ2hhcnMgKyBkZWxpbUNoYXJzKTtcblxuICAgICAgICBpZiAodG9rLm1hdGNoKC9eWy0rXT9bMC05XSskLykpIHtcbiAgICAgICAgICBpZiAodGhpcy5jdXJyZW50KCkgPT09ICcuJykge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG5cbiAgICAgICAgICAgIHZhciBkZWMgPSB0aGlzLl9leHRyYWN0KGludENoYXJzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0ZMT0FULCB0b2sgKyAnLicgKyBkZWMsIGxpbmVubywgY29sbm8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fSU5ULCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2subWF0Y2goL14odHJ1ZXxmYWxzZSkkLykpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fQk9PTEVBTiwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2sgPT09ICdub25lJykge1xuICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9OT05FLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogQWRkZWQgdG8gbWFrZSB0aGUgdGVzdCBgbnVsbCBpcyBudWxsYCBldmFsdWF0ZSB0cnV0aGlseS5cbiAgICAgICAgICAgKiBPdGhlcndpc2UsIE51bmp1Y2tzIHdpbGwgbG9vayB1cCBudWxsIGluIHRoZSBjb250ZXh0IGFuZFxuICAgICAgICAgICAqIHJldHVybiBgdW5kZWZpbmVkYCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC4gVGhpcyAqbWF5KiBoYXZlXG4gICAgICAgICAgICogY29uc2VxdWVuY2VzIGlzIHNvbWVvbmUgaXMgdXNpbmcgbnVsbCBpbiB0aGVpciB0ZW1wbGF0ZXMgYXMgYVxuICAgICAgICAgICAqIHZhcmlhYmxlLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IGVsc2UgaWYgKHRvayA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX05PTkUsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1NZTUJPTCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWUgd2hpbGUgcGFyc2luZzogJyArIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGFyc2Ugb3V0IHRoZSB0ZW1wbGF0ZSB0ZXh0LCBicmVha2luZyBvbiB0YWdcbiAgICAgIC8vIGRlbGltaXRlcnMgYmVjYXVzZSB3ZSBuZWVkIHRvIGxvb2sgZm9yIGJsb2NrL3ZhcmlhYmxlIHN0YXJ0XG4gICAgICAvLyB0YWdzIChkb24ndCB1c2UgdGhlIGZ1bGwgZGVsaW1DaGFycyBmb3Igb3B0aW1pemF0aW9uKVxuICAgICAgdmFyIGJlZ2luQ2hhcnMgPSB0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQuY2hhckF0KDApICsgdGhpcy50YWdzLlZBUklBQkxFX1NUQVJULmNoYXJBdCgwKSArIHRoaXMudGFncy5DT01NRU5UX1NUQVJULmNoYXJBdCgwKSArIHRoaXMudGFncy5DT01NRU5UX0VORC5jaGFyQXQoMCk7XG5cbiAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLkJMT0NLX1NUQVJUICsgJy0nKSkgfHwgKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLkJMT0NLX1NUQVJUKSkpIHtcbiAgICAgICAgdGhpcy5pbl9jb2RlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0JMT0NLX1NUQVJULCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmICgodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuVkFSSUFCTEVfU1RBUlQgKyAnLScpKSB8fCAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuVkFSSUFCTEVfU1RBUlQpKSkge1xuICAgICAgICB0aGlzLmluX2NvZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fVkFSSUFCTEVfU1RBUlQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2sgPSAnJztcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIHZhciBpbkNvbW1lbnQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuQ09NTUVOVF9TVEFSVCkpIHtcbiAgICAgICAgICBpbkNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgIHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLkNPTU1FTlRfU1RBUlQpO1xuICAgICAgICB9IC8vIENvbnRpbnVhbGx5IGNvbnN1bWUgdGV4dCwgYnJlYWtpbmcgb24gdGhlIHRhZyBkZWxpbWl0ZXJcbiAgICAgICAgLy8gY2hhcmFjdGVycyBhbmQgY2hlY2tpbmcgdG8gc2VlIGlmIGl0J3MgYSBzdGFydCB0YWcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGNvdWxkIGhpdCB0aGUgZW5kIG9mIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICAgIC8vIG91ciBsb29waW5nLCBzbyBjaGVjayBmb3IgdGhlIG51bGwgcmV0dXJuIHZhbHVlIGZyb21cbiAgICAgICAgLy8gX2V4dHJhY3RVbnRpbFxuXG5cbiAgICAgICAgd2hpbGUgKChkYXRhID0gdGhpcy5fZXh0cmFjdFVudGlsKGJlZ2luQ2hhcnMpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRvayArPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKCh0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5CTE9DS19TVEFSVCkgfHwgdGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuVkFSSUFCTEVfU1RBUlQpIHx8IHRoaXMuX21hdGNoZXModGhpcy50YWdzLkNPTU1FTlRfU1RBUlQpKSAmJiAhaW5Db21tZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sc3RyaXBCbG9ja3MgJiYgdGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQpICYmIHRoaXMuY29sbm8gPiAwICYmIHRoaXMuY29sbm8gPD0gdG9rLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgbGFzdExpbmUgPSB0b2suc2xpY2UoLXRoaXMuY29sbm8pO1xuXG4gICAgICAgICAgICAgIGlmICgvXlxccyskLy50ZXN0KGxhc3RMaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBibG9jayBsZWFkaW5nIHdoaXRlc3BhY2UgZnJvbSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHRvayA9IHRvay5zbGljZSgwLCAtdGhpcy5jb2xubyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRvay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFsbCBkYXRhIHJlbW92ZWQsIGNvbGxhcHNlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IG5vZGVzXG4gICAgICAgICAgICAgICAgICAvLyBieSByZXR1cm5pbmcgbmV4dCB0b2tlbiAoYmxvY2sgc3RhcnQpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gSWYgaXQgaXMgYSBzdGFydCB0YWcsIHN0b3AgbG9vcGluZ1xuXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuQ09NTUVOVF9FTkQpKSB7XG4gICAgICAgICAgICBpZiAoIWluQ29tbWVudCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGNvbW1lbnQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9rICs9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFnLCBzbyBhZGQgdGhlIGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgIC8vIGNhcnJ5IG9uXG4gICAgICAgICAgICB0b2sgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCAmJiBpbkNvbW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGVuZCBvZiBjb21tZW50LCBnb3QgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbihpbkNvbW1lbnQgPyBUT0tFTl9DT01NRU5UIDogVE9LRU5fREFUQSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZVN0cmluZyhkZWxpbWl0ZXIpIHtcbiAgICB0aGlzLmZvcndhcmQoKTtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICB3aGlsZSAoIXRoaXMuaXNGaW5pc2hlZCgpICYmIHRoaXMuY3VycmVudCgpICE9PSBkZWxpbWl0ZXIpIHtcbiAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcblxuICAgICAgaWYgKGN1ciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50KCkpIHtcbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gY3VyO1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcndhcmQoKTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIF9wcm90by5fbWF0Y2hlcyA9IGZ1bmN0aW9uIF9tYXRjaGVzKHN0cikge1xuICAgIGlmICh0aGlzLmluZGV4ICsgc3RyLmxlbmd0aCA+IHRoaXMubGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHRoaXMuc3RyLnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBzdHIubGVuZ3RoKTtcbiAgICByZXR1cm4gbSA9PT0gc3RyO1xuICB9O1xuXG4gIF9wcm90by5fZXh0cmFjdFN0cmluZyA9IGZ1bmN0aW9uIF9leHRyYWN0U3RyaW5nKHN0cikge1xuICAgIGlmICh0aGlzLl9tYXRjaGVzKHN0cikpIHtcbiAgICAgIHRoaXMuZm9yd2FyZE4oc3RyLmxlbmd0aCk7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fZXh0cmFjdFVudGlsID0gZnVuY3Rpb24gX2V4dHJhY3RVbnRpbChjaGFyU3RyaW5nKSB7XG4gICAgLy8gRXh0cmFjdCBhbGwgbm9uLW1hdGNoaW5nIGNoYXJzLCB3aXRoIHRoZSBkZWZhdWx0IG1hdGNoaW5nIHNldFxuICAgIC8vIHRvIGV2ZXJ5dGhpbmdcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdE1hdGNoaW5nKHRydWUsIGNoYXJTdHJpbmcgfHwgJycpO1xuICB9O1xuXG4gIF9wcm90by5fZXh0cmFjdCA9IGZ1bmN0aW9uIF9leHRyYWN0KGNoYXJTdHJpbmcpIHtcbiAgICAvLyBFeHRyYWN0IGFsbCBtYXRjaGluZyBjaGFycyAobm8gZGVmYXVsdCwgc28gY2hhclN0cmluZyBtdXN0IGJlXG4gICAgLy8gZXhwbGljaXQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dHJhY3RNYXRjaGluZyhmYWxzZSwgY2hhclN0cmluZyk7XG4gIH07XG5cbiAgX3Byb3RvLl9leHRyYWN0TWF0Y2hpbmcgPSBmdW5jdGlvbiBfZXh0cmFjdE1hdGNoaW5nKGJyZWFrT25NYXRjaCwgY2hhclN0cmluZykge1xuICAgIC8vIFB1bGwgb3V0IGNoYXJhY3RlcnMgdW50aWwgYSBicmVha2luZyBjaGFyIGlzIGhpdC5cbiAgICAvLyBJZiBicmVha09uTWF0Y2ggaXMgZmFsc2UsIGEgbm9uLW1hdGNoaW5nIGNoYXIgc3RvcHMgaXQuXG4gICAgLy8gSWYgYnJlYWtPbk1hdGNoIGlzIHRydWUsIGEgbWF0Y2hpbmcgY2hhciBzdG9wcyBpdC5cbiAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmaXJzdCA9IGNoYXJTdHJpbmcuaW5kZXhPZih0aGlzLmN1cnJlbnQoKSk7IC8vIE9ubHkgcHJvY2VlZCBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGRvZXNuJ3QgbWVldCBvdXIgY29uZGl0aW9uXG5cbiAgICBpZiAoYnJlYWtPbk1hdGNoICYmIGZpcnN0ID09PSAtMSB8fCAhYnJlYWtPbk1hdGNoICYmIGZpcnN0ICE9PSAtMSkge1xuICAgICAgdmFyIHQgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpOyAvLyBBbmQgcHVsbCBvdXQgYWxsIHRoZSBjaGFycyBvbmUgYXQgYSB0aW1lIHVudGlsIHdlIGhpdCBhXG4gICAgICAvLyBicmVha2luZyBjaGFyXG5cbiAgICAgIHZhciBpZHggPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpO1xuXG4gICAgICB3aGlsZSAoKGJyZWFrT25NYXRjaCAmJiBpZHggPT09IC0xIHx8ICFicmVha09uTWF0Y2ggJiYgaWR4ICE9PSAtMSkgJiYgIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgIHQgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBpZHggPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgX3Byb3RvLl9leHRyYWN0UmVnZXggPSBmdW5jdGlvbiBfZXh0cmFjdFJlZ2V4KHJlZ2V4KSB7XG4gICAgdmFyIG1hdGNoZXMgPSB0aGlzLmN1cnJlbnRTdHIoKS5tYXRjaChyZWdleCk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gTW92ZSBmb3J3YXJkIHdoYXRldmVyIHdhcyBtYXRjaGVkXG5cblxuICAgIHRoaXMuZm9yd2FyZE4obWF0Y2hlc1swXS5sZW5ndGgpO1xuICAgIHJldHVybiBtYXRjaGVzO1xuICB9O1xuXG4gIF9wcm90by5pc0ZpbmlzaGVkID0gZnVuY3Rpb24gaXNGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbjtcbiAgfTtcblxuICBfcHJvdG8uZm9yd2FyZE4gPSBmdW5jdGlvbiBmb3J3YXJkTihuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgdGhpcy5pbmRleCsrO1xuXG4gICAgaWYgKHRoaXMucHJldmlvdXMoKSA9PT0gJ1xcbicpIHtcbiAgICAgIHRoaXMubGluZW5vKys7XG4gICAgICB0aGlzLmNvbG5vID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xubysrO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYmFja04gPSBmdW5jdGlvbiBiYWNrTihuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHRoaXMuYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYmFjayA9IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgdGhpcy5pbmRleC0tO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudCgpID09PSAnXFxuJykge1xuICAgICAgdGhpcy5saW5lbm8tLTtcbiAgICAgIHZhciBpZHggPSB0aGlzLnNyYy5sYXN0SW5kZXhPZignXFxuJywgdGhpcy5pbmRleCAtIDEpO1xuXG4gICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICB0aGlzLmNvbG5vID0gdGhpcy5pbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sbm8gPSB0aGlzLmluZGV4IC0gaWR4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG5vLS07XG4gICAgfVxuICB9IC8vIGN1cnJlbnQgcmV0dXJucyBjdXJyZW50IGNoYXJhY3RlclxuICA7XG5cbiAgX3Byb3RvLmN1cnJlbnQgPSBmdW5jdGlvbiBjdXJyZW50KCkge1xuICAgIGlmICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9IC8vIGN1cnJlbnRTdHIgcmV0dXJucyB3aGF0J3MgbGVmdCBvZiB0aGUgdW5wYXJzZWQgc3RyaW5nXG4gIDtcblxuICBfcHJvdG8uY3VycmVudFN0ciA9IGZ1bmN0aW9uIGN1cnJlbnRTdHIoKSB7XG4gICAgaWYgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyLnN1YnN0cih0aGlzLmluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgX3Byb3RvLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLmNoYXJBdCh0aGlzLmluZGV4IC0gMSk7XG4gIH07XG5cbiAgcmV0dXJuIFRva2VuaXplcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxleDogZnVuY3Rpb24gbGV4KHNyYywgb3B0cykge1xuICAgIHJldHVybiBuZXcgVG9rZW5pemVyKHNyYywgb3B0cyk7XG4gIH0sXG4gIFRPS0VOX1NUUklORzogVE9LRU5fU1RSSU5HLFxuICBUT0tFTl9XSElURVNQQUNFOiBUT0tFTl9XSElURVNQQUNFLFxuICBUT0tFTl9EQVRBOiBUT0tFTl9EQVRBLFxuICBUT0tFTl9CTE9DS19TVEFSVDogVE9LRU5fQkxPQ0tfU1RBUlQsXG4gIFRPS0VOX0JMT0NLX0VORDogVE9LRU5fQkxPQ0tfRU5ELFxuICBUT0tFTl9WQVJJQUJMRV9TVEFSVDogVE9LRU5fVkFSSUFCTEVfU1RBUlQsXG4gIFRPS0VOX1ZBUklBQkxFX0VORDogVE9LRU5fVkFSSUFCTEVfRU5ELFxuICBUT0tFTl9DT01NRU5UOiBUT0tFTl9DT01NRU5ULFxuICBUT0tFTl9MRUZUX1BBUkVOOiBUT0tFTl9MRUZUX1BBUkVOLFxuICBUT0tFTl9SSUdIVF9QQVJFTjogVE9LRU5fUklHSFRfUEFSRU4sXG4gIFRPS0VOX0xFRlRfQlJBQ0tFVDogVE9LRU5fTEVGVF9CUkFDS0VULFxuICBUT0tFTl9SSUdIVF9CUkFDS0VUOiBUT0tFTl9SSUdIVF9CUkFDS0VULFxuICBUT0tFTl9MRUZUX0NVUkxZOiBUT0tFTl9MRUZUX0NVUkxZLFxuICBUT0tFTl9SSUdIVF9DVVJMWTogVE9LRU5fUklHSFRfQ1VSTFksXG4gIFRPS0VOX09QRVJBVE9SOiBUT0tFTl9PUEVSQVRPUixcbiAgVE9LRU5fQ09NTUE6IFRPS0VOX0NPTU1BLFxuICBUT0tFTl9DT0xPTjogVE9LRU5fQ09MT04sXG4gIFRPS0VOX1RJTERFOiBUT0tFTl9USUxERSxcbiAgVE9LRU5fUElQRTogVE9LRU5fUElQRSxcbiAgVE9LRU5fSU5UOiBUT0tFTl9JTlQsXG4gIFRPS0VOX0ZMT0FUOiBUT0tFTl9GTE9BVCxcbiAgVE9LRU5fQk9PTEVBTjogVE9LRU5fQk9PTEVBTixcbiAgVE9LRU5fTk9ORTogVE9LRU5fTk9ORSxcbiAgVE9LRU5fU1lNQk9MOiBUT0tFTl9TWU1CT0wsXG4gIFRPS0VOX1NQRUNJQUw6IFRPS0VOX1NQRUNJQUwsXG4gIFRPS0VOX1JFR0VYOiBUT0tFTl9SRUdFWFxufTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIExvYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpLFxuICAgIFByZWNvbXBpbGVkTG9hZGVyID0gX3JlcXVpcmUuUHJlY29tcGlsZWRMb2FkZXI7XG5cbnZhciBXZWJMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Mb2FkZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoV2ViTG9hZGVyLCBfTG9hZGVyKTtcblxuICBmdW5jdGlvbiBXZWJMb2FkZXIoYmFzZVVSTCwgb3B0cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0xvYWRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuYmFzZVVSTCA9IGJhc2VVUkwgfHwgJy4nO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBCeSBkZWZhdWx0LCB0aGUgY2FjaGUgaXMgdHVybmVkIG9mZiBiZWNhdXNlIHRoZXJlJ3Mgbm8gd2F5XG4gICAgLy8gdG8gXCJ3YXRjaFwiIHRlbXBsYXRlcyBvdmVyIEhUVFAsIHNvIHRoZXkgYXJlIHJlLWRvd25sb2FkZWRcbiAgICAvLyBhbmQgY29tcGlsZWQgZWFjaCB0aW1lLiAoUmVtZW1iZXIsIFBSRUNPTVBJTEUgWU9VUlxuICAgIC8vIFRFTVBMQVRFUyBpbiBwcm9kdWN0aW9uISlcblxuICAgIF90aGlzLnVzZUNhY2hlID0gISFvcHRzLnVzZUNhY2hlOyAvLyBXZSBkZWZhdWx0IGBhc3luY2AgdG8gZmFsc2Ugc28gdGhhdCB0aGUgc2ltcGxlIHN5bmNocm9ub3VzXG4gICAgLy8gQVBJIGNhbiBiZSB1c2VkIHdoZW4geW91IGFyZW4ndCBkb2luZyBhbnl0aGluZyBhc3luYyBpblxuICAgIC8vIHlvdXIgdGVtcGxhdGVzICh3aGljaCBpcyBtb3N0IG9mIHRoZSB0aW1lKS4gVGhpcyBwZXJmb3JtcyBhXG4gICAgLy8gc3luYyBhamF4IHJlcXVlc3QsIGJ1dCB0aGF0J3Mgb2sgYmVjYXVzZSBpdCBzaG91bGQgKm9ubHkqXG4gICAgLy8gaGFwcGVuIGluIGRldmVsb3BtZW50LiBQUkVDT01QSUxFIFlPVVIgVEVNUExBVEVTLlxuXG4gICAgX3RoaXMuYXN5bmMgPSAhIW9wdHMuYXN5bmM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFdlYkxvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSB0ZW1wbGF0ZXMgbm90IHN1cHBvcnQgaW4gdGhlIGJyb3dzZXIgeWV0Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNvdXJjZSA9IGZ1bmN0aW9uIGdldFNvdXJjZShuYW1lLCBjYikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIHVzZUNhY2hlID0gdGhpcy51c2VDYWNoZTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHRoaXMuZmV0Y2godGhpcy5iYXNlVVJMICsgJy8nICsgbmFtZSwgZnVuY3Rpb24gKGVyciwgc3JjKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVyci5jb250ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVyci5jb250ZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgICBub0NhY2hlOiAhdXNlQ2FjaGVcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczIuZW1pdCgnbG9hZCcsIG5hbWUsIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyBpZiB0aGlzIFdlYkxvYWRlciBpc24ndCBydW5uaW5nIGFzeW5jaHJvbm91c2x5LCB0aGVcbiAgICAvLyBmZXRjaCBhYm92ZSB3b3VsZCBhY3R1YWxseSBydW4gc3luYyBhbmQgd2UnbGwgaGF2ZSBhXG4gICAgLy8gcmVzdWx0IGhlcmVcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmZldGNoID0gZnVuY3Rpb24gZmV0Y2godXJsLCBjYikge1xuICAgIC8vIE9ubHkgaW4gdGhlIGJyb3dzZXIgcGxlYXNlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkxvYWRlciBjYW4gb25seSBieSB1c2VkIGluIGEgYnJvd3NlcicpO1xuICAgIH1cblxuICAgIHZhciBhamF4ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRpbmcgPSB0cnVlO1xuXG4gICAgYWpheC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYWpheC5yZWFkeVN0YXRlID09PSA0ICYmIGxvYWRpbmcpIHtcbiAgICAgICAgbG9hZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChhamF4LnN0YXR1cyA9PT0gMCB8fCBhamF4LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgY2IobnVsbCwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgIHN0YXR1czogYWpheC5zdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50OiBhamF4LnJlc3BvbnNlVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgJ3M9JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGFqYXgub3BlbignR0VUJywgdXJsLCB0aGlzLmFzeW5jKTtcbiAgICBhamF4LnNlbmQoKTtcbiAgfTtcblxuICByZXR1cm4gV2ViTG9hZGVyO1xufShMb2FkZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViTG9hZGVyOiBXZWJMb2FkZXIsXG4gIFByZWNvbXBpbGVkTG9hZGVyOiBQcmVjb21waWxlZExvYWRlclxufTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxcbiAgICBFbnZpcm9ubWVudCA9IF9yZXF1aXJlLkVudmlyb25tZW50LFxuICAgIFRlbXBsYXRlID0gX3JlcXVpcmUuVGVtcGxhdGU7XG5cbnZhciBMb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgbG9hZGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgcHJlY29tcGlsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG52YXIgY29tcGlsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIGxleGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIHJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgbm9kZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgaW5zdGFsbEppbmphQ29tcGF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7IC8vIEEgc2luZ2xlIGluc3RhbmNlIG9mIGFuIGVudmlyb25tZW50LCBzaW5jZSB0aGlzIGlzIHNvIGNvbW1vbmx5IHVzZWRcblxuXG52YXIgZTtcblxuZnVuY3Rpb24gY29uZmlndXJlKHRlbXBsYXRlc1BhdGgsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKGxpYi5pc09iamVjdCh0ZW1wbGF0ZXNQYXRoKSkge1xuICAgIG9wdHMgPSB0ZW1wbGF0ZXNQYXRoO1xuICAgIHRlbXBsYXRlc1BhdGggPSBudWxsO1xuICB9XG5cbiAgdmFyIFRlbXBsYXRlTG9hZGVyO1xuXG4gIGlmIChsb2FkZXJzLkZpbGVTeXN0ZW1Mb2FkZXIpIHtcbiAgICBUZW1wbGF0ZUxvYWRlciA9IG5ldyBsb2FkZXJzLkZpbGVTeXN0ZW1Mb2FkZXIodGVtcGxhdGVzUGF0aCwge1xuICAgICAgd2F0Y2g6IG9wdHMud2F0Y2gsXG4gICAgICBub0NhY2hlOiBvcHRzLm5vQ2FjaGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsb2FkZXJzLldlYkxvYWRlcikge1xuICAgIFRlbXBsYXRlTG9hZGVyID0gbmV3IGxvYWRlcnMuV2ViTG9hZGVyKHRlbXBsYXRlc1BhdGgsIHtcbiAgICAgIHVzZUNhY2hlOiBvcHRzLndlYiAmJiBvcHRzLndlYi51c2VDYWNoZSxcbiAgICAgIGFzeW5jOiBvcHRzLndlYiAmJiBvcHRzLndlYi5hc3luY1xuICAgIH0pO1xuICB9XG5cbiAgZSA9IG5ldyBFbnZpcm9ubWVudChUZW1wbGF0ZUxvYWRlciwgb3B0cyk7XG5cbiAgaWYgKG9wdHMgJiYgb3B0cy5leHByZXNzKSB7XG4gICAgZS5leHByZXNzKG9wdHMuZXhwcmVzcyk7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVudmlyb25tZW50OiBFbnZpcm9ubWVudCxcbiAgVGVtcGxhdGU6IFRlbXBsYXRlLFxuICBMb2FkZXI6IExvYWRlcixcbiAgRmlsZVN5c3RlbUxvYWRlcjogbG9hZGVycy5GaWxlU3lzdGVtTG9hZGVyLFxuICBOb2RlUmVzb2x2ZUxvYWRlcjogbG9hZGVycy5Ob2RlUmVzb2x2ZUxvYWRlcixcbiAgUHJlY29tcGlsZWRMb2FkZXI6IGxvYWRlcnMuUHJlY29tcGlsZWRMb2FkZXIsXG4gIFdlYkxvYWRlcjogbG9hZGVycy5XZWJMb2FkZXIsXG4gIGNvbXBpbGVyOiBjb21waWxlcixcbiAgcGFyc2VyOiBwYXJzZXIsXG4gIGxleGVyOiBsZXhlcixcbiAgcnVudGltZTogcnVudGltZSxcbiAgbGliOiBsaWIsXG4gIG5vZGVzOiBub2RlcyxcbiAgaW5zdGFsbEppbmphQ29tcGF0OiBpbnN0YWxsSmluamFDb21wYXQsXG4gIGNvbmZpZ3VyZTogY29uZmlndXJlLFxuICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZSA9IHVuZGVmaW5lZDtcbiAgfSxcbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBjb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlKHNyYywgZW52LCBwYXRoLCBlYWdlckNvbXBpbGUpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihuYW1lLCBjdHgsIGNiKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBjb25maWd1cmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZS5yZW5kZXIobmFtZSwgY3R4LCBjYik7XG4gIH0sXG4gIHJlbmRlclN0cmluZzogZnVuY3Rpb24gcmVuZGVyU3RyaW5nKHNyYywgY3R4LCBjYikge1xuICAgIGlmICghZSkge1xuICAgICAgY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGUucmVuZGVyU3RyaW5nKHNyYywgY3R4LCBjYik7XG4gIH0sXG4gIHByZWNvbXBpbGU6IHByZWNvbXBpbGUgPyBwcmVjb21waWxlLnByZWNvbXBpbGUgOiB1bmRlZmluZWQsXG4gIHByZWNvbXBpbGVTdHJpbmc6IHByZWNvbXBpbGUgPyBwcmVjb21waWxlLnByZWNvbXBpbGVTdHJpbmcgOiB1bmRlZmluZWRcbn07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gcmF3QXNhcCBwcm92aWRlcyBldmVyeXRoaW5nIHdlIG5lZWQgZXhjZXB0IGV4Y2VwdGlvbiBtYW5hZ2VtZW50LlxudmFyIHJhd0FzYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IG1lYW5zIHBvc3NpYmxlIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGl0cyBvd24gdHVybiwgd2l0aFxuLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuLy8gZXZlbnRzIGluIGJyb3dzZXJzLlxuLy9cbi8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4vLyBzdWJzZXF1ZW50IHRhc2tzLiBUaGUgaGlnaGVyIGxldmVsIGBhc2FwYCBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gYnkgYSB0YXNrLCB0aGF0IHRoZSB0YXNrIHF1ZXVlIHdpbGwgY29udGludWUgZmx1c2hpbmcgYXNcbi8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuLy8gZWl0aGVyIGVuc3VyZSB0aGF0IG5vIGV4Y2VwdGlvbnMgYXJlIHRocm93biBmcm9tIHlvdXIgdGFzaywgb3IgdG8gbWFudWFsbHlcbi8vIGNhbGwgYHJhd0FzYXAucmVxdWVzdEZsdXNoYCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxubW9kdWxlLmV4cG9ydHMgPSByYXdBc2FwO1xuZnVuY3Rpb24gcmF3QXNhcCh0YXNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRXF1aXZhbGVudCB0byBwdXNoLCBidXQgYXZvaWRzIGEgZnVuY3Rpb24gY2FsbC5cbiAgICBxdWV1ZVtxdWV1ZS5sZW5ndGhdID0gdGFzaztcbn1cblxudmFyIHF1ZXVlID0gW107XG4vLyBPbmNlIGEgZmx1c2ggaGFzIGJlZW4gcmVxdWVzdGVkLCBubyBmdXJ0aGVyIGNhbGxzIHRvIGByZXF1ZXN0Rmx1c2hgIGFyZVxuLy8gbmVjZXNzYXJ5IHVudGlsIHRoZSBuZXh0IGBmbHVzaGAgY29tcGxldGVzLlxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBhbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBtZXRob2QgdGhhdCBhdHRlbXB0cyB0byBraWNrXG4vLyBvZmYgYSBgZmx1c2hgIGV2ZW50IGFzIHF1aWNrbHkgYXMgcG9zc2libGUuIGBmbHVzaGAgd2lsbCBhdHRlbXB0IHRvIGV4aGF1c3Rcbi8vIHRoZSBldmVudCBxdWV1ZSBiZWZvcmUgeWllbGRpbmcgdG8gdGhlIGJyb3dzZXIncyBvd24gZXZlbnQgbG9vcC5cbnZhciByZXF1ZXN0Rmx1c2g7XG4vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGFzayB0byBleGVjdXRlIGluIHRoZSB0YXNrIHF1ZXVlLiBUaGlzIGlzXG4vLyBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscyB0byBgZmx1c2hgIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgaWZcbi8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxudmFyIGluZGV4ID0gMDtcbi8vIElmIGEgdGFzayBzY2hlZHVsZXMgYWRkaXRpb25hbCB0YXNrcyByZWN1cnNpdmVseSwgdGhlIHRhc2sgcXVldWUgY2FuIGdyb3dcbi8vIHVuYm91bmRlZC4gVG8gcHJldmVudCBtZW1vcnkgZXhoYXVzdGlvbiwgdGhlIHRhc2sgcXVldWUgd2lsbCBwZXJpb2RpY2FsbHlcbi8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxudmFyIGNhcGFjaXR5ID0gMTAyNDtcblxuLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbi8vIGByYXdBc2FwYCB1bmxlc3MgYW5kIHVudGlsIG9uZSBvZiB0aG9zZSB0YXNrcyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuLy8gSWYgYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24sIGBmbHVzaGAgZW5zdXJlcyB0aGF0IGl0cyBzdGF0ZSB3aWxsIHJlbWFpblxuLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4vLyBIb3dldmVyLCBgZmx1c2hgIGRvZXMgbm90IG1ha2UgYW55IGFycmFuZ2VtZW50cyB0byBiZSBjYWxsZWQgYWdhaW4gaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpbmRleCBiZWZvcmUgY2FsbGluZyB0aGUgdGFzay4gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugd2lsbFxuICAgICAgICAvLyBiZWdpbiBmbHVzaGluZyBvbiB0aGUgbmV4dCB0YXNrIHRoZSB0YXNrIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHF1ZXVlW2N1cnJlbnRJbmRleF0uY2FsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IGxlYWtpbmcgbWVtb3J5IGZvciBsb25nIGNoYWlucyBvZiByZWN1cnNpdmUgY2FsbHMgdG8gYGFzYXBgLlxuICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgLy8gZ3JvdywgYnV0IHRvIGF2b2lkIGFuIE8obikgd2FsayBmb3IgZXZlcnkgdGFzayB3ZSBleGVjdXRlLCB3ZSBkb24ndFxuICAgICAgICAvLyBzaGlmdCB0YXNrcyBvZmYgdGhlIHF1ZXVlIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICBpZiAoaW5kZXggPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2hpZnQgYWxsIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgaW5kZXggYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gMCwgbmV3TGVuZ3RoID0gcXVldWUubGVuZ3RoIC0gaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3NjYW5dID0gcXVldWVbc2NhbiArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAtPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGluZGV4ID0gMDtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHN0cmF0ZWd5IGJhc2VkIG9uIGRhdGEgY29sbGVjdGVkIGZyb21cbi8vIGV2ZXJ5IGF2YWlsYWJsZSBTYXVjZUxhYnMgU2VsZW5pdW0gd2ViIGRyaXZlciB3b3JrZXIgYXQgdGltZSBvZiB3cml0aW5nLlxuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBvciBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cblxuLyogZ2xvYmFscyBzZWxmICovXG52YXIgc2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogc2VsZjtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IHNjb3BlLk11dGF0aW9uT2JzZXJ2ZXIgfHwgc2NvcGUuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gTXV0YXRpb25PYnNlcnZlcnMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgaGF2ZSBoaWdoIHByaW9yaXR5IGFuZCB3b3JrXG4vLyByZWxpYWJseSBldmVyeXdoZXJlIHRoZXkgYXJlIGltcGxlbWVudGVkLlxuLy8gVGhleSBhcmUgaW1wbGVtZW50ZWQgaW4gYWxsIG1vZGVybiBicm93c2Vycy5cbi8vXG4vLyAtIEFuZHJvaWQgNC00LjNcbi8vIC0gQ2hyb21lIDI2LTM0XG4vLyAtIEZpcmVmb3ggMTQtMjlcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbi8vIC0gaVBhZCBTYWZhcmkgNi03LjFcbi8vIC0gaVBob25lIFNhZmFyaSA3LTcuMVxuLy8gLSBTYWZhcmkgNi03XG5pZiAodHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG5cbi8vIE1lc3NhZ2VDaGFubmVscyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBnaXZlIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIEhUTUxcbi8vIHRhc2sgcXVldWUsIGFyZSBpbXBsZW1lbnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCwgU2FmYXJpIDUuMC0xLCBhbmQgT3BlcmFcbi8vIDExLTEyLCBhbmQgaW4gd2ViIHdvcmtlcnMgaW4gbWFueSBlbmdpbmVzLlxuLy8gQWx0aG91Z2ggbWVzc2FnZSBjaGFubmVscyB5aWVsZCB0byBhbnkgcXVldWVkIHJlbmRlcmluZyBhbmQgSU8gdGFza3MsIHRoZXlcbi8vIHdvdWxkIGJlIGJldHRlciB0aGFuIGltcG9zaW5nIHRoZSA0bXMgZGVsYXkgb2YgdGltZXJzLlxuLy8gSG93ZXZlciwgdGhleSBkbyBub3Qgd29yayByZWxpYWJseSBpbiBJbnRlcm5ldCBFeHBsb3JlciBvciBTYWZhcmkuXG5cbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBoYXMgc2V0SW1tZWRpYXRlIGJ1dCBkb2VzXG4vLyBub3QgaGF2ZSBNdXRhdGlvbk9ic2VydmVycy5cbi8vIEFsdGhvdWdoIHNldEltbWVkaWF0ZSB5aWVsZHMgdG8gdGhlIGJyb3dzZXIncyByZW5kZXJlciwgaXQgd291bGQgYmVcbi8vIHByZWZlcnJhYmxlIHRvIGZhbGxpbmcgYmFjayB0byBzZXRUaW1lb3V0IHNpbmNlIGl0IGRvZXMgbm90IGhhdmVcbi8vIHRoZSBtaW5pbXVtIDRtcyBwZW5hbHR5LlxuLy8gVW5mb3J0dW5hdGVseSB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwIE1vYmlsZSAoYW5kXG4vLyBEZXNrdG9wIHRvIGEgbGVzc2VyIGV4dGVudCkgdGhhdCByZW5kZXJzIGJvdGggc2V0SW1tZWRpYXRlIGFuZFxuLy8gTWVzc2FnZUNoYW5uZWwgdXNlbGVzcyBmb3IgdGhlIHB1cnBvc2VzIG9mIEFTQVAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvaXNzdWVzLzM5NlxuXG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbn0gZWxzZSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGZsdXNoKTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLlxuLy8gVGhpcyBpcyB1c2VmdWwgdG8gcHJldmVudCBhbiBlcnJvciB0aHJvd24gaW4gYSB0YXNrIGZyb20gc3RhbGxpbmcgdGhlIGV2ZW50XG4vLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbi8vIGBwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIilgIG9yIGJ5IGEgZG9tYWluLlxucmF3QXNhcC5yZXF1ZXN0Rmx1c2ggPSByZXF1ZXN0Rmx1c2g7XG5cbi8vIFRvIHJlcXVlc3QgYSBoaWdoIHByaW9yaXR5IGV2ZW50LCB3ZSBpbmR1Y2UgYSBtdXRhdGlvbiBvYnNlcnZlciBieSB0b2dnbGluZ1xuLy8gdGhlIHRleHQgb2YgYSB0ZXh0IG5vZGUgYmV0d2VlbiBcIjFcIiBhbmQgXCItMVwiLlxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB2YXIgdG9nZ2xlID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgdG9nZ2xlID0gLXRvZ2dsZTtcbiAgICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlO1xuICAgIH07XG59XG5cbi8vIFRoZSBtZXNzYWdlIGNoYW5uZWwgdGVjaG5pcXVlIHdhcyBkaXNjb3ZlcmVkIGJ5IE1hbHRlIFVibCBhbmQgd2FzIHRoZVxuLy8gb3JpZ2luYWwgZm91bmRhdGlvbiBmb3IgdGhpcyBsaWJyYXJ5LlxuLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcblxuLy8gU2FmYXJpIDYuMC41IChhdCBsZWFzdCkgaW50ZXJtaXR0ZW50bHkgZmFpbHMgdG8gY3JlYXRlIG1lc3NhZ2UgcG9ydHMgb24gYVxuLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbi8vIE11dGF0aW9uT2JzZXJ2ZXJzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGZhbGwgYmFjayBpbiB0aGF0IGNhc2UuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuLy8gICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4vLyAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gRm9yIHJlYXNvbnMgZXhwbGFpbmVkIGFib3ZlLCB3ZSBhcmUgYWxzbyB1bmFibGUgdG8gdXNlIGBzZXRJbW1lZGlhdGVgXG4vLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbi8vIEV2ZW4gaWYgd2Ugd2VyZSwgdGhlcmUgaXMgYW5vdGhlciBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4vLyBJdCBpcyBub3Qgc3VmZmljaWVudCB0byBhc3NpZ24gYHNldEltbWVkaWF0ZWAgdG8gYHJlcXVlc3RGbHVzaGAgYmVjYXVzZVxuLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbi8vIGNsb3N1cmUuXG4vLyBOZXZlciBmb3JnZXQuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21TZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gU2FmYXJpIDYuMCBoYXMgYSBwcm9ibGVtIHdoZXJlIHRpbWVycyB3aWxsIGdldCBsb3N0IHdoaWxlIHRoZSB1c2VyIGlzXG4vLyBzY3JvbGxpbmcuIFRoaXMgcHJvYmxlbSBkb2VzIG5vdCBpbXBhY3QgQVNBUCBiZWNhdXNlIFNhZmFyaSA2LjAgc3VwcG9ydHNcbi8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4vLyBIb3dldmVyLCBpZiB3ZSBldmVyIGVsZWN0IHRvIHVzZSB0aW1lcnMgaW4gU2FmYXJpLCB0aGUgcHJldmFsZW50IHdvcmstYXJvdW5kXG4vLyBpcyB0byBhZGQgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBmb3IgYSBmbHVzaC5cblxuLy8gYHNldFRpbWVvdXRgIGRvZXMgbm90IGNhbGwgdGhlIHBhc3NlZCBjYWxsYmFjayBpZiB0aGUgZGVsYXkgaXMgbGVzcyB0aGFuXG4vLyBhcHByb3hpbWF0ZWx5IDcgaW4gd2ViIHdvcmtlcnMgaW4gRmlyZWZveCA4IHRocm91Z2ggMTgsIGFuZCBzb21ldGltZXMgbm90XG4vLyBldmVuIHRoZW4uXG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgLy8gV2UgZGlzcGF0Y2ggYSB0aW1lb3V0IHdpdGggYSBzcGVjaWZpZWQgZGVsYXkgb2YgMCBmb3IgZW5naW5lcyB0aGF0XG4gICAgICAgIC8vIGNhbiByZWxpYWJseSBhY2NvbW1vZGF0ZSB0aGF0IHJlcXVlc3QuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHNuYXBwZWRcbiAgICAgICAgLy8gdG8gYSA0IG1pbGlzZWNvbmQgZGVsYXksIGJ1dCBvbmNlIHdlJ3JlIGZsdXNoaW5nLCB0aGVyZSdzIG5vIGRlbGF5XG4gICAgICAgIC8vIGJldHdlZW4gZXZlbnRzLlxuICAgICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoaGFuZGxlVGltZXIsIDApO1xuICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIHRpbWVyIGdldHMgZnJlcXVlbnRseSBkcm9wcGVkIGluIEZpcmVmb3hcbiAgICAgICAgLy8gd29ya2Vycywgd2UgZW5saXN0IGFuIGludGVydmFsIGhhbmRsZSB0aGF0IHdpbGwgdHJ5IHRvIGZpcmVcbiAgICAgICAgLy8gYW4gZXZlbnQgMjAgdGltZXMgcGVyIHNlY29uZCB1bnRpbCBpdCBzdWNjZWVkcy5cbiAgICAgICAgdmFyIGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUaW1lcigpIHtcbiAgICAgICAgICAgIC8vIFdoaWNoZXZlciB0aW1lciBzdWNjZWVkcyB3aWxsIGNhbmNlbCBib3RoIHRpbWVycyBhbmRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4vLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXQgZGVwZW5kcyBvblxuLy8gaXRzIGV4aXN0ZW5jZS5cbnJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyO1xuXG4vLyBBU0FQIHdhcyBvcmlnaW5hbGx5IGEgbmV4dFRpY2sgc2hpbSBpbmNsdWRlZCBpbiBRLiBUaGlzIHdhcyBmYWN0b3JlZCBvdXRcbi8vIGludG8gdGhpcyBBU0FQIHBhY2thZ2UuIEl0IHdhcyBsYXRlciBhZGFwdGVkIHRvIFJTVlAgd2hpY2ggbWFkZSBmdXJ0aGVyXG4vLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbi8vIHRvIGNhcHR1cmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaW4gYSBjbG9zdXJlLCB3ZXJlIGludGVncmF0ZWRcbi8vIGJhY2sgaW50byBBU0FQIHByb3Blci5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTQpKSlcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187Ly8gTUlUIGxpY2Vuc2UgKGJ5IEVsYW4gU2hhbmtlcikuXG4oZnVuY3Rpb24oZ2xvYmFscykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4ZWN1dGVTeW5jID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgYXJncy5zcGxpY2UoMSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24oZm4pe1xuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1ha2VJdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICB9O1xuICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgfTtcbiAgXG4gIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24obWF5YmVBcnJheSl7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICB2YXIgd2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHZhciBuZXh0VGljayA9IGZvcmNlQXN5bmMgPyBleGVjdXRlQXN5bmMgOiBleGVjdXRlU3luYztcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICB3cmFwSXRlcmF0b3IobWFrZUl0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgfTtcblxuICBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gd2F0ZXJmYWxsO1xuICAgIH0pLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7IC8vIFJlcXVpcmVKU1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3YXRlcmZhbGw7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFscy53YXRlcmZhbGwgPSB3YXRlcmZhbGw7IC8vIDxzY3JpcHQ+XG4gIH1cbn0pKHRoaXMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIG5vZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBzeW0gPSAwO1xuXG5mdW5jdGlvbiBnZW5zeW0oKSB7XG4gIHJldHVybiAnaG9sZV8nICsgc3ltKys7XG59IC8vIGNvcHktb24td3JpdGUgdmVyc2lvbiBvZiBtYXBcblxuXG5mdW5jdGlvbiBtYXBDT1coYXJyLCBmdW5jKSB7XG4gIHZhciByZXMgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBmdW5jKGFycltpXSk7XG5cbiAgICBpZiAoaXRlbSAhPT0gYXJyW2ldKSB7XG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXMgPSBhcnIuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgcmVzW2ldID0gaXRlbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzIHx8IGFycjtcbn1cblxuZnVuY3Rpb24gd2Fsayhhc3QsIGZ1bmMsIGRlcHRoRmlyc3QpIHtcbiAgaWYgKCEoYXN0IGluc3RhbmNlb2Ygbm9kZXMuTm9kZSkpIHtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgaWYgKCFkZXB0aEZpcnN0KSB7XG4gICAgdmFyIGFzdFQgPSBmdW5jKGFzdCk7XG5cbiAgICBpZiAoYXN0VCAmJiBhc3RUICE9PSBhc3QpIHtcbiAgICAgIHJldHVybiBhc3RUO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3QgaW5zdGFuY2VvZiBub2Rlcy5Ob2RlTGlzdCkge1xuICAgIHZhciBjaGlsZHJlbiA9IG1hcENPVyhhc3QuY2hpbGRyZW4sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gd2Fsayhub2RlLCBmdW5jLCBkZXB0aEZpcnN0KTtcbiAgICB9KTtcblxuICAgIGlmIChjaGlsZHJlbiAhPT0gYXN0LmNoaWxkcmVuKSB7XG4gICAgICBhc3QgPSBuZXcgbm9kZXNbYXN0LnR5cGVuYW1lXShhc3QubGluZW5vLCBhc3QuY29sbm8sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXN0IGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbikge1xuICAgIHZhciBhcmdzID0gd2Fsayhhc3QuYXJncywgZnVuYywgZGVwdGhGaXJzdCk7XG4gICAgdmFyIGNvbnRlbnRBcmdzID0gbWFwQ09XKGFzdC5jb250ZW50QXJncywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiB3YWxrKG5vZGUsIGZ1bmMsIGRlcHRoRmlyc3QpO1xuICAgIH0pO1xuXG4gICAgaWYgKGFyZ3MgIT09IGFzdC5hcmdzIHx8IGNvbnRlbnRBcmdzICE9PSBhc3QuY29udGVudEFyZ3MpIHtcbiAgICAgIGFzdCA9IG5ldyBub2Rlc1thc3QudHlwZW5hbWVdKGFzdC5leHROYW1lLCBhc3QucHJvcCwgYXJncywgY29udGVudEFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJvcHMgPSBhc3QuZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBhc3RbZmllbGRdO1xuICAgIH0pO1xuICAgIHZhciBwcm9wc1QgPSBtYXBDT1cocHJvcHMsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gd2Fsayhwcm9wLCBmdW5jLCBkZXB0aEZpcnN0KTtcbiAgICB9KTtcblxuICAgIGlmIChwcm9wc1QgIT09IHByb3BzKSB7XG4gICAgICBhc3QgPSBuZXcgbm9kZXNbYXN0LnR5cGVuYW1lXShhc3QubGluZW5vLCBhc3QuY29sbm8pO1xuICAgICAgcHJvcHNULmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgICAgYXN0W2FzdC5maWVsZHNbaV1dID0gcHJvcDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZXB0aEZpcnN0ID8gZnVuYyhhc3QpIHx8IGFzdCA6IGFzdDtcbn1cblxuZnVuY3Rpb24gZGVwdGhXYWxrKGFzdCwgZnVuYykge1xuICByZXR1cm4gd2Fsayhhc3QsIGZ1bmMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzLCBwcm9wKSB7XG4gIHZhciBjaGlsZHJlbiA9IFtdO1xuICB2YXIgd2Fsa2VkID0gZGVwdGhXYWxrKHByb3AgPyBub2RlW3Byb3BdIDogbm9kZSwgZnVuY3Rpb24gKGRlc2NOb2RlKSB7XG4gICAgdmFyIHN5bWJvbDtcblxuICAgIGlmIChkZXNjTm9kZSBpbnN0YW5jZW9mIG5vZGVzLkJsb2NrKSB7XG4gICAgICByZXR1cm4gZGVzY05vZGU7XG4gICAgfSBlbHNlIGlmIChkZXNjTm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZpbHRlciAmJiBsaWIuaW5kZXhPZihhc3luY0ZpbHRlcnMsIGRlc2NOb2RlLm5hbWUudmFsdWUpICE9PSAtMSB8fCBkZXNjTm9kZSBpbnN0YW5jZW9mIG5vZGVzLkNhbGxFeHRlbnNpb25Bc3luYykge1xuICAgICAgc3ltYm9sID0gbmV3IG5vZGVzLlN5bWJvbChkZXNjTm9kZS5saW5lbm8sIGRlc2NOb2RlLmNvbG5vLCBnZW5zeW0oKSk7XG4gICAgICBjaGlsZHJlbi5wdXNoKG5ldyBub2Rlcy5GaWx0ZXJBc3luYyhkZXNjTm9kZS5saW5lbm8sIGRlc2NOb2RlLmNvbG5vLCBkZXNjTm9kZS5uYW1lLCBkZXNjTm9kZS5hcmdzLCBzeW1ib2wpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sO1xuICB9KTtcblxuICBpZiAocHJvcCkge1xuICAgIG5vZGVbcHJvcF0gPSB3YWxrZWQ7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IHdhbGtlZDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgIHJldHVybiBuZXcgbm9kZXMuTm9kZUxpc3Qobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIGNoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaWZ0RmlsdGVycyhhc3QsIGFzeW5jRmlsdGVycykge1xuICByZXR1cm4gZGVwdGhXYWxrKGFzdCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk91dHB1dCkge1xuICAgICAgcmV0dXJuIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNldCkge1xuICAgICAgcmV0dXJuIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMsICd2YWx1ZScpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZvcikge1xuICAgICAgcmV0dXJuIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMsICdhcnInKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5JZikge1xuICAgICAgcmV0dXJuIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMsICdjb25kJyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuIF9saWZ0RmlsdGVycyhub2RlLCBhc3luY0ZpbHRlcnMsICdhcmdzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlmdFN1cGVyKGFzdCkge1xuICByZXR1cm4gd2Fsayhhc3QsIGZ1bmN0aW9uIChibG9ja05vZGUpIHtcbiAgICBpZiAoIShibG9ja05vZGUgaW5zdGFuY2VvZiBub2Rlcy5CbG9jaykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaGFzU3VwZXIgPSBmYWxzZTtcbiAgICB2YXIgc3ltYm9sID0gZ2Vuc3ltKCk7XG4gICAgYmxvY2tOb2RlLmJvZHkgPSB3YWxrKGJsb2NrTm9kZS5ib2R5LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5GdW5DYWxsICYmIG5vZGUubmFtZS52YWx1ZSA9PT0gJ3N1cGVyJykge1xuICAgICAgICBoYXNTdXBlciA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgbm9kZXMuU3ltYm9sKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBzeW1ib2wpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGhhc1N1cGVyKSB7XG4gICAgICBibG9ja05vZGUuYm9keS5jaGlsZHJlbi51bnNoaWZ0KG5ldyBub2Rlcy5TdXBlcigwLCAwLCBibG9ja05vZGUubmFtZSwgbmV3IG5vZGVzLlN5bWJvbCgwLCAwLCBzeW1ib2wpKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29udmVydFN0YXRlbWVudHMoYXN0KSB7XG4gIHJldHVybiBkZXB0aFdhbGsoYXN0LCBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5JZikgJiYgIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuRm9yKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgYXN5bmMgPSBmYWxzZTtcbiAgICB3YWxrKG5vZGUsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuRmlsdGVyQXN5bmMgfHwgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5JZkFzeW5jIHx8IGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuQXN5bmNFYWNoIHx8IGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuQXN5bmNBbGwgfHwgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXh0ZW5zaW9uQXN5bmMpIHtcbiAgICAgICAgYXN5bmMgPSB0cnVlOyAvLyBTdG9wIGl0ZXJhdGluZyBieSByZXR1cm5pbmcgdGhlIG5vZGVcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuSWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBub2Rlcy5JZkFzeW5jKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLmNvbmQsIG5vZGUuYm9keSwgbm9kZS5lbHNlXyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5Gb3IgJiYgIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuQXN5bmNBbGwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgbm9kZXMuQXN5bmNFYWNoKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLmFyciwgbm9kZS5uYW1lLCBub2RlLmJvZHksIG5vZGUuZWxzZV8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcHMoYXN0LCBhc3luY0ZpbHRlcnMpIHtcbiAgcmV0dXJuIGNvbnZlcnRTdGF0ZW1lbnRzKGxpZnRTdXBlcihsaWZ0RmlsdGVycyhhc3QsIGFzeW5jRmlsdGVycykpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtKGFzdCwgYXN5bmNGaWx0ZXJzKSB7XG4gIHJldHVybiBjcHMoYXN0LCBhc3luY0ZpbHRlcnMgfHwgW10pO1xufSAvLyB2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbi8vIHZhciBzcmMgPSAnaGVsbG8geyUgZm9vICV9eyUgZW5kZm9vICV9IGVuZCc7XG4vLyB2YXIgYXN0ID0gdHJhbnNmb3JtKHBhcnNlci5wYXJzZShzcmMsIFtuZXcgRm9vRXh0ZW5zaW9uKCldKSwgWydiYXInXSk7XG4vLyBub2Rlcy5wcmludE5vZGVzKGFzdCk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYW5zZm9ybTogdHJhbnNmb3JtXG59O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy5hYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gaXNOYU4obnVtKSB7XG4gIHJldHVybiBudW0gIT09IG51bTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuZnVuY3Rpb24gYmF0Y2goYXJyLCBsaW5lY291bnQsIGZpbGxXaXRoKSB7XG4gIHZhciBpO1xuICB2YXIgcmVzID0gW107XG4gIHZhciB0bXAgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBsaW5lY291bnQgPT09IDAgJiYgdG1wLmxlbmd0aCkge1xuICAgICAgcmVzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9IFtdO1xuICAgIH1cblxuICAgIHRtcC5wdXNoKGFycltpXSk7XG4gIH1cblxuICBpZiAodG1wLmxlbmd0aCkge1xuICAgIGlmIChmaWxsV2l0aCkge1xuICAgICAgZm9yIChpID0gdG1wLmxlbmd0aDsgaSA8IGxpbmVjb3VudDsgaSsrKSB7XG4gICAgICAgIHRtcC5wdXNoKGZpbGxXaXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXMucHVzaCh0bXApO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0cy5iYXRjaCA9IGJhdGNoO1xuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHZhciByZXQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcmV0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcmV0LnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0cy5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcblxuZnVuY3Rpb24gY2VudGVyKHN0ciwgd2lkdGgpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICB3aWR0aCA9IHdpZHRoIHx8IDgwO1xuXG4gIGlmIChzdHIubGVuZ3RoID49IHdpZHRoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBzcGFjZXMgPSB3aWR0aCAtIHN0ci5sZW5ndGg7XG4gIHZhciBwcmUgPSBsaWIucmVwZWF0KCcgJywgc3BhY2VzIC8gMiAtIHNwYWNlcyAlIDIpO1xuICB2YXIgcG9zdCA9IGxpYi5yZXBlYXQoJyAnLCBzcGFjZXMgLyAyKTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcHJlICsgc3RyICsgcG9zdCk7XG59XG5cbmV4cG9ydHMuY2VudGVyID0gY2VudGVyO1xuXG5mdW5jdGlvbiBkZWZhdWx0Xyh2YWwsIGRlZiwgYm9vbCkge1xuICBpZiAoYm9vbCkge1xuICAgIHJldHVybiB2YWwgfHwgZGVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGRlZjtcbiAgfVxufSAvLyBUT0RPOiBpdCBpcyBjb25mdXNpbmcgdG8gZXhwb3J0IHNvbWV0aGluZyBjYWxsZWQgJ2RlZmF1bHQnXG5cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZGVmYXVsdF87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG5cbmZ1bmN0aW9uIGRpY3Rzb3J0KHZhbCwgY2FzZVNlbnNpdGl2ZSwgYnkpIHtcbiAgaWYgKCFsaWIuaXNPYmplY3QodmFsKSkge1xuICAgIHRocm93IG5ldyBsaWIuVGVtcGxhdGVFcnJvcignZGljdHNvcnQgZmlsdGVyOiB2YWwgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHZhciBhcnJheSA9IFtdOyAvLyBkZWxpYmVyYXRlbHkgaW5jbHVkZSBwcm9wZXJ0aWVzIGZyb20gdGhlIG9iamVjdCdzIHByb3RvdHlwZVxuXG4gIGZvciAodmFyIGsgaW4gdmFsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW4sIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgYXJyYXkucHVzaChbaywgdmFsW2tdXSk7XG4gIH1cblxuICB2YXIgc2k7XG5cbiAgaWYgKGJ5ID09PSB1bmRlZmluZWQgfHwgYnkgPT09ICdrZXknKSB7XG4gICAgc2kgPSAwO1xuICB9IGVsc2UgaWYgKGJ5ID09PSAndmFsdWUnKSB7XG4gICAgc2kgPSAxO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBsaWIuVGVtcGxhdGVFcnJvcignZGljdHNvcnQgZmlsdGVyOiBZb3UgY2FuIG9ubHkgc29ydCBieSBlaXRoZXIga2V5IG9yIHZhbHVlJyk7XG4gIH1cblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uICh0MSwgdDIpIHtcbiAgICB2YXIgYSA9IHQxW3NpXTtcbiAgICB2YXIgYiA9IHQyW3NpXTtcblxuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgaWYgKGxpYi5pc1N0cmluZyhhKSkge1xuICAgICAgICBhID0gYS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGliLmlzU3RyaW5nKGIpKSB7XG4gICAgICAgIGIgPSBiLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPT09IGIgPyAwIDogLTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0cy5kaWN0c29ydCA9IGRpY3Rzb3J0O1xuXG5mdW5jdGlvbiBkdW1wKG9iaiwgc3BhY2VzKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIHNwYWNlcyk7XG59XG5cbmV4cG9ydHMuZHVtcCA9IGR1bXA7XG5cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgaWYgKHN0ciBpbnN0YW5jZW9mIHIuU2FmZVN0cmluZykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBzdHIgPSBzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQgPyAnJyA6IHN0cjtcbiAgcmV0dXJuIHIubWFya1NhZmUobGliLmVzY2FwZShzdHIudG9TdHJpbmcoKSkpO1xufVxuXG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcblxuZnVuY3Rpb24gc2FmZShzdHIpIHtcbiAgaWYgKHN0ciBpbnN0YW5jZW9mIHIuU2FmZVN0cmluZykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBzdHIgPSBzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQgPyAnJyA6IHN0cjtcbiAgcmV0dXJuIHIubWFya1NhZmUoc3RyLnRvU3RyaW5nKCkpO1xufVxuXG5leHBvcnRzLnNhZmUgPSBzYWZlO1xuXG5mdW5jdGlvbiBmaXJzdChhcnIpIHtcbiAgcmV0dXJuIGFyclswXTtcbn1cblxuZXhwb3J0cy5maXJzdCA9IGZpcnN0O1xuXG5mdW5jdGlvbiBmb3JjZWVzY2FwZShzdHIpIHtcbiAgc3RyID0gc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkID8gJycgOiBzdHI7XG4gIHJldHVybiByLm1hcmtTYWZlKGxpYi5lc2NhcGUoc3RyLnRvU3RyaW5nKCkpKTtcbn1cblxuZXhwb3J0cy5mb3JjZWVzY2FwZSA9IGZvcmNlZXNjYXBlO1xuXG5mdW5jdGlvbiBncm91cGJ5KGFyciwgYXR0cikge1xuICByZXR1cm4gbGliLmdyb3VwQnkoYXJyLCBhdHRyLCB0aGlzLmVudi5vcHRzLnRocm93T25VbmRlZmluZWQpO1xufVxuXG5leHBvcnRzLmdyb3VwYnkgPSBncm91cGJ5O1xuXG5mdW5jdGlvbiBpbmRlbnQoc3RyLCB3aWR0aCwgaW5kZW50Zmlyc3QpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuXG4gIGlmIChzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgd2lkdGggPSB3aWR0aCB8fCA0OyAvLyBsZXQgcmVzID0gJyc7XG5cbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKTtcbiAgdmFyIHNwID0gbGliLnJlcGVhdCgnICcsIHdpZHRoKTtcbiAgdmFyIHJlcyA9IGxpbmVzLm1hcChmdW5jdGlvbiAobCwgaSkge1xuICAgIHJldHVybiBpID09PSAwICYmICFpbmRlbnRmaXJzdCA/IGwgOiBcIlwiICsgc3AgKyBsO1xuICB9KS5qb2luKCdcXG4nKTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcmVzKTtcbn1cblxuZXhwb3J0cy5pbmRlbnQgPSBpbmRlbnQ7XG5cbmZ1bmN0aW9uIGpvaW4oYXJyLCBkZWwsIGF0dHIpIHtcbiAgZGVsID0gZGVsIHx8ICcnO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgYXJyID0gbGliLm1hcChhcnIsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdlthdHRyXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhcnIuam9pbihkZWwpO1xufVxuXG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuZXhwb3J0cy5sYXN0ID0gbGFzdDtcblxuZnVuY3Rpb24gbGVuZ3RoRmlsdGVyKHZhbCkge1xuICB2YXIgdmFsdWUgPSBub3JtYWxpemUodmFsLCAnJyk7XG5cbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAvLyBFQ01BU2NyaXB0IDIwMTUgTWFwcyBhbmQgU2V0c1xuICAgICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKGxpYi5pc09iamVjdCh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIHIuU2FmZVN0cmluZykpIHtcbiAgICAgIC8vIE9iamVjdHMgKGJlc2lkZXMgU2FmZVN0cmluZ3MpLCBub24tcHJpbWF0aXZlIEFycmF5c1xuICAgICAgcmV0dXJuIGxpYi5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aEZpbHRlcjtcblxuZnVuY3Rpb24gbGlzdCh2YWwpIHtcbiAgaWYgKGxpYi5pc1N0cmluZyh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5zcGxpdCgnJyk7XG4gIH0gZWxzZSBpZiAobGliLmlzT2JqZWN0KHZhbCkpIHtcbiAgICByZXR1cm4gbGliLl9lbnRyaWVzKHZhbCB8fCB7fSkubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIga2V5ID0gX3JlZlswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWZbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxpYi5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBsaWIuVGVtcGxhdGVFcnJvcignbGlzdCBmaWx0ZXI6IHR5cGUgbm90IGl0ZXJhYmxlJyk7XG4gIH1cbn1cblxuZXhwb3J0cy5saXN0ID0gbGlzdDtcblxuZnVuY3Rpb24gbG93ZXIoc3RyKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG5leHBvcnRzLmxvd2VyID0gbG93ZXI7XG5cbmZ1bmN0aW9uIG5sMmJyKHN0cikge1xuICBpZiAoc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgc3RyLnJlcGxhY2UoL1xcclxcbnxcXG4vZywgJzxiciAvPlxcbicpKTtcbn1cblxuZXhwb3J0cy5ubDJiciA9IG5sMmJyO1xuXG5mdW5jdGlvbiByYW5kb20oYXJyKSB7XG4gIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xufVxuXG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbi8qKlxuICogQ29uc3RydWN0IHNlbGVjdCBvciByZWplY3QgZmlsdGVyXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBleHBlY3RlZFRlc3RSZXN1bHRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihhcnJheSwgc3RyaW5nLCAqKTogYXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0T3JSZWplY3QoZXhwZWN0ZWRUZXN0UmVzdWx0KSB7XG4gIGZ1bmN0aW9uIGZpbHRlcihhcnIsIHRlc3ROYW1lLCBzZWNvbmRBcmcpIHtcbiAgICBpZiAodGVzdE5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgdGVzdE5hbWUgPSAndHJ1dGh5JztcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgdmFyIHRlc3QgPSBjb250ZXh0LmVudi5nZXRUZXN0KHRlc3ROYW1lKTtcbiAgICByZXR1cm4gbGliLnRvQXJyYXkoYXJyKS5maWx0ZXIoZnVuY3Rpb24gZXhhbWluZVRlc3RSZXN1bHQoaXRlbSkge1xuICAgICAgcmV0dXJuIHRlc3QuY2FsbChjb250ZXh0LCBpdGVtLCBzZWNvbmRBcmcpID09PSBleHBlY3RlZFRlc3RSZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyO1xufVxuXG5leHBvcnRzLnJlamVjdCA9IGdldFNlbGVjdE9yUmVqZWN0KGZhbHNlKTtcblxuZnVuY3Rpb24gcmVqZWN0YXR0cihhcnIsIGF0dHIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gIWl0ZW1bYXR0cl07XG4gIH0pO1xufVxuXG5leHBvcnRzLnJlamVjdGF0dHIgPSByZWplY3RhdHRyO1xuZXhwb3J0cy5zZWxlY3QgPSBnZXRTZWxlY3RPclJlamVjdCh0cnVlKTtcblxuZnVuY3Rpb24gc2VsZWN0YXR0cihhcnIsIGF0dHIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gISFpdGVtW2F0dHJdO1xuICB9KTtcbn1cblxuZXhwb3J0cy5zZWxlY3RhdHRyID0gc2VsZWN0YXR0cjtcblxuZnVuY3Rpb24gcmVwbGFjZShzdHIsIG9sZCwgbmV3XywgbWF4Q291bnQpIHtcbiAgdmFyIG9yaWdpbmFsU3RyID0gc3RyO1xuXG4gIGlmIChvbGQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2Uob2xkLCBuZXdfKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4Q291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbWF4Q291bnQgPSAtMTtcbiAgfVxuXG4gIHZhciByZXMgPSAnJzsgLy8gT3V0cHV0XG4gIC8vIENhc3QgTnVtYmVycyBpbiB0aGUgc2VhcmNoIHRlcm0gdG8gc3RyaW5nXG5cbiAgaWYgKHR5cGVvZiBvbGQgPT09ICdudW1iZXInKSB7XG4gICAgb2xkID0gJycgKyBvbGQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9sZCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiBpdCBpcyBzb21ldGhpbmcgb3RoZXIgdGhhbiBudW1iZXIgb3Igc3RyaW5nLFxuICAgIC8vIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgcmV0dXJuIHN0cjtcbiAgfSAvLyBDYXN0IG51bWJlcnMgaW4gdGhlIHJlcGxhY2VtZW50IHRvIHN0cmluZ1xuXG5cbiAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKSB7XG4gICAgc3RyID0gJycgKyBzdHI7XG4gIH0gLy8gSWYgYnkgbm93LCB3ZSBkb24ndCBoYXZlIGEgc3RyaW5nLCB0aHJvdyBpdCBiYWNrXG5cblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgJiYgIShzdHIgaW5zdGFuY2VvZiByLlNhZmVTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfSAvLyBTaG9ydENpcmN1aXRzXG5cblxuICBpZiAob2xkID09PSAnJykge1xuICAgIC8vIE1pbWljIHRoZSBweXRob24gYmVoYXZpb3VyOiBlbXB0eSBzdHJpbmcgaXMgcmVwbGFjZWRcbiAgICAvLyBieSByZXBsYWNlbWVudCBlLmcuIFwiYWJjXCJ8cmVwbGFjZShcIlwiLCBcIi5cIikgLT4gLmEuYi5jLlxuICAgIHJlcyA9IG5ld18gKyBzdHIuc3BsaXQoJycpLmpvaW4obmV3XykgKyBuZXdfO1xuICAgIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHJlcyk7XG4gIH1cblxuICB2YXIgbmV4dEluZGV4ID0gc3RyLmluZGV4T2Yob2xkKTsgLy8gaWYgIyBvZiByZXBsYWNlbWVudHMgdG8gcGVyZm9ybSBpcyAwLCBvciB0aGUgc3RyaW5nIHRvIGRvZXNcbiAgLy8gbm90IGNvbnRhaW4gdGhlIG9sZCB2YWx1ZSwgcmV0dXJuIHRoZSBzdHJpbmdcblxuICBpZiAobWF4Q291bnQgPT09IDAgfHwgbmV4dEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgcG9zID0gMDtcbiAgdmFyIGNvdW50ID0gMDsgLy8gIyBvZiByZXBsYWNlbWVudHMgbWFkZVxuXG4gIHdoaWxlIChuZXh0SW5kZXggPiAtMSAmJiAobWF4Q291bnQgPT09IC0xIHx8IGNvdW50IDwgbWF4Q291bnQpKSB7XG4gICAgLy8gR3JhYiB0aGUgbmV4dCBjaHVuayBvZiBzcmMgc3RyaW5nIGFuZCBhZGQgaXQgd2l0aCB0aGVcbiAgICAvLyByZXBsYWNlbWVudCwgdG8gdGhlIHJlc3VsdFxuICAgIHJlcyArPSBzdHIuc3Vic3RyaW5nKHBvcywgbmV4dEluZGV4KSArIG5ld187IC8vIEluY3JlbWVudCBvdXIgcG9pbnRlciBpbiB0aGUgc3JjIHN0cmluZ1xuXG4gICAgcG9zID0gbmV4dEluZGV4ICsgb2xkLmxlbmd0aDtcbiAgICBjb3VudCsrOyAvLyBTZWUgaWYgdGhlcmUgYXJlIGFueSBtb3JlIHJlcGxhY2VtZW50cyB0byBiZSBtYWRlXG5cbiAgICBuZXh0SW5kZXggPSBzdHIuaW5kZXhPZihvbGQsIHBvcyk7XG4gIH0gLy8gV2UndmUgZWl0aGVyIHJlYWNoZWQgdGhlIGVuZCwgb3IgZG9uZSB0aGUgbWF4ICMgb2ZcbiAgLy8gcmVwbGFjZW1lbnRzLCB0YWNrIG9uIGFueSByZW1haW5pbmcgc3RyaW5nXG5cblxuICBpZiAocG9zIDwgc3RyLmxlbmd0aCkge1xuICAgIHJlcyArPSBzdHIuc3Vic3RyaW5nKHBvcyk7XG4gIH1cblxuICByZXR1cm4gci5jb3B5U2FmZW5lc3Mob3JpZ2luYWxTdHIsIHJlcyk7XG59XG5cbmV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG5cbmZ1bmN0aW9uIHJldmVyc2UodmFsKSB7XG4gIHZhciBhcnI7XG5cbiAgaWYgKGxpYi5pc1N0cmluZyh2YWwpKSB7XG4gICAgYXJyID0gbGlzdCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvcHkgaXRcbiAgICBhcnIgPSBsaWIubWFwKHZhbCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9XG5cbiAgYXJyLnJldmVyc2UoKTtcblxuICBpZiAobGliLmlzU3RyaW5nKHZhbCkpIHtcbiAgICByZXR1cm4gci5jb3B5U2FmZW5lc3ModmFsLCBhcnIuam9pbignJykpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0cy5yZXZlcnNlID0gcmV2ZXJzZTtcblxuZnVuY3Rpb24gcm91bmQodmFsLCBwcmVjaXNpb24sIG1ldGhvZCkge1xuICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMDtcbiAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICB2YXIgcm91bmRlcjtcblxuICBpZiAobWV0aG9kID09PSAnY2VpbCcpIHtcbiAgICByb3VuZGVyID0gTWF0aC5jZWlsO1xuICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gJ2Zsb29yJykge1xuICAgIHJvdW5kZXIgPSBNYXRoLmZsb29yO1xuICB9IGVsc2Uge1xuICAgIHJvdW5kZXIgPSBNYXRoLnJvdW5kO1xuICB9XG5cbiAgcmV0dXJuIHJvdW5kZXIodmFsICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuXG5mdW5jdGlvbiBzbGljZShhcnIsIHNsaWNlcywgZmlsbFdpdGgpIHtcbiAgdmFyIHNsaWNlTGVuZ3RoID0gTWF0aC5mbG9vcihhcnIubGVuZ3RoIC8gc2xpY2VzKTtcbiAgdmFyIGV4dHJhID0gYXJyLmxlbmd0aCAlIHNsaWNlcztcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlczsgaSsrKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0ICsgaSAqIHNsaWNlTGVuZ3RoO1xuXG4gICAgaWYgKGkgPCBleHRyYSkge1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IG9mZnNldCArIChpICsgMSkgKiBzbGljZUxlbmd0aDtcbiAgICB2YXIgY3VyclNsaWNlID0gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgaWYgKGZpbGxXaXRoICYmIGkgPj0gZXh0cmEpIHtcbiAgICAgIGN1cnJTbGljZS5wdXNoKGZpbGxXaXRoKTtcbiAgICB9XG5cbiAgICByZXMucHVzaChjdXJyU2xpY2UpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuXG5mdW5jdGlvbiBzdW0oYXJyLCBhdHRyLCBzdGFydCkge1xuICBpZiAoc3RhcnQgPT09IHZvaWQgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChhdHRyKSB7XG4gICAgYXJyID0gbGliLm1hcChhcnIsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdlthdHRyXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzdGFydCArIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH0sIDApO1xufVxuXG5leHBvcnRzLnN1bSA9IHN1bTtcbmV4cG9ydHMuc29ydCA9IHIubWFrZU1hY3JvKFsndmFsdWUnLCAncmV2ZXJzZScsICdjYXNlX3NlbnNpdGl2ZScsICdhdHRyaWJ1dGUnXSwgW10sIGZ1bmN0aW9uIChhcnIsIHJldmVyc2VkLCBjYXNlU2VucywgYXR0cikge1xuICAvLyBDb3B5IGl0XG4gIHZhciBhcnJheSA9IGxpYi5tYXAoYXJyLCBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2O1xuICB9KTtcbiAgYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB4ID0gYXR0ciA/IGFbYXR0cl0gOiBhO1xuICAgIHZhciB5ID0gYXR0ciA/IGJbYXR0cl0gOiBiO1xuXG4gICAgaWYgKCFjYXNlU2VucyAmJiBsaWIuaXNTdHJpbmcoeCkgJiYgbGliLmlzU3RyaW5nKHkpKSB7XG4gICAgICB4ID0geC50b0xvd2VyQ2FzZSgpO1xuICAgICAgeSA9IHkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiByZXZlcnNlZCA/IDEgOiAtMTtcbiAgICB9IGVsc2UgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gcmV2ZXJzZWQgPyAtMSA6IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn0pO1xuXG5mdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhvYmosIG9iaik7XG59XG5cbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuXG5mdW5jdGlvbiBzdHJpcHRhZ3MoaW5wdXQsIHByZXNlcnZlTGluZWJyZWFrcykge1xuICBpbnB1dCA9IG5vcm1hbGl6ZShpbnB1dCwgJycpO1xuICB2YXIgdGFncyA9IC88XFwvPyhbYS16XVthLXowLTldKilcXGJbXj5dKj58PCEtLVtcXHNcXFNdKj8tLT4vZ2k7XG4gIHZhciB0cmltbWVkSW5wdXQgPSB0cmltKGlucHV0LnJlcGxhY2UodGFncywgJycpKTtcbiAgdmFyIHJlcyA9ICcnO1xuXG4gIGlmIChwcmVzZXJ2ZUxpbmVicmVha3MpIHtcbiAgICByZXMgPSB0cmltbWVkSW5wdXQucmVwbGFjZSgvXiArfCArJC9nbSwgJycpIC8vIHJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAgICAucmVwbGFjZSgvICsvZywgJyAnKSAvLyBzcXVhc2ggYWRqYWNlbnQgc3BhY2VzXG4gICAgLnJlcGxhY2UoLyhcXHJcXG4pL2csICdcXG4nKSAvLyBub3JtYWxpemUgbGluZWJyZWFrcyAoQ1JMRiAtPiBMRilcbiAgICAucmVwbGFjZSgvXFxuXFxuXFxuKy9nLCAnXFxuXFxuJyk7IC8vIHNxdWFzaCBhYm5vcm1hbCBhZGphY2VudCBsaW5lYnJlYWtzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0gdHJpbW1lZElucHV0LnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICByZXR1cm4gci5jb3B5U2FmZW5lc3MoaW5wdXQsIHJlcyk7XG59XG5cbmV4cG9ydHMuc3RyaXB0YWdzID0gc3RyaXB0YWdzO1xuXG5mdW5jdGlvbiB0aXRsZShzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICB2YXIgd29yZHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICByZXR1cm4gY2FwaXRhbGl6ZSh3b3JkKTtcbiAgfSk7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHdvcmRzLmpvaW4oJyAnKSk7XG59XG5cbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKSk7XG59XG5cbmV4cG9ydHMudHJpbSA9IHRyaW07XG5cbmZ1bmN0aW9uIHRydW5jYXRlKGlucHV0LCBsZW5ndGgsIGtpbGx3b3JkcywgZW5kKSB7XG4gIHZhciBvcmlnID0gaW5wdXQ7XG4gIGlucHV0ID0gbm9ybWFsaXplKGlucHV0LCAnJyk7XG4gIGxlbmd0aCA9IGxlbmd0aCB8fCAyNTU7XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBpZiAoa2lsbHdvcmRzKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaWR4ID0gaW5wdXQubGFzdEluZGV4T2YoJyAnLCBsZW5ndGgpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGlkeCA9IGxlbmd0aDtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBpZHgpO1xuICB9XG5cbiAgaW5wdXQgKz0gZW5kICE9PSB1bmRlZmluZWQgJiYgZW5kICE9PSBudWxsID8gZW5kIDogJy4uLic7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhvcmlnLCBpbnB1dCk7XG59XG5cbmV4cG9ydHMudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcblxuZnVuY3Rpb24gdXBwZXIoc3RyKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnRzLnVwcGVyID0gdXBwZXI7XG5cbmZ1bmN0aW9uIHVybGVuY29kZShvYmopIHtcbiAgdmFyIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICBpZiAobGliLmlzU3RyaW5nKG9iaikpIHtcbiAgICByZXR1cm4gZW5jKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXZhbHMgPSBsaWIuaXNBcnJheShvYmopID8gb2JqIDogbGliLl9lbnRyaWVzKG9iaik7XG4gICAgcmV0dXJuIGtleXZhbHMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIGsgPSBfcmVmMlswXSxcbiAgICAgICAgICB2ID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gZW5jKGspICsgXCI9XCIgKyBlbmModik7XG4gICAgfSkuam9pbignJicpO1xuICB9XG59XG5cbmV4cG9ydHMudXJsZW5jb2RlID0gdXJsZW5jb2RlOyAvLyBGb3IgdGhlIGppbmphIHJlZ2V4cCwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWl0c3VoaWtvL2ppbmphMi9ibG9iL2YxNWI4MTRkY2JhNmFhMTJiYzc0ZDFmN2QwYzg4MWQ1NWY3MTI2YmUvamluamEyL3V0aWxzLnB5I0wyMC1MMjNcblxudmFyIHB1bmNSZSA9IC9eKD86XFwofDx8Jmx0Oyk/KC4qPykoPzpcXC58LHxcXCl8XFxufCZndDspPyQvOyAvLyBmcm9tIGh0dHA6Ly9ibG9nLmdlcnYubmV0LzIwMTEvMDUvaHRtbDVfZW1haWxfYWRkcmVzc19yZWdleHAvXG5cbnZhciBlbWFpbFJlID0gL15bXFx3LiEjJCUmJyorXFwtXFwvPT9cXF5ge3x9fl0rQFthLXpcXGRcXC1dKyhcXC5bYS16XFxkXFwtXSspKyQvaTtcbnZhciBodHRwSHR0cHNSZSA9IC9eaHR0cHM/OlxcL1xcLy4qJC87XG52YXIgd3d3UmUgPSAvXnd3d1xcLi87XG52YXIgdGxkUmUgPSAvXFwuKD86b3JnfG5ldHxjb20pKD86XFw6fFxcL3wkKS87XG5cbmZ1bmN0aW9uIHVybGl6ZShzdHIsIGxlbmd0aCwgbm9mb2xsb3cpIHtcbiAgaWYgKGlzTmFOKGxlbmd0aCkpIHtcbiAgICBsZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHZhciBub0ZvbGxvd0F0dHIgPSBub2ZvbGxvdyA9PT0gdHJ1ZSA/ICcgcmVsPVwibm9mb2xsb3dcIicgOiAnJztcbiAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KC8oXFxzKykvKS5maWx0ZXIoZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAvLyBJZiB0aGUgd29yZCBoYXMgbm8gbGVuZ3RoLCBiYWlsLiBUaGlzIGNhbiBoYXBwZW4gZm9yIHN0ciB3aXRoXG4gICAgLy8gdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICByZXR1cm4gd29yZCAmJiB3b3JkLmxlbmd0aDtcbiAgfSkubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgdmFyIG1hdGNoZXMgPSB3b3JkLm1hdGNoKHB1bmNSZSk7XG4gICAgdmFyIHBvc3NpYmxlVXJsID0gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiB3b3JkO1xuICAgIHZhciBzaG9ydFVybCA9IHBvc3NpYmxlVXJsLnN1YnN0cigwLCBsZW5ndGgpOyAvLyB1cmwgdGhhdCBzdGFydHMgd2l0aCBodHRwIG9yIGh0dHBzXG5cbiAgICBpZiAoaHR0cEh0dHBzUmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgcG9zc2libGVVcmwgKyBcIlxcXCJcIiArIG5vRm9sbG93QXR0ciArIFwiPlwiICsgc2hvcnRVcmwgKyBcIjwvYT5cIjtcbiAgICB9IC8vIHVybCB0aGF0IHN0YXJ0cyB3aXRoIHd3dy5cblxuXG4gICAgaWYgKHd3d1JlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJodHRwOi8vXCIgKyBwb3NzaWJsZVVybCArIFwiXFxcIlwiICsgbm9Gb2xsb3dBdHRyICsgXCI+XCIgKyBzaG9ydFVybCArIFwiPC9hPlwiO1xuICAgIH0gLy8gYW4gZW1haWwgYWRkcmVzcyBvZiB0aGUgZm9ybSB1c2VybmFtZUBkb21haW4udGxkXG5cblxuICAgIGlmIChlbWFpbFJlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJtYWlsdG86XCIgKyBwb3NzaWJsZVVybCArIFwiXFxcIj5cIiArIHBvc3NpYmxlVXJsICsgXCI8L2E+XCI7XG4gICAgfSAvLyB1cmwgdGhhdCBlbmRzIGluIC5jb20sIC5vcmcgb3IgLm5ldCB0aGF0IGlzIG5vdCBhbiBlbWFpbCBhZGRyZXNzXG5cblxuICAgIGlmICh0bGRSZS50ZXN0KHBvc3NpYmxlVXJsKSkge1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiaHR0cDovL1wiICsgcG9zc2libGVVcmwgKyBcIlxcXCJcIiArIG5vRm9sbG93QXR0ciArIFwiPlwiICsgc2hvcnRVcmwgKyBcIjwvYT5cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gd29yZDtcbiAgfSk7XG4gIHJldHVybiB3b3Jkcy5qb2luKCcnKTtcbn1cblxuZXhwb3J0cy51cmxpemUgPSB1cmxpemU7XG5cbmZ1bmN0aW9uIHdvcmRjb3VudChzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICB2YXIgd29yZHMgPSBzdHIgPyBzdHIubWF0Y2goL1xcdysvZykgOiBudWxsO1xuICByZXR1cm4gd29yZHMgPyB3b3Jkcy5sZW5ndGggOiBudWxsO1xufVxuXG5leHBvcnRzLndvcmRjb3VudCA9IHdvcmRjb3VudDtcblxuZnVuY3Rpb24gZmxvYXQodmFsLCBkZWYpIHtcbiAgdmFyIHJlcyA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKHJlcykgPyBkZWYgOiByZXM7XG59XG5cbmV4cG9ydHMuZmxvYXQgPSBmbG9hdDtcblxuZnVuY3Rpb24gaW50KHZhbCwgZGVmKSB7XG4gIHZhciByZXMgPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgcmV0dXJuIGlzTmFOKHJlcykgPyBkZWYgOiByZXM7XG59XG5cbmV4cG9ydHMuaW50ID0gaW50OyAvLyBBbGlhc2VzXG5cbmV4cG9ydHMuZCA9IGV4cG9ydHMuZGVmYXVsdDtcbmV4cG9ydHMuZSA9IGV4cG9ydHMuZXNjYXBlO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgTG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFByZWNvbXBpbGVkTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFByZWNvbXBpbGVkTG9hZGVyLCBfTG9hZGVyKTtcblxuICBmdW5jdGlvbiBQcmVjb21waWxlZExvYWRlcihjb21waWxlZFRlbXBsYXRlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0xvYWRlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMucHJlY29tcGlsZWQgPSBjb21waWxlZFRlbXBsYXRlcyB8fCB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUHJlY29tcGlsZWRMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRTb3VyY2UgPSBmdW5jdGlvbiBnZXRTb3VyY2UobmFtZSkge1xuICAgIGlmICh0aGlzLnByZWNvbXBpbGVkW25hbWVdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcmM6IHtcbiAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgb2JqOiB0aGlzLnByZWNvbXBpbGVkW25hbWVdXG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFByZWNvbXBpbGVkTG9hZGVyO1xufShMb2FkZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJlY29tcGlsZWRMb2FkZXI6IFByZWNvbXBpbGVkTG9hZGVyXG59O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBTYWZlU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKS5TYWZlU3RyaW5nO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuXG5mdW5jdGlvbiBjYWxsYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnRzLmNhbGxhYmxlID0gY2FsbGFibGU7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaXMgc3RyaWN0bHkgbm90IGB1bmRlZmluZWRgLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy5kZWZpbmVkID0gZGVmaW5lZDtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgZGl2aXNibGUgYnkgdGhlIHRlc3QncyBhcmd1bWVudFxuICogKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBkaXZpc2libGVieShvbmUsIHR3bykge1xuICByZXR1cm4gb25lICUgdHdvID09PSAwO1xufVxuXG5leHBvcnRzLmRpdmlzaWJsZWJ5ID0gZGl2aXNpYmxlYnk7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBiZWVuIGVzY2FwZWQgKGkuZS4sIGlzIGEgU2FmZVN0cmluZykuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHJpbmc7XG59XG5cbmV4cG9ydHMuZXNjYXBlZCA9IGVzY2FwZWQ7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICogQHBhcmFtIHsgYW55IH0gb25lXG4gKiBAcGFyYW0geyBhbnkgfSB0d29cbiAqL1xuXG5mdW5jdGlvbiBlcXVhbHRvKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPT09IHR3bztcbn1cblxuZXhwb3J0cy5lcXVhbHRvID0gZXF1YWx0bzsgLy8gQWxpYXNlc1xuXG5leHBvcnRzLmVxID0gZXhwb3J0cy5lcXVhbHRvO1xuZXhwb3J0cy5zYW1lYXMgPSBleHBvcnRzLmVxdWFsdG87XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBldmVubHkgZGl2aXNpYmxlIGJ5IDIuXG4gKiBAcGFyYW0geyBudW1iZXIgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBldmVuKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAlIDIgPT09IDA7XG59XG5cbmV4cG9ydHMuZXZlbiA9IGV2ZW47XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBmYWxzeSAtIGlmIEkgcmVjYWxsIGNvcnJlY3RseSwgJycsIDAsIGZhbHNlLFxuICogdW5kZWZpbmVkLCBOYU4gb3IgbnVsbC4gSSBkb24ndCBrbm93IGlmIHdlIHNob3VsZCBzdGljayB0byB0aGUgZGVmYXVsdCBKU1xuICogYmVoYXZpb3Igb3IgYXR0ZW1wdCB0byByZXBsaWNhdGUgd2hhdCBQeXRob24gYmVsaWV2ZXMgc2hvdWxkIGJlIGZhbHN5IChpLmUuLFxuICogZW1wdHkgYXJyYXlzLCBlbXB0eSBkaWN0cywgbm90IDAuLi4pLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZmFsc3kodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZTtcbn1cblxuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSB0ZXN0J3NcbiAqIGFyZ3VtZW50ICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZ2Uob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA+PSB0d287XG59XG5cbmV4cG9ydHMuZ2UgPSBnZTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0ZXN0J3MgYXJndW1lbnRcbiAqICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZ3JlYXRlcnRoYW4ob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA+IHR3bztcbn1cblxuZXhwb3J0cy5ncmVhdGVydGhhbiA9IGdyZWF0ZXJ0aGFuOyAvLyBhbGlhc1xuXG5leHBvcnRzLmd0ID0gZXhwb3J0cy5ncmVhdGVydGhhbjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0ZXN0J3NcbiAqIGFyZ3VtZW50ICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbGUob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA8PSB0d287XG59XG5cbmV4cG9ydHMubGUgPSBsZTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgbGVzcyB0aGFuIHRoZSB0ZXN0J3MgcGFzc2VkIGFyZ3VtZW50XG4gKiAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGxlc3N0aGFuKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPCB0d287XG59XG5cbmV4cG9ydHMubGVzc3RoYW4gPSBsZXNzdGhhbjsgLy8gYWxpYXNcblxuZXhwb3J0cy5sdCA9IGV4cG9ydHMubGVzc3RoYW47XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzdHJpbmcgaXMgbG93ZXJjYXNlZC5cbiAqIEBwYXJhbSB7IHN0cmluZyB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGxvd2VyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZTtcbn1cblxuZXhwb3J0cy5sb3dlciA9IGxvd2VyO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRlc3Qnc1xuICogYXJndW1lbnQgKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBuZShvbmUsIHR3bykge1xuICByZXR1cm4gb25lICE9PSB0d287XG59XG5cbmV4cG9ydHMubmUgPSBuZTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBzdHJpY3RseSBlcXVhbCB0byBgbnVsbGAuXG4gKiBAcGFyYW0geyBhbnkgfVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBudWxsVGVzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbmV4cG9ydHMubnVsbCA9IG51bGxUZXN0O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0geyBhbnkgfVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgKm5vdCogZXZlbmx5IGRpdmlzaWJsZSBieSAyLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gb2RkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAlIDIgPT09IDE7XG59XG5cbmV4cG9ydHMub2RkID0gb2RkO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGBmYWxzZWAgaWYgbm90LlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiB0aGluZ3MgY29uc2lkZXJlZCBmYWxzeTpcbiAqICcnLCBudWxsLCB1bmRlZmluZWQsIDAsIE5hTiBhbmQgZmFsc2UuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWU7XG59XG5cbmV4cG9ydHMudHJ1dGh5ID0gdHJ1dGh5O1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gdW5kZWZpbmVkVGVzdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0cy51bmRlZmluZWQgPSB1bmRlZmluZWRUZXN0O1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyaW5nIGlzIHVwcGVyY2FzZWQuXG4gKiBAcGFyYW0geyBzdHJpbmcgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiB1cHBlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKSA9PT0gdmFsdWU7XG59XG5cbmV4cG9ydHMudXBwZXIgPSB1cHBlcjtcbi8qKlxuICogSWYgRVM2IGZlYXR1cmVzIGFyZSBhdmFpbGFibGUsIHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpbXBsZW1lbnRzIHRoZVxuICogYFN5bWJvbC5pdGVyYXRvcmAgbWV0aG9kLiBJZiBub3QsIGl0J3MgYSBzdHJpbmcgb3IgQXJyYXkuXG4gKlxuICogQ291bGQgcG90ZW50aWFsbHkgY2F1c2UgaXNzdWVzIGlmIGEgYnJvd3NlciBleGlzdHMgdGhhdCBoYXMgU2V0IGFuZCBNYXAgYnV0XG4gKiBub3QgU3ltYm9sLlxuICpcbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhYmxlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAhIXZhbHVlW1N5bWJvbC5pdGVyYXRvcl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gIH1cbn1cblxuZXhwb3J0cy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuLyoqXG4gKiBJZiBFUzYgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSwgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBoYXNoXG4gKiBvciBhbiBFUzYgTWFwLiBPdGhlcndpc2UganVzdCByZXR1cm4gaWYgaXQncyBhbiBvYmplY3QgaGFzaC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIG1hcHBpbmcodmFsdWUpIHtcbiAgLy8gb25seSBtYXBzIGFuZCBvYmplY3QgaGFzaGVzXG4gIHZhciBib29sID0gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuICBpZiAoU2V0KSB7XG4gICAgcmV0dXJuIGJvb2wgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFNldCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH1cbn1cblxuZXhwb3J0cy5tYXBwaW5nID0gbWFwcGluZztcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfY3ljbGVyKGl0ZW1zKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaW5kZXgrKztcblxuICAgICAgaWYgKGluZGV4ID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudCA9IGl0ZW1zW2luZGV4XTtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBfam9pbmVyKHNlcCkge1xuICBzZXAgPSBzZXAgfHwgJywnO1xuICB2YXIgZmlyc3QgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBmaXJzdCA/ICcnIDogc2VwO1xuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbn0gLy8gTWFraW5nIHRoaXMgYSBmdW5jdGlvbiBpbnN0ZWFkIHNvIGl0IHJldHVybnMgYSBuZXcgb2JqZWN0XG4vLyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuIFRoYXQgd2F5LCBpZiBzb21ldGhpbmcgbGlrZSBhbiBlbnZpcm9ubWVudFxuLy8gdXNlcyBpdCwgdGhleSB3aWxsIGVhY2ggaGF2ZSB0aGVpciBvd24gY29weS5cblxuXG5mdW5jdGlvbiBnbG9iYWxzKCkge1xuICByZXR1cm4ge1xuICAgIHJhbmdlOiBmdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgaWYgKHR5cGVvZiBzdG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKCFzdGVwKSB7XG4gICAgICAgIHN0ZXAgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICBhcnIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBzdGFydDsgX2kgPiBzdG9wOyBfaSArPSBzdGVwKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmb3ItZGlyZWN0aW9uXG4gICAgICAgICAgYXJyLnB1c2goX2kpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICBjeWNsZXI6IGZ1bmN0aW9uIGN5Y2xlcigpIHtcbiAgICAgIHJldHVybiBfY3ljbGVyKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgam9pbmVyOiBmdW5jdGlvbiBqb2luZXIoc2VwKSB7XG4gICAgICByZXR1cm4gX2pvaW5lcihzZXApO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxzO1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHByZXNzKGVudiwgYXBwKSB7XG4gIGZ1bmN0aW9uIE51bmp1Y2tzVmlldyhuYW1lLCBvcHRzKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnBhdGggPSBuYW1lO1xuICAgIHRoaXMuZGVmYXVsdEVuZ2luZSA9IG9wdHMuZGVmYXVsdEVuZ2luZTtcbiAgICB0aGlzLmV4dCA9IHBhdGguZXh0bmFtZShuYW1lKTtcblxuICAgIGlmICghdGhpcy5leHQgJiYgIXRoaXMuZGVmYXVsdEVuZ2luZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkZWZhdWx0IGVuZ2luZSB3YXMgc3BlY2lmaWVkIGFuZCBubyBleHRlbnNpb24gd2FzIHByb3ZpZGVkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5leHQpIHtcbiAgICAgIHRoaXMubmFtZSArPSB0aGlzLmV4dCA9ICh0aGlzLmRlZmF1bHRFbmdpbmVbMF0gIT09ICcuJyA/ICcuJyA6ICcnKSArIHRoaXMuZGVmYXVsdEVuZ2luZTtcbiAgICB9XG4gIH1cblxuICBOdW5qdWNrc1ZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihvcHRzLCBjYikge1xuICAgIGVudi5yZW5kZXIodGhpcy5uYW1lLCBvcHRzLCBjYik7XG4gIH07XG5cbiAgYXBwLnNldCgndmlldycsIE51bmp1Y2tzVmlldyk7XG4gIGFwcC5zZXQoJ251bmp1Y2tzRW52JywgZW52KTtcbiAgcmV0dXJuIGVudjtcbn07XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGZzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIF9wcmV0dGlmeUVycm9yID0gX3JlcXVpcmUuX3ByZXR0aWZ5RXJyb3I7XG5cbnZhciBjb21waWxlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLFxuICAgIEVudmlyb25tZW50ID0gX3JlcXVpcmUyLkVudmlyb25tZW50O1xuXG52YXIgcHJlY29tcGlsZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5mdW5jdGlvbiBtYXRjaChmaWxlbmFtZSwgcGF0dGVybnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm5zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJucy5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZpbGVuYW1lLm1hdGNoKHBhdHRlcm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlY29tcGlsZVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMuaXNTdHJpbmcgPSB0cnVlO1xuICB2YXIgZW52ID0gb3B0cy5lbnYgfHwgbmV3IEVudmlyb25tZW50KFtdKTtcbiAgdmFyIHdyYXBwZXIgPSBvcHRzLndyYXBwZXIgfHwgcHJlY29tcGlsZUdsb2JhbDtcblxuICBpZiAoIW9wdHMubmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGhlIFwibmFtZVwiIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIGNvbXBpbGluZyBhIHN0cmluZycpO1xuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXIoW19wcmVjb21waWxlKHN0ciwgb3B0cy5uYW1lLCBlbnYpXSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGUoaW5wdXQsIG9wdHMpIHtcbiAgLy8gVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhdmFpbGFibGU6XG4gIC8vXG4gIC8vICogbmFtZTogbmFtZSBvZiB0aGUgdGVtcGxhdGUgKGF1dG8tZ2VuZXJhdGVkIHdoZW4gY29tcGlsaW5nIGEgZGlyZWN0b3J5KVxuICAvLyAqIGlzU3RyaW5nOiBpbnB1dCBpcyBhIHN0cmluZywgbm90IGEgZmlsZSBwYXRoXG4gIC8vICogYXNGdW5jdGlvbjogZ2VuZXJhdGUgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAvLyAqIGZvcmNlOiBrZWVwIGNvbXBpbGluZyBvbiBlcnJvclxuICAvLyAqIGVudjogdGhlIEVudmlyb25tZW50IHRvIHVzZSAoZ2V0cyBleHRlbnNpb25zIGFuZCBhc3luYyBmaWx0ZXJzIGZyb20gaXQpXG4gIC8vICogaW5jbHVkZTogd2hpY2ggZmlsZS9mb2xkZXJzIHRvIGluY2x1ZGUgKGZvbGRlcnMgYXJlIGF1dG8taW5jbHVkZWQsIGZpbGVzIGFyZSBhdXRvLWV4Y2x1ZGVkKVxuICAvLyAqIGV4Y2x1ZGU6IHdoaWNoIGZpbGUvZm9sZGVycyB0byBleGNsdWRlIChmb2xkZXJzIGFyZSBhdXRvLWluY2x1ZGVkLCBmaWxlcyBhcmUgYXV0by1leGNsdWRlZClcbiAgLy8gKiB3cmFwcGVyOiBmdW5jdGlvbih0ZW1wbGF0ZXMsIG9wdHMpIHsuLi59XG4gIC8vICAgICAgIEN1c3RvbWl6ZSB0aGUgb3V0cHV0IGZvcm1hdCB0byBzdG9yZSB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gIC8vICAgICAgIEJ5IGRlZmF1bHQsIHRlbXBsYXRlcyBhcmUgc3RvcmVkIGluIGEgZ2xvYmFsIHZhcmlhYmxlIHVzZWQgYnkgdGhlIHJ1bnRpbWUuXG4gIC8vICAgICAgIEEgY3VzdG9tIGxvYWRlciB3aWxsIGJlIG5lY2Vzc2FyeSB0byBsb2FkIHlvdXIgY3VzdG9tIHdyYXBwZXIuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgZW52ID0gb3B0cy5lbnYgfHwgbmV3IEVudmlyb25tZW50KFtdKTtcbiAgdmFyIHdyYXBwZXIgPSBvcHRzLndyYXBwZXIgfHwgcHJlY29tcGlsZUdsb2JhbDtcblxuICBpZiAob3B0cy5pc1N0cmluZykge1xuICAgIHJldHVybiBwcmVjb21waWxlU3RyaW5nKGlucHV0LCBvcHRzKTtcbiAgfVxuXG4gIHZhciBwYXRoU3RhdHMgPSBmcy5leGlzdHNTeW5jKGlucHV0KSAmJiBmcy5zdGF0U3luYyhpbnB1dCk7XG4gIHZhciBwcmVjb21waWxlZCA9IFtdO1xuICB2YXIgdGVtcGxhdGVzID0gW107XG5cbiAgZnVuY3Rpb24gYWRkVGVtcGxhdGVzKGRpcikge1xuICAgIGZzLnJlYWRkaXJTeW5jKGRpcikuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgdmFyIGZpbGVwYXRoID0gcGF0aC5qb2luKGRpciwgZmlsZSk7XG4gICAgICB2YXIgc3VicGF0aCA9IGZpbGVwYXRoLnN1YnN0cihwYXRoLmpvaW4oaW5wdXQsICcvJykubGVuZ3RoKTtcbiAgICAgIHZhciBzdGF0ID0gZnMuc3RhdFN5bmMoZmlsZXBhdGgpO1xuXG4gICAgICBpZiAoc3RhdCAmJiBzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgc3VicGF0aCArPSAnLyc7XG5cbiAgICAgICAgaWYgKCFtYXRjaChzdWJwYXRoLCBvcHRzLmV4Y2x1ZGUpKSB7XG4gICAgICAgICAgYWRkVGVtcGxhdGVzKGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXRjaChzdWJwYXRoLCBvcHRzLmluY2x1ZGUpKSB7XG4gICAgICAgIHRlbXBsYXRlcy5wdXNoKGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXRoU3RhdHMuaXNGaWxlKCkpIHtcbiAgICBwcmVjb21waWxlZC5wdXNoKF9wcmVjb21waWxlKGZzLnJlYWRGaWxlU3luYyhpbnB1dCwgJ3V0Zi04JyksIG9wdHMubmFtZSB8fCBpbnB1dCwgZW52KSk7XG4gIH0gZWxzZSBpZiAocGF0aFN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBhZGRUZW1wbGF0ZXMoaW5wdXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gdGVtcGxhdGVzW2ldLnJlcGxhY2UocGF0aC5qb2luKGlucHV0LCAnLycpLCAnJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHByZWNvbXBpbGVkLnB1c2goX3ByZWNvbXBpbGUoZnMucmVhZEZpbGVTeW5jKHRlbXBsYXRlc1tpXSwgJ3V0Zi04JyksIG5hbWUsIGVudikpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAob3B0cy5mb3JjZSkge1xuICAgICAgICAgIC8vIERvbid0IHN0b3AgZ2VuZXJhdGluZyB0aGUgb3V0cHV0IGlmIHdlJ3JlXG4gICAgICAgICAgLy8gZm9yY2luZyBjb21waWxhdGlvbi5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXIocHJlY29tcGlsZWQsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBfcHJlY29tcGlsZShzdHIsIG5hbWUsIGVudikge1xuICBlbnYgPSBlbnYgfHwgbmV3IEVudmlyb25tZW50KFtdKTtcbiAgdmFyIGFzeW5jRmlsdGVycyA9IGVudi5hc3luY0ZpbHRlcnM7XG4gIHZhciBleHRlbnNpb25zID0gZW52LmV4dGVuc2lvbnNMaXN0O1xuICB2YXIgdGVtcGxhdGU7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcblxuICB0cnkge1xuICAgIHRlbXBsYXRlID0gY29tcGlsZXIuY29tcGlsZShzdHIsIGFzeW5jRmlsdGVycywgZXh0ZW5zaW9ucywgbmFtZSwgZW52Lm9wdHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBfcHJldHRpZnlFcnJvcihuYW1lLCBmYWxzZSwgZXJyKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICB0ZW1wbGF0ZTogdGVtcGxhdGVcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZWNvbXBpbGU6IHByZWNvbXBpbGUsXG4gIHByZWNvbXBpbGVTdHJpbmc6IHByZWNvbXBpbGVTdHJpbmdcbn07XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gcHJlY29tcGlsZUdsb2JhbCh0ZW1wbGF0ZXMsIG9wdHMpIHtcbiAgdmFyIG91dCA9ICcnO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBsYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gSlNPTi5zdHJpbmdpZnkodGVtcGxhdGVzW2ldLm5hbWUpO1xuICAgIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1tpXS50ZW1wbGF0ZTtcbiAgICBvdXQgKz0gJyhmdW5jdGlvbigpIHsnICsgJyh3aW5kb3cubnVuanVja3NQcmVjb21waWxlZCA9IHdpbmRvdy5udW5qdWNrc1ByZWNvbXBpbGVkIHx8IHt9KScgKyAnWycgKyBuYW1lICsgJ10gPSAoZnVuY3Rpb24oKSB7XFxuJyArIHRlbXBsYXRlICsgJ1xcbn0pKCk7XFxuJztcblxuICAgIGlmIChvcHRzLmFzRnVuY3Rpb24pIHtcbiAgICAgIG91dCArPSAncmV0dXJuIGZ1bmN0aW9uKGN0eCwgY2IpIHsgcmV0dXJuIG51bmp1Y2tzLnJlbmRlcignICsgbmFtZSArICcsIGN0eCwgY2IpOyB9XFxuJztcbiAgICB9XG5cbiAgICBvdXQgKz0gJ30pKCk7XFxuJztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlY29tcGlsZUdsb2JhbDtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcGF0KCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAvLyBUaGlzIG11c3QgYmUgY2FsbGVkIGxpa2UgYG51bmp1Y2tzLmluc3RhbGxDb21wYXRgIHNvIHRoYXQgYHRoaXNgXG4gIC8vIHJlZmVyZW5jZXMgdGhlIG51bmp1Y2tzIGluc3RhbmNlXG5cbiAgdmFyIHJ1bnRpbWUgPSB0aGlzLnJ1bnRpbWU7XG4gIHZhciBsaWIgPSB0aGlzLmxpYjsgLy8gSGFuZGxlIHNsaW0gY2FzZSB3aGVyZSB0aGVzZSAnbW9kdWxlcycgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGJ1aWx0IHNvdXJjZVxuXG4gIHZhciBDb21waWxlciA9IHRoaXMuY29tcGlsZXIuQ29tcGlsZXI7XG4gIHZhciBQYXJzZXIgPSB0aGlzLnBhcnNlci5QYXJzZXI7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBsZXhlciA9IHRoaXMubGV4ZXI7XG4gIHZhciBvcmlnX2NvbnRleHRPckZyYW1lTG9va3VwID0gcnVudGltZS5jb250ZXh0T3JGcmFtZUxvb2t1cDtcbiAgdmFyIG9yaWdfbWVtYmVyTG9va3VwID0gcnVudGltZS5tZW1iZXJMb29rdXA7XG4gIHZhciBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGU7XG4gIHZhciBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZTtcblxuICBpZiAoQ29tcGlsZXIpIHtcbiAgICBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGUgPSBDb21waWxlci5wcm90b3R5cGUuYXNzZXJ0VHlwZTtcbiAgfVxuXG4gIGlmIChQYXJzZXIpIHtcbiAgICBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZSA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VBZ2dyZWdhdGU7XG4gIH1cblxuICBmdW5jdGlvbiB1bmluc3RhbGwoKSB7XG4gICAgcnVudGltZS5jb250ZXh0T3JGcmFtZUxvb2t1cCA9IG9yaWdfY29udGV4dE9yRnJhbWVMb29rdXA7XG4gICAgcnVudGltZS5tZW1iZXJMb29rdXAgPSBvcmlnX21lbWJlckxvb2t1cDtcblxuICAgIGlmIChDb21waWxlcikge1xuICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmFzc2VydFR5cGUgPSBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGU7XG4gICAgfVxuXG4gICAgaWYgKFBhcnNlcikge1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFnZ3JlZ2F0ZSA9IG9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlO1xuICAgIH1cbiAgfVxuXG4gIHJ1bnRpbWUuY29udGV4dE9yRnJhbWVMb29rdXAgPSBmdW5jdGlvbiBjb250ZXh0T3JGcmFtZUxvb2t1cChjb250ZXh0LCBmcmFtZSwga2V5KSB7XG4gICAgdmFyIHZhbCA9IG9yaWdfY29udGV4dE9yRnJhbWVMb29rdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnVHJ1ZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlICdGYWxzZSc6XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSAnTm9uZSc6XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUb2tlbnNTdGF0ZSh0b2tlbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IHRva2Vucy5pbmRleCxcbiAgICAgIGxpbmVubzogdG9rZW5zLmxpbmVubyxcbiAgICAgIGNvbG5vOiB0b2tlbnMuY29sbm9cbiAgICB9O1xuICB9XG5cbiAgaWYgKFwiU1REXCIgIT09ICdTTElNJyAmJiBub2RlcyAmJiBDb21waWxlciAmJiBQYXJzZXIpIHtcbiAgICAvLyBpLmUuLCBub3Qgc2xpbSBtb2RlXG4gICAgdmFyIFNsaWNlID0gbm9kZXMuTm9kZS5leHRlbmQoJ1NsaWNlJywge1xuICAgICAgZmllbGRzOiBbJ3N0YXJ0JywgJ3N0b3AnLCAnc3RlcCddLFxuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdChsaW5lbm8sIGNvbG5vLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IG5ldyBub2Rlcy5MaXRlcmFsKGxpbmVubywgY29sbm8sIG51bGwpO1xuICAgICAgICBzdG9wID0gc3RvcCB8fCBuZXcgbm9kZXMuTGl0ZXJhbChsaW5lbm8sIGNvbG5vLCBudWxsKTtcbiAgICAgICAgc3RlcCA9IHN0ZXAgfHwgbmV3IG5vZGVzLkxpdGVyYWwobGluZW5vLCBjb2xubywgMSk7XG4gICAgICAgIHRoaXMucGFyZW50KGxpbmVubywgY29sbm8sIHN0YXJ0LCBzdG9wLCBzdGVwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIENvbXBpbGVyLnByb3RvdHlwZS5hc3NlcnRUeXBlID0gZnVuY3Rpb24gYXNzZXJ0VHlwZShub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNsaWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3JpZ19Db21waWxlcl9hc3NlcnRUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlU2xpY2UgPSBmdW5jdGlvbiBjb21waWxlU2xpY2Uobm9kZSwgZnJhbWUpIHtcbiAgICAgIHRoaXMuX2VtaXQoJygnKTtcblxuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5zdGFydCwgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0KCcpLCgnKTtcblxuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5zdG9wLCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJyksKCcpO1xuXG4gICAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnN0ZXAsIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdCgnKScpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWdncmVnYXRlID0gZnVuY3Rpb24gcGFyc2VBZ2dyZWdhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3JpZ1N0YXRlID0gZ2V0VG9rZW5zU3RhdGUodGhpcy50b2tlbnMpOyAvLyBTZXQgYmFjayBvbmUgYWNjb3VudGluZyBmb3Igb3BlbmluZyBicmFja2V0L3BhcmVuc1xuXG4gICAgICBvcmlnU3RhdGUuY29sbm8tLTtcbiAgICAgIG9yaWdTdGF0ZS5pbmRleC0tO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZ19QYXJzZXJfcGFyc2VBZ2dyZWdhdGUuYXBwbHkodGhpcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBlcnJTdGF0ZSA9IGdldFRva2Vuc1N0YXRlKHRoaXMudG9rZW5zKTtcblxuICAgICAgICB2YXIgcmV0aHJvdyA9IGZ1bmN0aW9uIHJldGhyb3coKSB7XG4gICAgICAgICAgbGliLl9hc3NpZ24oX3RoaXMudG9rZW5zLCBlcnJTdGF0ZSk7XG5cbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTsgLy8gUmVzZXQgdG8gc3RhdGUgYmVmb3JlIG9yaWdpbmFsIHBhcnNlQWdncmVnYXRlIGNhbGxlZFxuXG5cbiAgICAgICAgbGliLl9hc3NpZ24odGhpcy50b2tlbnMsIG9yaWdTdGF0ZSk7XG5cbiAgICAgICAgdGhpcy5wZWVrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICAgICAgaWYgKHRvay50eXBlICE9PSBsZXhlci5UT0tFTl9MRUZUX0JSQUNLRVQpIHtcbiAgICAgICAgICB0aHJvdyByZXRocm93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gbmV3IFNsaWNlKHRvay5saW5lbm8sIHRvay5jb2xubyk7IC8vIElmIHdlIGRvbid0IGVuY291bnRlciBhIGNvbG9uIHdoaWxlIHBhcnNpbmcsIHRoaXMgaXMgbm90IGEgc2xpY2UsXG4gICAgICAgIC8vIHNvIHJlLXJhaXNlIHRoZSBvcmlnaW5hbCBleGNlcHRpb24uXG5cbiAgICAgICAgdmFyIGlzU2xpY2UgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBub2RlLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fUklHSFRfQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID09PSBub2RlLmZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc1NsaWNlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VTbGljZTogdG9vIG1hbnkgc2xpY2UgY29tcG9uZW50cycsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTE9OKSkge1xuICAgICAgICAgICAgaXNTbGljZSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG5vZGUuZmllbGRzW2ldO1xuICAgICAgICAgICAgbm9kZVtmaWVsZF0gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgaXNTbGljZSA9IHRoaXMuc2tpcChsZXhlci5UT0tFTl9DT0xPTikgfHwgaXNTbGljZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU2xpY2UpIHtcbiAgICAgICAgICB0aHJvdyByZXRocm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLkFycmF5KHRvay5saW5lbm8sIHRvay5jb2xubywgW25vZGVdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpY2VMb29rdXAob2JqLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIG9iaiA9IG9iaiB8fCBbXTtcblxuICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSBzdGVwIDwgMCA/IG9iai5sZW5ndGggLSAxIDogMDtcbiAgICB9XG5cbiAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0ZXAgPCAwID8gLTEgOiBvYmoubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoc3RvcCA8IDApIHtcbiAgICAgIHN0b3AgKz0gb2JqLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCArPSBvYmoubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7OyBpICs9IHN0ZXApIHtcbiAgICAgIGlmIChpIDwgMCB8fCBpID4gb2JqLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgPiAwICYmIGkgPj0gc3RvcCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgPCAwICYmIGkgPD0gc3RvcCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVzdWx0cy5wdXNoKHJ1bnRpbWUubWVtYmVyTG9va3VwKG9iaiwgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG5cbiAgdmFyIEFSUkFZX01FTUJFUlMgPSB7XG4gICAgcG9wOiBmdW5jdGlvbiBwb3AoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGggfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5RXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9LFxuICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2goZWxlbWVudCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZUVycm9yJyk7XG4gICAgfSxcbiAgICBjb3VudDogZnVuY3Rpb24gY291bnQoZWxlbWVudCkge1xuICAgICAgdmFyIGNvdW50ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcbiAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgoZWxlbWVudCkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICgoaSA9IHRoaXMuaW5kZXhPZihlbGVtZW50KSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWVFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9LFxuICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGluZGV4LCBlbGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDAsIGVsZW0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIE9CSkVDVF9NRU1CRVJTID0ge1xuICAgIGl0ZW1zOiBmdW5jdGlvbiBpdGVtcygpIHtcbiAgICAgIHJldHVybiBsaWIuX2VudHJpZXModGhpcyk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICAgIHJldHVybiBsaWIuX3ZhbHVlcyh0aGlzKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gbGliLmtleXModGhpcyk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXksIGRlZikge1xuICAgICAgdmFyIG91dHB1dCA9IHRoaXNba2V5XTtcblxuICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dCA9IGRlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIGhhc19rZXk6IGZ1bmN0aW9uIGhhc19rZXkoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzT3duUHJvcCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgcG9wOiBmdW5jdGlvbiBwb3Aoa2V5LCBkZWYpIHtcbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzW2tleV07XG5cbiAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCAmJiBkZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQgPSBkZWY7XG4gICAgICB9IGVsc2UgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5RXJyb3InKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICBwb3BpdGVtOiBmdW5jdGlvbiBwb3BpdGVtKCkge1xuICAgICAgdmFyIGtleXMgPSBsaWIua2V5cyh0aGlzKTtcblxuICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleUVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrID0ga2V5c1swXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzW2tdO1xuICAgICAgZGVsZXRlIHRoaXNba107XG4gICAgICByZXR1cm4gW2ssIHZhbF07XG4gICAgfSxcbiAgICBzZXRkZWZhdWx0OiBmdW5jdGlvbiBzZXRkZWZhdWx0KGtleSwgZGVmKSB7XG4gICAgICBpZiAoZGVmID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVmID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGRlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNba2V5XTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGt3YXJncykge1xuICAgICAgbGliLl9hc3NpZ24odGhpcywga3dhcmdzKTtcblxuICAgICAgcmV0dXJuIG51bGw7IC8vIEFsd2F5cyByZXR1cm5zIE5vbmVcbiAgICB9XG4gIH07XG4gIE9CSkVDVF9NRU1CRVJTLml0ZXJpdGVtcyA9IE9CSkVDVF9NRU1CRVJTLml0ZW1zO1xuICBPQkpFQ1RfTUVNQkVSUy5pdGVydmFsdWVzID0gT0JKRUNUX01FTUJFUlMudmFsdWVzO1xuICBPQkpFQ1RfTUVNQkVSUy5pdGVya2V5cyA9IE9CSkVDVF9NRU1CRVJTLmtleXM7XG5cbiAgcnVudGltZS5tZW1iZXJMb29rdXAgPSBmdW5jdGlvbiBtZW1iZXJMb29rdXAob2JqLCB2YWwsIGF1dG9lc2NhcGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIHNsaWNlTG9va3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgb2JqID0gb2JqIHx8IHt9OyAvLyBJZiB0aGUgb2JqZWN0IGlzIGFuIG9iamVjdCwgcmV0dXJuIGFueSBvZiB0aGUgbWV0aG9kcyB0aGF0IFB5dGhvbiB3b3VsZFxuICAgIC8vIG90aGVyd2lzZSBwcm92aWRlLlxuXG4gICAgaWYgKGxpYi5pc0FycmF5KG9iaikgJiYgaGFzT3duUHJvcChBUlJBWV9NRU1CRVJTLCB2YWwpKSB7XG4gICAgICByZXR1cm4gQVJSQVlfTUVNQkVSU1t2YWxdLmJpbmQob2JqKTtcbiAgICB9XG5cbiAgICBpZiAobGliLmlzT2JqZWN0KG9iaikgJiYgaGFzT3duUHJvcChPQkpFQ1RfTUVNQkVSUywgdmFsKSkge1xuICAgICAgcmV0dXJuIE9CSkVDVF9NRU1CRVJTW3ZhbF0uYmluZChvYmopO1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnX21lbWJlckxvb2t1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHJldHVybiB1bmluc3RhbGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFsbENvbXBhdDtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW5qdWNrcy5qcy5tYXAiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUmVzb25hbmNlQXVkaW8gbGlicmFyeSBjb21tb24gdXRpbGl0aWVzLCBtYXRoZW1hdGljYWwgY29uc3RhbnRzLFxuICogYW5kIGRlZmF1bHQgdmFsdWVzLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLyoqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBkZXNjcmlwdGlvbiBBIHNldCBvZiBkZWZhdWx0cywgY29uc3RhbnRzIGFuZCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gVXRpbHMoKSB7fTtcblxuXG4vKipcbiAqIERlZmF1bHQgaW5wdXQgZ2FpbiAobGluZWFyKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfU09VUkNFX0dBSU4gPSAxO1xuXG5cbi8qKlxuICogTWF4aW11bSBvdXRzaWRlLXRoZS1yb29tIGRpc3RhbmNlIHRvIGF0dGVudWF0ZSBmYXItZmllbGQgbGlzdGVuZXIgYnkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5MSVNURU5FUl9NQVhfT1VUU0lERV9ST09NX0RJU1RBTkNFID0gMTtcblxuXG4vKipcbiAqIE1heGltdW0gb3V0c2lkZS10aGUtcm9vbSBkaXN0YW5jZSB0byBhdHRlbnVhdGUgZmFyLWZpZWxkIHNvdXJjZXMgYnkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5TT1VSQ0VfTUFYX09VVFNJREVfUk9PTV9ESVNUQU5DRSA9IDE7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGRpc3RhbmNlIGZyb20gbGlzdGVuZXIgd2hlbiBzZXR0aW5nIGFuZ2xlLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9TT1VSQ0VfRElTVEFOQ0UgPSAxO1xuXG5cbi8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xuVXRpbHMuREVGQVVMVF9QT1NJVElPTiA9IFswLCAwLCAwXTtcblxuXG4vKiogQHR5cGUge0Zsb2F0MzJBcnJheX0gKi9cblV0aWxzLkRFRkFVTFRfRk9SV0FSRCA9IFswLCAwLCAtMV07XG5cblxuLyoqIEB0eXBlIHtGbG9hdDMyQXJyYXl9ICovXG5VdGlscy5ERUZBVUxUX1VQID0gWzAsIDEsIDBdO1xuXG5cbi8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xuVXRpbHMuREVGQVVMVF9SSUdIVCA9IFsxLCAwLCAwXTtcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQgPSAzNDM7XG5cblxuLyoqIFJvbGxvZmYgbW9kZWxzIChlLmcuICdsb2dhcml0aG1pYycsICdsaW5lYXInLCBvciAnbm9uZScpLlxuICogQHR5cGUge0FycmF5fVxuICovXG5VdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyA9IFsnbG9nYXJpdGhtaWMnLCAnbGluZWFyJywgJ25vbmUnXTtcblxuXG4vKiogRGVmYXVsdCByb2xsb2ZmIG1vZGVsICgnbG9nYXJpdGhtaWMnKS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRiA9ICdsb2dhcml0aG1pYyc7XG5cblxuLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG5VdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRSA9IDE7XG5cblxuLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG5VdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRSA9IDEwMDA7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhbHBoYSAoaS5lLiBtaWNyb3Bob25lIHBhdHRlcm4pLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQSA9IDA7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBwYXR0ZXJuIHNoYXJwbmVzcyAoaS5lLiBwYXR0ZXJuIGV4cG9uZW50KS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTID0gMTtcblxuXG4vKipcbiAqIERlZmF1bHQgYXppbXV0aCAoaW4gZGVncmVlcykuIFN1aXRhYmxlIHJhbmdlIGlzIDAgdG8gMzYwLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9BWklNVVRIID0gMDtcblxuXG4vKipcbiAqIERlZmF1bHQgZWxldmF0aW9uIChpbiBkZWdyZXMpLlxuICogU3VpdGFibGUgcmFuZ2UgaXMgZnJvbSAtOTAgKGJlbG93KSB0byA5MCAoYWJvdmUpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9FTEVWQVRJT04gPSAwO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYW1iaXNvbmljIG9yZGVyLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVIgPSAxO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc291cmNlIHdpZHRoLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEggPSAwO1xuXG5cbi8qKlxuICogVGhlIG1heGltdW0gZGVsYXkgKGluIHNlY29uZHMpIG9mIGEgc2luZ2xlIHdhbGwgcmVmbGVjdGlvbi5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NQVhfRFVSQVRJT04gPSAwLjU7XG5cblxuLyoqXG4gKiBUaGUgLTEyZEIgY3V0b2ZmIGZyZXF1ZW5jeSAoaW4gSGVydHopIGZvciB0aGUgbG93cGFzcyBmaWx0ZXIgYXBwbGllZCB0b1xuICogYWxsIHJlZmxlY3Rpb25zLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NVVE9GRl9GUkVRVUVOQ1kgPSA2NDAwOyAvLyBVc2VzIC0xMmRCIGN1dG9mZi5cblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHJlZmxlY3Rpb24gY29lZmZpY2llbnRzICh3aGVyZSAwID0gbm8gcmVmbGVjdGlvbiwgMSA9IHBlcmZlY3RcbiAqIHJlZmxlY3Rpb24sIC0xID0gbWlycm9yZWQgcmVmbGVjdGlvbiAoMTgwLWRlZ3JlZXMgb3V0IG9mIHBoYXNlKSkuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTID0ge1xuICBsZWZ0OiAwLCByaWdodDogMCwgZnJvbnQ6IDAsIGJhY2s6IDAsIGRvd246IDAsIHVwOiAwLFxufTtcblxuXG4vKipcbiAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIHdlIGNvbnNpZGVyIHRoZSBsaXN0ZW5lciB0byBiZSB0byBhbnkgZ2l2ZW4gd2FsbC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UgPSAxO1xuXG5cbi8qKlxuICogRGVmYXVsdCByb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyA9IHtcbiAgd2lkdGg6IDAsIGhlaWdodDogMCwgZGVwdGg6IDAsXG59O1xuXG5cbi8qKlxuICogVGhlIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gZGlzdGFuY2VzIGZyb20gdGhlIGxpc3RlbmVyIHRvIGVhY2ggd2FsbC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSID0gMTtcblxuXG4vKiogVGhlIGRlZmF1bHQgYmFuZHdpZHRoIChpbiBvY3RhdmVzKSBvZiB0aGUgY2VudGVyIGZyZXF1ZW5jaWVzLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfQkFORFdJRFRIID0gMTtcblxuXG4vKiogVGhlIGRlZmF1bHQgbXVsdGlwbGllciBhcHBsaWVkIHdoZW4gY29tcHV0aW5nIHRhaWwgbGVuZ3Rocy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX0RVUkFUSU9OX01VTFRJUExJRVIgPSAxO1xuXG5cbi8qKlxuICogVGhlIGxhdGUgcmVmbGVjdGlvbnMgcHJlLWRlbGF5IChpbiBtaWxsaXNlY29uZHMpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfUFJFREVMQVkgPSAxLjU7XG5cblxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGltcHVsc2UgcmVzcG9uc2UgdG8gYXBwbHkgYVxuICogaGFsZi1IYW5uIHdpbmRvdyB0by5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX1RBSUxfT05TRVQgPSAzLjg7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBnYWluIChsaW5lYXIpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfR0FJTiA9IDAuMDE7XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBpbXB1bHNlIHJlc3BvbnNlIGxlbmd0aCAoaW4gc2Vjb25kcykuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9NQVhfRFVSQVRJT04gPSAzO1xuXG5cbi8qKlxuICogQ2VudGVyIGZyZXF1ZW5jaWVzIG9mIHRoZSBtdWx0aWJhbmQgbGF0ZSByZWZsZWN0aW9ucy5cbiAqIE5pbmUgYmFuZHMgYXJlIGNvbXB1dGVkIGJ5OiAzMS4yNSAqIDJeKDA6OCkuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUyA9IFtcbiAgMzEuMjUsIDYyLjUsIDEyNSwgMjUwLCA1MDAsIDEwMDAsIDIwMDAsIDQwMDAsIDgwMDAsXG5dO1xuXG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBmcmVxdWVuY3kgYmFuZHMuXG4gKi9cblV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTID1cbiAgVXRpbHMuREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTLmxlbmd0aDtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG11bHRpYmFuZCBSVDYwIGR1cmF0aW9ucyAoaW4gc2Vjb25kcykuXG4gKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9EVVJBVElPTlMgPVxuICBuZXcgRmxvYXQzMkFycmF5KFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTKTtcblxuXG4vKipcbiAqIFByZS1kZWZpbmVkIGZyZXF1ZW5jeS1kZXBlbmRlbnQgYWJzb3JwdGlvbiBjb2VmZmljaWVudHMgZm9yIGxpc3RlZCBtYXRlcmlhbHMuXG4gKiBDdXJyZW50bHkgc3VwcG9ydGVkIG1hdGVyaWFscyBhcmU6XG4gKiA8dWw+XG4gKiA8bGk+J3RyYW5zcGFyZW50JzwvbGk+XG4gKiA8bGk+J2Fjb3VzdGljLWNlaWxpbmctdGlsZXMnPC9saT5cbiAqIDxsaT4nYnJpY2stYmFyZSc8L2xpPlxuICogPGxpPidicmljay1wYWludGVkJzwvbGk+XG4gKiA8bGk+J2NvbmNyZXRlLWJsb2NrLWNvYXJzZSc8L2xpPlxuICogPGxpPidjb25jcmV0ZS1ibG9jay1wYWludGVkJzwvbGk+XG4gKiA8bGk+J2N1cnRhaW4taGVhdnknPC9saT5cbiAqIDxsaT4nZmliZXItZ2xhc3MtaW5zdWxhdGlvbic8L2xpPlxuICogPGxpPidnbGFzcy10aGluJzwvbGk+XG4gKiA8bGk+J2dsYXNzLXRoaWNrJzwvbGk+XG4gKiA8bGk+J2dyYXNzJzwvbGk+XG4gKiA8bGk+J2xpbm9sZXVtLW9uLWNvbmNyZXRlJzwvbGk+XG4gKiA8bGk+J21hcmJsZSc8L2xpPlxuICogPGxpPidtZXRhbCc8L2xpPlxuICogPGxpPidwYXJxdWV0LW9uLWNvbmNyZXRlJzwvbGk+XG4gKiA8bGk+J3BsYXN0ZXItc21vb3RoJzwvbGk+XG4gKiA8bGk+J3BseXdvb2QtcGFuZWwnPC9saT5cbiAqIDxsaT4ncG9saXNoZWQtY29uY3JldGUtb3ItdGlsZSc8L2xpPlxuICogPGxpPidzaGVldHJvY2snPC9saT5cbiAqIDxsaT4nd2F0ZXItb3ItaWNlLXN1cmZhY2UnPC9saT5cbiAqIDxsaT4nd29vZC1jZWlsaW5nJzwvbGk+XG4gKiA8bGk+J3dvb2QtcGFuZWwnPC9saT5cbiAqIDxsaT4ndW5pZm9ybSc8L2xpPlxuICogPC91bD5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxzLlJPT01fTUFURVJJQUxfQ09FRkZJQ0lFTlRTID0ge1xuICAndHJhbnNwYXJlbnQnOlxuICBbMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMF0sXG4gICdhY291c3RpYy1jZWlsaW5nLXRpbGVzJzpcbiAgWzAuNjcyLCAwLjY3NSwgMC43MDAsIDAuNjYwLCAwLjcyMCwgMC45MjAsIDAuODgwLCAwLjc1MCwgMS4wMDBdLFxuICAnYnJpY2stYmFyZSc6XG4gIFswLjAzMCwgMC4wMzAsIDAuMDMwLCAwLjAzMCwgMC4wMzAsIDAuMDQwLCAwLjA1MCwgMC4wNzAsIDAuMTQwXSxcbiAgJ2JyaWNrLXBhaW50ZWQnOlxuICBbMC4wMDYsIDAuMDA3LCAwLjAxMCwgMC4wMTAsIDAuMDIwLCAwLjAyMCwgMC4wMjAsIDAuMDMwLCAwLjA2MF0sXG4gICdjb25jcmV0ZS1ibG9jay1jb2Fyc2UnOlxuICBbMC4zNjAsIDAuMzYwLCAwLjM2MCwgMC40NDAsIDAuMzEwLCAwLjI5MCwgMC4zOTAsIDAuMjUwLCAwLjUwMF0sXG4gICdjb25jcmV0ZS1ibG9jay1wYWludGVkJzpcbiAgWzAuMDkyLCAwLjA5MCwgMC4xMDAsIDAuMDUwLCAwLjA2MCwgMC4wNzAsIDAuMDkwLCAwLjA4MCwgMC4xNjBdLFxuICAnY3VydGFpbi1oZWF2eSc6XG4gIFswLjA3MywgMC4xMDYsIDAuMTQwLCAwLjM1MCwgMC41NTAsIDAuNzIwLCAwLjcwMCwgMC42NTAsIDEuMDAwXSxcbiAgJ2ZpYmVyLWdsYXNzLWluc3VsYXRpb24nOlxuICBbMC4xOTMsIDAuMjIwLCAwLjIyMCwgMC44MjAsIDAuOTkwLCAwLjk5MCwgMC45OTAsIDAuOTkwLCAxLjAwMF0sXG4gICdnbGFzcy10aGluJzpcbiAgWzAuMTgwLCAwLjE2OSwgMC4xODAsIDAuMDYwLCAwLjA0MCwgMC4wMzAsIDAuMDIwLCAwLjAyMCwgMC4wNDBdLFxuICAnZ2xhc3MtdGhpY2snOlxuICBbMC4zNTAsIDAuMzUwLCAwLjM1MCwgMC4yNTAsIDAuMTgwLCAwLjEyMCwgMC4wNzAsIDAuMDQwLCAwLjA4MF0sXG4gICdncmFzcyc6XG4gIFswLjA1MCwgMC4wNTAsIDAuMTUwLCAwLjI1MCwgMC40MDAsIDAuNTUwLCAwLjYwMCwgMC42MDAsIDAuNjAwXSxcbiAgJ2xpbm9sZXVtLW9uLWNvbmNyZXRlJzpcbiAgWzAuMDIwLCAwLjAyMCwgMC4wMjAsIDAuMDMwLCAwLjAzMCwgMC4wMzAsIDAuMDMwLCAwLjAyMCwgMC4wNDBdLFxuICAnbWFyYmxlJzpcbiAgWzAuMDEwLCAwLjAxMCwgMC4wMTAsIDAuMDEwLCAwLjAxMCwgMC4wMTAsIDAuMDIwLCAwLjAyMCwgMC4wNDBdLFxuICAnbWV0YWwnOlxuICBbMC4wMzAsIDAuMDM1LCAwLjA0MCwgMC4wNDAsIDAuMDUwLCAwLjA1MCwgMC4wNTAsIDAuMDcwLCAwLjA5MF0sXG4gICdwYXJxdWV0LW9uLWNvbmNyZXRlJzpcbiAgWzAuMDI4LCAwLjAzMCwgMC4wNDAsIDAuMDQwLCAwLjA3MCwgMC4wNjAsIDAuMDYwLCAwLjA3MCwgMC4xNDBdLFxuICAncGxhc3Rlci1yb3VnaCc6XG4gIFswLjAxNywgMC4wMTgsIDAuMDIwLCAwLjAzMCwgMC4wNDAsIDAuMDUwLCAwLjA0MCwgMC4wMzAsIDAuMDYwXSxcbiAgJ3BsYXN0ZXItc21vb3RoJzpcbiAgWzAuMDExLCAwLjAxMiwgMC4wMTMsIDAuMDE1LCAwLjAyMCwgMC4wMzAsIDAuMDQwLCAwLjA1MCwgMC4xMDBdLFxuICAncGx5d29vZC1wYW5lbCc6XG4gIFswLjQwMCwgMC4zNDAsIDAuMjgwLCAwLjIyMCwgMC4xNzAsIDAuMDkwLCAwLjEwMCwgMC4xMTAsIDAuMjIwXSxcbiAgJ3BvbGlzaGVkLWNvbmNyZXRlLW9yLXRpbGUnOlxuICBbMC4wMDgsIDAuMDA4LCAwLjAxMCwgMC4wMTAsIDAuMDE1LCAwLjAyMCwgMC4wMjAsIDAuMDIwLCAwLjA0MF0sXG4gICdzaGVldC1yb2NrJzpcbiAgWzAuMjkwLCAwLjI3OSwgMC4yOTAsIDAuMTAwLCAwLjA1MCwgMC4wNDAsIDAuMDcwLCAwLjA5MCwgMC4xODBdLFxuICAnd2F0ZXItb3ItaWNlLXN1cmZhY2UnOlxuICBbMC4wMDYsIDAuMDA2LCAwLjAwOCwgMC4wMDgsIDAuMDEzLCAwLjAxNSwgMC4wMjAsIDAuMDI1LCAwLjA1MF0sXG4gICd3b29kLWNlaWxpbmcnOlxuICBbMC4xNTAsIDAuMTQ3LCAwLjE1MCwgMC4xMTAsIDAuMTAwLCAwLjA3MCwgMC4wNjAsIDAuMDcwLCAwLjE0MF0sXG4gICd3b29kLXBhbmVsJzpcbiAgWzAuMjgwLCAwLjI4MCwgMC4yODAsIDAuMjIwLCAwLjE3MCwgMC4wOTAsIDAuMTAwLCAwLjExMCwgMC4yMjBdLFxuICAndW5pZm9ybSc6XG4gIFswLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwXSxcbn07XG5cblxuLyoqXG4gKiBEZWZhdWx0IG1hdGVyaWFscyB0aGF0IHVzZSBzdHJpbmdzIGZyb21cbiAqIHtAbGlua2NvZGUgVXRpbHMuTUFURVJJQUxfQ09FRkZJQ0lFTlRTIE1BVEVSSUFMX0NPRUZGSUNJRU5UU31cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMgPSB7XG4gIGxlZnQ6ICd0cmFuc3BhcmVudCcsIHJpZ2h0OiAndHJhbnNwYXJlbnQnLCBmcm9udDogJ3RyYW5zcGFyZW50JyxcbiAgYmFjazogJ3RyYW5zcGFyZW50JywgZG93bjogJ3RyYW5zcGFyZW50JywgdXA6ICd0cmFuc3BhcmVudCcsXG59O1xuXG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBiYW5kcyB0byBhdmVyYWdlIG92ZXIgd2hlbiBjb21wdXRpbmcgcmVmbGVjdGlvbiBjb2VmZmljaWVudHMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5OVU1CRVJfUkVGTEVDVElPTl9BVkVSQUdJTkdfQkFORFMgPSAzO1xuXG5cbi8qKlxuICogVGhlIHN0YXJ0aW5nIGJhbmQgdG8gYXZlcmFnZSBvdmVyIHdoZW4gY29tcHV0aW5nIHJlZmxlY3Rpb24gY29lZmZpY2llbnRzLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuUk9PTV9TVEFSVElOR19BVkVSQUdJTkdfQkFORCA9IDQ7XG5cblxuLyoqXG4gKiBUaGUgbWluaW11bSB0aHJlc2hvbGQgZm9yIHJvb20gdm9sdW1lLlxuICogUm9vbSBtb2RlbCBpcyBkaXNhYmxlZCBpZiB2b2x1bWUgaXMgYmVsb3cgdGhpcyB2YWx1ZS5cbiAqIEB0eXBlIHtOdW1iZXJ9ICovXG5VdGlscy5ST09NX01JTl9WT0xVTUUgPSAxZS00O1xuXG5cbi8qKlxuICogQWlyIGFic29ycHRpb24gY29lZmZpY2llbnRzIHBlciBmcmVxdWVuY3kgYmFuZC5cbiAqIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG4gKi9cblV0aWxzLlJPT01fQUlSX0FCU09SUFRJT05fQ09FRkZJQ0lFTlRTID1cbiAgWzAuMDAwNiwgMC4wMDA2LCAwLjAwMDcsIDAuMDAwOCwgMC4wMDEwLCAwLjAwMTUsIDAuMDAyNiwgMC4wMDYwLCAwLjAyMDddO1xuXG5cbi8qKlxuICogQSBzY2FsYXIgY29ycmVjdGlvbiB2YWx1ZSB0byBlbnN1cmUgU2FiaW5lIGFuZCBFeXJpbmcgcHJvZHVjZSB0aGUgc2FtZSBSVDYwXG4gKiB2YWx1ZSBhdCB0aGUgY3Jvc3Mtb3ZlciB0aHJlc2hvbGQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ST09NX0VZUklOR19DT1JSRUNUSU9OX0NPRUZGSUNJRU5UID0gMS4zODtcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5UV09fUEkgPSA2LjI4MzE4NTMwNzE3OTU5O1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLlRXRU5UWV9GT1VSX0xPRzEwID0gNTUuMjYyMDQyMjMxODU3MTtcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5MT0cxMDAwID0gNi45MDc3NTUyNzg5ODIxNDtcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5MT0cyX0RJVjIgPSAwLjM0NjU3MzU5MDI3OTk3MztcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5ERUdSRUVTX1RPX1JBRElBTlMgPSAwLjAxNzQ1MzI5MjUxOTk0MztcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5SQURJQU5TX1RPX0RFR1JFRVMgPSA1Ny4yOTU3Nzk1MTMwODIzMjM7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuRVBTSUxPTl9GTE9BVCA9IDFlLTg7XG5cblxuLyoqXG4gKiBSZXNvbmFuY2VBdWRpbyBsaWJyYXJ5IGxvZ2dpbmcgZnVuY3Rpb24uXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge2FueX0gTWVzc2FnZSB0byBiZSBwcmludGVkIG91dC5cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkod2luZG93LmNvbnNvbGUsIFtcbiAgICAnJWNbUmVzb25hbmNlQXVkaW9dJWMgJ1xuICAgICAgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKSArICcgJWMoQCdcbiAgICAgICsgcGVyZm9ybWFuY2Uubm93KCkudG9GaXhlZCgyKSArICdtcyknLFxuICAgICdiYWNrZ3JvdW5kOiAjQkJERUZCOyBjb2xvcjogI0ZGNTcyMjsgZm9udC13ZWlnaHQ6IDcwMCcsXG4gICAgJ2ZvbnQtd2VpZ2h0OiA0MDAnLFxuICAgICdjb2xvcjogI0FBQScsXG4gIF0pO1xufTtcblxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIDMtZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdiAzLWVsZW1lbnQgdmVjdG9yLlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAzLWVsZW1lbnQgdmVjdG9yLlxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMubm9ybWFsaXplVmVjdG9yID0gZnVuY3Rpb24odikge1xuICBsZXQgbiA9IE1hdGguc3FydCh2WzBdICogdlswXSArIHZbMV0gKiB2WzFdICsgdlsyXSAqIHZbMl0pO1xuICBpZiAobiA+IGV4cG9ydHMuRVBTSUxPTl9GTE9BVCkge1xuICAgIG4gPSAxIC8gbjtcbiAgICB2WzBdICo9IG47XG4gICAgdlsxXSAqPSBuO1xuICAgIHZbMl0gKj0gbjtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cblxuLyoqXG4gKiBDcm9zcy1wcm9kdWN0IGJldHdlZW4gdHdvIDMtZCB2ZWN0b3JzLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGEgMy1lbGVtZW50IHZlY3Rvci5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBiIDMtZWxlbWVudCB2ZWN0b3IuXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5jcm9zc1Byb2R1Y3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBbXG4gICAgYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSxcbiAgICBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLFxuICAgIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF0sXG4gIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBTcGF0aWFsbHkgZW5jb2RlcyBpbnB1dCB1c2luZyB3ZWlnaHRlZCBzcGhlcmljYWwgaGFybW9uaWNzLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IFRhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgRW5jb2RlclxuICogQGRlc2NyaXB0aW9uIFNwYXRpYWxseSBlbmNvZGVzIGlucHV0IHVzaW5nIHdlaWdodGVkIHNwaGVyaWNhbCBoYXJtb25pY3MuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbWJpc29uaWNPcmRlclxuICogRGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSIERFRkFVTFRfQU1CSVNPTklDX09SREVSfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmF6aW11dGhcbiAqIEF6aW11dGggKGluIGRlZ3JlZXMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FaSU1VVEggREVGQVVMVF9BWklNVVRIfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmVsZXZhdGlvblxuICogRWxldmF0aW9uIChpbiBkZWdyZWVzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9FTEVWQVRJT04gREVGQVVMVF9FTEVWQVRJT059LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc291cmNlV2lkdGhcbiAqIFNvdXJjZSB3aWR0aCAoaW4gZGVncmVlcykuIFdoZXJlIDAgZGVncmVlcyBpcyBhIHBvaW50IHNvdXJjZSBhbmQgMzYwIGRlZ3JlZXNcbiAqIGlzIGFuIG9tbmlkaXJlY3Rpb25hbCBzb3VyY2UuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIIERFRkFVTFRfU09VUkNFX1dJRFRIfS5cbiAqL1xuZnVuY3Rpb24gRW5jb2Rlcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIEVuY29kZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgRW5jb2RlclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciA9IFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSO1xuICB9XG4gIGlmIChvcHRpb25zLmF6aW11dGggPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hemltdXRoID0gVXRpbHMuREVGQVVMVF9BWklNVVRIO1xuICB9XG4gIGlmIChvcHRpb25zLmVsZXZhdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmVsZXZhdGlvbiA9IFV0aWxzLkRFRkFVTFRfRUxFVkFUSU9OO1xuICB9XG4gIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc291cmNlV2lkdGggPSBVdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSDtcbiAgfVxuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIC8vIENyZWF0ZSBJL08gbm9kZXMuXG4gIHRoaXMuaW5wdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fY2hhbm5lbEdhaW4gPSBbXTtcbiAgdGhpcy5fbWVyZ2VyID0gdW5kZWZpbmVkO1xuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIFNldCBpbml0aWFsIG9yZGVyLCBhbmdsZSBhbmQgc291cmNlIHdpZHRoLlxuICB0aGlzLnNldEFtYmlzb25pY09yZGVyKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIpO1xuICB0aGlzLl9hemltdXRoID0gb3B0aW9ucy5hemltdXRoO1xuICB0aGlzLl9lbGV2YXRpb24gPSBvcHRpb25zLmVsZXZhdGlvbjtcbiAgdGhpcy5zZXRTb3VyY2VXaWR0aChvcHRpb25zLnNvdXJjZVdpZHRoKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGRlc2lyZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIERlc2lyZWQgYW1iaXNvbmljIG9yZGVyLlxuICovXG5FbmNvZGVyLnByb3RvdHlwZS5zZXRBbWJpc29uaWNPcmRlciA9IGZ1bmN0aW9uKGFtYmlzb25pY09yZGVyKSB7XG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID0gRW5jb2Rlci52YWxpZGF0ZUFtYmlzb25pY09yZGVyKGFtYmlzb25pY09yZGVyKTtcblxuICB0aGlzLmlucHV0LmRpc2Nvbm5lY3QoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jaGFubmVsR2Fpbi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuX2NoYW5uZWxHYWluW2ldLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodGhpcy5fbWVyZ2VyICE9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX21lcmdlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2NoYW5uZWxHYWluO1xuICBkZWxldGUgdGhpcy5fbWVyZ2VyO1xuXG4gIC8vIENyZWF0ZSBhdWRpbyBncmFwaC5cbiAgbGV0IG51bUNoYW5uZWxzID0gKHRoaXMuX2FtYmlzb25pY09yZGVyICsgMSkgKiAodGhpcy5fYW1iaXNvbmljT3JkZXIgKyAxKTtcbiAgdGhpcy5fbWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKG51bUNoYW5uZWxzKTtcbiAgdGhpcy5fY2hhbm5lbEdhaW4gPSBuZXcgQXJyYXkobnVtQ2hhbm5lbHMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNoYW5uZWxzOyBpKyspIHtcbiAgICB0aGlzLl9jaGFubmVsR2FpbltpXSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9jaGFubmVsR2FpbltpXSk7XG4gICAgdGhpcy5fY2hhbm5lbEdhaW5baV0uY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIGkpO1xuICB9XG4gIHRoaXMuX21lcmdlci5jb25uZWN0KHRoaXMub3V0cHV0KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZW5jb2RlZCBzb3VyY2Ugc2lnbmFsLlxuICogQHBhcmFtIHtOdW1iZXJ9IGF6aW11dGhcbiAqIEF6aW11dGggKGluIGRlZ3JlZXMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FaSU1VVEggREVGQVVMVF9BWklNVVRIfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbGV2YXRpb25cbiAqIEVsZXZhdGlvbiAoaW4gZGVncmVlcykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRUxFVkFUSU9OIERFRkFVTFRfRUxFVkFUSU9OfS5cbiAqL1xuRW5jb2Rlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24oYXppbXV0aCwgZWxldmF0aW9uKSB7XG4gIC8vIEZvcm1hdCBpbnB1dCBkaXJlY3Rpb24gdG8gbmVhcmVzdCBpbmRpY2VzLlxuICBpZiAoYXppbXV0aCA9PSB1bmRlZmluZWQgfHwgaXNOYU4oYXppbXV0aCkpIHtcbiAgICBhemltdXRoID0gVXRpbHMuREVGQVVMVF9BWklNVVRIO1xuICB9XG4gIGlmIChlbGV2YXRpb24gPT0gdW5kZWZpbmVkIHx8IGlzTmFOKGVsZXZhdGlvbikpIHtcbiAgICBlbGV2YXRpb24gPSBVdGlscy5ERUZBVUxUX0VMRVZBVElPTjtcbiAgfVxuXG4gIC8vIFN0b3JlIHRoZSBmb3JtYXR0ZWQgaW5wdXQgKGZvciB1cGRhdGluZyBzb3VyY2Ugd2lkdGgpLlxuICB0aGlzLl9hemltdXRoID0gYXppbXV0aDtcbiAgdGhpcy5fZWxldmF0aW9uID0gZWxldmF0aW9uO1xuXG4gIC8vIEZvcm1hdCBkaXJlY3Rpb24gZm9yIGluZGV4IGxvb2t1cHMuXG4gIGF6aW11dGggPSBNYXRoLnJvdW5kKGF6aW11dGggJSAzNjApO1xuICBpZiAoYXppbXV0aCA8IDApIHtcbiAgICBhemltdXRoICs9IDM2MDtcbiAgfVxuICBlbGV2YXRpb24gPSBNYXRoLnJvdW5kKE1hdGgubWluKDkwLCBNYXRoLm1heCgtOTAsIGVsZXZhdGlvbikpKSArIDkwO1xuXG4gIC8vIEFzc2lnbiBnYWlucyB0byBlYWNoIG91dHB1dC5cbiAgdGhpcy5fY2hhbm5lbEdhaW5bMF0uZ2Fpbi52YWx1ZSA9IFRhYmxlcy5NQVhfUkVfV0VJR0hUU1t0aGlzLl9zcHJlYWRJbmRleF1bMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuX2FtYmlzb25pY09yZGVyOyBpKyspIHtcbiAgICBsZXQgZGVncmVlV2VpZ2h0ID0gVGFibGVzLk1BWF9SRV9XRUlHSFRTW3RoaXMuX3NwcmVhZEluZGV4XVtpXTtcbiAgICBmb3IgKGxldCBqID0gLWk7IGogPD0gaTsgaisrKSB7XG4gICAgICBsZXQgYWNuQ2hhbm5lbCA9IChpICogaSkgKyBpICsgajtcbiAgICAgIGxldCBlbGV2YXRpb25JbmRleCA9IGkgKiAoaSArIDEpIC8gMiArIE1hdGguYWJzKGopIC0gMTtcbiAgICAgIGxldCB2YWwgPSBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU1sxXVtlbGV2YXRpb25dW2VsZXZhdGlvbkluZGV4XTtcbiAgICAgIGlmIChqICE9IDApIHtcbiAgICAgICAgbGV0IGF6aW11dGhJbmRleCA9IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUiArIGogLSAxO1xuICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICBhemltdXRoSW5kZXggPSBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIgKyBqO1xuICAgICAgICB9XG4gICAgICAgIHZhbCAqPSBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU1swXVthemltdXRoXVthemltdXRoSW5kZXhdO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbm5lbEdhaW5bYWNuQ2hhbm5lbF0uZ2Fpbi52YWx1ZSA9IHZhbCAqIGRlZ3JlZVdlaWdodDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSB3aWR0aCAoaW4gZGVncmVlcykuIFdoZXJlIDAgZGVncmVlcyBpcyBhIHBvaW50IHNvdXJjZSBhbmQgMzYwXG4gKiBkZWdyZWVzIGlzIGFuIG9tbmlkaXJlY3Rpb25hbCBzb3VyY2UuXG4gKiBAcGFyYW0ge051bWJlcn0gc291cmNlV2lkdGggKGluIGRlZ3JlZXMpLlxuICovXG5FbmNvZGVyLnByb3RvdHlwZS5zZXRTb3VyY2VXaWR0aCA9IGZ1bmN0aW9uKHNvdXJjZVdpZHRoKSB7XG4gIC8vIFRoZSBNQVhfUkVfV0VJR0hUUyBpcyBhIDM2MCB4IChUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIrMSlcbiAgLy8gc2l6ZSB0YWJsZS5cbiAgdGhpcy5fc3ByZWFkSW5kZXggPSBNYXRoLm1pbigzNTksIE1hdGgubWF4KDAsIE1hdGgucm91bmQoc291cmNlV2lkdGgpKSk7XG4gIHRoaXMuc2V0RGlyZWN0aW9uKHRoaXMuX2F6aW11dGgsIHRoaXMuX2VsZXZhdGlvbik7XG59O1xuXG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGFtYmlzb25pYyBvcmRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciBEZXNpcmVkIGFtYmlzb25pYyBvcmRlci5cbiAqIEByZXR1cm4ge051bWJlcn0gVmFsaWRhdGVkL2FkanVzdGVkIGFtYmlzb25pYyBvcmRlci5cbiAqIEBwcml2YXRlXG4gKi9cbkVuY29kZXIudmFsaWRhdGVBbWJpc29uaWNPcmRlciA9IGZ1bmN0aW9uKGFtYmlzb25pY09yZGVyKSB7XG4gIGlmIChpc05hTihhbWJpc29uaWNPcmRlcikgfHwgYW1iaXNvbmljT3JkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgVXRpbHMubG9nKCdFcnJvcjogSW52YWxpZCBhbWJpc29uaWMgb3JkZXInLFxuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIsICdcXG5Vc2luZyBhbWJpc29uaWNPcmRlcj0xIGluc3RlYWQuJyk7XG4gICAgYW1iaXNvbmljT3JkZXIgPSAxO1xuICB9IGVsc2UgaWYgKGFtYmlzb25pY09yZGVyIDwgMSkge1xuICAgIFV0aWxzLmxvZygnRXJyb3I6IFVuYWJsZSB0byByZW5kZXIgYW1iaXNvbmljIG9yZGVyJyxcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyLCAnKE1pbiBvcmRlciBpcyAxKScsXG4gICAgJ1xcblVzaW5nIG1pbiBvcmRlciBpbnN0ZWFkLicpO1xuICAgIGFtYmlzb25pY09yZGVyID0gMTtcbiAgfSBlbHNlIGlmIChhbWJpc29uaWNPcmRlciA+IFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUikge1xuICAgIFV0aWxzLmxvZygnRXJyb3I6IFVuYWJsZSB0byByZW5kZXIgYW1iaXNvbmljIG9yZGVyJyxcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyLCAnKE1heCBvcmRlciBpcycsXG4gICAgVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSLCAnKVxcblVzaW5nIG1heCBvcmRlciBpbnN0ZWFkLicpO1xuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPSBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVI7XG4gIH1cbiAgcmV0dXJuIGFtYmlzb25pY09yZGVyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIExpc3RlbmVyIG1vZGVsIHRvIHNwYXRpYWxpemUgc291cmNlcyBpbiBhbiBlbnZpcm9ubWVudC5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IE9tbml0b25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5jb25zdCBFbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBMaXN0ZW5lclxuICogQGRlc2NyaXB0aW9uIExpc3RlbmVyIG1vZGVsIHRvIHNwYXRpYWxpemUgc291cmNlcyBpbiBhbiBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFtYmlzb25pY09yZGVyXG4gKiBEZXNpcmVkIGFtYmlzb25pYyBvcmRlci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVIgREVGQVVMVF9BTUJJU09OSUNfT1JERVJ9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMucG9zaXRpb25cbiAqIEluaXRpYWwgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmZvcndhcmRcbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgZm9yd2FyZCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRk9SV0FSRCBERUZBVUxUX0ZPUldBUkR9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMudXBcbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgdXAgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1VQIERFRkFVTFRfVVB9LlxuICovXG5mdW5jdGlvbiBMaXN0ZW5lcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiAoaW4gbWV0ZXJzKS5cbiAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBwb3NpdGlvblxuICAgKiBAbWVtYmVyb2YgTGlzdGVuZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIExpc3RlbmVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEJpbmF1cmFsbHktcmVuZGVyZWQgc3RlcmVvICgyLWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgTGlzdGVuZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGFtYmlzb25pY091dHB1dFxuICAgKiBAbWVtYmVyb2YgTGlzdGVuZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbWJpc29uaWNPcmRlciA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyID0gVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVI7XG4gIH1cbiAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5wb3NpdGlvbiA9IFV0aWxzLkRFRkFVTFRfUE9TSVRJT04uc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3J3YXJkID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZm9yd2FyZCA9IFV0aWxzLkRFRkFVTFRfRk9SV0FSRC5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLnVwID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMudXAgPSBVdGlscy5ERUZBVUxUX1VQLnNsaWNlKCk7XG4gIH1cblxuICAvLyBNZW1iZXIgdmFyaWFibGVzLlxuICB0aGlzLnBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgdGhpcy5fdGVtcE1hdHJpeDMgPSBuZXcgRmxvYXQzMkFycmF5KDkpO1xuXG4gIC8vIFNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgSFJJUiBmaWx0ZXJzIHVzaW5nIDItY2hhbm5lbCBjaHVua3Mgc2luY2VcbiAgLy8gbXVsdGljaGFubmVsIGF1ZGlvIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGJ5IGEgbWFqb3JpdHkgb2YgYnJvd3NlcnMuXG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID1cbiAgICBFbmNvZGVyLnZhbGlkYXRlQW1iaXNvbmljT3JkZXIob3B0aW9ucy5hbWJpc29uaWNPcmRlcik7XG5cbiAgICAvLyBDcmVhdGUgYXVkaW8gbm9kZXMuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICBpZiAodGhpcy5fYW1iaXNvbmljT3JkZXIgPT0gMSkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gT21uaXRvbmUuT21uaXRvbmUuY3JlYXRlRk9BUmVuZGVyZXIoY29udGV4dCwge30pO1xuICB9IGVsc2UgaWYgKHRoaXMuX2FtYmlzb25pY09yZGVyID4gMSkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gT21uaXRvbmUuT21uaXRvbmUuY3JlYXRlSE9BUmVuZGVyZXIoY29udGV4dCwge1xuICAgICAgYW1iaXNvbmljT3JkZXI6IHRoaXMuX2FtYmlzb25pY09yZGVyLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gVGhlc2Ugbm9kZXMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gc2FmZWx5IGFzeW5jaHJvbm91c2x5IGxvYWQgT21uaXRvbmVcbiAgLy8gd2hpbGUgdGhlIHJlc3Qgb2YgdGhlIHNjZW5lIGlzIGJlaW5nIGNyZWF0ZWQuXG4gIHRoaXMuaW5wdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5hbWJpc29uaWNPdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBJbml0aWFsaXplIE9tbml0b25lIChhc3luYykgYW5kIGNvbm5lY3QgdG8gYXVkaW8gZ3JhcGggd2hlbiBjb21wbGV0ZS5cbiAgbGV0IHRoYXQgPSB0aGlzO1xuICB0aGlzLl9yZW5kZXJlci5pbml0aWFsaXplKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAvLyBDb25uZWN0IHByZS1yb3RhdGVkIHNvdW5kZmllbGQgdG8gcmVuZGVyZXIuXG4gICAgdGhhdC5pbnB1dC5jb25uZWN0KHRoYXQuX3JlbmRlcmVyLmlucHV0KTtcblxuICAgIC8vIENvbm5lY3Qgcm90YXRlZCBzb3VuZGZpZWxkIHRvIGFtYmlzb25pYyBvdXRwdXQuXG4gICAgaWYgKHRoYXQuX2FtYmlzb25pY09yZGVyID4gMSkge1xuICAgICAgdGhhdC5fcmVuZGVyZXIuX2hvYVJvdGF0b3Iub3V0cHV0LmNvbm5lY3QodGhhdC5hbWJpc29uaWNPdXRwdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9yZW5kZXJlci5fZm9hUm90YXRvci5vdXRwdXQuY29ubmVjdCh0aGF0LmFtYmlzb25pY091dHB1dCk7XG4gICAgfVxuXG4gICAgLy8gQ29ubmVjdCBiaW5hdXJhbGx5LXJlbmRlcmVkIHNvdW5kZmllbGQgdG8gYmluYXVyYWwgb3V0cHV0LlxuICAgIHRoYXQuX3JlbmRlcmVyLm91dHB1dC5jb25uZWN0KHRoYXQub3V0cHV0KTtcbiAgfSk7XG5cbiAgLy8gU2V0IG9yaWVudGF0aW9uIGFuZCB1cGRhdGUgcm90YXRpb24gbWF0cml4IGFjY29yZGluZ2x5LlxuICB0aGlzLnNldE9yaWVudGF0aW9uKG9wdGlvbnMuZm9yd2FyZFswXSwgb3B0aW9ucy5mb3J3YXJkWzFdLFxuICAgIG9wdGlvbnMuZm9yd2FyZFsyXSwgb3B0aW9ucy51cFswXSwgb3B0aW9ucy51cFsxXSwgb3B0aW9ucy51cFsyXSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UncyBvcmllbnRhdGlvbiB1c2luZyBmb3J3YXJkIGFuZCB1cCB2ZWN0b3JzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRYXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFlcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWlxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWFxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWVxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWlxuICovXG5MaXN0ZW5lci5wcm90b3R5cGUuc2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbihmb3J3YXJkWCwgZm9yd2FyZFksIGZvcndhcmRaLFxuICB1cFgsIHVwWSwgdXBaKSB7XG4gIGxldCByaWdodCA9IFV0aWxzLmNyb3NzUHJvZHVjdChbZm9yd2FyZFgsIGZvcndhcmRZLCBmb3J3YXJkWl0sXG4gICAgW3VwWCwgdXBZLCB1cFpdKTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbMF0gPSByaWdodFswXTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbMV0gPSByaWdodFsxXTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbMl0gPSByaWdodFsyXTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbM10gPSB1cFg7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzRdID0gdXBZO1xuICB0aGlzLl90ZW1wTWF0cml4M1s1XSA9IHVwWjtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbNl0gPSBmb3J3YXJkWDtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbN10gPSBmb3J3YXJkWTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbOF0gPSBmb3J3YXJkWjtcbiAgdGhpcy5fcmVuZGVyZXIuc2V0Um90YXRpb25NYXRyaXgzKHRoaXMuX3RlbXBNYXRyaXgzKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIHVzaW5nIGEgVGhyZWUuanMgTWF0cml4NCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0cml4NFxuICogVGhlIFRocmVlLmpzIE1hdHJpeDQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbGlzdGVuZXIncyB3b3JsZCB0cmFuc2Zvcm0uXG4gKi9cbkxpc3RlbmVyLnByb3RvdHlwZS5zZXRGcm9tTWF0cml4ID0gZnVuY3Rpb24obWF0cml4NCkge1xuICAvLyBVcGRhdGUgYW1iaXNvbmljIHJvdGF0aW9uIG1hdHJpeCBpbnRlcm5hbGx5LlxuICB0aGlzLl9yZW5kZXJlci5zZXRSb3RhdGlvbk1hdHJpeDQobWF0cml4NC5lbGVtZW50cyk7XG5cbiAgLy8gRXh0cmFjdCBwb3NpdGlvbiBmcm9tIG1hdHJpeC5cbiAgdGhpcy5wb3NpdGlvblswXSA9IG1hdHJpeDQuZWxlbWVudHNbMTJdO1xuICB0aGlzLnBvc2l0aW9uWzFdID0gbWF0cml4NC5lbGVtZW50c1sxM107XG4gIHRoaXMucG9zaXRpb25bMl0gPSBtYXRyaXg0LmVsZW1lbnRzWzE0XTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0ZW5lcjtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBQcmUtY29tcHV0ZWQgbG9va3VwIHRhYmxlcyBmb3IgZW5jb2RpbmcgYW1iaXNvbmljIHNvdXJjZXMuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vKipcbiAqIFByZS1jb21wdXRlZCBTcGhlcmljYWwgSGFybW9uaWNzIENvZWZmaWNpZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhbiBlZmZpY2llbnQgbG9va3VwIHRhYmxlIG9mIFNIIGNvZWZmaWNpZW50cy4gSXRcbiAqIGV4cGxvaXRzIHRoZSB3YXkgU0hzIGFyZSBnZW5lcmF0ZWQgKGkuZS4gWWxtID0gTmxtICogUGxtICogRW0pLiBTaW5jZSBObG1cbiAqICYgUGxtIGNvZWZmaWNpZW50cyBvbmx5IGRlcGVuZCBvbiB0aGV0YSwgYW5kIEVtIG9ubHkgZGVwZW5kcyBvbiBwaGksIHdlXG4gKiBjYW4gc2VwYXJhdGUgdGhlIGVxdWF0aW9uIGFsb25nIHRoZXNlIGxpbmVzLiBFbSBkb2VzIG5vdCBkZXBlbmQgb25cbiAqIGRlZ3JlZSwgc28gd2Ugb25seSBuZWVkIHRvIGNvbXB1dGUgKDIgKiBsKSBwZXIgYXppbXV0aCBFbSB0b3RhbCBhbmRcbiAqIE5sbSAqIFBsbSBpcyBzeW1tZXRyaWNhbCBhY3Jvc3MgaW5kZXhlcywgc28gb25seSBwb3NpdGl2ZSBpbmRleGVzIGFyZVxuICogY29tcHV0ZWQgKChsICsgMSkgKiAobCArIDIpIC8gMiAtIDEpIHBlciBlbGV2YXRpb24uXG4gKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICovXG5leHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1MgPVxuW1xuICBbXG4gICAgWzAuMDAwMDAwLCAwLjAwMDAwMCwgMC4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICAgIFswLjA1MjMzNiwgMC4wMzQ4OTksIDAuMDE3NDUyLCAwLjk5OTg0OCwgMC45OTkzOTEsIDAuOTk4NjMwXSxcbiAgICBbMC4xMDQ1MjgsIDAuMDY5NzU2LCAwLjAzNDg5OSwgMC45OTkzOTEsIDAuOTk3NTY0LCAwLjk5NDUyMl0sXG4gICAgWzAuMTU2NDM0LCAwLjEwNDUyOCwgMC4wNTIzMzYsIDAuOTk4NjMwLCAwLjk5NDUyMiwgMC45ODc2ODhdLFxuICAgIFswLjIwNzkxMiwgMC4xMzkxNzMsIDAuMDY5NzU2LCAwLjk5NzU2NCwgMC45OTAyNjgsIDAuOTc4MTQ4XSxcbiAgICBbMC4yNTg4MTksIDAuMTczNjQ4LCAwLjA4NzE1NiwgMC45OTYxOTUsIDAuOTg0ODA4LCAwLjk2NTkyNl0sXG4gICAgWzAuMzA5MDE3LCAwLjIwNzkxMiwgMC4xMDQ1MjgsIDAuOTk0NTIyLCAwLjk3ODE0OCwgMC45NTEwNTddLFxuICAgIFswLjM1ODM2OCwgMC4yNDE5MjIsIDAuMTIxODY5LCAwLjk5MjU0NiwgMC45NzAyOTYsIDAuOTMzNTgwXSxcbiAgICBbMC40MDY3MzcsIDAuMjc1NjM3LCAwLjEzOTE3MywgMC45OTAyNjgsIDAuOTYxMjYyLCAwLjkxMzU0NV0sXG4gICAgWzAuNDUzOTkwLCAwLjMwOTAxNywgMC4xNTY0MzQsIDAuOTg3Njg4LCAwLjk1MTA1NywgMC44OTEwMDddLFxuICAgIFswLjUwMDAwMCwgMC4zNDIwMjAsIDAuMTczNjQ4LCAwLjk4NDgwOCwgMC45Mzk2OTMsIDAuODY2MDI1XSxcbiAgICBbMC41NDQ2MzksIDAuMzc0NjA3LCAwLjE5MDgwOSwgMC45ODE2MjcsIDAuOTI3MTg0LCAwLjgzODY3MV0sXG4gICAgWzAuNTg3Nzg1LCAwLjQwNjczNywgMC4yMDc5MTIsIDAuOTc4MTQ4LCAwLjkxMzU0NSwgMC44MDkwMTddLFxuICAgIFswLjYyOTMyMCwgMC40MzgzNzEsIDAuMjI0OTUxLCAwLjk3NDM3MCwgMC44OTg3OTQsIDAuNzc3MTQ2XSxcbiAgICBbMC42NjkxMzEsIDAuNDY5NDcyLCAwLjI0MTkyMiwgMC45NzAyOTYsIDAuODgyOTQ4LCAwLjc0MzE0NV0sXG4gICAgWzAuNzA3MTA3LCAwLjUwMDAwMCwgMC4yNTg4MTksIDAuOTY1OTI2LCAwLjg2NjAyNSwgMC43MDcxMDddLFxuICAgIFswLjc0MzE0NSwgMC41Mjk5MTksIDAuMjc1NjM3LCAwLjk2MTI2MiwgMC44NDgwNDgsIDAuNjY5MTMxXSxcbiAgICBbMC43NzcxNDYsIDAuNTU5MTkzLCAwLjI5MjM3MiwgMC45NTYzMDUsIDAuODI5MDM4LCAwLjYyOTMyMF0sXG4gICAgWzAuODA5MDE3LCAwLjU4Nzc4NSwgMC4zMDkwMTcsIDAuOTUxMDU3LCAwLjgwOTAxNywgMC41ODc3ODVdLFxuICAgIFswLjgzODY3MSwgMC42MTU2NjEsIDAuMzI1NTY4LCAwLjk0NTUxOSwgMC43ODgwMTEsIDAuNTQ0NjM5XSxcbiAgICBbMC44NjYwMjUsIDAuNjQyNzg4LCAwLjM0MjAyMCwgMC45Mzk2OTMsIDAuNzY2MDQ0LCAwLjUwMDAwMF0sXG4gICAgWzAuODkxMDA3LCAwLjY2OTEzMSwgMC4zNTgzNjgsIDAuOTMzNTgwLCAwLjc0MzE0NSwgMC40NTM5OTBdLFxuICAgIFswLjkxMzU0NSwgMC42OTQ2NTgsIDAuMzc0NjA3LCAwLjkyNzE4NCwgMC43MTkzNDAsIDAuNDA2NzM3XSxcbiAgICBbMC45MzM1ODAsIDAuNzE5MzQwLCAwLjM5MDczMSwgMC45MjA1MDUsIDAuNjk0NjU4LCAwLjM1ODM2OF0sXG4gICAgWzAuOTUxMDU3LCAwLjc0MzE0NSwgMC40MDY3MzcsIDAuOTEzNTQ1LCAwLjY2OTEzMSwgMC4zMDkwMTddLFxuICAgIFswLjk2NTkyNiwgMC43NjYwNDQsIDAuNDIyNjE4LCAwLjkwNjMwOCwgMC42NDI3ODgsIDAuMjU4ODE5XSxcbiAgICBbMC45NzgxNDgsIDAuNzg4MDExLCAwLjQzODM3MSwgMC44OTg3OTQsIDAuNjE1NjYxLCAwLjIwNzkxMl0sXG4gICAgWzAuOTg3Njg4LCAwLjgwOTAxNywgMC40NTM5OTAsIDAuODkxMDA3LCAwLjU4Nzc4NSwgMC4xNTY0MzRdLFxuICAgIFswLjk5NDUyMiwgMC44MjkwMzgsIDAuNDY5NDcyLCAwLjg4Mjk0OCwgMC41NTkxOTMsIDAuMTA0NTI4XSxcbiAgICBbMC45OTg2MzAsIDAuODQ4MDQ4LCAwLjQ4NDgxMCwgMC44NzQ2MjAsIDAuNTI5OTE5LCAwLjA1MjMzNl0sXG4gICAgWzEuMDAwMDAwLCAwLjg2NjAyNSwgMC41MDAwMDAsIDAuODY2MDI1LCAwLjUwMDAwMCwgMC4wMDAwMDBdLFxuICAgIFswLjk5ODYzMCwgMC44ODI5NDgsIDAuNTE1MDM4LCAwLjg1NzE2NywgMC40Njk0NzIsIC0wLjA1MjMzNl0sXG4gICAgWzAuOTk0NTIyLCAwLjg5ODc5NCwgMC41Mjk5MTksIDAuODQ4MDQ4LCAwLjQzODM3MSwgLTAuMTA0NTI4XSxcbiAgICBbMC45ODc2ODgsIDAuOTEzNTQ1LCAwLjU0NDYzOSwgMC44Mzg2NzEsIDAuNDA2NzM3LCAtMC4xNTY0MzRdLFxuICAgIFswLjk3ODE0OCwgMC45MjcxODQsIDAuNTU5MTkzLCAwLjgyOTAzOCwgMC4zNzQ2MDcsIC0wLjIwNzkxMl0sXG4gICAgWzAuOTY1OTI2LCAwLjkzOTY5MywgMC41NzM1NzYsIDAuODE5MTUyLCAwLjM0MjAyMCwgLTAuMjU4ODE5XSxcbiAgICBbMC45NTEwNTcsIDAuOTUxMDU3LCAwLjU4Nzc4NSwgMC44MDkwMTcsIDAuMzA5MDE3LCAtMC4zMDkwMTddLFxuICAgIFswLjkzMzU4MCwgMC45NjEyNjIsIDAuNjAxODE1LCAwLjc5ODYzNiwgMC4yNzU2MzcsIC0wLjM1ODM2OF0sXG4gICAgWzAuOTEzNTQ1LCAwLjk3MDI5NiwgMC42MTU2NjEsIDAuNzg4MDExLCAwLjI0MTkyMiwgLTAuNDA2NzM3XSxcbiAgICBbMC44OTEwMDcsIDAuOTc4MTQ4LCAwLjYyOTMyMCwgMC43NzcxNDYsIDAuMjA3OTEyLCAtMC40NTM5OTBdLFxuICAgIFswLjg2NjAyNSwgMC45ODQ4MDgsIDAuNjQyNzg4LCAwLjc2NjA0NCwgMC4xNzM2NDgsIC0wLjUwMDAwMF0sXG4gICAgWzAuODM4NjcxLCAwLjk5MDI2OCwgMC42NTYwNTksIDAuNzU0NzEwLCAwLjEzOTE3MywgLTAuNTQ0NjM5XSxcbiAgICBbMC44MDkwMTcsIDAuOTk0NTIyLCAwLjY2OTEzMSwgMC43NDMxNDUsIDAuMTA0NTI4LCAtMC41ODc3ODVdLFxuICAgIFswLjc3NzE0NiwgMC45OTc1NjQsIDAuNjgxOTk4LCAwLjczMTM1NCwgMC4wNjk3NTYsIC0wLjYyOTMyMF0sXG4gICAgWzAuNzQzMTQ1LCAwLjk5OTM5MSwgMC42OTQ2NTgsIDAuNzE5MzQwLCAwLjAzNDg5OSwgLTAuNjY5MTMxXSxcbiAgICBbMC43MDcxMDcsIDEuMDAwMDAwLCAwLjcwNzEwNywgMC43MDcxMDcsIDAuMDAwMDAwLCAtMC43MDcxMDddLFxuICAgIFswLjY2OTEzMSwgMC45OTkzOTEsIDAuNzE5MzQwLCAwLjY5NDY1OCwgLTAuMDM0ODk5LCAtMC43NDMxNDVdLFxuICAgIFswLjYyOTMyMCwgMC45OTc1NjQsIDAuNzMxMzU0LCAwLjY4MTk5OCwgLTAuMDY5NzU2LCAtMC43NzcxNDZdLFxuICAgIFswLjU4Nzc4NSwgMC45OTQ1MjIsIDAuNzQzMTQ1LCAwLjY2OTEzMSwgLTAuMTA0NTI4LCAtMC44MDkwMTddLFxuICAgIFswLjU0NDYzOSwgMC45OTAyNjgsIDAuNzU0NzEwLCAwLjY1NjA1OSwgLTAuMTM5MTczLCAtMC44Mzg2NzFdLFxuICAgIFswLjUwMDAwMCwgMC45ODQ4MDgsIDAuNzY2MDQ0LCAwLjY0Mjc4OCwgLTAuMTczNjQ4LCAtMC44NjYwMjVdLFxuICAgIFswLjQ1Mzk5MCwgMC45NzgxNDgsIDAuNzc3MTQ2LCAwLjYyOTMyMCwgLTAuMjA3OTEyLCAtMC44OTEwMDddLFxuICAgIFswLjQwNjczNywgMC45NzAyOTYsIDAuNzg4MDExLCAwLjYxNTY2MSwgLTAuMjQxOTIyLCAtMC45MTM1NDVdLFxuICAgIFswLjM1ODM2OCwgMC45NjEyNjIsIDAuNzk4NjM2LCAwLjYwMTgxNSwgLTAuMjc1NjM3LCAtMC45MzM1ODBdLFxuICAgIFswLjMwOTAxNywgMC45NTEwNTcsIDAuODA5MDE3LCAwLjU4Nzc4NSwgLTAuMzA5MDE3LCAtMC45NTEwNTddLFxuICAgIFswLjI1ODgxOSwgMC45Mzk2OTMsIDAuODE5MTUyLCAwLjU3MzU3NiwgLTAuMzQyMDIwLCAtMC45NjU5MjZdLFxuICAgIFswLjIwNzkxMiwgMC45MjcxODQsIDAuODI5MDM4LCAwLjU1OTE5MywgLTAuMzc0NjA3LCAtMC45NzgxNDhdLFxuICAgIFswLjE1NjQzNCwgMC45MTM1NDUsIDAuODM4NjcxLCAwLjU0NDYzOSwgLTAuNDA2NzM3LCAtMC45ODc2ODhdLFxuICAgIFswLjEwNDUyOCwgMC44OTg3OTQsIDAuODQ4MDQ4LCAwLjUyOTkxOSwgLTAuNDM4MzcxLCAtMC45OTQ1MjJdLFxuICAgIFswLjA1MjMzNiwgMC44ODI5NDgsIDAuODU3MTY3LCAwLjUxNTAzOCwgLTAuNDY5NDcyLCAtMC45OTg2MzBdLFxuICAgIFswLjAwMDAwMCwgMC44NjYwMjUsIDAuODY2MDI1LCAwLjUwMDAwMCwgLTAuNTAwMDAwLCAtMS4wMDAwMDBdLFxuICAgIFstMC4wNTIzMzYsIDAuODQ4MDQ4LCAwLjg3NDYyMCwgMC40ODQ4MTAsIC0wLjUyOTkxOSwgLTAuOTk4NjMwXSxcbiAgICBbLTAuMTA0NTI4LCAwLjgyOTAzOCwgMC44ODI5NDgsIDAuNDY5NDcyLCAtMC41NTkxOTMsIC0wLjk5NDUyMl0sXG4gICAgWy0wLjE1NjQzNCwgMC44MDkwMTcsIDAuODkxMDA3LCAwLjQ1Mzk5MCwgLTAuNTg3Nzg1LCAtMC45ODc2ODhdLFxuICAgIFstMC4yMDc5MTIsIDAuNzg4MDExLCAwLjg5ODc5NCwgMC40MzgzNzEsIC0wLjYxNTY2MSwgLTAuOTc4MTQ4XSxcbiAgICBbLTAuMjU4ODE5LCAwLjc2NjA0NCwgMC45MDYzMDgsIDAuNDIyNjE4LCAtMC42NDI3ODgsIC0wLjk2NTkyNl0sXG4gICAgWy0wLjMwOTAxNywgMC43NDMxNDUsIDAuOTEzNTQ1LCAwLjQwNjczNywgLTAuNjY5MTMxLCAtMC45NTEwNTddLFxuICAgIFstMC4zNTgzNjgsIDAuNzE5MzQwLCAwLjkyMDUwNSwgMC4zOTA3MzEsIC0wLjY5NDY1OCwgLTAuOTMzNTgwXSxcbiAgICBbLTAuNDA2NzM3LCAwLjY5NDY1OCwgMC45MjcxODQsIDAuMzc0NjA3LCAtMC43MTkzNDAsIC0wLjkxMzU0NV0sXG4gICAgWy0wLjQ1Mzk5MCwgMC42NjkxMzEsIDAuOTMzNTgwLCAwLjM1ODM2OCwgLTAuNzQzMTQ1LCAtMC44OTEwMDddLFxuICAgIFstMC41MDAwMDAsIDAuNjQyNzg4LCAwLjkzOTY5MywgMC4zNDIwMjAsIC0wLjc2NjA0NCwgLTAuODY2MDI1XSxcbiAgICBbLTAuNTQ0NjM5LCAwLjYxNTY2MSwgMC45NDU1MTksIDAuMzI1NTY4LCAtMC43ODgwMTEsIC0wLjgzODY3MV0sXG4gICAgWy0wLjU4Nzc4NSwgMC41ODc3ODUsIDAuOTUxMDU3LCAwLjMwOTAxNywgLTAuODA5MDE3LCAtMC44MDkwMTddLFxuICAgIFstMC42MjkzMjAsIDAuNTU5MTkzLCAwLjk1NjMwNSwgMC4yOTIzNzIsIC0wLjgyOTAzOCwgLTAuNzc3MTQ2XSxcbiAgICBbLTAuNjY5MTMxLCAwLjUyOTkxOSwgMC45NjEyNjIsIDAuMjc1NjM3LCAtMC44NDgwNDgsIC0wLjc0MzE0NV0sXG4gICAgWy0wLjcwNzEwNywgMC41MDAwMDAsIDAuOTY1OTI2LCAwLjI1ODgxOSwgLTAuODY2MDI1LCAtMC43MDcxMDddLFxuICAgIFstMC43NDMxNDUsIDAuNDY5NDcyLCAwLjk3MDI5NiwgMC4yNDE5MjIsIC0wLjg4Mjk0OCwgLTAuNjY5MTMxXSxcbiAgICBbLTAuNzc3MTQ2LCAwLjQzODM3MSwgMC45NzQzNzAsIDAuMjI0OTUxLCAtMC44OTg3OTQsIC0wLjYyOTMyMF0sXG4gICAgWy0wLjgwOTAxNywgMC40MDY3MzcsIDAuOTc4MTQ4LCAwLjIwNzkxMiwgLTAuOTEzNTQ1LCAtMC41ODc3ODVdLFxuICAgIFstMC44Mzg2NzEsIDAuMzc0NjA3LCAwLjk4MTYyNywgMC4xOTA4MDksIC0wLjkyNzE4NCwgLTAuNTQ0NjM5XSxcbiAgICBbLTAuODY2MDI1LCAwLjM0MjAyMCwgMC45ODQ4MDgsIDAuMTczNjQ4LCAtMC45Mzk2OTMsIC0wLjUwMDAwMF0sXG4gICAgWy0wLjg5MTAwNywgMC4zMDkwMTcsIDAuOTg3Njg4LCAwLjE1NjQzNCwgLTAuOTUxMDU3LCAtMC40NTM5OTBdLFxuICAgIFstMC45MTM1NDUsIDAuMjc1NjM3LCAwLjk5MDI2OCwgMC4xMzkxNzMsIC0wLjk2MTI2MiwgLTAuNDA2NzM3XSxcbiAgICBbLTAuOTMzNTgwLCAwLjI0MTkyMiwgMC45OTI1NDYsIDAuMTIxODY5LCAtMC45NzAyOTYsIC0wLjM1ODM2OF0sXG4gICAgWy0wLjk1MTA1NywgMC4yMDc5MTIsIDAuOTk0NTIyLCAwLjEwNDUyOCwgLTAuOTc4MTQ4LCAtMC4zMDkwMTddLFxuICAgIFstMC45NjU5MjYsIDAuMTczNjQ4LCAwLjk5NjE5NSwgMC4wODcxNTYsIC0wLjk4NDgwOCwgLTAuMjU4ODE5XSxcbiAgICBbLTAuOTc4MTQ4LCAwLjEzOTE3MywgMC45OTc1NjQsIDAuMDY5NzU2LCAtMC45OTAyNjgsIC0wLjIwNzkxMl0sXG4gICAgWy0wLjk4NzY4OCwgMC4xMDQ1MjgsIDAuOTk4NjMwLCAwLjA1MjMzNiwgLTAuOTk0NTIyLCAtMC4xNTY0MzRdLFxuICAgIFstMC45OTQ1MjIsIDAuMDY5NzU2LCAwLjk5OTM5MSwgMC4wMzQ4OTksIC0wLjk5NzU2NCwgLTAuMTA0NTI4XSxcbiAgICBbLTAuOTk4NjMwLCAwLjAzNDg5OSwgMC45OTk4NDgsIDAuMDE3NDUyLCAtMC45OTkzOTEsIC0wLjA1MjMzNl0sXG4gICAgWy0xLjAwMDAwMCwgMC4wMDAwMDAsIDEuMDAwMDAwLCAwLjAwMDAwMCwgLTEuMDAwMDAwLCAtMC4wMDAwMDBdLFxuICAgIFstMC45OTg2MzAsIC0wLjAzNDg5OSwgMC45OTk4NDgsIC0wLjAxNzQ1MiwgLTAuOTk5MzkxLCAwLjA1MjMzNl0sXG4gICAgWy0wLjk5NDUyMiwgLTAuMDY5NzU2LCAwLjk5OTM5MSwgLTAuMDM0ODk5LCAtMC45OTc1NjQsIDAuMTA0NTI4XSxcbiAgICBbLTAuOTg3Njg4LCAtMC4xMDQ1MjgsIDAuOTk4NjMwLCAtMC4wNTIzMzYsIC0wLjk5NDUyMiwgMC4xNTY0MzRdLFxuICAgIFstMC45NzgxNDgsIC0wLjEzOTE3MywgMC45OTc1NjQsIC0wLjA2OTc1NiwgLTAuOTkwMjY4LCAwLjIwNzkxMl0sXG4gICAgWy0wLjk2NTkyNiwgLTAuMTczNjQ4LCAwLjk5NjE5NSwgLTAuMDg3MTU2LCAtMC45ODQ4MDgsIDAuMjU4ODE5XSxcbiAgICBbLTAuOTUxMDU3LCAtMC4yMDc5MTIsIDAuOTk0NTIyLCAtMC4xMDQ1MjgsIC0wLjk3ODE0OCwgMC4zMDkwMTddLFxuICAgIFstMC45MzM1ODAsIC0wLjI0MTkyMiwgMC45OTI1NDYsIC0wLjEyMTg2OSwgLTAuOTcwMjk2LCAwLjM1ODM2OF0sXG4gICAgWy0wLjkxMzU0NSwgLTAuMjc1NjM3LCAwLjk5MDI2OCwgLTAuMTM5MTczLCAtMC45NjEyNjIsIDAuNDA2NzM3XSxcbiAgICBbLTAuODkxMDA3LCAtMC4zMDkwMTcsIDAuOTg3Njg4LCAtMC4xNTY0MzQsIC0wLjk1MTA1NywgMC40NTM5OTBdLFxuICAgIFstMC44NjYwMjUsIC0wLjM0MjAyMCwgMC45ODQ4MDgsIC0wLjE3MzY0OCwgLTAuOTM5NjkzLCAwLjUwMDAwMF0sXG4gICAgWy0wLjgzODY3MSwgLTAuMzc0NjA3LCAwLjk4MTYyNywgLTAuMTkwODA5LCAtMC45MjcxODQsIDAuNTQ0NjM5XSxcbiAgICBbLTAuODA5MDE3LCAtMC40MDY3MzcsIDAuOTc4MTQ4LCAtMC4yMDc5MTIsIC0wLjkxMzU0NSwgMC41ODc3ODVdLFxuICAgIFstMC43NzcxNDYsIC0wLjQzODM3MSwgMC45NzQzNzAsIC0wLjIyNDk1MSwgLTAuODk4Nzk0LCAwLjYyOTMyMF0sXG4gICAgWy0wLjc0MzE0NSwgLTAuNDY5NDcyLCAwLjk3MDI5NiwgLTAuMjQxOTIyLCAtMC44ODI5NDgsIDAuNjY5MTMxXSxcbiAgICBbLTAuNzA3MTA3LCAtMC41MDAwMDAsIDAuOTY1OTI2LCAtMC4yNTg4MTksIC0wLjg2NjAyNSwgMC43MDcxMDddLFxuICAgIFstMC42NjkxMzEsIC0wLjUyOTkxOSwgMC45NjEyNjIsIC0wLjI3NTYzNywgLTAuODQ4MDQ4LCAwLjc0MzE0NV0sXG4gICAgWy0wLjYyOTMyMCwgLTAuNTU5MTkzLCAwLjk1NjMwNSwgLTAuMjkyMzcyLCAtMC44MjkwMzgsIDAuNzc3MTQ2XSxcbiAgICBbLTAuNTg3Nzg1LCAtMC41ODc3ODUsIDAuOTUxMDU3LCAtMC4zMDkwMTcsIC0wLjgwOTAxNywgMC44MDkwMTddLFxuICAgIFstMC41NDQ2MzksIC0wLjYxNTY2MSwgMC45NDU1MTksIC0wLjMyNTU2OCwgLTAuNzg4MDExLCAwLjgzODY3MV0sXG4gICAgWy0wLjUwMDAwMCwgLTAuNjQyNzg4LCAwLjkzOTY5MywgLTAuMzQyMDIwLCAtMC43NjYwNDQsIDAuODY2MDI1XSxcbiAgICBbLTAuNDUzOTkwLCAtMC42NjkxMzEsIDAuOTMzNTgwLCAtMC4zNTgzNjgsIC0wLjc0MzE0NSwgMC44OTEwMDddLFxuICAgIFstMC40MDY3MzcsIC0wLjY5NDY1OCwgMC45MjcxODQsIC0wLjM3NDYwNywgLTAuNzE5MzQwLCAwLjkxMzU0NV0sXG4gICAgWy0wLjM1ODM2OCwgLTAuNzE5MzQwLCAwLjkyMDUwNSwgLTAuMzkwNzMxLCAtMC42OTQ2NTgsIDAuOTMzNTgwXSxcbiAgICBbLTAuMzA5MDE3LCAtMC43NDMxNDUsIDAuOTEzNTQ1LCAtMC40MDY3MzcsIC0wLjY2OTEzMSwgMC45NTEwNTddLFxuICAgIFstMC4yNTg4MTksIC0wLjc2NjA0NCwgMC45MDYzMDgsIC0wLjQyMjYxOCwgLTAuNjQyNzg4LCAwLjk2NTkyNl0sXG4gICAgWy0wLjIwNzkxMiwgLTAuNzg4MDExLCAwLjg5ODc5NCwgLTAuNDM4MzcxLCAtMC42MTU2NjEsIDAuOTc4MTQ4XSxcbiAgICBbLTAuMTU2NDM0LCAtMC44MDkwMTcsIDAuODkxMDA3LCAtMC40NTM5OTAsIC0wLjU4Nzc4NSwgMC45ODc2ODhdLFxuICAgIFstMC4xMDQ1MjgsIC0wLjgyOTAzOCwgMC44ODI5NDgsIC0wLjQ2OTQ3MiwgLTAuNTU5MTkzLCAwLjk5NDUyMl0sXG4gICAgWy0wLjA1MjMzNiwgLTAuODQ4MDQ4LCAwLjg3NDYyMCwgLTAuNDg0ODEwLCAtMC41Mjk5MTksIDAuOTk4NjMwXSxcbiAgICBbLTAuMDAwMDAwLCAtMC44NjYwMjUsIDAuODY2MDI1LCAtMC41MDAwMDAsIC0wLjUwMDAwMCwgMS4wMDAwMDBdLFxuICAgIFswLjA1MjMzNiwgLTAuODgyOTQ4LCAwLjg1NzE2NywgLTAuNTE1MDM4LCAtMC40Njk0NzIsIDAuOTk4NjMwXSxcbiAgICBbMC4xMDQ1MjgsIC0wLjg5ODc5NCwgMC44NDgwNDgsIC0wLjUyOTkxOSwgLTAuNDM4MzcxLCAwLjk5NDUyMl0sXG4gICAgWzAuMTU2NDM0LCAtMC45MTM1NDUsIDAuODM4NjcxLCAtMC41NDQ2MzksIC0wLjQwNjczNywgMC45ODc2ODhdLFxuICAgIFswLjIwNzkxMiwgLTAuOTI3MTg0LCAwLjgyOTAzOCwgLTAuNTU5MTkzLCAtMC4zNzQ2MDcsIDAuOTc4MTQ4XSxcbiAgICBbMC4yNTg4MTksIC0wLjkzOTY5MywgMC44MTkxNTIsIC0wLjU3MzU3NiwgLTAuMzQyMDIwLCAwLjk2NTkyNl0sXG4gICAgWzAuMzA5MDE3LCAtMC45NTEwNTcsIDAuODA5MDE3LCAtMC41ODc3ODUsIC0wLjMwOTAxNywgMC45NTEwNTddLFxuICAgIFswLjM1ODM2OCwgLTAuOTYxMjYyLCAwLjc5ODYzNiwgLTAuNjAxODE1LCAtMC4yNzU2MzcsIDAuOTMzNTgwXSxcbiAgICBbMC40MDY3MzcsIC0wLjk3MDI5NiwgMC43ODgwMTEsIC0wLjYxNTY2MSwgLTAuMjQxOTIyLCAwLjkxMzU0NV0sXG4gICAgWzAuNDUzOTkwLCAtMC45NzgxNDgsIDAuNzc3MTQ2LCAtMC42MjkzMjAsIC0wLjIwNzkxMiwgMC44OTEwMDddLFxuICAgIFswLjUwMDAwMCwgLTAuOTg0ODA4LCAwLjc2NjA0NCwgLTAuNjQyNzg4LCAtMC4xNzM2NDgsIDAuODY2MDI1XSxcbiAgICBbMC41NDQ2MzksIC0wLjk5MDI2OCwgMC43NTQ3MTAsIC0wLjY1NjA1OSwgLTAuMTM5MTczLCAwLjgzODY3MV0sXG4gICAgWzAuNTg3Nzg1LCAtMC45OTQ1MjIsIDAuNzQzMTQ1LCAtMC42NjkxMzEsIC0wLjEwNDUyOCwgMC44MDkwMTddLFxuICAgIFswLjYyOTMyMCwgLTAuOTk3NTY0LCAwLjczMTM1NCwgLTAuNjgxOTk4LCAtMC4wNjk3NTYsIDAuNzc3MTQ2XSxcbiAgICBbMC42NjkxMzEsIC0wLjk5OTM5MSwgMC43MTkzNDAsIC0wLjY5NDY1OCwgLTAuMDM0ODk5LCAwLjc0MzE0NV0sXG4gICAgWzAuNzA3MTA3LCAtMS4wMDAwMDAsIDAuNzA3MTA3LCAtMC43MDcxMDcsIC0wLjAwMDAwMCwgMC43MDcxMDddLFxuICAgIFswLjc0MzE0NSwgLTAuOTk5MzkxLCAwLjY5NDY1OCwgLTAuNzE5MzQwLCAwLjAzNDg5OSwgMC42NjkxMzFdLFxuICAgIFswLjc3NzE0NiwgLTAuOTk3NTY0LCAwLjY4MTk5OCwgLTAuNzMxMzU0LCAwLjA2OTc1NiwgMC42MjkzMjBdLFxuICAgIFswLjgwOTAxNywgLTAuOTk0NTIyLCAwLjY2OTEzMSwgLTAuNzQzMTQ1LCAwLjEwNDUyOCwgMC41ODc3ODVdLFxuICAgIFswLjgzODY3MSwgLTAuOTkwMjY4LCAwLjY1NjA1OSwgLTAuNzU0NzEwLCAwLjEzOTE3MywgMC41NDQ2MzldLFxuICAgIFswLjg2NjAyNSwgLTAuOTg0ODA4LCAwLjY0Mjc4OCwgLTAuNzY2MDQ0LCAwLjE3MzY0OCwgMC41MDAwMDBdLFxuICAgIFswLjg5MTAwNywgLTAuOTc4MTQ4LCAwLjYyOTMyMCwgLTAuNzc3MTQ2LCAwLjIwNzkxMiwgMC40NTM5OTBdLFxuICAgIFswLjkxMzU0NSwgLTAuOTcwMjk2LCAwLjYxNTY2MSwgLTAuNzg4MDExLCAwLjI0MTkyMiwgMC40MDY3MzddLFxuICAgIFswLjkzMzU4MCwgLTAuOTYxMjYyLCAwLjYwMTgxNSwgLTAuNzk4NjM2LCAwLjI3NTYzNywgMC4zNTgzNjhdLFxuICAgIFswLjk1MTA1NywgLTAuOTUxMDU3LCAwLjU4Nzc4NSwgLTAuODA5MDE3LCAwLjMwOTAxNywgMC4zMDkwMTddLFxuICAgIFswLjk2NTkyNiwgLTAuOTM5NjkzLCAwLjU3MzU3NiwgLTAuODE5MTUyLCAwLjM0MjAyMCwgMC4yNTg4MTldLFxuICAgIFswLjk3ODE0OCwgLTAuOTI3MTg0LCAwLjU1OTE5MywgLTAuODI5MDM4LCAwLjM3NDYwNywgMC4yMDc5MTJdLFxuICAgIFswLjk4NzY4OCwgLTAuOTEzNTQ1LCAwLjU0NDYzOSwgLTAuODM4NjcxLCAwLjQwNjczNywgMC4xNTY0MzRdLFxuICAgIFswLjk5NDUyMiwgLTAuODk4Nzk0LCAwLjUyOTkxOSwgLTAuODQ4MDQ4LCAwLjQzODM3MSwgMC4xMDQ1MjhdLFxuICAgIFswLjk5ODYzMCwgLTAuODgyOTQ4LCAwLjUxNTAzOCwgLTAuODU3MTY3LCAwLjQ2OTQ3MiwgMC4wNTIzMzZdLFxuICAgIFsxLjAwMDAwMCwgLTAuODY2MDI1LCAwLjUwMDAwMCwgLTAuODY2MDI1LCAwLjUwMDAwMCwgMC4wMDAwMDBdLFxuICAgIFswLjk5ODYzMCwgLTAuODQ4MDQ4LCAwLjQ4NDgxMCwgLTAuODc0NjIwLCAwLjUyOTkxOSwgLTAuMDUyMzM2XSxcbiAgICBbMC45OTQ1MjIsIC0wLjgyOTAzOCwgMC40Njk0NzIsIC0wLjg4Mjk0OCwgMC41NTkxOTMsIC0wLjEwNDUyOF0sXG4gICAgWzAuOTg3Njg4LCAtMC44MDkwMTcsIDAuNDUzOTkwLCAtMC44OTEwMDcsIDAuNTg3Nzg1LCAtMC4xNTY0MzRdLFxuICAgIFswLjk3ODE0OCwgLTAuNzg4MDExLCAwLjQzODM3MSwgLTAuODk4Nzk0LCAwLjYxNTY2MSwgLTAuMjA3OTEyXSxcbiAgICBbMC45NjU5MjYsIC0wLjc2NjA0NCwgMC40MjI2MTgsIC0wLjkwNjMwOCwgMC42NDI3ODgsIC0wLjI1ODgxOV0sXG4gICAgWzAuOTUxMDU3LCAtMC43NDMxNDUsIDAuNDA2NzM3LCAtMC45MTM1NDUsIDAuNjY5MTMxLCAtMC4zMDkwMTddLFxuICAgIFswLjkzMzU4MCwgLTAuNzE5MzQwLCAwLjM5MDczMSwgLTAuOTIwNTA1LCAwLjY5NDY1OCwgLTAuMzU4MzY4XSxcbiAgICBbMC45MTM1NDUsIC0wLjY5NDY1OCwgMC4zNzQ2MDcsIC0wLjkyNzE4NCwgMC43MTkzNDAsIC0wLjQwNjczN10sXG4gICAgWzAuODkxMDA3LCAtMC42NjkxMzEsIDAuMzU4MzY4LCAtMC45MzM1ODAsIDAuNzQzMTQ1LCAtMC40NTM5OTBdLFxuICAgIFswLjg2NjAyNSwgLTAuNjQyNzg4LCAwLjM0MjAyMCwgLTAuOTM5NjkzLCAwLjc2NjA0NCwgLTAuNTAwMDAwXSxcbiAgICBbMC44Mzg2NzEsIC0wLjYxNTY2MSwgMC4zMjU1NjgsIC0wLjk0NTUxOSwgMC43ODgwMTEsIC0wLjU0NDYzOV0sXG4gICAgWzAuODA5MDE3LCAtMC41ODc3ODUsIDAuMzA5MDE3LCAtMC45NTEwNTcsIDAuODA5MDE3LCAtMC41ODc3ODVdLFxuICAgIFswLjc3NzE0NiwgLTAuNTU5MTkzLCAwLjI5MjM3MiwgLTAuOTU2MzA1LCAwLjgyOTAzOCwgLTAuNjI5MzIwXSxcbiAgICBbMC43NDMxNDUsIC0wLjUyOTkxOSwgMC4yNzU2MzcsIC0wLjk2MTI2MiwgMC44NDgwNDgsIC0wLjY2OTEzMV0sXG4gICAgWzAuNzA3MTA3LCAtMC41MDAwMDAsIDAuMjU4ODE5LCAtMC45NjU5MjYsIDAuODY2MDI1LCAtMC43MDcxMDddLFxuICAgIFswLjY2OTEzMSwgLTAuNDY5NDcyLCAwLjI0MTkyMiwgLTAuOTcwMjk2LCAwLjg4Mjk0OCwgLTAuNzQzMTQ1XSxcbiAgICBbMC42MjkzMjAsIC0wLjQzODM3MSwgMC4yMjQ5NTEsIC0wLjk3NDM3MCwgMC44OTg3OTQsIC0wLjc3NzE0Nl0sXG4gICAgWzAuNTg3Nzg1LCAtMC40MDY3MzcsIDAuMjA3OTEyLCAtMC45NzgxNDgsIDAuOTEzNTQ1LCAtMC44MDkwMTddLFxuICAgIFswLjU0NDYzOSwgLTAuMzc0NjA3LCAwLjE5MDgwOSwgLTAuOTgxNjI3LCAwLjkyNzE4NCwgLTAuODM4NjcxXSxcbiAgICBbMC41MDAwMDAsIC0wLjM0MjAyMCwgMC4xNzM2NDgsIC0wLjk4NDgwOCwgMC45Mzk2OTMsIC0wLjg2NjAyNV0sXG4gICAgWzAuNDUzOTkwLCAtMC4zMDkwMTcsIDAuMTU2NDM0LCAtMC45ODc2ODgsIDAuOTUxMDU3LCAtMC44OTEwMDddLFxuICAgIFswLjQwNjczNywgLTAuMjc1NjM3LCAwLjEzOTE3MywgLTAuOTkwMjY4LCAwLjk2MTI2MiwgLTAuOTEzNTQ1XSxcbiAgICBbMC4zNTgzNjgsIC0wLjI0MTkyMiwgMC4xMjE4NjksIC0wLjk5MjU0NiwgMC45NzAyOTYsIC0wLjkzMzU4MF0sXG4gICAgWzAuMzA5MDE3LCAtMC4yMDc5MTIsIDAuMTA0NTI4LCAtMC45OTQ1MjIsIDAuOTc4MTQ4LCAtMC45NTEwNTddLFxuICAgIFswLjI1ODgxOSwgLTAuMTczNjQ4LCAwLjA4NzE1NiwgLTAuOTk2MTk1LCAwLjk4NDgwOCwgLTAuOTY1OTI2XSxcbiAgICBbMC4yMDc5MTIsIC0wLjEzOTE3MywgMC4wNjk3NTYsIC0wLjk5NzU2NCwgMC45OTAyNjgsIC0wLjk3ODE0OF0sXG4gICAgWzAuMTU2NDM0LCAtMC4xMDQ1MjgsIDAuMDUyMzM2LCAtMC45OTg2MzAsIDAuOTk0NTIyLCAtMC45ODc2ODhdLFxuICAgIFswLjEwNDUyOCwgLTAuMDY5NzU2LCAwLjAzNDg5OSwgLTAuOTk5MzkxLCAwLjk5NzU2NCwgLTAuOTk0NTIyXSxcbiAgICBbMC4wNTIzMzYsIC0wLjAzNDg5OSwgMC4wMTc0NTIsIC0wLjk5OTg0OCwgMC45OTkzOTEsIC0wLjk5ODYzMF0sXG4gICAgWzAuMDAwMDAwLCAtMC4wMDAwMDAsIDAuMDAwMDAwLCAtMS4wMDAwMDAsIDEuMDAwMDAwLCAtMS4wMDAwMDBdLFxuICAgIFstMC4wNTIzMzYsIDAuMDM0ODk5LCAtMC4wMTc0NTIsIC0wLjk5OTg0OCwgMC45OTkzOTEsIC0wLjk5ODYzMF0sXG4gICAgWy0wLjEwNDUyOCwgMC4wNjk3NTYsIC0wLjAzNDg5OSwgLTAuOTk5MzkxLCAwLjk5NzU2NCwgLTAuOTk0NTIyXSxcbiAgICBbLTAuMTU2NDM0LCAwLjEwNDUyOCwgLTAuMDUyMzM2LCAtMC45OTg2MzAsIDAuOTk0NTIyLCAtMC45ODc2ODhdLFxuICAgIFstMC4yMDc5MTIsIDAuMTM5MTczLCAtMC4wNjk3NTYsIC0wLjk5NzU2NCwgMC45OTAyNjgsIC0wLjk3ODE0OF0sXG4gICAgWy0wLjI1ODgxOSwgMC4xNzM2NDgsIC0wLjA4NzE1NiwgLTAuOTk2MTk1LCAwLjk4NDgwOCwgLTAuOTY1OTI2XSxcbiAgICBbLTAuMzA5MDE3LCAwLjIwNzkxMiwgLTAuMTA0NTI4LCAtMC45OTQ1MjIsIDAuOTc4MTQ4LCAtMC45NTEwNTddLFxuICAgIFstMC4zNTgzNjgsIDAuMjQxOTIyLCAtMC4xMjE4NjksIC0wLjk5MjU0NiwgMC45NzAyOTYsIC0wLjkzMzU4MF0sXG4gICAgWy0wLjQwNjczNywgMC4yNzU2MzcsIC0wLjEzOTE3MywgLTAuOTkwMjY4LCAwLjk2MTI2MiwgLTAuOTEzNTQ1XSxcbiAgICBbLTAuNDUzOTkwLCAwLjMwOTAxNywgLTAuMTU2NDM0LCAtMC45ODc2ODgsIDAuOTUxMDU3LCAtMC44OTEwMDddLFxuICAgIFstMC41MDAwMDAsIDAuMzQyMDIwLCAtMC4xNzM2NDgsIC0wLjk4NDgwOCwgMC45Mzk2OTMsIC0wLjg2NjAyNV0sXG4gICAgWy0wLjU0NDYzOSwgMC4zNzQ2MDcsIC0wLjE5MDgwOSwgLTAuOTgxNjI3LCAwLjkyNzE4NCwgLTAuODM4NjcxXSxcbiAgICBbLTAuNTg3Nzg1LCAwLjQwNjczNywgLTAuMjA3OTEyLCAtMC45NzgxNDgsIDAuOTEzNTQ1LCAtMC44MDkwMTddLFxuICAgIFstMC42MjkzMjAsIDAuNDM4MzcxLCAtMC4yMjQ5NTEsIC0wLjk3NDM3MCwgMC44OTg3OTQsIC0wLjc3NzE0Nl0sXG4gICAgWy0wLjY2OTEzMSwgMC40Njk0NzIsIC0wLjI0MTkyMiwgLTAuOTcwMjk2LCAwLjg4Mjk0OCwgLTAuNzQzMTQ1XSxcbiAgICBbLTAuNzA3MTA3LCAwLjUwMDAwMCwgLTAuMjU4ODE5LCAtMC45NjU5MjYsIDAuODY2MDI1LCAtMC43MDcxMDddLFxuICAgIFstMC43NDMxNDUsIDAuNTI5OTE5LCAtMC4yNzU2MzcsIC0wLjk2MTI2MiwgMC44NDgwNDgsIC0wLjY2OTEzMV0sXG4gICAgWy0wLjc3NzE0NiwgMC41NTkxOTMsIC0wLjI5MjM3MiwgLTAuOTU2MzA1LCAwLjgyOTAzOCwgLTAuNjI5MzIwXSxcbiAgICBbLTAuODA5MDE3LCAwLjU4Nzc4NSwgLTAuMzA5MDE3LCAtMC45NTEwNTcsIDAuODA5MDE3LCAtMC41ODc3ODVdLFxuICAgIFstMC44Mzg2NzEsIDAuNjE1NjYxLCAtMC4zMjU1NjgsIC0wLjk0NTUxOSwgMC43ODgwMTEsIC0wLjU0NDYzOV0sXG4gICAgWy0wLjg2NjAyNSwgMC42NDI3ODgsIC0wLjM0MjAyMCwgLTAuOTM5NjkzLCAwLjc2NjA0NCwgLTAuNTAwMDAwXSxcbiAgICBbLTAuODkxMDA3LCAwLjY2OTEzMSwgLTAuMzU4MzY4LCAtMC45MzM1ODAsIDAuNzQzMTQ1LCAtMC40NTM5OTBdLFxuICAgIFstMC45MTM1NDUsIDAuNjk0NjU4LCAtMC4zNzQ2MDcsIC0wLjkyNzE4NCwgMC43MTkzNDAsIC0wLjQwNjczN10sXG4gICAgWy0wLjkzMzU4MCwgMC43MTkzNDAsIC0wLjM5MDczMSwgLTAuOTIwNTA1LCAwLjY5NDY1OCwgLTAuMzU4MzY4XSxcbiAgICBbLTAuOTUxMDU3LCAwLjc0MzE0NSwgLTAuNDA2NzM3LCAtMC45MTM1NDUsIDAuNjY5MTMxLCAtMC4zMDkwMTddLFxuICAgIFstMC45NjU5MjYsIDAuNzY2MDQ0LCAtMC40MjI2MTgsIC0wLjkwNjMwOCwgMC42NDI3ODgsIC0wLjI1ODgxOV0sXG4gICAgWy0wLjk3ODE0OCwgMC43ODgwMTEsIC0wLjQzODM3MSwgLTAuODk4Nzk0LCAwLjYxNTY2MSwgLTAuMjA3OTEyXSxcbiAgICBbLTAuOTg3Njg4LCAwLjgwOTAxNywgLTAuNDUzOTkwLCAtMC44OTEwMDcsIDAuNTg3Nzg1LCAtMC4xNTY0MzRdLFxuICAgIFstMC45OTQ1MjIsIDAuODI5MDM4LCAtMC40Njk0NzIsIC0wLjg4Mjk0OCwgMC41NTkxOTMsIC0wLjEwNDUyOF0sXG4gICAgWy0wLjk5ODYzMCwgMC44NDgwNDgsIC0wLjQ4NDgxMCwgLTAuODc0NjIwLCAwLjUyOTkxOSwgLTAuMDUyMzM2XSxcbiAgICBbLTEuMDAwMDAwLCAwLjg2NjAyNSwgLTAuNTAwMDAwLCAtMC44NjYwMjUsIDAuNTAwMDAwLCAwLjAwMDAwMF0sXG4gICAgWy0wLjk5ODYzMCwgMC44ODI5NDgsIC0wLjUxNTAzOCwgLTAuODU3MTY3LCAwLjQ2OTQ3MiwgMC4wNTIzMzZdLFxuICAgIFstMC45OTQ1MjIsIDAuODk4Nzk0LCAtMC41Mjk5MTksIC0wLjg0ODA0OCwgMC40MzgzNzEsIDAuMTA0NTI4XSxcbiAgICBbLTAuOTg3Njg4LCAwLjkxMzU0NSwgLTAuNTQ0NjM5LCAtMC44Mzg2NzEsIDAuNDA2NzM3LCAwLjE1NjQzNF0sXG4gICAgWy0wLjk3ODE0OCwgMC45MjcxODQsIC0wLjU1OTE5MywgLTAuODI5MDM4LCAwLjM3NDYwNywgMC4yMDc5MTJdLFxuICAgIFstMC45NjU5MjYsIDAuOTM5NjkzLCAtMC41NzM1NzYsIC0wLjgxOTE1MiwgMC4zNDIwMjAsIDAuMjU4ODE5XSxcbiAgICBbLTAuOTUxMDU3LCAwLjk1MTA1NywgLTAuNTg3Nzg1LCAtMC44MDkwMTcsIDAuMzA5MDE3LCAwLjMwOTAxN10sXG4gICAgWy0wLjkzMzU4MCwgMC45NjEyNjIsIC0wLjYwMTgxNSwgLTAuNzk4NjM2LCAwLjI3NTYzNywgMC4zNTgzNjhdLFxuICAgIFstMC45MTM1NDUsIDAuOTcwMjk2LCAtMC42MTU2NjEsIC0wLjc4ODAxMSwgMC4yNDE5MjIsIDAuNDA2NzM3XSxcbiAgICBbLTAuODkxMDA3LCAwLjk3ODE0OCwgLTAuNjI5MzIwLCAtMC43NzcxNDYsIDAuMjA3OTEyLCAwLjQ1Mzk5MF0sXG4gICAgWy0wLjg2NjAyNSwgMC45ODQ4MDgsIC0wLjY0Mjc4OCwgLTAuNzY2MDQ0LCAwLjE3MzY0OCwgMC41MDAwMDBdLFxuICAgIFstMC44Mzg2NzEsIDAuOTkwMjY4LCAtMC42NTYwNTksIC0wLjc1NDcxMCwgMC4xMzkxNzMsIDAuNTQ0NjM5XSxcbiAgICBbLTAuODA5MDE3LCAwLjk5NDUyMiwgLTAuNjY5MTMxLCAtMC43NDMxNDUsIDAuMTA0NTI4LCAwLjU4Nzc4NV0sXG4gICAgWy0wLjc3NzE0NiwgMC45OTc1NjQsIC0wLjY4MTk5OCwgLTAuNzMxMzU0LCAwLjA2OTc1NiwgMC42MjkzMjBdLFxuICAgIFstMC43NDMxNDUsIDAuOTk5MzkxLCAtMC42OTQ2NTgsIC0wLjcxOTM0MCwgMC4wMzQ4OTksIDAuNjY5MTMxXSxcbiAgICBbLTAuNzA3MTA3LCAxLjAwMDAwMCwgLTAuNzA3MTA3LCAtMC43MDcxMDcsIDAuMDAwMDAwLCAwLjcwNzEwN10sXG4gICAgWy0wLjY2OTEzMSwgMC45OTkzOTEsIC0wLjcxOTM0MCwgLTAuNjk0NjU4LCAtMC4wMzQ4OTksIDAuNzQzMTQ1XSxcbiAgICBbLTAuNjI5MzIwLCAwLjk5NzU2NCwgLTAuNzMxMzU0LCAtMC42ODE5OTgsIC0wLjA2OTc1NiwgMC43NzcxNDZdLFxuICAgIFstMC41ODc3ODUsIDAuOTk0NTIyLCAtMC43NDMxNDUsIC0wLjY2OTEzMSwgLTAuMTA0NTI4LCAwLjgwOTAxN10sXG4gICAgWy0wLjU0NDYzOSwgMC45OTAyNjgsIC0wLjc1NDcxMCwgLTAuNjU2MDU5LCAtMC4xMzkxNzMsIDAuODM4NjcxXSxcbiAgICBbLTAuNTAwMDAwLCAwLjk4NDgwOCwgLTAuNzY2MDQ0LCAtMC42NDI3ODgsIC0wLjE3MzY0OCwgMC44NjYwMjVdLFxuICAgIFstMC40NTM5OTAsIDAuOTc4MTQ4LCAtMC43NzcxNDYsIC0wLjYyOTMyMCwgLTAuMjA3OTEyLCAwLjg5MTAwN10sXG4gICAgWy0wLjQwNjczNywgMC45NzAyOTYsIC0wLjc4ODAxMSwgLTAuNjE1NjYxLCAtMC4yNDE5MjIsIDAuOTEzNTQ1XSxcbiAgICBbLTAuMzU4MzY4LCAwLjk2MTI2MiwgLTAuNzk4NjM2LCAtMC42MDE4MTUsIC0wLjI3NTYzNywgMC45MzM1ODBdLFxuICAgIFstMC4zMDkwMTcsIDAuOTUxMDU3LCAtMC44MDkwMTcsIC0wLjU4Nzc4NSwgLTAuMzA5MDE3LCAwLjk1MTA1N10sXG4gICAgWy0wLjI1ODgxOSwgMC45Mzk2OTMsIC0wLjgxOTE1MiwgLTAuNTczNTc2LCAtMC4zNDIwMjAsIDAuOTY1OTI2XSxcbiAgICBbLTAuMjA3OTEyLCAwLjkyNzE4NCwgLTAuODI5MDM4LCAtMC41NTkxOTMsIC0wLjM3NDYwNywgMC45NzgxNDhdLFxuICAgIFstMC4xNTY0MzQsIDAuOTEzNTQ1LCAtMC44Mzg2NzEsIC0wLjU0NDYzOSwgLTAuNDA2NzM3LCAwLjk4NzY4OF0sXG4gICAgWy0wLjEwNDUyOCwgMC44OTg3OTQsIC0wLjg0ODA0OCwgLTAuNTI5OTE5LCAtMC40MzgzNzEsIDAuOTk0NTIyXSxcbiAgICBbLTAuMDUyMzM2LCAwLjg4Mjk0OCwgLTAuODU3MTY3LCAtMC41MTUwMzgsIC0wLjQ2OTQ3MiwgMC45OTg2MzBdLFxuICAgIFstMC4wMDAwMDAsIDAuODY2MDI1LCAtMC44NjYwMjUsIC0wLjUwMDAwMCwgLTAuNTAwMDAwLCAxLjAwMDAwMF0sXG4gICAgWzAuMDUyMzM2LCAwLjg0ODA0OCwgLTAuODc0NjIwLCAtMC40ODQ4MTAsIC0wLjUyOTkxOSwgMC45OTg2MzBdLFxuICAgIFswLjEwNDUyOCwgMC44MjkwMzgsIC0wLjg4Mjk0OCwgLTAuNDY5NDcyLCAtMC41NTkxOTMsIDAuOTk0NTIyXSxcbiAgICBbMC4xNTY0MzQsIDAuODA5MDE3LCAtMC44OTEwMDcsIC0wLjQ1Mzk5MCwgLTAuNTg3Nzg1LCAwLjk4NzY4OF0sXG4gICAgWzAuMjA3OTEyLCAwLjc4ODAxMSwgLTAuODk4Nzk0LCAtMC40MzgzNzEsIC0wLjYxNTY2MSwgMC45NzgxNDhdLFxuICAgIFswLjI1ODgxOSwgMC43NjYwNDQsIC0wLjkwNjMwOCwgLTAuNDIyNjE4LCAtMC42NDI3ODgsIDAuOTY1OTI2XSxcbiAgICBbMC4zMDkwMTcsIDAuNzQzMTQ1LCAtMC45MTM1NDUsIC0wLjQwNjczNywgLTAuNjY5MTMxLCAwLjk1MTA1N10sXG4gICAgWzAuMzU4MzY4LCAwLjcxOTM0MCwgLTAuOTIwNTA1LCAtMC4zOTA3MzEsIC0wLjY5NDY1OCwgMC45MzM1ODBdLFxuICAgIFswLjQwNjczNywgMC42OTQ2NTgsIC0wLjkyNzE4NCwgLTAuMzc0NjA3LCAtMC43MTkzNDAsIDAuOTEzNTQ1XSxcbiAgICBbMC40NTM5OTAsIDAuNjY5MTMxLCAtMC45MzM1ODAsIC0wLjM1ODM2OCwgLTAuNzQzMTQ1LCAwLjg5MTAwN10sXG4gICAgWzAuNTAwMDAwLCAwLjY0Mjc4OCwgLTAuOTM5NjkzLCAtMC4zNDIwMjAsIC0wLjc2NjA0NCwgMC44NjYwMjVdLFxuICAgIFswLjU0NDYzOSwgMC42MTU2NjEsIC0wLjk0NTUxOSwgLTAuMzI1NTY4LCAtMC43ODgwMTEsIDAuODM4NjcxXSxcbiAgICBbMC41ODc3ODUsIDAuNTg3Nzg1LCAtMC45NTEwNTcsIC0wLjMwOTAxNywgLTAuODA5MDE3LCAwLjgwOTAxN10sXG4gICAgWzAuNjI5MzIwLCAwLjU1OTE5MywgLTAuOTU2MzA1LCAtMC4yOTIzNzIsIC0wLjgyOTAzOCwgMC43NzcxNDZdLFxuICAgIFswLjY2OTEzMSwgMC41Mjk5MTksIC0wLjk2MTI2MiwgLTAuMjc1NjM3LCAtMC44NDgwNDgsIDAuNzQzMTQ1XSxcbiAgICBbMC43MDcxMDcsIDAuNTAwMDAwLCAtMC45NjU5MjYsIC0wLjI1ODgxOSwgLTAuODY2MDI1LCAwLjcwNzEwN10sXG4gICAgWzAuNzQzMTQ1LCAwLjQ2OTQ3MiwgLTAuOTcwMjk2LCAtMC4yNDE5MjIsIC0wLjg4Mjk0OCwgMC42NjkxMzFdLFxuICAgIFswLjc3NzE0NiwgMC40MzgzNzEsIC0wLjk3NDM3MCwgLTAuMjI0OTUxLCAtMC44OTg3OTQsIDAuNjI5MzIwXSxcbiAgICBbMC44MDkwMTcsIDAuNDA2NzM3LCAtMC45NzgxNDgsIC0wLjIwNzkxMiwgLTAuOTEzNTQ1LCAwLjU4Nzc4NV0sXG4gICAgWzAuODM4NjcxLCAwLjM3NDYwNywgLTAuOTgxNjI3LCAtMC4xOTA4MDksIC0wLjkyNzE4NCwgMC41NDQ2MzldLFxuICAgIFswLjg2NjAyNSwgMC4zNDIwMjAsIC0wLjk4NDgwOCwgLTAuMTczNjQ4LCAtMC45Mzk2OTMsIDAuNTAwMDAwXSxcbiAgICBbMC44OTEwMDcsIDAuMzA5MDE3LCAtMC45ODc2ODgsIC0wLjE1NjQzNCwgLTAuOTUxMDU3LCAwLjQ1Mzk5MF0sXG4gICAgWzAuOTEzNTQ1LCAwLjI3NTYzNywgLTAuOTkwMjY4LCAtMC4xMzkxNzMsIC0wLjk2MTI2MiwgMC40MDY3MzddLFxuICAgIFswLjkzMzU4MCwgMC4yNDE5MjIsIC0wLjk5MjU0NiwgLTAuMTIxODY5LCAtMC45NzAyOTYsIDAuMzU4MzY4XSxcbiAgICBbMC45NTEwNTcsIDAuMjA3OTEyLCAtMC45OTQ1MjIsIC0wLjEwNDUyOCwgLTAuOTc4MTQ4LCAwLjMwOTAxN10sXG4gICAgWzAuOTY1OTI2LCAwLjE3MzY0OCwgLTAuOTk2MTk1LCAtMC4wODcxNTYsIC0wLjk4NDgwOCwgMC4yNTg4MTldLFxuICAgIFswLjk3ODE0OCwgMC4xMzkxNzMsIC0wLjk5NzU2NCwgLTAuMDY5NzU2LCAtMC45OTAyNjgsIDAuMjA3OTEyXSxcbiAgICBbMC45ODc2ODgsIDAuMTA0NTI4LCAtMC45OTg2MzAsIC0wLjA1MjMzNiwgLTAuOTk0NTIyLCAwLjE1NjQzNF0sXG4gICAgWzAuOTk0NTIyLCAwLjA2OTc1NiwgLTAuOTk5MzkxLCAtMC4wMzQ4OTksIC0wLjk5NzU2NCwgMC4xMDQ1MjhdLFxuICAgIFswLjk5ODYzMCwgMC4wMzQ4OTksIC0wLjk5OTg0OCwgLTAuMDE3NDUyLCAtMC45OTkzOTEsIDAuMDUyMzM2XSxcbiAgICBbMS4wMDAwMDAsIDAuMDAwMDAwLCAtMS4wMDAwMDAsIC0wLjAwMDAwMCwgLTEuMDAwMDAwLCAwLjAwMDAwMF0sXG4gICAgWzAuOTk4NjMwLCAtMC4wMzQ4OTksIC0wLjk5OTg0OCwgMC4wMTc0NTIsIC0wLjk5OTM5MSwgLTAuMDUyMzM2XSxcbiAgICBbMC45OTQ1MjIsIC0wLjA2OTc1NiwgLTAuOTk5MzkxLCAwLjAzNDg5OSwgLTAuOTk3NTY0LCAtMC4xMDQ1MjhdLFxuICAgIFswLjk4NzY4OCwgLTAuMTA0NTI4LCAtMC45OTg2MzAsIDAuMDUyMzM2LCAtMC45OTQ1MjIsIC0wLjE1NjQzNF0sXG4gICAgWzAuOTc4MTQ4LCAtMC4xMzkxNzMsIC0wLjk5NzU2NCwgMC4wNjk3NTYsIC0wLjk5MDI2OCwgLTAuMjA3OTEyXSxcbiAgICBbMC45NjU5MjYsIC0wLjE3MzY0OCwgLTAuOTk2MTk1LCAwLjA4NzE1NiwgLTAuOTg0ODA4LCAtMC4yNTg4MTldLFxuICAgIFswLjk1MTA1NywgLTAuMjA3OTEyLCAtMC45OTQ1MjIsIDAuMTA0NTI4LCAtMC45NzgxNDgsIC0wLjMwOTAxN10sXG4gICAgWzAuOTMzNTgwLCAtMC4yNDE5MjIsIC0wLjk5MjU0NiwgMC4xMjE4NjksIC0wLjk3MDI5NiwgLTAuMzU4MzY4XSxcbiAgICBbMC45MTM1NDUsIC0wLjI3NTYzNywgLTAuOTkwMjY4LCAwLjEzOTE3MywgLTAuOTYxMjYyLCAtMC40MDY3MzddLFxuICAgIFswLjg5MTAwNywgLTAuMzA5MDE3LCAtMC45ODc2ODgsIDAuMTU2NDM0LCAtMC45NTEwNTcsIC0wLjQ1Mzk5MF0sXG4gICAgWzAuODY2MDI1LCAtMC4zNDIwMjAsIC0wLjk4NDgwOCwgMC4xNzM2NDgsIC0wLjkzOTY5MywgLTAuNTAwMDAwXSxcbiAgICBbMC44Mzg2NzEsIC0wLjM3NDYwNywgLTAuOTgxNjI3LCAwLjE5MDgwOSwgLTAuOTI3MTg0LCAtMC41NDQ2MzldLFxuICAgIFswLjgwOTAxNywgLTAuNDA2NzM3LCAtMC45NzgxNDgsIDAuMjA3OTEyLCAtMC45MTM1NDUsIC0wLjU4Nzc4NV0sXG4gICAgWzAuNzc3MTQ2LCAtMC40MzgzNzEsIC0wLjk3NDM3MCwgMC4yMjQ5NTEsIC0wLjg5ODc5NCwgLTAuNjI5MzIwXSxcbiAgICBbMC43NDMxNDUsIC0wLjQ2OTQ3MiwgLTAuOTcwMjk2LCAwLjI0MTkyMiwgLTAuODgyOTQ4LCAtMC42NjkxMzFdLFxuICAgIFswLjcwNzEwNywgLTAuNTAwMDAwLCAtMC45NjU5MjYsIDAuMjU4ODE5LCAtMC44NjYwMjUsIC0wLjcwNzEwN10sXG4gICAgWzAuNjY5MTMxLCAtMC41Mjk5MTksIC0wLjk2MTI2MiwgMC4yNzU2MzcsIC0wLjg0ODA0OCwgLTAuNzQzMTQ1XSxcbiAgICBbMC42MjkzMjAsIC0wLjU1OTE5MywgLTAuOTU2MzA1LCAwLjI5MjM3MiwgLTAuODI5MDM4LCAtMC43NzcxNDZdLFxuICAgIFswLjU4Nzc4NSwgLTAuNTg3Nzg1LCAtMC45NTEwNTcsIDAuMzA5MDE3LCAtMC44MDkwMTcsIC0wLjgwOTAxN10sXG4gICAgWzAuNTQ0NjM5LCAtMC42MTU2NjEsIC0wLjk0NTUxOSwgMC4zMjU1NjgsIC0wLjc4ODAxMSwgLTAuODM4NjcxXSxcbiAgICBbMC41MDAwMDAsIC0wLjY0Mjc4OCwgLTAuOTM5NjkzLCAwLjM0MjAyMCwgLTAuNzY2MDQ0LCAtMC44NjYwMjVdLFxuICAgIFswLjQ1Mzk5MCwgLTAuNjY5MTMxLCAtMC45MzM1ODAsIDAuMzU4MzY4LCAtMC43NDMxNDUsIC0wLjg5MTAwN10sXG4gICAgWzAuNDA2NzM3LCAtMC42OTQ2NTgsIC0wLjkyNzE4NCwgMC4zNzQ2MDcsIC0wLjcxOTM0MCwgLTAuOTEzNTQ1XSxcbiAgICBbMC4zNTgzNjgsIC0wLjcxOTM0MCwgLTAuOTIwNTA1LCAwLjM5MDczMSwgLTAuNjk0NjU4LCAtMC45MzM1ODBdLFxuICAgIFswLjMwOTAxNywgLTAuNzQzMTQ1LCAtMC45MTM1NDUsIDAuNDA2NzM3LCAtMC42NjkxMzEsIC0wLjk1MTA1N10sXG4gICAgWzAuMjU4ODE5LCAtMC43NjYwNDQsIC0wLjkwNjMwOCwgMC40MjI2MTgsIC0wLjY0Mjc4OCwgLTAuOTY1OTI2XSxcbiAgICBbMC4yMDc5MTIsIC0wLjc4ODAxMSwgLTAuODk4Nzk0LCAwLjQzODM3MSwgLTAuNjE1NjYxLCAtMC45NzgxNDhdLFxuICAgIFswLjE1NjQzNCwgLTAuODA5MDE3LCAtMC44OTEwMDcsIDAuNDUzOTkwLCAtMC41ODc3ODUsIC0wLjk4NzY4OF0sXG4gICAgWzAuMTA0NTI4LCAtMC44MjkwMzgsIC0wLjg4Mjk0OCwgMC40Njk0NzIsIC0wLjU1OTE5MywgLTAuOTk0NTIyXSxcbiAgICBbMC4wNTIzMzYsIC0wLjg0ODA0OCwgLTAuODc0NjIwLCAwLjQ4NDgxMCwgLTAuNTI5OTE5LCAtMC45OTg2MzBdLFxuICAgIFswLjAwMDAwMCwgLTAuODY2MDI1LCAtMC44NjYwMjUsIDAuNTAwMDAwLCAtMC41MDAwMDAsIC0xLjAwMDAwMF0sXG4gICAgWy0wLjA1MjMzNiwgLTAuODgyOTQ4LCAtMC44NTcxNjcsIDAuNTE1MDM4LCAtMC40Njk0NzIsIC0wLjk5ODYzMF0sXG4gICAgWy0wLjEwNDUyOCwgLTAuODk4Nzk0LCAtMC44NDgwNDgsIDAuNTI5OTE5LCAtMC40MzgzNzEsIC0wLjk5NDUyMl0sXG4gICAgWy0wLjE1NjQzNCwgLTAuOTEzNTQ1LCAtMC44Mzg2NzEsIDAuNTQ0NjM5LCAtMC40MDY3MzcsIC0wLjk4NzY4OF0sXG4gICAgWy0wLjIwNzkxMiwgLTAuOTI3MTg0LCAtMC44MjkwMzgsIDAuNTU5MTkzLCAtMC4zNzQ2MDcsIC0wLjk3ODE0OF0sXG4gICAgWy0wLjI1ODgxOSwgLTAuOTM5NjkzLCAtMC44MTkxNTIsIDAuNTczNTc2LCAtMC4zNDIwMjAsIC0wLjk2NTkyNl0sXG4gICAgWy0wLjMwOTAxNywgLTAuOTUxMDU3LCAtMC44MDkwMTcsIDAuNTg3Nzg1LCAtMC4zMDkwMTcsIC0wLjk1MTA1N10sXG4gICAgWy0wLjM1ODM2OCwgLTAuOTYxMjYyLCAtMC43OTg2MzYsIDAuNjAxODE1LCAtMC4yNzU2MzcsIC0wLjkzMzU4MF0sXG4gICAgWy0wLjQwNjczNywgLTAuOTcwMjk2LCAtMC43ODgwMTEsIDAuNjE1NjYxLCAtMC4yNDE5MjIsIC0wLjkxMzU0NV0sXG4gICAgWy0wLjQ1Mzk5MCwgLTAuOTc4MTQ4LCAtMC43NzcxNDYsIDAuNjI5MzIwLCAtMC4yMDc5MTIsIC0wLjg5MTAwN10sXG4gICAgWy0wLjUwMDAwMCwgLTAuOTg0ODA4LCAtMC43NjYwNDQsIDAuNjQyNzg4LCAtMC4xNzM2NDgsIC0wLjg2NjAyNV0sXG4gICAgWy0wLjU0NDYzOSwgLTAuOTkwMjY4LCAtMC43NTQ3MTAsIDAuNjU2MDU5LCAtMC4xMzkxNzMsIC0wLjgzODY3MV0sXG4gICAgWy0wLjU4Nzc4NSwgLTAuOTk0NTIyLCAtMC43NDMxNDUsIDAuNjY5MTMxLCAtMC4xMDQ1MjgsIC0wLjgwOTAxN10sXG4gICAgWy0wLjYyOTMyMCwgLTAuOTk3NTY0LCAtMC43MzEzNTQsIDAuNjgxOTk4LCAtMC4wNjk3NTYsIC0wLjc3NzE0Nl0sXG4gICAgWy0wLjY2OTEzMSwgLTAuOTk5MzkxLCAtMC43MTkzNDAsIDAuNjk0NjU4LCAtMC4wMzQ4OTksIC0wLjc0MzE0NV0sXG4gICAgWy0wLjcwNzEwNywgLTEuMDAwMDAwLCAtMC43MDcxMDcsIDAuNzA3MTA3LCAtMC4wMDAwMDAsIC0wLjcwNzEwN10sXG4gICAgWy0wLjc0MzE0NSwgLTAuOTk5MzkxLCAtMC42OTQ2NTgsIDAuNzE5MzQwLCAwLjAzNDg5OSwgLTAuNjY5MTMxXSxcbiAgICBbLTAuNzc3MTQ2LCAtMC45OTc1NjQsIC0wLjY4MTk5OCwgMC43MzEzNTQsIDAuMDY5NzU2LCAtMC42MjkzMjBdLFxuICAgIFstMC44MDkwMTcsIC0wLjk5NDUyMiwgLTAuNjY5MTMxLCAwLjc0MzE0NSwgMC4xMDQ1MjgsIC0wLjU4Nzc4NV0sXG4gICAgWy0wLjgzODY3MSwgLTAuOTkwMjY4LCAtMC42NTYwNTksIDAuNzU0NzEwLCAwLjEzOTE3MywgLTAuNTQ0NjM5XSxcbiAgICBbLTAuODY2MDI1LCAtMC45ODQ4MDgsIC0wLjY0Mjc4OCwgMC43NjYwNDQsIDAuMTczNjQ4LCAtMC41MDAwMDBdLFxuICAgIFstMC44OTEwMDcsIC0wLjk3ODE0OCwgLTAuNjI5MzIwLCAwLjc3NzE0NiwgMC4yMDc5MTIsIC0wLjQ1Mzk5MF0sXG4gICAgWy0wLjkxMzU0NSwgLTAuOTcwMjk2LCAtMC42MTU2NjEsIDAuNzg4MDExLCAwLjI0MTkyMiwgLTAuNDA2NzM3XSxcbiAgICBbLTAuOTMzNTgwLCAtMC45NjEyNjIsIC0wLjYwMTgxNSwgMC43OTg2MzYsIDAuMjc1NjM3LCAtMC4zNTgzNjhdLFxuICAgIFstMC45NTEwNTcsIC0wLjk1MTA1NywgLTAuNTg3Nzg1LCAwLjgwOTAxNywgMC4zMDkwMTcsIC0wLjMwOTAxN10sXG4gICAgWy0wLjk2NTkyNiwgLTAuOTM5NjkzLCAtMC41NzM1NzYsIDAuODE5MTUyLCAwLjM0MjAyMCwgLTAuMjU4ODE5XSxcbiAgICBbLTAuOTc4MTQ4LCAtMC45MjcxODQsIC0wLjU1OTE5MywgMC44MjkwMzgsIDAuMzc0NjA3LCAtMC4yMDc5MTJdLFxuICAgIFstMC45ODc2ODgsIC0wLjkxMzU0NSwgLTAuNTQ0NjM5LCAwLjgzODY3MSwgMC40MDY3MzcsIC0wLjE1NjQzNF0sXG4gICAgWy0wLjk5NDUyMiwgLTAuODk4Nzk0LCAtMC41Mjk5MTksIDAuODQ4MDQ4LCAwLjQzODM3MSwgLTAuMTA0NTI4XSxcbiAgICBbLTAuOTk4NjMwLCAtMC44ODI5NDgsIC0wLjUxNTAzOCwgMC44NTcxNjcsIDAuNDY5NDcyLCAtMC4wNTIzMzZdLFxuICAgIFstMS4wMDAwMDAsIC0wLjg2NjAyNSwgLTAuNTAwMDAwLCAwLjg2NjAyNSwgMC41MDAwMDAsIC0wLjAwMDAwMF0sXG4gICAgWy0wLjk5ODYzMCwgLTAuODQ4MDQ4LCAtMC40ODQ4MTAsIDAuODc0NjIwLCAwLjUyOTkxOSwgMC4wNTIzMzZdLFxuICAgIFstMC45OTQ1MjIsIC0wLjgyOTAzOCwgLTAuNDY5NDcyLCAwLjg4Mjk0OCwgMC41NTkxOTMsIDAuMTA0NTI4XSxcbiAgICBbLTAuOTg3Njg4LCAtMC44MDkwMTcsIC0wLjQ1Mzk5MCwgMC44OTEwMDcsIDAuNTg3Nzg1LCAwLjE1NjQzNF0sXG4gICAgWy0wLjk3ODE0OCwgLTAuNzg4MDExLCAtMC40MzgzNzEsIDAuODk4Nzk0LCAwLjYxNTY2MSwgMC4yMDc5MTJdLFxuICAgIFstMC45NjU5MjYsIC0wLjc2NjA0NCwgLTAuNDIyNjE4LCAwLjkwNjMwOCwgMC42NDI3ODgsIDAuMjU4ODE5XSxcbiAgICBbLTAuOTUxMDU3LCAtMC43NDMxNDUsIC0wLjQwNjczNywgMC45MTM1NDUsIDAuNjY5MTMxLCAwLjMwOTAxN10sXG4gICAgWy0wLjkzMzU4MCwgLTAuNzE5MzQwLCAtMC4zOTA3MzEsIDAuOTIwNTA1LCAwLjY5NDY1OCwgMC4zNTgzNjhdLFxuICAgIFstMC45MTM1NDUsIC0wLjY5NDY1OCwgLTAuMzc0NjA3LCAwLjkyNzE4NCwgMC43MTkzNDAsIDAuNDA2NzM3XSxcbiAgICBbLTAuODkxMDA3LCAtMC42NjkxMzEsIC0wLjM1ODM2OCwgMC45MzM1ODAsIDAuNzQzMTQ1LCAwLjQ1Mzk5MF0sXG4gICAgWy0wLjg2NjAyNSwgLTAuNjQyNzg4LCAtMC4zNDIwMjAsIDAuOTM5NjkzLCAwLjc2NjA0NCwgMC41MDAwMDBdLFxuICAgIFstMC44Mzg2NzEsIC0wLjYxNTY2MSwgLTAuMzI1NTY4LCAwLjk0NTUxOSwgMC43ODgwMTEsIDAuNTQ0NjM5XSxcbiAgICBbLTAuODA5MDE3LCAtMC41ODc3ODUsIC0wLjMwOTAxNywgMC45NTEwNTcsIDAuODA5MDE3LCAwLjU4Nzc4NV0sXG4gICAgWy0wLjc3NzE0NiwgLTAuNTU5MTkzLCAtMC4yOTIzNzIsIDAuOTU2MzA1LCAwLjgyOTAzOCwgMC42MjkzMjBdLFxuICAgIFstMC43NDMxNDUsIC0wLjUyOTkxOSwgLTAuMjc1NjM3LCAwLjk2MTI2MiwgMC44NDgwNDgsIDAuNjY5MTMxXSxcbiAgICBbLTAuNzA3MTA3LCAtMC41MDAwMDAsIC0wLjI1ODgxOSwgMC45NjU5MjYsIDAuODY2MDI1LCAwLjcwNzEwN10sXG4gICAgWy0wLjY2OTEzMSwgLTAuNDY5NDcyLCAtMC4yNDE5MjIsIDAuOTcwMjk2LCAwLjg4Mjk0OCwgMC43NDMxNDVdLFxuICAgIFstMC42MjkzMjAsIC0wLjQzODM3MSwgLTAuMjI0OTUxLCAwLjk3NDM3MCwgMC44OTg3OTQsIDAuNzc3MTQ2XSxcbiAgICBbLTAuNTg3Nzg1LCAtMC40MDY3MzcsIC0wLjIwNzkxMiwgMC45NzgxNDgsIDAuOTEzNTQ1LCAwLjgwOTAxN10sXG4gICAgWy0wLjU0NDYzOSwgLTAuMzc0NjA3LCAtMC4xOTA4MDksIDAuOTgxNjI3LCAwLjkyNzE4NCwgMC44Mzg2NzFdLFxuICAgIFstMC41MDAwMDAsIC0wLjM0MjAyMCwgLTAuMTczNjQ4LCAwLjk4NDgwOCwgMC45Mzk2OTMsIDAuODY2MDI1XSxcbiAgICBbLTAuNDUzOTkwLCAtMC4zMDkwMTcsIC0wLjE1NjQzNCwgMC45ODc2ODgsIDAuOTUxMDU3LCAwLjg5MTAwN10sXG4gICAgWy0wLjQwNjczNywgLTAuMjc1NjM3LCAtMC4xMzkxNzMsIDAuOTkwMjY4LCAwLjk2MTI2MiwgMC45MTM1NDVdLFxuICAgIFstMC4zNTgzNjgsIC0wLjI0MTkyMiwgLTAuMTIxODY5LCAwLjk5MjU0NiwgMC45NzAyOTYsIDAuOTMzNTgwXSxcbiAgICBbLTAuMzA5MDE3LCAtMC4yMDc5MTIsIC0wLjEwNDUyOCwgMC45OTQ1MjIsIDAuOTc4MTQ4LCAwLjk1MTA1N10sXG4gICAgWy0wLjI1ODgxOSwgLTAuMTczNjQ4LCAtMC4wODcxNTYsIDAuOTk2MTk1LCAwLjk4NDgwOCwgMC45NjU5MjZdLFxuICAgIFstMC4yMDc5MTIsIC0wLjEzOTE3MywgLTAuMDY5NzU2LCAwLjk5NzU2NCwgMC45OTAyNjgsIDAuOTc4MTQ4XSxcbiAgICBbLTAuMTU2NDM0LCAtMC4xMDQ1MjgsIC0wLjA1MjMzNiwgMC45OTg2MzAsIDAuOTk0NTIyLCAwLjk4NzY4OF0sXG4gICAgWy0wLjEwNDUyOCwgLTAuMDY5NzU2LCAtMC4wMzQ4OTksIDAuOTk5MzkxLCAwLjk5NzU2NCwgMC45OTQ1MjJdLFxuICAgIFstMC4wNTIzMzYsIC0wLjAzNDg5OSwgLTAuMDE3NDUyLCAwLjk5OTg0OCwgMC45OTkzOTEsIDAuOTk4NjMwXSxcbiAgXSxcbiAgW1xuICAgIFstMS4wMDAwMDAsIC0wLjAwMDAwMCwgMS4wMDAwMDAsIC0wLjAwMDAwMCwgMC4wMDAwMDAsXG4gICAgIC0xLjAwMDAwMCwgLTAuMDAwMDAwLCAwLjAwMDAwMCwgLTAuMDAwMDAwXSxcbiAgICBbLTAuOTk5ODQ4LCAwLjAxNzQ1MiwgMC45OTk1NDMsIC0wLjAzMDIyNCwgMC4wMDAyNjQsXG4gICAgIC0wLjk5OTA4NiwgMC4wNDI3MzMsIC0wLjAwMDU5MCwgMC4wMDAwMDRdLFxuICAgIFstMC45OTkzOTEsIDAuMDM0ODk5LCAwLjk5ODE3MywgLTAuMDYwNDExLCAwLjAwMTA1NSxcbiAgICAgLTAuOTk2MzQ4LCAwLjA4NTM1NiwgLTAuMDAyMzU3LCAwLjAwMDAzNF0sXG4gICAgWy0wLjk5ODYzMCwgMC4wNTIzMzYsIDAuOTk1ODkxLCAtMC4wOTA1MjQsIDAuMDAyMzcyLFxuICAgICAtMC45OTE3OTEsIDAuMTI3NzU3LCAtMC4wMDUyOTcsIDAuMDAwMTEzXSxcbiAgICBbLTAuOTk3NTY0LCAwLjA2OTc1NiwgMC45OTI3MDEsIC0wLjEyMDUyNywgMC4wMDQyMTQsXG4gICAgIC0wLjk4NTQyOSwgMC4xNjk4MjgsIC0wLjAwOTQwMCwgMC4wMDAyNjhdLFxuICAgIFstMC45OTYxOTUsIDAuMDg3MTU2LCAwLjk4ODYwNiwgLTAuMTUwMzg0LCAwLjAwNjU3OCxcbiAgICAgLTAuOTc3Mjc3LCAwLjIxMTQ2MCwgLTAuMDE0NjU0LCAwLjAwMDUyM10sXG4gICAgWy0wLjk5NDUyMiwgMC4xMDQ1MjgsIDAuOTgzNjExLCAtMC4xODAwNTcsIDAuMDA5NDYyLFxuICAgICAtMC45NjczNTYsIDAuMjUyNTQ0LCAtMC4wMjEwNDMsIDAuMDAwOTAzXSxcbiAgICBbLTAuOTkyNTQ2LCAwLjEyMTg2OSwgMC45Nzc3MjIsIC0wLjIwOTUxMSwgMC4wMTI4NjIsXG4gICAgIC0wLjk1NTY5MywgMC4yOTI5NzYsIC0wLjAyODU0NywgMC4wMDE0MzFdLFxuICAgIFstMC45OTAyNjgsIDAuMTM5MTczLCAwLjk3MDk0NiwgLTAuMjM4NzA5LCAwLjAxNjc3NCxcbiAgICAgLTAuOTQyMzE2LCAwLjMzMjY0OSwgLTAuMDM3MTQzLCAwLjAwMjEzMV0sXG4gICAgWy0wLjk4NzY4OCwgMC4xNTY0MzQsIDAuOTYzMjkyLCAtMC4yNjc2MTcsIDAuMDIxMTkzLFxuICAgICAtMC45MjcyNjIsIDAuMzcxNDYzLCAtMC4wNDY4MDYsIDAuMDAzMDI2XSxcbiAgICBbLTAuOTg0ODA4LCAwLjE3MzY0OCwgMC45NTQ3NjksIC0wLjI5NjE5OCwgMC4wMjYxMTQsXG4gICAgIC0wLjkxMDU2OSwgMC40MDkzMTcsIC0wLjA1NzUwNSwgMC4wMDQxNDBdLFxuICAgIFstMC45ODE2MjcsIDAuMTkwODA5LCAwLjk0NTM4OCwgLTAuMzI0NDE5LCAwLjAzMTUzMCxcbiAgICAgLTAuODkyMjc5LCAwLjQ0NjExNCwgLTAuMDY5MjA5LCAwLjAwNTQ5Ml0sXG4gICAgWy0wLjk3ODE0OCwgMC4yMDc5MTIsIDAuOTM1MTU5LCAtMC4zNTIyNDQsIDAuMDM3NDM2LFxuICAgICAtMC44NzI0NDEsIDAuNDgxNzU5LCAtMC4wODE4ODAsIDAuMDA3MTA1XSxcbiAgICBbLTAuOTc0MzcwLCAwLjIyNDk1MSwgMC45MjQwOTYsIC0wLjM3OTY0MSwgMC4wNDM4MjMsXG4gICAgIC0wLjg1MTEwNSwgMC41MTYxNjIsIC0wLjA5NTQ4MSwgMC4wMDg5OTldLFxuICAgIFstMC45NzAyOTYsIDAuMjQxOTIyLCAwLjkxMjIxMSwgLTAuNDA2NTc0LCAwLjA1MDY4NSxcbiAgICAgLTAuODI4MzI2LCAwLjU0OTIzMywgLTAuMTA5OTY5LCAwLjAxMTE5M10sXG4gICAgWy0wLjk2NTkyNiwgMC4yNTg4MTksIDAuODk5NTE5LCAtMC40MzMwMTMsIDAuMDU4MDEzLFxuICAgICAtMC44MDQxNjQsIDAuNTgwODg5LCAtMC4xMjUzMDAsIDAuMDEzNzA3XSxcbiAgICBbLTAuOTYxMjYyLCAwLjI3NTYzNywgMC44ODYwMzYsIC0wLjQ1ODkyNCwgMC4wNjU3OTcsXG4gICAgIC0wLjc3ODY4MCwgMC42MTEwNTAsIC0wLjE0MTQyNywgMC4wMTY1NTZdLFxuICAgIFstMC45NTYzMDUsIDAuMjkyMzcyLCAwLjg3MTc3OCwgLTAuNDg0Mjc1LCAwLjA3NDAyOSxcbiAgICAgLTAuNzUxOTQwLCAwLjYzOTYzOSwgLTAuMTU4MzAxLCAwLjAxOTc1OF0sXG4gICAgWy0wLjk1MTA1NywgMC4zMDkwMTcsIDAuODU2NzYzLCAtMC41MDkwMzcsIDAuMDgyNjk4LFxuICAgICAtMC43MjQwMTIsIDAuNjY2NTgzLCAtMC4xNzU4NjgsIDAuMDIzMzI5XSxcbiAgICBbLTAuOTQ1NTE5LCAwLjMyNTU2OCwgMC44NDEwMDgsIC0wLjUzMzE3OCwgMC4wOTE3OTQsXG4gICAgIC0wLjY5NDk2OSwgMC42OTE4MTYsIC0wLjE5NDA3NSwgMC4wMjcyODFdLFxuICAgIFstMC45Mzk2OTMsIDAuMzQyMDIwLCAwLjgyNDUzMywgLTAuNTU2NjcwLCAwLjEwMTMwNixcbiAgICAgLTAuNjY0ODg1LCAwLjcxNTI3NCwgLTAuMjEyODY1LCAwLjAzMTYzMF0sXG4gICAgWy0wLjkzMzU4MCwgMC4zNTgzNjgsIDAuODA3MzU5LCAtMC41Nzk0ODQsIDAuMTExMjIyLFxuICAgICAtMC42MzM4MzcsIDAuNzM2ODk4LCAtMC4yMzIxODAsIDAuMDM2Mzg1XSxcbiAgICBbLTAuOTI3MTg0LCAwLjM3NDYwNywgMC43ODk1MDUsIC0wLjYwMTU5MiwgMC4xMjE1MjksXG4gICAgIC0wLjYwMTkwNCwgMC43NTY2MzcsIC0wLjI1MTk2MCwgMC4wNDE1NTldLFxuICAgIFstMC45MjA1MDUsIDAuMzkwNzMxLCAwLjc3MDk5NCwgLTAuNjIyOTY3LCAwLjEzMjIxNyxcbiAgICAgLTAuNTY5MTY5LCAwLjc3NDQ0MiwgLTAuMjcyMTQzLCAwLjA0NzE2MF0sXG4gICAgWy0wLjkxMzU0NSwgMC40MDY3MzcsIDAuNzUxODQ4LCAtMC42NDM1ODIsIDAuMTQzMjcxLFxuICAgICAtMC41MzU3MTUsIDAuNzkwMjcwLCAtMC4yOTI2NjYsIDAuMDUzMTk2XSxcbiAgICBbLTAuOTA2MzA4LCAwLjQyMjYxOCwgMC43MzIwOTEsIC0wLjY2MzQxNCwgMC4xNTQ2NzgsXG4gICAgIC0wLjUwMTYyNywgMC44MDQwODMsIC0wLjMxMzQ2NCwgMC4wNTk2NzRdLFxuICAgIFstMC44OTg3OTQsIDAuNDM4MzcxLCAwLjcxMTc0NiwgLTAuNjgyNDM3LCAwLjE2NjQyMyxcbiAgICAgLTAuNDY2OTkzLCAwLjgxNTg1MCwgLTAuMzM0NDcyLCAwLjA2NjU5OV0sXG4gICAgWy0wLjg5MTAwNywgMC40NTM5OTAsIDAuNjkwODM5LCAtMC43MDA2MjksIDAuMTc4NDk0LFxuICAgICAtMC40MzE4OTksIDAuODI1NTQ0LCAtMC4zNTU2MjMsIDAuMDczOTc0XSxcbiAgICBbLTAuODgyOTQ4LCAwLjQ2OTQ3MiwgMC42NjkzOTUsIC0wLjcxNzk2OCwgMC4xOTA4NzUsXG4gICAgIC0wLjM5NjQzNiwgMC44MzMxNDUsIC0wLjM3Njg1MSwgMC4wODE4MDNdLFxuICAgIFstMC44NzQ2MjAsIDAuNDg0ODEwLCAwLjY0NzQzOSwgLTAuNzM0NDMxLCAwLjIwMzU1MSxcbiAgICAgLTAuMzYwNjkyLCAwLjgzODYzOCwgLTAuMzk4MDg2LCAwLjA5MDA4NV0sXG4gICAgWy0wLjg2NjAyNSwgMC41MDAwMDAsIDAuNjI1MDAwLCAtMC43NTAwMDAsIDAuMjE2NTA2LFxuICAgICAtMC4zMjQ3NjAsIDAuODQyMDEyLCAtMC40MTkyNjMsIDAuMDk4ODIxXSxcbiAgICBbLTAuODU3MTY3LCAwLjUxNTAzOCwgMC42MDIxMDQsIC0wLjc2NDY1NSwgMC4yMjk3MjYsXG4gICAgIC0wLjI4ODcyOCwgMC44NDMyNjUsIC0wLjQ0MDMxMSwgMC4xMDgwMDldLFxuICAgIFstMC44NDgwNDgsIDAuNTI5OTE5LCAwLjU3ODc3OCwgLTAuNzc4Mzc4LCAwLjI0MzE5MixcbiAgICAgLTAuMjUyNjg4LCAwLjg0MjM5OSwgLTAuNDYxMTY0LCAwLjExNzY0NF0sXG4gICAgWy0wLjgzODY3MSwgMC41NDQ2MzksIDAuNTU1MDUyLCAtMC43OTExNTQsIDAuMjU2ODkxLFxuICAgICAtMC4yMTY3MzAsIDAuODM5NDIyLCAtMC40ODE3NTMsIDAuMTI3NzIyXSxcbiAgICBbLTAuODI5MDM4LCAwLjU1OTE5MywgMC41MzA5NTUsIC0wLjgwMjk2NSwgMC4yNzA4MDMsXG4gICAgIC0wLjE4MDk0NCwgMC44MzQzNDcsIC0wLjUwMjAxMSwgMC4xMzgyMzddLFxuICAgIFstMC44MTkxNTIsIDAuNTczNTc2LCAwLjUwNjUxNSwgLTAuODEzNzk4LCAwLjI4NDkxNCxcbiAgICAgLTAuMTQ1NDIwLCAwLjgyNzE5NCwgLTAuNTIxODcxLCAwLjE0OTE4MV0sXG4gICAgWy0wLjgwOTAxNywgMC41ODc3ODUsIDAuNDgxNzYzLCAtMC44MjM2MzksIDAuMjk5MjA0LFxuICAgICAtMC4xMTAyNDYsIDAuODE3OTg3LCAtMC41NDEyNjYsIDAuMTYwNTQ1XSxcbiAgICBbLTAuNzk4NjM2LCAwLjYwMTgxNSwgMC40NTY3MjgsIC0wLjgzMjQ3NywgMC4zMTM2NTgsXG4gICAgIC0wLjA3NTUwOCwgMC44MDY3NTcsIC0wLjU2MDEzMiwgMC4xNzIzMTddLFxuICAgIFstMC43ODgwMTEsIDAuNjE1NjYxLCAwLjQzMTQ0MSwgLTAuODQwMzAxLCAwLjMyODI1NyxcbiAgICAgLTAuMDQxMjk0LCAwLjc5MzU0MSwgLTAuNTc4NDA1LCAwLjE4NDQ4N10sXG4gICAgWy0wLjc3NzE0NiwgMC42MjkzMjAsIDAuNDA1OTM0LCAtMC44NDcxMDEsIDAuMzQyOTg0LFxuICAgICAtMC4wMDc2ODYsIDAuNzc4Mzc5LCAtMC41OTYwMjEsIDAuMTk3MDQwXSxcbiAgICBbLTAuNzY2MDQ0LCAwLjY0Mjc4OCwgMC4zODAyMzYsIC0wLjg1Mjg2OSwgMC4zNTc4MjEsXG4gICAgIDAuMDI1MjMzLCAwLjc2MTMxOSwgLTAuNjEyOTIxLCAwLjIwOTk2M10sXG4gICAgWy0wLjc1NDcxMCwgMC42NTYwNTksIDAuMzU0MzgwLCAtMC44NTc1OTcsIDAuMzcyNzQ5LFxuICAgICAwLjA1NzM4MywgMC43NDI0MTIsIC0wLjYyOTA0NCwgMC4yMjMyMzhdLFxuICAgIFstMC43NDMxNDUsIDAuNjY5MTMxLCAwLjMyODM5NiwgLTAuODYxMjgxLCAwLjM4Nzc1MSxcbiAgICAgMC4wODg2ODYsIDAuNzIxNzE0LCAtMC42NDQzMzQsIDAuMjM2ODUwXSxcbiAgICBbLTAuNzMxMzU0LCAwLjY4MTk5OCwgMC4zMDIzMTcsIC0wLjg2MzkxNiwgMC40MDI4MDcsXG4gICAgIDAuMTE5MDY4LCAwLjY5OTI4OCwgLTAuNjU4NzM0LCAwLjI1MDc3OF0sXG4gICAgWy0wLjcxOTM0MCwgMC42OTQ2NTgsIDAuMjc2MTc1LCAtMC44NjU0OTgsIDAuNDE3OTAxLFxuICAgICAwLjE0ODQ1NCwgMC42NzUxOTksIC0wLjY3MjE5MCwgMC4yNjUwMDVdLFxuICAgIFstMC43MDcxMDcsIDAuNzA3MTA3LCAwLjI1MDAwMCwgLTAuODY2MDI1LCAwLjQzMzAxMyxcbiAgICAgMC4xNzY3NzcsIDAuNjQ5NTE5LCAtMC42ODQ2NTMsIDAuMjc5NTA4XSxcbiAgICBbLTAuNjk0NjU4LCAwLjcxOTM0MCwgMC4yMjM4MjUsIC0wLjg2NTQ5OCwgMC40NDgxMjUsXG4gICAgIDAuMjAzOTY5LCAwLjYyMjMyMiwgLTAuNjk2MDczLCAwLjI5NDI2N10sXG4gICAgWy0wLjY4MTk5OCwgMC43MzEzNTQsIDAuMTk3NjgzLCAtMC44NjM5MTYsIDAuNDYzMjE4LFxuICAgICAwLjIyOTk2NywgMC41OTM2ODgsIC0wLjcwNjQwNSwgMC4zMDkyNTldLFxuICAgIFstMC42NjkxMzEsIDAuNzQzMTQ1LCAwLjE3MTYwNCwgLTAuODYxMjgxLCAwLjQ3ODI3NSxcbiAgICAgMC4yNTQ3MTIsIDAuNTYzNzAwLCAtMC43MTU2MDUsIDAuMzI0NDU5XSxcbiAgICBbLTAuNjU2MDU5LCAwLjc1NDcxMCwgMC4xNDU2MjAsIC0wLjg1NzU5NywgMC40OTMyNzYsXG4gICAgIDAuMjc4MTQ3LCAwLjUzMjQ0MywgLTAuNzIzNjMzLCAwLjMzOTg0NF0sXG4gICAgWy0wLjY0Mjc4OCwgMC43NjYwNDQsIDAuMTE5NzY0LCAtMC44NTI4NjksIDAuNTA4MjA1LFxuICAgICAwLjMwMDIyMSwgMC41MDAwMDksIC0wLjczMDQ1MSwgMC4zNTUzODddLFxuICAgIFstMC42MjkzMjAsIDAuNzc3MTQ2LCAwLjA5NDA2NiwgLTAuODQ3MTAxLCAwLjUyMzA0MSxcbiAgICAgMC4zMjA4ODQsIDAuNDY2NDkwLCAtMC43MzYwMjUsIDAuMzcxMDYzXSxcbiAgICBbLTAuNjE1NjYxLCAwLjc4ODAxMSwgMC4wNjg1NTksIC0wLjg0MDMwMSwgMC41Mzc3NjgsXG4gICAgIDAuMzQwMDkzLCAwLjQzMTk4MiwgLTAuNzQwMzI0LCAwLjM4Njg0NV0sXG4gICAgWy0wLjYwMTgxNSwgMC43OTg2MzYsIDAuMDQzMjcyLCAtMC44MzI0NzcsIDAuNTUyMzY3LFxuICAgICAwLjM1NzgwNywgMC4zOTY1ODQsIC0wLjc0MzMyMCwgMC40MDI3MDRdLFxuICAgIFstMC41ODc3ODUsIDAuODA5MDE3LCAwLjAxODIzNywgLTAuODIzNjM5LCAwLjU2NjgyMSxcbiAgICAgMC4zNzM5OTEsIDAuMzYwMzk3LCAtMC43NDQ5ODksIDAuNDE4NjEzXSxcbiAgICBbLTAuNTczNTc2LCAwLjgxOTE1MiwgLTAuMDA2NTE1LCAtMC44MTM3OTgsIDAuNTgxMTEyLFxuICAgICAwLjM4ODYxMiwgMC4zMjM1MjQsIC0wLjc0NTMwOCwgMC40MzQ1NDRdLFxuICAgIFstMC41NTkxOTMsIDAuODI5MDM4LCAtMC4wMzA5NTUsIC0wLjgwMjk2NSwgMC41OTUyMjIsXG4gICAgIDAuNDAxNjQ1LCAwLjI4NjA2OSwgLTAuNzQ0MjYyLCAwLjQ1MDQ2N10sXG4gICAgWy0wLjU0NDYzOSwgMC44Mzg2NzEsIC0wLjA1NTA1MiwgLTAuNzkxMTU0LCAwLjYwOTEzNSxcbiAgICAgMC40MTMwNjYsIDAuMjQ4MTQwLCAtMC43NDE4MzUsIDAuNDY2MzUyXSxcbiAgICBbLTAuNTI5OTE5LCAwLjg0ODA0OCwgLTAuMDc4Nzc4LCAtMC43NzgzNzgsIDAuNjIyODMzLFxuICAgICAwLjQyMjg1NiwgMC4yMDk4NDMsIC0wLjczODAxNywgMC40ODIxNzFdLFxuICAgIFstMC41MTUwMzgsIDAuODU3MTY3LCAtMC4xMDIxMDQsIC0wLjc2NDY1NSwgMC42MzYzMDAsXG4gICAgIDAuNDMxMDA0LCAwLjE3MTI4OCwgLTAuNzMyODAxLCAwLjQ5Nzg5NF0sXG4gICAgWy0wLjUwMDAwMCwgMC44NjYwMjUsIC0wLjEyNTAwMCwgLTAuNzUwMDAwLCAwLjY0OTUxOSxcbiAgICAgMC40Mzc1MDAsIDAuMTMyNTgzLCAtMC43MjYxODQsIDAuNTEzNDkwXSxcbiAgICBbLTAuNDg0ODEwLCAwLjg3NDYyMCwgLTAuMTQ3NDM5LCAtMC43MzQ0MzEsIDAuNjYyNDc0LFxuICAgICAwLjQ0MjM0MCwgMC4wOTM4MzcsIC0wLjcxODE2NywgMC41Mjg5MjldLFxuICAgIFstMC40Njk0NzIsIDAuODgyOTQ4LCAtMC4xNjkzOTUsIC0wLjcxNzk2OCwgMC42NzUxNTAsXG4gICAgIDAuNDQ1NTI0LCAwLjA1NTE2MCwgLTAuNzA4NzUzLCAwLjU0NDE4M10sXG4gICAgWy0wLjQ1Mzk5MCwgMC44OTEwMDcsIC0wLjE5MDgzOSwgLTAuNzAwNjI5LCAwLjY4NzUzMSxcbiAgICAgMC40NDcwNTksIDAuMDE2NjYyLCAtMC42OTc5NTAsIDAuNTU5MjIwXSxcbiAgICBbLTAuNDM4MzcxLCAwLjg5ODc5NCwgLTAuMjExNzQ2LCAtMC42ODI0MzcsIDAuNjk5NjAyLFxuICAgICAwLjQ0Njk1MywgLTAuMDIxNTUwLCAtMC42ODU3NjksIDAuNTc0MDExXSxcbiAgICBbLTAuNDIyNjE4LCAwLjkwNjMwOCwgLTAuMjMyMDkxLCAtMC42NjM0MTQsIDAuNzExMzQ4LFxuICAgICAwLjQ0NTIyMiwgLTAuMDU5MzY4LCAtMC42NzIyMjYsIDAuNTg4NTI4XSxcbiAgICBbLTAuNDA2NzM3LCAwLjkxMzU0NSwgLTAuMjUxODQ4LCAtMC42NDM1ODIsIDAuNzIyNzU1LFxuICAgICAwLjQ0MTg4NCwgLTAuMDk2Njg0LCAtMC42NTczMzksIDAuNjAyNzQxXSxcbiAgICBbLTAuMzkwNzMxLCAwLjkyMDUwNSwgLTAuMjcwOTk0LCAtMC42MjI5NjcsIDAuNzMzODA5LFxuICAgICAwLjQzNjk2NCwgLTAuMTMzMzk1LCAtMC42NDExMzAsIDAuNjE2NjIxXSxcbiAgICBbLTAuMzc0NjA3LCAwLjkyNzE4NCwgLTAuMjg5NTA1LCAtMC42MDE1OTIsIDAuNzQ0NDk2LFxuICAgICAwLjQzMDQ4OCwgLTAuMTY5Mzk3LCAtMC42MjM2MjQsIDAuNjMwMTQxXSxcbiAgICBbLTAuMzU4MzY4LCAwLjkzMzU4MCwgLTAuMzA3MzU5LCAtMC41Nzk0ODQsIDAuNzU0ODA0LFxuICAgICAwLjQyMjQ5MSwgLTAuMjA0NTg5LCAtMC42MDQ4NTEsIDAuNjQzMjczXSxcbiAgICBbLTAuMzQyMDIwLCAwLjkzOTY5MywgLTAuMzI0NTMzLCAtMC41NTY2NzAsIDAuNzY0NzIwLFxuICAgICAwLjQxMzAwOCwgLTAuMjM4ODcyLCAtMC41ODQ4NDMsIDAuNjU1OTkwXSxcbiAgICBbLTAuMzI1NTY4LCAwLjk0NTUxOSwgLTAuMzQxMDA4LCAtMC41MzMxNzgsIDAuNzc0MjMxLFxuICAgICAwLjQwMjA4MSwgLTAuMjcyMTUwLCAtMC41NjM2MzUsIDAuNjY4MjY3XSxcbiAgICBbLTAuMzA5MDE3LCAwLjk1MTA1NywgLTAuMzU2NzYzLCAtMC41MDkwMzcsIDAuNzgzMzI3LFxuICAgICAwLjM4OTc1NCwgLTAuMzA0MzI5LCAtMC41NDEyNjYsIDAuNjgwMDc4XSxcbiAgICBbLTAuMjkyMzcyLCAwLjk1NjMwNSwgLTAuMzcxNzc4LCAtMC40ODQyNzUsIDAuNzkxOTk3LFxuICAgICAwLjM3NjA3NywgLTAuMzM1MzE5LCAtMC41MTc3NzgsIDAuNjkxMzk5XSxcbiAgICBbLTAuMjc1NjM3LCAwLjk2MTI2MiwgLTAuMzg2MDM2LCAtMC40NTg5MjQsIDAuODAwMjI4LFxuICAgICAwLjM2MTEwMiwgLTAuMzY1MDM0LCAtMC40OTMyMTYsIDAuNzAyMjA3XSxcbiAgICBbLTAuMjU4ODE5LCAwLjk2NTkyNiwgLTAuMzk5NTE5LCAtMC40MzMwMTMsIDAuODA4MDEzLFxuICAgICAwLjM0NDg4NSwgLTAuMzkzMzg5LCAtMC40Njc2MjcsIDAuNzEyNDc4XSxcbiAgICBbLTAuMjQxOTIyLCAwLjk3MDI5NiwgLTAuNDEyMjExLCAtMC40MDY1NzQsIDAuODE1MzQwLFxuICAgICAwLjMyNzQ4NiwgLTAuNDIwMzA2LCAtMC40NDEwNjEsIDAuNzIyMTkxXSxcbiAgICBbLTAuMjI0OTUxLCAwLjk3NDM3MCwgLTAuNDI0MDk2LCAtMC4zNzk2NDEsIDAuODIyMjAyLFxuICAgICAwLjMwODk2OSwgLTAuNDQ1NzA5LCAtMC40MTM1NzIsIDAuNzMxMzI3XSxcbiAgICBbLTAuMjA3OTEyLCAwLjk3ODE0OCwgLTAuNDM1MTU5LCAtMC4zNTIyNDQsIDAuODI4NTg5LFxuICAgICAwLjI4OTM5OSwgLTAuNDY5NTI3LCAtMC4zODUyMTUsIDAuNzM5ODY2XSxcbiAgICBbLTAuMTkwODA5LCAwLjk4MTYyNywgLTAuNDQ1Mzg4LCAtMC4zMjQ0MTksIDAuODM0NDk1LFxuICAgICAwLjI2ODg0NiwgLTAuNDkxNjkzLCAtMC4zNTYwNDcsIDAuNzQ3NzkwXSxcbiAgICBbLTAuMTczNjQ4LCAwLjk4NDgwOCwgLTAuNDU0NzY5LCAtMC4yOTYxOTgsIDAuODM5OTEyLFxuICAgICAwLjI0NzM4MiwgLTAuNTEyMTQ1LCAtMC4zMjYxMjksIDAuNzU1MDgyXSxcbiAgICBbLTAuMTU2NDM0LCAwLjk4NzY4OCwgLTAuNDYzMjkyLCAtMC4yNjc2MTcsIDAuODQ0ODMyLFxuICAgICAwLjIyNTA4MSwgLTAuNTMwODI3LCAtMC4yOTU1MjEsIDAuNzYxNzI4XSxcbiAgICBbLTAuMTM5MTczLCAwLjk5MDI2OCwgLTAuNDcwOTQ2LCAtMC4yMzg3MDksIDAuODQ5MjUxLFxuICAgICAwLjIwMjAyMCwgLTAuNTQ3Njg0LCAtMC4yNjQyODcsIDAuNzY3NzEyXSxcbiAgICBbLTAuMTIxODY5LCAwLjk5MjU0NiwgLTAuNDc3NzIyLCAtMC4yMDk1MTEsIDAuODUzMTYzLFxuICAgICAwLjE3ODI3OSwgLTAuNTYyNjcyLCAtMC4yMzI0OTQsIDAuNzczMDIzXSxcbiAgICBbLTAuMTA0NTI4LCAwLjk5NDUyMiwgLTAuNDgzNjExLCAtMC4xODAwNTcsIDAuODU2NTYzLFxuICAgICAwLjE1MzkzNywgLTAuNTc1NzQ3LCAtMC4yMDAyMDcsIDAuNzc3NjQ4XSxcbiAgICBbLTAuMDg3MTU2LCAwLjk5NjE5NSwgLTAuNDg4NjA2LCAtMC4xNTAzODQsIDAuODU5NDQ3LFxuICAgICAwLjEyOTA3OCwgLTAuNTg2ODcyLCAtMC4xNjc0OTQsIDAuNzgxNTc5XSxcbiAgICBbLTAuMDY5NzU2LCAwLjk5NzU2NCwgLTAuNDkyNzAxLCAtMC4xMjA1MjcsIDAuODYxODExLFxuICAgICAwLjEwMzc4NiwgLTAuNTk2MDE4LCAtMC4xMzQ0MjYsIDAuNzg0ODA2XSxcbiAgICBbLTAuMDUyMzM2LCAwLjk5ODYzMCwgLTAuNDk1ODkxLCAtMC4wOTA1MjQsIDAuODYzNjUzLFxuICAgICAwLjA3ODE0NiwgLTAuNjAzMTU4LCAtMC4xMDEwNzEsIDAuNzg3MzI0XSxcbiAgICBbLTAuMDM0ODk5LCAwLjk5OTM5MSwgLTAuNDk4MTczLCAtMC4wNjA0MTEsIDAuODY0OTcxLFxuICAgICAwLjA1MjI0MywgLTAuNjA4MjcyLCAtMC4wNjc1MDAsIDAuNzg5MTI2XSxcbiAgICBbLTAuMDE3NDUyLCAwLjk5OTg0OCwgLTAuNDk5NTQzLCAtMC4wMzAyMjQsIDAuODY1NzYyLFxuICAgICAwLjAyNjE2NSwgLTAuNjExMzQ3LCAtMC4wMzM3ODYsIDAuNzkwMjA4XSxcbiAgICBbMC4wMDAwMDAsIDEuMDAwMDAwLCAtMC41MDAwMDAsIDAuMDAwMDAwLCAwLjg2NjAyNSxcbiAgICAgLTAuMDAwMDAwLCAtMC42MTIzNzIsIDAuMDAwMDAwLCAwLjc5MDU2OV0sXG4gICAgWzAuMDE3NDUyLCAwLjk5OTg0OCwgLTAuNDk5NTQzLCAwLjAzMDIyNCwgMC44NjU3NjIsXG4gICAgIC0wLjAyNjE2NSwgLTAuNjExMzQ3LCAwLjAzMzc4NiwgMC43OTAyMDhdLFxuICAgIFswLjAzNDg5OSwgMC45OTkzOTEsIC0wLjQ5ODE3MywgMC4wNjA0MTEsIDAuODY0OTcxLFxuICAgICAtMC4wNTIyNDMsIC0wLjYwODI3MiwgMC4wNjc1MDAsIDAuNzg5MTI2XSxcbiAgICBbMC4wNTIzMzYsIDAuOTk4NjMwLCAtMC40OTU4OTEsIDAuMDkwNTI0LCAwLjg2MzY1MyxcbiAgICAgLTAuMDc4MTQ2LCAtMC42MDMxNTgsIDAuMTAxMDcxLCAwLjc4NzMyNF0sXG4gICAgWzAuMDY5NzU2LCAwLjk5NzU2NCwgLTAuNDkyNzAxLCAwLjEyMDUyNywgMC44NjE4MTEsXG4gICAgIC0wLjEwMzc4NiwgLTAuNTk2MDE4LCAwLjEzNDQyNiwgMC43ODQ4MDZdLFxuICAgIFswLjA4NzE1NiwgMC45OTYxOTUsIC0wLjQ4ODYwNiwgMC4xNTAzODQsIDAuODU5NDQ3LFxuICAgICAtMC4xMjkwNzgsIC0wLjU4Njg3MiwgMC4xNjc0OTQsIDAuNzgxNTc5XSxcbiAgICBbMC4xMDQ1MjgsIDAuOTk0NTIyLCAtMC40ODM2MTEsIDAuMTgwMDU3LCAwLjg1NjU2MyxcbiAgICAgLTAuMTUzOTM3LCAtMC41NzU3NDcsIDAuMjAwMjA3LCAwLjc3NzY0OF0sXG4gICAgWzAuMTIxODY5LCAwLjk5MjU0NiwgLTAuNDc3NzIyLCAwLjIwOTUxMSwgMC44NTMxNjMsXG4gICAgIC0wLjE3ODI3OSwgLTAuNTYyNjcyLCAwLjIzMjQ5NCwgMC43NzMwMjNdLFxuICAgIFswLjEzOTE3MywgMC45OTAyNjgsIC0wLjQ3MDk0NiwgMC4yMzg3MDksIDAuODQ5MjUxLFxuICAgICAtMC4yMDIwMjAsIC0wLjU0NzY4NCwgMC4yNjQyODcsIDAuNzY3NzEyXSxcbiAgICBbMC4xNTY0MzQsIDAuOTg3Njg4LCAtMC40NjMyOTIsIDAuMjY3NjE3LCAwLjg0NDgzMixcbiAgICAgLTAuMjI1MDgxLCAtMC41MzA4MjcsIDAuMjk1NTIxLCAwLjc2MTcyOF0sXG4gICAgWzAuMTczNjQ4LCAwLjk4NDgwOCwgLTAuNDU0NzY5LCAwLjI5NjE5OCwgMC44Mzk5MTIsXG4gICAgIC0wLjI0NzM4MiwgLTAuNTEyMTQ1LCAwLjMyNjEyOSwgMC43NTUwODJdLFxuICAgIFswLjE5MDgwOSwgMC45ODE2MjcsIC0wLjQ0NTM4OCwgMC4zMjQ0MTksIDAuODM0NDk1LFxuICAgICAtMC4yNjg4NDYsIC0wLjQ5MTY5MywgMC4zNTYwNDcsIDAuNzQ3NzkwXSxcbiAgICBbMC4yMDc5MTIsIDAuOTc4MTQ4LCAtMC40MzUxNTksIDAuMzUyMjQ0LCAwLjgyODU4OSxcbiAgICAgLTAuMjg5Mzk5LCAtMC40Njk1MjcsIDAuMzg1MjE1LCAwLjczOTg2Nl0sXG4gICAgWzAuMjI0OTUxLCAwLjk3NDM3MCwgLTAuNDI0MDk2LCAwLjM3OTY0MSwgMC44MjIyMDIsXG4gICAgIC0wLjMwODk2OSwgLTAuNDQ1NzA5LCAwLjQxMzU3MiwgMC43MzEzMjddLFxuICAgIFswLjI0MTkyMiwgMC45NzAyOTYsIC0wLjQxMjIxMSwgMC40MDY1NzQsIDAuODE1MzQwLFxuICAgICAtMC4zMjc0ODYsIC0wLjQyMDMwNiwgMC40NDEwNjEsIDAuNzIyMTkxXSxcbiAgICBbMC4yNTg4MTksIDAuOTY1OTI2LCAtMC4zOTk1MTksIDAuNDMzMDEzLCAwLjgwODAxMyxcbiAgICAgLTAuMzQ0ODg1LCAtMC4zOTMzODksIDAuNDY3NjI3LCAwLjcxMjQ3OF0sXG4gICAgWzAuMjc1NjM3LCAwLjk2MTI2MiwgLTAuMzg2MDM2LCAwLjQ1ODkyNCwgMC44MDAyMjgsXG4gICAgIC0wLjM2MTEwMiwgLTAuMzY1MDM0LCAwLjQ5MzIxNiwgMC43MDIyMDddLFxuICAgIFswLjI5MjM3MiwgMC45NTYzMDUsIC0wLjM3MTc3OCwgMC40ODQyNzUsIDAuNzkxOTk3LFxuICAgICAtMC4zNzYwNzcsIC0wLjMzNTMxOSwgMC41MTc3NzgsIDAuNjkxMzk5XSxcbiAgICBbMC4zMDkwMTcsIDAuOTUxMDU3LCAtMC4zNTY3NjMsIDAuNTA5MDM3LCAwLjc4MzMyNyxcbiAgICAgLTAuMzg5NzU0LCAtMC4zMDQzMjksIDAuNTQxMjY2LCAwLjY4MDA3OF0sXG4gICAgWzAuMzI1NTY4LCAwLjk0NTUxOSwgLTAuMzQxMDA4LCAwLjUzMzE3OCwgMC43NzQyMzEsXG4gICAgIC0wLjQwMjA4MSwgLTAuMjcyMTUwLCAwLjU2MzYzNSwgMC42NjgyNjddLFxuICAgIFswLjM0MjAyMCwgMC45Mzk2OTMsIC0wLjMyNDUzMywgMC41NTY2NzAsIDAuNzY0NzIwLFxuICAgICAtMC40MTMwMDgsIC0wLjIzODg3MiwgMC41ODQ4NDMsIDAuNjU1OTkwXSxcbiAgICBbMC4zNTgzNjgsIDAuOTMzNTgwLCAtMC4zMDczNTksIDAuNTc5NDg0LCAwLjc1NDgwNCxcbiAgICAgLTAuNDIyNDkxLCAtMC4yMDQ1ODksIDAuNjA0ODUxLCAwLjY0MzI3M10sXG4gICAgWzAuMzc0NjA3LCAwLjkyNzE4NCwgLTAuMjg5NTA1LCAwLjYwMTU5MiwgMC43NDQ0OTYsXG4gICAgIC0wLjQzMDQ4OCwgLTAuMTY5Mzk3LCAwLjYyMzYyNCwgMC42MzAxNDFdLFxuICAgIFswLjM5MDczMSwgMC45MjA1MDUsIC0wLjI3MDk5NCwgMC42MjI5NjcsIDAuNzMzODA5LFxuICAgICAtMC40MzY5NjQsIC0wLjEzMzM5NSwgMC42NDExMzAsIDAuNjE2NjIxXSxcbiAgICBbMC40MDY3MzcsIDAuOTEzNTQ1LCAtMC4yNTE4NDgsIDAuNjQzNTgyLCAwLjcyMjc1NSxcbiAgICAgLTAuNDQxODg0LCAtMC4wOTY2ODQsIDAuNjU3MzM5LCAwLjYwMjc0MV0sXG4gICAgWzAuNDIyNjE4LCAwLjkwNjMwOCwgLTAuMjMyMDkxLCAwLjY2MzQxNCwgMC43MTEzNDgsXG4gICAgIC0wLjQ0NTIyMiwgLTAuMDU5MzY4LCAwLjY3MjIyNiwgMC41ODg1MjhdLFxuICAgIFswLjQzODM3MSwgMC44OTg3OTQsIC0wLjIxMTc0NiwgMC42ODI0MzcsIDAuNjk5NjAyLFxuICAgICAtMC40NDY5NTMsIC0wLjAyMTU1MCwgMC42ODU3NjksIDAuNTc0MDExXSxcbiAgICBbMC40NTM5OTAsIDAuODkxMDA3LCAtMC4xOTA4MzksIDAuNzAwNjI5LCAwLjY4NzUzMSxcbiAgICAgLTAuNDQ3MDU5LCAwLjAxNjY2MiwgMC42OTc5NTAsIDAuNTU5MjIwXSxcbiAgICBbMC40Njk0NzIsIDAuODgyOTQ4LCAtMC4xNjkzOTUsIDAuNzE3OTY4LCAwLjY3NTE1MCxcbiAgICAgLTAuNDQ1NTI0LCAwLjA1NTE2MCwgMC43MDg3NTMsIDAuNTQ0MTgzXSxcbiAgICBbMC40ODQ4MTAsIDAuODc0NjIwLCAtMC4xNDc0MzksIDAuNzM0NDMxLCAwLjY2MjQ3NCxcbiAgICAgLTAuNDQyMzQwLCAwLjA5MzgzNywgMC43MTgxNjcsIDAuNTI4OTI5XSxcbiAgICBbMC41MDAwMDAsIDAuODY2MDI1LCAtMC4xMjUwMDAsIDAuNzUwMDAwLCAwLjY0OTUxOSxcbiAgICAgLTAuNDM3NTAwLCAwLjEzMjU4MywgMC43MjYxODQsIDAuNTEzNDkwXSxcbiAgICBbMC41MTUwMzgsIDAuODU3MTY3LCAtMC4xMDIxMDQsIDAuNzY0NjU1LCAwLjYzNjMwMCxcbiAgICAgLTAuNDMxMDA0LCAwLjE3MTI4OCwgMC43MzI4MDEsIDAuNDk3ODk0XSxcbiAgICBbMC41Mjk5MTksIDAuODQ4MDQ4LCAtMC4wNzg3NzgsIDAuNzc4Mzc4LCAwLjYyMjgzMyxcbiAgICAgLTAuNDIyODU2LCAwLjIwOTg0MywgMC43MzgwMTcsIDAuNDgyMTcxXSxcbiAgICBbMC41NDQ2MzksIDAuODM4NjcxLCAtMC4wNTUwNTIsIDAuNzkxMTU0LCAwLjYwOTEzNSxcbiAgICAgLTAuNDEzMDY2LCAwLjI0ODE0MCwgMC43NDE4MzUsIDAuNDY2MzUyXSxcbiAgICBbMC41NTkxOTMsIDAuODI5MDM4LCAtMC4wMzA5NTUsIDAuODAyOTY1LCAwLjU5NTIyMixcbiAgICAgLTAuNDAxNjQ1LCAwLjI4NjA2OSwgMC43NDQyNjIsIDAuNDUwNDY3XSxcbiAgICBbMC41NzM1NzYsIDAuODE5MTUyLCAtMC4wMDY1MTUsIDAuODEzNzk4LCAwLjU4MTExMixcbiAgICAgLTAuMzg4NjEyLCAwLjMyMzUyNCwgMC43NDUzMDgsIDAuNDM0NTQ0XSxcbiAgICBbMC41ODc3ODUsIDAuODA5MDE3LCAwLjAxODIzNywgMC44MjM2MzksIDAuNTY2ODIxLFxuICAgICAtMC4zNzM5OTEsIDAuMzYwMzk3LCAwLjc0NDk4OSwgMC40MTg2MTNdLFxuICAgIFswLjYwMTgxNSwgMC43OTg2MzYsIDAuMDQzMjcyLCAwLjgzMjQ3NywgMC41NTIzNjcsXG4gICAgIC0wLjM1NzgwNywgMC4zOTY1ODQsIDAuNzQzMzIwLCAwLjQwMjcwNF0sXG4gICAgWzAuNjE1NjYxLCAwLjc4ODAxMSwgMC4wNjg1NTksIDAuODQwMzAxLCAwLjUzNzc2OCxcbiAgICAgLTAuMzQwMDkzLCAwLjQzMTk4MiwgMC43NDAzMjQsIDAuMzg2ODQ1XSxcbiAgICBbMC42MjkzMjAsIDAuNzc3MTQ2LCAwLjA5NDA2NiwgMC44NDcxMDEsIDAuNTIzMDQxLFxuICAgICAtMC4zMjA4ODQsIDAuNDY2NDkwLCAwLjczNjAyNSwgMC4zNzEwNjNdLFxuICAgIFswLjY0Mjc4OCwgMC43NjYwNDQsIDAuMTE5NzY0LCAwLjg1Mjg2OSwgMC41MDgyMDUsXG4gICAgIC0wLjMwMDIyMSwgMC41MDAwMDksIDAuNzMwNDUxLCAwLjM1NTM4N10sXG4gICAgWzAuNjU2MDU5LCAwLjc1NDcxMCwgMC4xNDU2MjAsIDAuODU3NTk3LCAwLjQ5MzI3NixcbiAgICAgLTAuMjc4MTQ3LCAwLjUzMjQ0MywgMC43MjM2MzMsIDAuMzM5ODQ0XSxcbiAgICBbMC42NjkxMzEsIDAuNzQzMTQ1LCAwLjE3MTYwNCwgMC44NjEyODEsIDAuNDc4Mjc1LFxuICAgICAtMC4yNTQ3MTIsIDAuNTYzNzAwLCAwLjcxNTYwNSwgMC4zMjQ0NTldLFxuICAgIFswLjY4MTk5OCwgMC43MzEzNTQsIDAuMTk3NjgzLCAwLjg2MzkxNiwgMC40NjMyMTgsXG4gICAgIC0wLjIyOTk2NywgMC41OTM2ODgsIDAuNzA2NDA1LCAwLjMwOTI1OV0sXG4gICAgWzAuNjk0NjU4LCAwLjcxOTM0MCwgMC4yMjM4MjUsIDAuODY1NDk4LCAwLjQ0ODEyNSxcbiAgICAgLTAuMjAzOTY5LCAwLjYyMjMyMiwgMC42OTYwNzMsIDAuMjk0MjY3XSxcbiAgICBbMC43MDcxMDcsIDAuNzA3MTA3LCAwLjI1MDAwMCwgMC44NjYwMjUsIDAuNDMzMDEzLFxuICAgICAtMC4xNzY3NzcsIDAuNjQ5NTE5LCAwLjY4NDY1MywgMC4yNzk1MDhdLFxuICAgIFswLjcxOTM0MCwgMC42OTQ2NTgsIDAuMjc2MTc1LCAwLjg2NTQ5OCwgMC40MTc5MDEsXG4gICAgIC0wLjE0ODQ1NCwgMC42NzUxOTksIDAuNjcyMTkwLCAwLjI2NTAwNV0sXG4gICAgWzAuNzMxMzU0LCAwLjY4MTk5OCwgMC4zMDIzMTcsIDAuODYzOTE2LCAwLjQwMjgwNyxcbiAgICAgLTAuMTE5MDY4LCAwLjY5OTI4OCwgMC42NTg3MzQsIDAuMjUwNzc4XSxcbiAgICBbMC43NDMxNDUsIDAuNjY5MTMxLCAwLjMyODM5NiwgMC44NjEyODEsIDAuMzg3NzUxLFxuICAgICAtMC4wODg2ODYsIDAuNzIxNzE0LCAwLjY0NDMzNCwgMC4yMzY4NTBdLFxuICAgIFswLjc1NDcxMCwgMC42NTYwNTksIDAuMzU0MzgwLCAwLjg1NzU5NywgMC4zNzI3NDksXG4gICAgIC0wLjA1NzM4MywgMC43NDI0MTIsIDAuNjI5MDQ0LCAwLjIyMzIzOF0sXG4gICAgWzAuNzY2MDQ0LCAwLjY0Mjc4OCwgMC4zODAyMzYsIDAuODUyODY5LCAwLjM1NzgyMSxcbiAgICAgLTAuMDI1MjMzLCAwLjc2MTMxOSwgMC42MTI5MjEsIDAuMjA5OTYzXSxcbiAgICBbMC43NzcxNDYsIDAuNjI5MzIwLCAwLjQwNTkzNCwgMC44NDcxMDEsIDAuMzQyOTg0LFxuICAgICAwLjAwNzY4NiwgMC43NzgzNzksIDAuNTk2MDIxLCAwLjE5NzA0MF0sXG4gICAgWzAuNzg4MDExLCAwLjYxNTY2MSwgMC40MzE0NDEsIDAuODQwMzAxLCAwLjMyODI1NyxcbiAgICAgMC4wNDEyOTQsIDAuNzkzNTQxLCAwLjU3ODQwNSwgMC4xODQ0ODddLFxuICAgIFswLjc5ODYzNiwgMC42MDE4MTUsIDAuNDU2NzI4LCAwLjgzMjQ3NywgMC4zMTM2NTgsXG4gICAgIDAuMDc1NTA4LCAwLjgwNjc1NywgMC41NjAxMzIsIDAuMTcyMzE3XSxcbiAgICBbMC44MDkwMTcsIDAuNTg3Nzg1LCAwLjQ4MTc2MywgMC44MjM2MzksIDAuMjk5MjA0LFxuICAgICAwLjExMDI0NiwgMC44MTc5ODcsIDAuNTQxMjY2LCAwLjE2MDU0NV0sXG4gICAgWzAuODE5MTUyLCAwLjU3MzU3NiwgMC41MDY1MTUsIDAuODEzNzk4LCAwLjI4NDkxNCxcbiAgICAgMC4xNDU0MjAsIDAuODI3MTk0LCAwLjUyMTg3MSwgMC4xNDkxODFdLFxuICAgIFswLjgyOTAzOCwgMC41NTkxOTMsIDAuNTMwOTU1LCAwLjgwMjk2NSwgMC4yNzA4MDMsXG4gICAgIDAuMTgwOTQ0LCAwLjgzNDM0NywgMC41MDIwMTEsIDAuMTM4MjM3XSxcbiAgICBbMC44Mzg2NzEsIDAuNTQ0NjM5LCAwLjU1NTA1MiwgMC43OTExNTQsIDAuMjU2ODkxLFxuICAgICAwLjIxNjczMCwgMC44Mzk0MjIsIDAuNDgxNzUzLCAwLjEyNzcyMl0sXG4gICAgWzAuODQ4MDQ4LCAwLjUyOTkxOSwgMC41Nzg3NzgsIDAuNzc4Mzc4LCAwLjI0MzE5MixcbiAgICAgMC4yNTI2ODgsIDAuODQyMzk5LCAwLjQ2MTE2NCwgMC4xMTc2NDRdLFxuICAgIFswLjg1NzE2NywgMC41MTUwMzgsIDAuNjAyMTA0LCAwLjc2NDY1NSwgMC4yMjk3MjYsXG4gICAgIDAuMjg4NzI4LCAwLjg0MzI2NSwgMC40NDAzMTEsIDAuMTA4MDA5XSxcbiAgICBbMC44NjYwMjUsIDAuNTAwMDAwLCAwLjYyNTAwMCwgMC43NTAwMDAsIDAuMjE2NTA2LFxuICAgICAwLjMyNDc2MCwgMC44NDIwMTIsIDAuNDE5MjYzLCAwLjA5ODgyMV0sXG4gICAgWzAuODc0NjIwLCAwLjQ4NDgxMCwgMC42NDc0MzksIDAuNzM0NDMxLCAwLjIwMzU1MSxcbiAgICAgMC4zNjA2OTIsIDAuODM4NjM4LCAwLjM5ODA4NiwgMC4wOTAwODVdLFxuICAgIFswLjg4Mjk0OCwgMC40Njk0NzIsIDAuNjY5Mzk1LCAwLjcxNzk2OCwgMC4xOTA4NzUsXG4gICAgIDAuMzk2NDM2LCAwLjgzMzE0NSwgMC4zNzY4NTEsIDAuMDgxODAzXSxcbiAgICBbMC44OTEwMDcsIDAuNDUzOTkwLCAwLjY5MDgzOSwgMC43MDA2MjksIDAuMTc4NDk0LFxuICAgICAwLjQzMTg5OSwgMC44MjU1NDQsIDAuMzU1NjIzLCAwLjA3Mzk3NF0sXG4gICAgWzAuODk4Nzk0LCAwLjQzODM3MSwgMC43MTE3NDYsIDAuNjgyNDM3LCAwLjE2NjQyMyxcbiAgICAgMC40NjY5OTMsIDAuODE1ODUwLCAwLjMzNDQ3MiwgMC4wNjY1OTldLFxuICAgIFswLjkwNjMwOCwgMC40MjI2MTgsIDAuNzMyMDkxLCAwLjY2MzQxNCwgMC4xNTQ2NzgsXG4gICAgIDAuNTAxNjI3LCAwLjgwNDA4MywgMC4zMTM0NjQsIDAuMDU5Njc0XSxcbiAgICBbMC45MTM1NDUsIDAuNDA2NzM3LCAwLjc1MTg0OCwgMC42NDM1ODIsIDAuMTQzMjcxLFxuICAgICAwLjUzNTcxNSwgMC43OTAyNzAsIDAuMjkyNjY2LCAwLjA1MzE5Nl0sXG4gICAgWzAuOTIwNTA1LCAwLjM5MDczMSwgMC43NzA5OTQsIDAuNjIyOTY3LCAwLjEzMjIxNyxcbiAgICAgMC41NjkxNjksIDAuNzc0NDQyLCAwLjI3MjE0MywgMC4wNDcxNjBdLFxuICAgIFswLjkyNzE4NCwgMC4zNzQ2MDcsIDAuNzg5NTA1LCAwLjYwMTU5MiwgMC4xMjE1MjksXG4gICAgIDAuNjAxOTA0LCAwLjc1NjYzNywgMC4yNTE5NjAsIDAuMDQxNTU5XSxcbiAgICBbMC45MzM1ODAsIDAuMzU4MzY4LCAwLjgwNzM1OSwgMC41Nzk0ODQsIDAuMTExMjIyLFxuICAgICAwLjYzMzgzNywgMC43MzY4OTgsIDAuMjMyMTgwLCAwLjAzNjM4NV0sXG4gICAgWzAuOTM5NjkzLCAwLjM0MjAyMCwgMC44MjQ1MzMsIDAuNTU2NjcwLCAwLjEwMTMwNixcbiAgICAgMC42NjQ4ODUsIDAuNzE1Mjc0LCAwLjIxMjg2NSwgMC4wMzE2MzBdLFxuICAgIFswLjk0NTUxOSwgMC4zMjU1NjgsIDAuODQxMDA4LCAwLjUzMzE3OCwgMC4wOTE3OTQsXG4gICAgIDAuNjk0OTY5LCAwLjY5MTgxNiwgMC4xOTQwNzUsIDAuMDI3MjgxXSxcbiAgICBbMC45NTEwNTcsIDAuMzA5MDE3LCAwLjg1Njc2MywgMC41MDkwMzcsIDAuMDgyNjk4LFxuICAgICAwLjcyNDAxMiwgMC42NjY1ODMsIDAuMTc1ODY4LCAwLjAyMzMyOV0sXG4gICAgWzAuOTU2MzA1LCAwLjI5MjM3MiwgMC44NzE3NzgsIDAuNDg0Mjc1LCAwLjA3NDAyOSxcbiAgICAgMC43NTE5NDAsIDAuNjM5NjM5LCAwLjE1ODMwMSwgMC4wMTk3NThdLFxuICAgIFswLjk2MTI2MiwgMC4yNzU2MzcsIDAuODg2MDM2LCAwLjQ1ODkyNCwgMC4wNjU3OTcsXG4gICAgIDAuNzc4NjgwLCAwLjYxMTA1MCwgMC4xNDE0MjcsIDAuMDE2NTU2XSxcbiAgICBbMC45NjU5MjYsIDAuMjU4ODE5LCAwLjg5OTUxOSwgMC40MzMwMTMsIDAuMDU4MDEzLFxuICAgICAwLjgwNDE2NCwgMC41ODA4ODksIDAuMTI1MzAwLCAwLjAxMzcwN10sXG4gICAgWzAuOTcwMjk2LCAwLjI0MTkyMiwgMC45MTIyMTEsIDAuNDA2NTc0LCAwLjA1MDY4NSxcbiAgICAgMC44MjgzMjYsIDAuNTQ5MjMzLCAwLjEwOTk2OSwgMC4wMTExOTNdLFxuICAgIFswLjk3NDM3MCwgMC4yMjQ5NTEsIDAuOTI0MDk2LCAwLjM3OTY0MSwgMC4wNDM4MjMsXG4gICAgIDAuODUxMTA1LCAwLjUxNjE2MiwgMC4wOTU0ODEsIDAuMDA4OTk5XSxcbiAgICBbMC45NzgxNDgsIDAuMjA3OTEyLCAwLjkzNTE1OSwgMC4zNTIyNDQsIDAuMDM3NDM2LFxuICAgICAwLjg3MjQ0MSwgMC40ODE3NTksIDAuMDgxODgwLCAwLjAwNzEwNV0sXG4gICAgWzAuOTgxNjI3LCAwLjE5MDgwOSwgMC45NDUzODgsIDAuMzI0NDE5LCAwLjAzMTUzMCxcbiAgICAgMC44OTIyNzksIDAuNDQ2MTE0LCAwLjA2OTIwOSwgMC4wMDU0OTJdLFxuICAgIFswLjk4NDgwOCwgMC4xNzM2NDgsIDAuOTU0NzY5LCAwLjI5NjE5OCwgMC4wMjYxMTQsXG4gICAgIDAuOTEwNTY5LCAwLjQwOTMxNywgMC4wNTc1MDUsIDAuMDA0MTQwXSxcbiAgICBbMC45ODc2ODgsIDAuMTU2NDM0LCAwLjk2MzI5MiwgMC4yNjc2MTcsIDAuMDIxMTkzLFxuICAgICAwLjkyNzI2MiwgMC4zNzE0NjMsIDAuMDQ2ODA2LCAwLjAwMzAyNl0sXG4gICAgWzAuOTkwMjY4LCAwLjEzOTE3MywgMC45NzA5NDYsIDAuMjM4NzA5LCAwLjAxNjc3NCxcbiAgICAgMC45NDIzMTYsIDAuMzMyNjQ5LCAwLjAzNzE0MywgMC4wMDIxMzFdLFxuICAgIFswLjk5MjU0NiwgMC4xMjE4NjksIDAuOTc3NzIyLCAwLjIwOTUxMSwgMC4wMTI4NjIsXG4gICAgIDAuOTU1NjkzLCAwLjI5Mjk3NiwgMC4wMjg1NDcsIDAuMDAxNDMxXSxcbiAgICBbMC45OTQ1MjIsIDAuMTA0NTI4LCAwLjk4MzYxMSwgMC4xODAwNTcsIDAuMDA5NDYyLFxuICAgICAwLjk2NzM1NiwgMC4yNTI1NDQsIDAuMDIxMDQzLCAwLjAwMDkwM10sXG4gICAgWzAuOTk2MTk1LCAwLjA4NzE1NiwgMC45ODg2MDYsIDAuMTUwMzg0LCAwLjAwNjU3OCxcbiAgICAgMC45NzcyNzcsIDAuMjExNDYwLCAwLjAxNDY1NCwgMC4wMDA1MjNdLFxuICAgIFswLjk5NzU2NCwgMC4wNjk3NTYsIDAuOTkyNzAxLCAwLjEyMDUyNywgMC4wMDQyMTQsXG4gICAgIDAuOTg1NDI5LCAwLjE2OTgyOCwgMC4wMDk0MDAsIDAuMDAwMjY4XSxcbiAgICBbMC45OTg2MzAsIDAuMDUyMzM2LCAwLjk5NTg5MSwgMC4wOTA1MjQsIDAuMDAyMzcyLFxuICAgICAwLjk5MTc5MSwgMC4xMjc3NTcsIDAuMDA1Mjk3LCAwLjAwMDExM10sXG4gICAgWzAuOTk5MzkxLCAwLjAzNDg5OSwgMC45OTgxNzMsIDAuMDYwNDExLCAwLjAwMTA1NSxcbiAgICAgMC45OTYzNDgsIDAuMDg1MzU2LCAwLjAwMjM1NywgMC4wMDAwMzRdLFxuICAgIFswLjk5OTg0OCwgMC4wMTc0NTIsIDAuOTk5NTQzLCAwLjAzMDIyNCwgMC4wMDAyNjQsXG4gICAgIDAuOTk5MDg2LCAwLjA0MjczMywgMC4wMDA1OTAsIDAuMDAwMDA0XSxcbiAgICBbMS4wMDAwMDAsIC0wLjAwMDAwMCwgMS4wMDAwMDAsIC0wLjAwMDAwMCwgMC4wMDAwMDAsXG4gICAgIDEuMDAwMDAwLCAtMC4wMDAwMDAsIDAuMDAwMDAwLCAtMC4wMDAwMDBdLFxuICBdLFxuXTtcblxuXG4vKiogQHR5cGUge051bWJlcn0gKi9cbmV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU19BWklNVVRIX1JFU09MVVRJT04gPVxuICBleHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NbMF0ubGVuZ3RoO1xuXG5cbi8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTX0VMRVZBVElPTl9SRVNPTFVUSU9OID1cbiAgZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTWzFdLmxlbmd0aDtcblxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGFsbG93ZWQgYW1iaXNvbmljIG9yZGVyLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUiA9XG4gIGV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU1swXVswXS5sZW5ndGggLyAyO1xuXG5cbi8qKlxuICogUHJlLWNvbXB1dGVkIHBlci1iYW5kIHdlaWdodGluZyBjb2VmZmljaWVudHMgZm9yIHByb2R1Y2luZyBlbmVyZ3ktcHJlc2VydmluZ1xuICogTWF4LVJlIHNvdXJjZXMuXG4gKi9cbmV4cG9ydHMuTUFYX1JFX1dFSUdIVFMgPVxuW1xuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDAwMDAsIDEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDBdLFxuICBbMS4wMDMyMzYsIDEuMDAyMTU2LCAwLjk5OTE1MiwgMC45OTAwMzhdLFxuICBbMS4wMzIzNzAsIDEuMDIxMTk0LCAwLjk5MDQzMywgMC44OTg1NzJdLFxuICBbMS4wNjI2OTQsIDEuMDQwMjMxLCAwLjk3OTE2MSwgMC43OTk4MDZdLFxuICBbMS4wOTM5OTksIDEuMDU4OTU0LCAwLjk2NDk3NiwgMC42OTM2MDNdLFxuICBbMS4xMjYwMDMsIDEuMDc3MDA2LCAwLjk0NzUyNiwgMC41Nzk4OTBdLFxuICBbMS4xNTgzNDUsIDEuMDkzOTgyLCAwLjkyNjQ3NCwgMC40NTg2OTBdLFxuICBbMS4xOTA1OTAsIDEuMTA5NDM3LCAwLjkwMTUxMiwgMC4zMzAxNThdLFxuICBbMS4yMjIyMjgsIDEuMTIyODkwLCAwLjg3MjM3MCwgMC4xOTQ2MjFdLFxuICBbMS4yNTI2ODQsIDEuMTMzODM3LCAwLjgzODgzOSwgMC4wNTI2MTRdLFxuICBbMS4yODE5ODcsIDEuMTQyMzU4LCAwLjgwMTE5OSwgMC4wMDAwMDBdLFxuICBbMS4zMTIwNzMsIDEuMTUwMjA3LCAwLjc2MDgzOSwgMC4wMDAwMDBdLFxuICBbMS4zNDMwMTEsIDEuMTU3NDI0LCAwLjcxNzc5OSwgMC4wMDAwMDBdLFxuICBbMS4zNzQ2NDksIDEuMTYzODU5LCAwLjY3MTk5OSwgMC4wMDAwMDBdLFxuICBbMS40MDY4MDksIDEuMTY5MzU0LCAwLjYyMzM3MSwgMC4wMDAwMDBdLFxuICBbMS40MzkyODYsIDEuMTczNzM5LCAwLjU3MTg2OCwgMC4wMDAwMDBdLFxuICBbMS40NzE4NDYsIDEuMTc2ODM3LCAwLjUxNzQ2NSwgMC4wMDAwMDBdLFxuICBbMS41MDQyMjYsIDEuMTc4NDY1LCAwLjQ2MDE3NCwgMC4wMDAwMDBdLFxuICBbMS41MzYxMzMsIDEuMTc4NDM4LCAwLjQwMDA0MywgMC4wMDAwMDBdLFxuICBbMS41NjcyNTMsIDEuMTc2NTczLCAwLjMzNzE2NSwgMC4wMDAwMDBdLFxuICBbMS41OTcyNDcsIDEuMTcyNjk1LCAwLjI3MTY4OCwgMC4wMDAwMDBdLFxuICBbMS42MjU3NjYsIDEuMTY2NjQ1LCAwLjIwMzgxNSwgMC4wMDAwMDBdLFxuICBbMS42NTI0NTUsIDEuMTU4Mjg1LCAwLjEzMzgwNiwgMC4wMDAwMDBdLFxuICBbMS42NzY5NjYsIDEuMTQ3NTA2LCAwLjA2MTk4MywgMC4wMDAwMDBdLFxuICBbMS42OTkwMDYsIDEuMTM0MjYxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS43MjAyMjQsIDEuMTE5Nzg5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS43NDE2MzEsIDEuMTA0ODEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS43NjMxODMsIDEuMDg5MzMwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS43ODQ4MzcsIDEuMDczMzU2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS44MDY1NDgsIDEuMDU2ODk4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS44MjgyNjksIDEuMDM5OTY4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS44NDk5NTIsIDEuMDIyNTgwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS44NzE1NTIsIDEuMDA0NzUyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS44OTMwMTgsIDAuOTg2NTA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS45MTQzMDUsIDAuOTY3ODU3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS45MzUzNjYsIDAuOTQ4ODM3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS45NTYxNTQsIDAuOTI5NDcxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS45NzY2MjUsIDAuOTA5NzkwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMS45OTY3MzYsIDAuODg5ODIzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4wMTY0NDgsIDAuODY5NjA3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4wMzU3MjEsIDAuODQ5MTc1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4wNTQ1MjIsIDAuODI4NTY1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4wNzI4MTgsIDAuODA3ODE2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4wOTA1ODEsIDAuNzg2OTY0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xMDc3ODUsIDAuNzY2MDUxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xMjQ0MTEsIDAuNzQ1MTE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xNDA0MzksIDAuNzI0MTk2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xNTU4NTYsIDAuNzAzMzMyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xNzA2NTMsIDAuNjgyNTYxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xODQ4MjMsIDAuNjYxOTIxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4xOTgzNjQsIDAuNjQxNDQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yMTEyNzUsIDAuNjIxMTY5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yMjM1NjIsIDAuNjAxMTI1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yMzUyMzAsIDAuNTgxMzQxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yNDYyODksIDAuNTYxODQ3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yNTY3NTEsIDAuNTQyNjY3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yNjY2MzEsIDAuNTIzODI2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yNzU5NDMsIDAuNTA1MzQ0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yODQ3MDcsIDAuNDg3MjM5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4yOTI5MzksIDAuNDY5NTI4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMDA2NjEsIDAuNDUyMjI1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMDc4OTIsIDAuNDM1MzQyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMTQ2NTQsIDAuNDE4ODg4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMjA5NjksIDAuNDAyODcwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMjY4NTgsIDAuMzg3Mjk0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMzIzNDMsIDAuMzcyMTY0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zMzc0NDUsIDAuMzU3NDgxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNDIxODYsIDAuMzQzMjQ2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNDY1ODUsIDAuMzI5NDU4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNTA2NjQsIDAuMzE2MTEzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNTQ0NDIsIDAuMzAzMjA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNTc5MzcsIDAuMjkwNzM4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNjExNjgsIDAuMjc4Njk4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNjQxNTIsIDAuMjY3MDgwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNjY5MDYsIDAuMjU1ODc4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNjk0NDYsIDAuMjQ1MDgyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNzE3ODYsIDAuMjM0Njg1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNzM5NDAsIDAuMjI0Njc3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNzU5MjMsIDAuMjE1MDQ4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNzc3NDUsIDAuMjA1NzkwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zNzk0MjEsIDAuMTk2ODkxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODA5NTksIDAuMTg4MzQyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODIzNzIsIDAuMTgwMTMyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODM2NjcsIDAuMTcyMjUxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODQ4NTYsIDAuMTY0Njg5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODU5NDUsIDAuMTU3NDM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODY5NDMsIDAuMTUwNDc5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODc4NTcsIDAuMTQzODExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODg2OTQsIDAuMTM3NDIxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zODk0NjAsIDAuMTMxMjk5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTAxNjAsIDAuMTI1NDM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTA4MDEsIDAuMTE5ODIwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTEzODYsIDAuMTE0NDQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTE5MjEsIDAuMTA5MzAwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTI0MTAsIDAuMTA0Mzc2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTI4NTcsIDAuMDk5NjY2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTMyNjUsIDAuMDk1MTYwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTM2MzcsIDAuMDkwODUxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTM5NzcsIDAuMDg2NzMxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTQyODgsIDAuMDgyNzkxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTQ1NzEsIDAuMDc5MDI1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTQ4MjksIDAuMDc1NDI2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTUwNjQsIDAuMDcxOTg2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTUyNzksIDAuMDY4Njk5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTU0NzUsIDAuMDY1NTU4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTU2NTMsIDAuMDYyNTU4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTU4MTYsIDAuMDU5NjkzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTU5NjQsIDAuMDU2OTU1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTYwOTksIDAuMDU0MzQxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTYyMjIsIDAuMDUxODQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTYzMzQsIDAuMDQ5NDYyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY0MzYsIDAuMDQ3MTg2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY1MjksIDAuMDQ1MDEzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY2MTMsIDAuMDQyOTM5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY2OTEsIDAuMDQwOTU5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY3NjEsIDAuMDM5MDY5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY4MjUsIDAuMDM3MjY2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY4ODMsIDAuMDM1NTQ0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY5MzYsIDAuMDMzOTAxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTY5ODQsIDAuMDMyMzM0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcwMjgsIDAuMDMwODM4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcwNjgsIDAuMDI5NDEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcxMDQsIDAuMDI4MDQ4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcxMzcsIDAuMDI2NzQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcxNjcsIDAuMDI1NTA5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcxOTQsIDAuMDI0MzI2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcyMTksIDAuMDIzMTk4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcyNDIsIDAuMDIyMTIyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcyNjIsIDAuMDIxMDk1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcyODEsIDAuMDIwMTE2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTcyOTgsIDAuMDE5MTgxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczMTQsIDAuMDE4MjkwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczMjgsIDAuMDE3NDQxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczNDEsIDAuMDE2NjMwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczNTIsIDAuMDE1ODU3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczNjMsIDAuMDE1MTE5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczNzIsIDAuMDE0NDE2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczODEsIDAuMDEzNzQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczODksIDAuMDEzMTA2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTczOTYsIDAuMDEyNDk2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MDMsIDAuMDExOTE0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MDksIDAuMDExMzYwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MTQsIDAuMDEwODMxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MTksIDAuMDEwMzI2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MjQsIDAuMDA5ODQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MjgsIDAuMDA5Mzg3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MzIsIDAuMDA4OTQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MzUsIDAuMDA4NTMyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0MzgsIDAuMDA4MTM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NDEsIDAuMDA3NzU1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NDMsIDAuMDA3Mzk0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NDYsIDAuMDA3MDQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NDgsIDAuMDA2NzIxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTAsIDAuMDA2NDA3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTEsIDAuMDA2MTA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTMsIDAuMDA1ODI0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTQsIDAuMDA1NTUyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTYsIDAuMDA1MjkzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTcsIDAuMDA1MDQ2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTgsIDAuMDA0ODExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NTksIDAuMDA0NTg2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjAsIDAuMDA0MzcyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjEsIDAuMDA0MTY4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjEsIDAuMDAzOTc0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjIsIDAuMDAzNzg4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjMsIDAuMDAzNjExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjMsIDAuMDAzNDQzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjQsIDAuMDAzMjgyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjQsIDAuMDAzMTI5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjUsIDAuMDAyOTgzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjUsIDAuMDAyODQ0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjUsIDAuMDAyNzExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjYsIDAuMDAyNTg0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjYsIDAuMDAyNDY0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjYsIDAuMDAyMzQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjYsIDAuMDAyMjM5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAyMTM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAyMDM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAxOTQwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAxODQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAxNzYzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjcsIDAuMDAxNjgxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxNjAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxNTI3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxNDU2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMzg4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMzIzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMjYxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMjAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMTQ2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMDkzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAxMDQyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAwOTkzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAwOTQ3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAwOTAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAwODYwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjgsIDAuMDAwODIwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNzgyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNzQ1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNzEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNjc3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNjQ2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNjE2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNTg3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNTU5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNTMzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNTA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNDg1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNDYyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNDQwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNDIwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwNDAwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzgxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzY0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzQ3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzMwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMzAwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjg2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjczLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjYwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjQ4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjM2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjI1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMjA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTk1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTg2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTc3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTY5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTYxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTU0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTQ3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTQwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTMzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTI3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTIxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMTAwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDk1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDkxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDg3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDgzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDc5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDc1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDcxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDY4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDY1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDYyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDU5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDU2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDU0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDUxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDQ5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDQ2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDQ0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDQyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDQwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDM4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDM3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDM1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDMzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDMyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDMwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDI5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDI3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDI2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDI1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDI0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDIzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDIyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDIxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDIwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDE0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDExLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDEwLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA5LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA4LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA3LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA2LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA1LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDA0LCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAzLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAyLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuICBbMi4zOTc0NjksIDAuMDAwMDAxLCAwLjAwMDAwMCwgMC4wMDAwMDBdLFxuXTtcblxuXG4vKiogQHR5cGUge051bWJlcn0gKi9cbmV4cG9ydHMuTUFYX1JFX1dFSUdIVFNfUkVTT0xVVElPTiA9IGV4cG9ydHMuTUFYX1JFX1dFSUdIVFMubGVuZ3RoO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBTb3VyY2UgbW9kZWwgdG8gc3BhdGlhbGl6ZSBhbiBhdWRpbyBidWZmZXIuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBEaXJlY3Rpdml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5jb25zdCBBdHRlbnVhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb25zdCBFbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBTb3VyY2VcbiAqIEBkZXNjcmlwdGlvbiBTb3VyY2UgbW9kZWwgdG8gc3BhdGlhbGl6ZSBhbiBhdWRpbyBidWZmZXIuXG4gKiBAcGFyYW0ge1Jlc29uYW5jZUF1ZGlvfSBzY2VuZSBBc3NvY2lhdGVkIHtAbGluayBSZXNvbmFuY2VBdWRpb1xuICogUmVzb25hbmNlQXVkaW99IGluc3RhbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnBvc2l0aW9uXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5mb3J3YXJkXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCBmb3J3YXJkIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9GT1JXQVJEIERFRkFVTFRfRk9SV0FSRH0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy51cFxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgdXAgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1VQIERFRkFVTFRfVVB9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWluRGlzdGFuY2VcbiAqIE1pbi4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFIERFRkFVTFRfTUlOX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heERpc3RhbmNlXG4gKiBNYXguIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRSBERUZBVUxUX01BWF9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yb2xsb2ZmXG4gKiBSb2xsb2ZmIG1vZGVsIHRvIHVzZSwgY2hvc2VuIGZyb20gb3B0aW9ucyBpblxuICoge0BsaW5rY29kZSBVdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyBBVFRFTlVBVElPTl9ST0xMT0ZGU30uIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRiBERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkZ9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZ2FpbiBJbnB1dCBnYWluIChsaW5lYXIpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NPVVJDRV9HQUlOIERFRkFVTFRfU09VUkNFX0dBSU59LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYWxwaGEgRGlyZWN0aXZpdHkgYWxwaGEuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEEgREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zaGFycG5lc3MgRGlyZWN0aXZpdHkgc2hhcnBuZXNzLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU1xuICogREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1N9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc291cmNlV2lkdGhcbiAqIFNvdXJjZSB3aWR0aCAoaW4gZGVncmVlcykuIFdoZXJlIDAgZGVncmVlcyBpcyBhIHBvaW50IHNvdXJjZSBhbmQgMzYwIGRlZ3JlZXNcbiAqIGlzIGFuIG9tbmlkaXJlY3Rpb25hbCBzb3VyY2UuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIIERFRkFVTFRfU09VUkNFX1dJRFRIfS5cbiAqL1xuZnVuY3Rpb24gU291cmNlKHNjZW5lLCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIFNvdXJjZVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKlxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnBvc2l0aW9uID0gVXRpbHMuREVGQVVMVF9QT1NJVElPTi5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcndhcmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5mb3J3YXJkID0gVXRpbHMuREVGQVVMVF9GT1JXQVJELnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudXAgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy51cCA9IFV0aWxzLkRFRkFVTFRfVVAuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5taW5EaXN0YW5jZSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1pbkRpc3RhbmNlID0gVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0U7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4RGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5tYXhEaXN0YW5jZSA9IFV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFO1xuICB9XG4gIGlmIChvcHRpb25zLnJvbGxvZmYgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5yb2xsb2ZmID0gVXRpbHMuREVGQVVMVF9ST0xMT0ZGO1xuICB9XG4gIGlmIChvcHRpb25zLmdhaW4gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5nYWluID0gVXRpbHMuREVGQVVMVF9TT1VSQ0VfR0FJTjtcbiAgfVxuICBpZiAob3B0aW9ucy5hbHBoYSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmFscGhhID0gVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQTtcbiAgfVxuICBpZiAob3B0aW9ucy5zaGFycG5lc3MgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zaGFycG5lc3MgPSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTUztcbiAgfVxuICBpZiAob3B0aW9ucy5zb3VyY2VXaWR0aCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNvdXJjZVdpZHRoID0gVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEg7XG4gIH1cblxuICAvLyBNZW1iZXIgdmFyaWFibGVzLlxuICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICB0aGlzLl9wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gIHRoaXMuX2ZvcndhcmQgPSBvcHRpb25zLmZvcndhcmQ7XG4gIHRoaXMuX3VwID0gb3B0aW9ucy51cDtcbiAgdGhpcy5fZHggPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICB0aGlzLl9yaWdodCA9IFV0aWxzLmNyb3NzUHJvZHVjdCh0aGlzLl9mb3J3YXJkLCB0aGlzLl91cCk7XG5cbiAgLy8gQ3JlYXRlIGF1ZGlvIG5vZGVzLlxuICBsZXQgY29udGV4dCA9IHNjZW5lLl9jb250ZXh0O1xuICB0aGlzLmlucHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2RpcmVjdGl2aXR5ID0gbmV3IERpcmVjdGl2aXR5KGNvbnRleHQsIHtcbiAgICBhbHBoYTogb3B0aW9ucy5hbHBoYSxcbiAgICBzaGFycG5lc3M6IG9wdGlvbnMuc2hhcnBuZXNzLFxuICB9KTtcbiAgdGhpcy5fdG9FYXJseSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl90b0xhdGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fYXR0ZW51YXRpb24gPSBuZXcgQXR0ZW51YXRpb24oY29udGV4dCwge1xuICAgIG1pbkRpc3RhbmNlOiBvcHRpb25zLm1pbkRpc3RhbmNlLFxuICAgIG1heERpc3RhbmNlOiBvcHRpb25zLm1heERpc3RhbmNlLFxuICAgIHJvbGxvZmY6IG9wdGlvbnMucm9sbG9mZixcbiAgfSk7XG4gIHRoaXMuX2VuY29kZXIgPSBuZXcgRW5jb2Rlcihjb250ZXh0LCB7XG4gICAgYW1iaXNvbmljT3JkZXI6IHNjZW5lLl9hbWJpc29uaWNPcmRlcixcbiAgICBzb3VyY2VXaWR0aDogb3B0aW9ucy5zb3VyY2VXaWR0aCxcbiAgfSk7XG5cbiAgLy8gQ29ubmVjdCBub2Rlcy5cbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX3RvTGF0ZSk7XG4gIHRoaXMuX3RvTGF0ZS5jb25uZWN0KHNjZW5lLl9yb29tLmxhdGUuaW5wdXQpO1xuXG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9hdHRlbnVhdGlvbi5pbnB1dCk7XG4gIHRoaXMuX2F0dGVudWF0aW9uLm91dHB1dC5jb25uZWN0KHRoaXMuX3RvRWFybHkpO1xuICB0aGlzLl90b0Vhcmx5LmNvbm5lY3Qoc2NlbmUuX3Jvb20uZWFybHkuaW5wdXQpO1xuXG4gIHRoaXMuX2F0dGVudWF0aW9uLm91dHB1dC5jb25uZWN0KHRoaXMuX2RpcmVjdGl2aXR5LmlucHV0KTtcbiAgdGhpcy5fZGlyZWN0aXZpdHkub3V0cHV0LmNvbm5lY3QodGhpcy5fZW5jb2Rlci5pbnB1dCk7XG5cbiAgdGhpcy5fZW5jb2Rlci5vdXRwdXQuY29ubmVjdChzY2VuZS5fbGlzdGVuZXIuaW5wdXQpO1xuXG4gIC8vIEFzc2lnbiBpbml0aWFsIGNvbmRpdGlvbnMuXG4gIHRoaXMuc2V0UG9zaXRpb24oXG4gICAgb3B0aW9ucy5wb3NpdGlvblswXSwgb3B0aW9ucy5wb3NpdGlvblsxXSwgb3B0aW9ucy5wb3NpdGlvblsyXSk7XG4gIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuZ2Fpbjtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgLy8gQXNzaWduIG5ldyBwb3NpdGlvbi5cbiAgdGhpcy5fcG9zaXRpb25bMF0gPSB4O1xuICB0aGlzLl9wb3NpdGlvblsxXSA9IHk7XG4gIHRoaXMuX3Bvc2l0aW9uWzJdID0gejtcblxuICAvLyBIYW5kbGUgZmFyLWZpZWxkIGVmZmVjdC5cbiAgbGV0IGRpc3RhbmNlID0gdGhpcy5fc2NlbmUuX3Jvb20uZ2V0RGlzdGFuY2VPdXRzaWRlUm9vbShcbiAgICB0aGlzLl9wb3NpdGlvblswXSwgdGhpcy5fcG9zaXRpb25bMV0sIHRoaXMuX3Bvc2l0aW9uWzJdKTtcbiAgICBsZXQgZ2FpbiA9IF9jb21wdXRlRGlzdGFuY2VPdXRzaWRlUm9vbShkaXN0YW5jZSk7XG4gIHRoaXMuX3RvTGF0ZS5nYWluLnZhbHVlID0gZ2FpbjtcbiAgdGhpcy5fdG9FYXJseS5nYWluLnZhbHVlID0gZ2FpbjtcblxuICB0aGlzLl91cGRhdGUoKTtcbn07XG5cblxuLy8gVXBkYXRlIHRoZSBzb3VyY2Ugd2hlbiBjaGFuZ2luZyB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbi5cblNvdXJjZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBDb21wdXRlIGRpc3RhbmNlIHRvIGxpc3RlbmVyLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHRoaXMuX2R4W2ldID0gdGhpcy5fcG9zaXRpb25baV0gLSB0aGlzLl9zY2VuZS5fbGlzdGVuZXIucG9zaXRpb25baV07XG4gIH1cbiAgbGV0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHRoaXMuX2R4WzBdICogdGhpcy5fZHhbMF0gK1xuICAgIHRoaXMuX2R4WzFdICogdGhpcy5fZHhbMV0gKyB0aGlzLl9keFsyXSAqIHRoaXMuX2R4WzJdKTtcbiAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgIC8vIE5vcm1hbGl6ZSBkaXJlY3Rpb24gdmVjdG9yLlxuICAgIHRoaXMuX2R4WzBdIC89IGRpc3RhbmNlO1xuICAgIHRoaXMuX2R4WzFdIC89IGRpc3RhbmNlO1xuICAgIHRoaXMuX2R4WzJdIC89IGRpc3RhbmNlO1xuICB9XG5cbiAgLy8gQ29tcHVldGUgYW5nbGUgb2YgZGlyZWN0aW9uIHZlY3Rvci5cbiAgbGV0IGF6aW11dGggPSBNYXRoLmF0YW4yKC10aGlzLl9keFswXSwgdGhpcy5fZHhbMl0pICpcbiAgICBVdGlscy5SQURJQU5TX1RPX0RFR1JFRVM7XG4gIGxldCBlbGV2YXRpb24gPSBNYXRoLmF0YW4yKHRoaXMuX2R4WzFdLCBNYXRoLnNxcnQodGhpcy5fZHhbMF0gKiB0aGlzLl9keFswXSArXG4gICAgdGhpcy5fZHhbMl0gKiB0aGlzLl9keFsyXSkpICogVXRpbHMuUkFESUFOU19UT19ERUdSRUVTO1xuXG4gIC8vIFNldCBkaXN0YW5jZS9kaXJlY3Rpdml0eS9kaXJlY3Rpb24gdmFsdWVzLlxuICB0aGlzLl9hdHRlbnVhdGlvbi5zZXREaXN0YW5jZShkaXN0YW5jZSk7XG4gIHRoaXMuX2RpcmVjdGl2aXR5LmNvbXB1dGVBbmdsZSh0aGlzLl9mb3J3YXJkLCB0aGlzLl9keCk7XG4gIHRoaXMuX2VuY29kZXIuc2V0RGlyZWN0aW9uKGF6aW11dGgsIGVsZXZhdGlvbik7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIHJvbGxvZmYuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sbG9mZlxuICogUm9sbG9mZiBtb2RlbCB0byB1c2UsIGNob3NlbiBmcm9tIG9wdGlvbnMgaW5cbiAqIHtAbGlua2NvZGUgVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgQVRURU5VQVRJT05fUk9MTE9GRlN9LlxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldFJvbGxvZmYgPSBmdW5jdGlvbihyb2xsb2ZmKSB7XG4gIHRoaXMuX2F0dGVudWF0aW9uLnNldFJvbGxvZmYocm9sbG9mZik7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIG1pbmltdW0gZGlzdGFuY2UgKGluIG1ldGVycykuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdGFuY2VcbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRNaW5EaXN0YW5jZSA9IGZ1bmN0aW9uKG1pbkRpc3RhbmNlKSB7XG4gIHRoaXMuX2F0dGVudWF0aW9uLm1pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIG1heGltdW0gZGlzdGFuY2UgKGluIG1ldGVycykuXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdGFuY2VcbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRNYXhEaXN0YW5jZSA9IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG4gIHRoaXMuX2F0dGVudWF0aW9uLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIGdhaW4gKGxpbmVhcikuXG4gKiBAcGFyYW0ge051bWJlcn0gZ2FpblxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldEdhaW4gPSBmdW5jdGlvbihnYWluKSB7XG4gIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IGdhaW47XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UncyBvcmllbnRhdGlvbiB1c2luZyBmb3J3YXJkIGFuZCB1cCB2ZWN0b3JzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRYXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFlcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWlxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWFxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWVxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWlxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24oZm9yd2FyZFgsIGZvcndhcmRZLCBmb3J3YXJkWixcbiAgICB1cFgsIHVwWSwgdXBaKSB7XG4gIHRoaXMuX2ZvcndhcmRbMF0gPSBmb3J3YXJkWDtcbiAgdGhpcy5fZm9yd2FyZFsxXSA9IGZvcndhcmRZO1xuICB0aGlzLl9mb3J3YXJkWzJdID0gZm9yd2FyZFo7XG4gIHRoaXMuX3VwWzBdID0gdXBYO1xuICB0aGlzLl91cFsxXSA9IHVwWTtcbiAgdGhpcy5fdXBbMl0gPSB1cFo7XG4gIHRoaXMuX3JpZ2h0ID0gVXRpbHMuY3Jvc3NQcm9kdWN0KHRoaXMuX2ZvcndhcmQsIHRoaXMuX3VwKTtcbn07XG5cblxuLy8gVE9ETyhiaXRsbGFtYSk6IE1ha2Ugc3VyZSB0aGlzIHdvcmtzIHdpdGggVGhyZWUuanMgYXMgaW50ZW5kZWQuXG4vKipcbiAqIFNldCBzb3VyY2UncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gdXNpbmcgYVxuICogVGhyZWUuanMgbW9kZWxWaWV3TWF0cml4IG9iamVjdC5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBtYXRyaXg0XG4gKiBUaGUgTWF0cml4NCByZXByZXNlbnRpbmcgdGhlIG9iamVjdCBwb3NpdGlvbiBhbmQgcm90YXRpb24gaW4gd29ybGQgc3BhY2UuXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0RnJvbU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeDQpIHtcbiAgdGhpcy5fcmlnaHRbMF0gPSBtYXRyaXg0LmVsZW1lbnRzWzBdO1xuICB0aGlzLl9yaWdodFsxXSA9IG1hdHJpeDQuZWxlbWVudHNbMV07XG4gIHRoaXMuX3JpZ2h0WzJdID0gbWF0cml4NC5lbGVtZW50c1syXTtcbiAgdGhpcy5fdXBbMF0gPSBtYXRyaXg0LmVsZW1lbnRzWzRdO1xuICB0aGlzLl91cFsxXSA9IG1hdHJpeDQuZWxlbWVudHNbNV07XG4gIHRoaXMuX3VwWzJdID0gbWF0cml4NC5lbGVtZW50c1s2XTtcbiAgdGhpcy5fZm9yd2FyZFswXSA9IG1hdHJpeDQuZWxlbWVudHNbOF07XG4gIHRoaXMuX2ZvcndhcmRbMV0gPSBtYXRyaXg0LmVsZW1lbnRzWzldO1xuICB0aGlzLl9mb3J3YXJkWzJdID0gbWF0cml4NC5lbGVtZW50c1sxMF07XG5cbiAgLy8gTm9ybWFsaXplIHRvIHJlbW92ZSBzY2FsaW5nLlxuICB0aGlzLl9yaWdodCA9IFV0aWxzLm5vcm1hbGl6ZVZlY3Rvcih0aGlzLl9yaWdodCk7XG4gIHRoaXMuX3VwID0gVXRpbHMubm9ybWFsaXplVmVjdG9yKHRoaXMuX3VwKTtcbiAgdGhpcy5fZm9yd2FyZCA9IFV0aWxzLm5vcm1hbGl6ZVZlY3Rvcih0aGlzLl9mb3J3YXJkKTtcblxuICAvLyBVcGRhdGUgcG9zaXRpb24uXG4gIHRoaXMuc2V0UG9zaXRpb24oXG4gICAgbWF0cml4NC5lbGVtZW50c1sxMl0sIG1hdHJpeDQuZWxlbWVudHNbMTNdLCBtYXRyaXg0LmVsZW1lbnRzWzE0XSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2Ugd2lkdGggKGluIGRlZ3JlZXMpLiBXaGVyZSAwIGRlZ3JlZXMgaXMgYSBwb2ludCBzb3VyY2UgYW5kIDM2MFxuICogZGVncmVlcyBpcyBhbiBvbW5pZGlyZWN0aW9uYWwgc291cmNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIChpbiBkZWdyZWVzKS5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRTb3VyY2VXaWR0aCA9IGZ1bmN0aW9uKHNvdXJjZVdpZHRoKSB7XG4gIHRoaXMuX2VuY29kZXIuc2V0U291cmNlV2lkdGgoc291cmNlV2lkdGgpO1xuICB0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uWzBdLCB0aGlzLl9wb3NpdGlvblsxXSwgdGhpcy5fcG9zaXRpb25bMl0pO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBkaXJlY3Rpdml0eSBwYXR0ZXJuIChkZWZpbmVkIGJ5IGFscGhhKSwgd2hlcmUgMCBpcyBhblxuICogb21uaWRpcmVjdGlvbmFsIHBhdHRlcm4sIDEgaXMgYSBiaWRpcmVjdGlvbmFsIHBhdHRlcm4sIDAuNSBpcyBhIGNhcmRpb2RcbiAqIHBhdHRlcm4uIFRoZSBzaGFycG5lc3Mgb2YgdGhlIHBhdHRlcm4gaXMgaW5jcmVhc2VkIGV4cG9uZW50aWFsbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcbiAqIERldGVybWluZXMgZGlyZWN0aXZpdHkgcGF0dGVybiAoMCB0byAxKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFycG5lc3NcbiAqIERldGVybWluZXMgdGhlIHNoYXJwbmVzcyBvZiB0aGUgZGlyZWN0aXZpdHkgcGF0dGVybiAoMSB0byBJbmYpLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldERpcmVjdGl2aXR5UGF0dGVybiA9IGZ1bmN0aW9uKGFscGhhLCBzaGFycG5lc3MpIHtcbiAgdGhpcy5fZGlyZWN0aXZpdHkuc2V0UGF0dGVybihhbHBoYSwgc2hhcnBuZXNzKTtcbiAgdGhpcy5zZXRQb3NpdGlvbih0aGlzLl9wb3NpdGlvblswXSwgdGhpcy5fcG9zaXRpb25bMV0sIHRoaXMuX3Bvc2l0aW9uWzJdKTtcbn07XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGEgc291cmNlIGlzIG91dHNpZGUgb2YgYSByb29tLiBBdHRlbnVhdGUgZ2FpbiBnb2luZ1xuICogdG8gdGhlIHJlZmxlY3Rpb25zIGFuZCByZXZlcmIgd2hlbiB0aGUgc291cmNlIGlzIG91dHNpZGUgb2YgdGhlIHJvb20uXG4gKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgaW4gbWV0ZXJzLlxuICogQHJldHVybiB7TnVtYmVyfSBHYWluIChsaW5lYXIpIG9mIHNvdXJjZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlRGlzdGFuY2VPdXRzaWRlUm9vbShkaXN0YW5jZSkge1xuICAvLyBXZSBhcHBseSBhIGxpbmVhciByYW1wIGZyb20gMSB0byAwIGFzIHRoZSBzb3VyY2UgaXMgdXAgdG8gMW0gb3V0c2lkZS5cbiAgbGV0IGdhaW4gPSAxO1xuICBpZiAoZGlzdGFuY2UgPiBVdGlscy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgZ2FpbiA9IDEgLSBkaXN0YW5jZSAvIFV0aWxzLlNPVVJDRV9NQVhfT1VUU0lERV9ST09NX0RJU1RBTkNFO1xuXG4gICAgLy8gQ2xhbXAgZ2FpbiBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgZ2FpbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGdhaW4pKTtcbiAgfVxuICByZXR1cm4gZ2Fpbjtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdXJjZTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgRGlyZWN0aXZpdHkvb2NjbHVzaW9uIGZpbHRlci5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgRGlyZWN0aXZpdHlcbiAqIEBkZXNjcmlwdGlvbiBEaXJlY3Rpdml0eS9vY2NsdXNpb24gZmlsdGVyLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYWxwaGFcbiAqIERldGVybWluZXMgZGlyZWN0aXZpdHkgcGF0dGVybiAoMCB0byAxKS4gU2VlXG4gKiB7QGxpbmsgRGlyZWN0aXZpdHkjc2V0UGF0dGVybiBzZXRQYXR0ZXJufSBmb3IgbW9yZSBkZXRhaWxzLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBIERFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEF9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2hhcnBuZXNzXG4gKiBEZXRlcm1pbmVzIHRoZSBzaGFycG5lc3Mgb2YgdGhlIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDEgdG8gSW5mKS4gU2VlXG4gKiB7QGxpbmsgRGlyZWN0aXZpdHkjc2V0UGF0dGVybiBzZXRQYXR0ZXJufSBmb3IgbW9yZSBkZXRhaWxzLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU1xuICogREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1N9LlxuICovXG5mdW5jdGlvbiBEaXJlY3Rpdml0eShjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIERpcmVjdGl2aXR5XG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBEaXJlY3Rpdml0eVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxwaGEgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hbHBoYSA9IFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEE7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc2hhcnBuZXNzID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc2hhcnBuZXNzID0gVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1M7XG4gIH1cblxuICAvLyBDcmVhdGUgYXVkaW8gbm9kZS5cbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2xvd3Bhc3MgPSBjb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXG4gIC8vIEluaXRpYWxpemUgZmlsdGVyIGNvZWZmaWNpZW50cy5cbiAgdGhpcy5fbG93cGFzcy50eXBlID0gJ2xvd3Bhc3MnO1xuICB0aGlzLl9sb3dwYXNzLlEudmFsdWUgPSAwO1xuICB0aGlzLl9sb3dwYXNzLmZyZXF1ZW5jeS52YWx1ZSA9IGNvbnRleHQuc2FtcGxlUmF0ZSAqIDAuNTtcblxuICB0aGlzLl9jb3NUaGV0YSA9IDA7XG4gIHRoaXMuc2V0UGF0dGVybihvcHRpb25zLmFscGhhLCBvcHRpb25zLnNoYXJwbmVzcyk7XG5cbiAgLy8gSW5wdXQvT3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fbG93cGFzcztcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9sb3dwYXNzO1xufVxuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgZmlsdGVyIHVzaW5nIHRoZSBzb3VyY2UncyBmb3J3YXJkIG9yaWVudGF0aW9uIGFuZCB0aGUgbGlzdGVuZXInc1xuICogcG9zaXRpb24uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZm9yd2FyZCBUaGUgc291cmNlJ3MgZm9yd2FyZCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgc291cmNlIHRvIHRoZVxuICogbGlzdGVuZXIuXG4gKi9cbkRpcmVjdGl2aXR5LnByb3RvdHlwZS5jb21wdXRlQW5nbGUgPSBmdW5jdGlvbihmb3J3YXJkLCBkaXJlY3Rpb24pIHtcbiAgbGV0IGZvcndhcmROb3JtID0gVXRpbHMubm9ybWFsaXplVmVjdG9yKGZvcndhcmQpO1xuICBsZXQgZGlyZWN0aW9uTm9ybSA9IFV0aWxzLm5vcm1hbGl6ZVZlY3RvcihkaXJlY3Rpb24pO1xuICBsZXQgY29lZmYgPSAxO1xuICBpZiAodGhpcy5fYWxwaGEgPiBVdGlscy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgbGV0IGNvc1RoZXRhID0gZm9yd2FyZE5vcm1bMF0gKiBkaXJlY3Rpb25Ob3JtWzBdICtcbiAgICAgIGZvcndhcmROb3JtWzFdICogZGlyZWN0aW9uTm9ybVsxXSArIGZvcndhcmROb3JtWzJdICogZGlyZWN0aW9uTm9ybVsyXTtcbiAgICBjb2VmZiA9ICgxIC0gdGhpcy5fYWxwaGEpICsgdGhpcy5fYWxwaGEgKiBjb3NUaGV0YTtcbiAgICBjb2VmZiA9IE1hdGgucG93KE1hdGguYWJzKGNvZWZmKSwgdGhpcy5fc2hhcnBuZXNzKTtcbiAgfVxuICB0aGlzLl9sb3dwYXNzLmZyZXF1ZW5jeS52YWx1ZSA9IHRoaXMuX2NvbnRleHQuc2FtcGxlUmF0ZSAqIDAuNSAqIGNvZWZmO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBkaXJlY3Rpdml0eSBwYXR0ZXJuIChkZWZpbmVkIGJ5IGFscGhhKSwgd2hlcmUgMCBpcyBhblxuICogb21uaWRpcmVjdGlvbmFsIHBhdHRlcm4sIDEgaXMgYSBiaWRpcmVjdGlvbmFsIHBhdHRlcm4sIDAuNSBpcyBhIGNhcmRpb2RcbiAqIHBhdHRlcm4uIFRoZSBzaGFycG5lc3Mgb2YgdGhlIHBhdHRlcm4gaXMgaW5jcmVhc2VkIGV4cG9uZW5lbnRpYWxseS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYVxuICogRGV0ZXJtaW5lcyBkaXJlY3Rpdml0eSBwYXR0ZXJuICgwIHRvIDEpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNoYXJwbmVzc1xuICogRGV0ZXJtaW5lcyB0aGUgc2hhcnBuZXNzIG9mIHRoZSBkaXJlY3Rpdml0eSBwYXR0ZXJuICgxIHRvIEluZikuXG4gKiBERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU30uXG4gKi9cbkRpcmVjdGl2aXR5LnByb3RvdHlwZS5zZXRQYXR0ZXJuID0gZnVuY3Rpb24oYWxwaGEsIHNoYXJwbmVzcykge1xuICAvLyBDbGFtcCBhbmQgc2V0IHZhbHVlcy5cbiAgdGhpcy5fYWxwaGEgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBhbHBoYSkpO1xuICB0aGlzLl9zaGFycG5lc3MgPSBNYXRoLm1heCgxLCBzaGFycG5lc3MpO1xuXG4gIC8vIFVwZGF0ZSBhbmdsZSBjYWxjdWxhdGlvbiB1c2luZyBuZXcgdmFsdWVzLlxuICB0aGlzLmNvbXB1dGVBbmdsZShbdGhpcy5fY29zVGhldGEgKiB0aGlzLl9jb3NUaGV0YSwgMCwgMF0sIFsxLCAwLCAwXSk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGlyZWN0aXZpdHk7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIERpc3RhbmNlLWJhc2VkIGF0dGVudWF0aW9uIGZpbHRlci5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBBdHRlbnVhdGlvblxuICogQGRlc2NyaXB0aW9uIERpc3RhbmNlLWJhc2VkIGF0dGVudWF0aW9uIGZpbHRlci5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1pbkRpc3RhbmNlXG4gKiBNaW4uIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRSBERUZBVUxUX01JTl9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhEaXN0YW5jZVxuICogTWF4LiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0UgREVGQVVMVF9NQVhfRElTVEFOQ0V9LlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucm9sbG9mZlxuICogUm9sbG9mZiBtb2RlbCB0byB1c2UsIGNob3NlbiBmcm9tIG9wdGlvbnMgaW5cbiAqIHtAbGlua2NvZGUgVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgQVRURU5VQVRJT05fUk9MTE9GRlN9LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkYgREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGfS5cbiAqL1xuZnVuY3Rpb24gQXR0ZW51YXRpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogTWluLiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS5cbiAgICogQG1lbWJlciB7TnVtYmVyfSBtaW5EaXN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQXR0ZW51YXRpb25cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTWF4LiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS5cbiAgICogQG1lbWJlciB7TnVtYmVyfSBtYXhEaXN0YW5jZVxuICAgKiBAbWVtYmVyb2YgQXR0ZW51YXRpb25cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBBdHRlbnVhdGlvblxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgQXR0ZW51YXRpb25cbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLm1pbkRpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWluRGlzdGFuY2UgPSBVdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXhEaXN0YW5jZSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1heERpc3RhbmNlID0gVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0U7XG4gIH1cbiAgaWYgKG9wdGlvbnMucm9sbG9mZiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnJvbGxvZmYgPSBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkY7XG4gIH1cblxuICAvLyBBc3NpZ24gdmFsdWVzLlxuICB0aGlzLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5taW5EaXN0YW5jZTtcbiAgdGhpcy5tYXhEaXN0YW5jZSA9IG9wdGlvbnMubWF4RGlzdGFuY2U7XG4gIHRoaXMuc2V0Um9sbG9mZihvcHRpb25zLnJvbGxvZmYpO1xuXG4gIC8vIENyZWF0ZSBub2RlLlxuICB0aGlzLl9nYWluTm9kZSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgdG8gbWF4IGRpc3RhbmNlLlxuICB0aGlzLnNldERpc3RhbmNlKG9wdGlvbnMubWF4RGlzdGFuY2UpO1xuXG4gIC8vIElucHV0L091dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2dhaW5Ob2RlO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX2dhaW5Ob2RlO1xufVxuXG5cbi8qKlxuICogU2V0IGRpc3RhbmNlIGZyb20gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIChpbiBtZXRlcnMpLlxuICovXG5BdHRlbnVhdGlvbi5wcm90b3R5cGUuc2V0RGlzdGFuY2UgPSBmdW5jdGlvbihkaXN0YW5jZSkge1xuICBsZXQgZ2FpbiA9IDE7XG4gIGlmICh0aGlzLl9yb2xsb2ZmID09ICdsb2dhcml0aG1pYycpIHtcbiAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLm1heERpc3RhbmNlKSB7XG4gICAgICBnYWluID0gMDtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID4gdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgbGV0IHJhbmdlID0gdGhpcy5tYXhEaXN0YW5jZSAtIHRoaXMubWluRGlzdGFuY2U7XG4gICAgICBpZiAocmFuZ2UgPiBVdGlscy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGF0dGVudWF0aW9uIHZhbHVlIGJ5IHRoZSBsb2dhcml0aG1pYyBjdXJ2ZVxuICAgICAgICAvLyBcIjEgLyAoZCArIDEpXCIgd2l0aCBhbiBvZmZzZXQgb2YgfG1pbkRpc3RhbmNlfC5cbiAgICAgICAgbGV0IHJlbGF0aXZlRGlzdGFuY2UgPSBkaXN0YW5jZSAtIHRoaXMubWluRGlzdGFuY2U7XG4gICAgICAgIGxldCBhdHRlbnVhdGlvbiA9IDEgLyAocmVsYXRpdmVEaXN0YW5jZSArIDEpO1xuICAgICAgICBsZXQgYXR0ZW51YXRpb25NYXggPSAxIC8gKHJhbmdlICsgMSk7XG4gICAgICAgIGdhaW4gPSAoYXR0ZW51YXRpb24gLSBhdHRlbnVhdGlvbk1heCkgLyAoMSAtIGF0dGVudWF0aW9uTWF4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fcm9sbG9mZiA9PSAnbGluZWFyJykge1xuICAgIGlmIChkaXN0YW5jZSA+IHRoaXMubWF4RGlzdGFuY2UpIHtcbiAgICAgIGdhaW4gPSAwO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPiB0aGlzLm1pbkRpc3RhbmNlKSB7XG4gICAgICBsZXQgcmFuZ2UgPSB0aGlzLm1heERpc3RhbmNlIC0gdGhpcy5taW5EaXN0YW5jZTtcbiAgICAgIGlmIChyYW5nZSA+IFV0aWxzLkVQU0lMT05fRkxPQVQpIHtcbiAgICAgICAgZ2FpbiA9ICh0aGlzLm1heERpc3RhbmNlIC0gZGlzdGFuY2UpIC8gcmFuZ2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBnYWluO1xufTtcblxuXG4vKipcbiAqIFNldCByb2xsb2ZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGxvZmZcbiAqIFJvbGxvZmYgbW9kZWwgdG8gdXNlLCBjaG9zZW4gZnJvbSBvcHRpb25zIGluXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTIEFUVEVOVUFUSU9OX1JPTExPRkZTfS5cbiAqL1xuQXR0ZW51YXRpb24ucHJvdG90eXBlLnNldFJvbGxvZmYgPSBmdW5jdGlvbihyb2xsb2ZmKSB7XG4gIGxldCBpc1ZhbGlkTW9kZWwgPSB+VXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMuaW5kZXhPZihyb2xsb2ZmKTtcbiAgaWYgKHJvbGxvZmYgPT0gdW5kZWZpbmVkIHx8ICFpc1ZhbGlkTW9kZWwpIHtcbiAgICBpZiAoIWlzVmFsaWRNb2RlbCkge1xuICAgICAgVXRpbHMubG9nKCdJbnZhbGlkIHJvbGxvZmYgbW9kZWwgKFxcXCInICsgcm9sbG9mZiArXG4gICAgICAgICdcXFwiKS4gVXNpbmcgZGVmYXVsdDogXFxcIicgKyBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkYgKyAnXFxcIi4nKTtcbiAgICB9XG4gICAgcm9sbG9mZiA9IFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRjtcbiAgfSBlbHNlIHtcbiAgICByb2xsb2ZmID0gcm9sbG9mZi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgdGhpcy5fcm9sbG9mZiA9IHJvbGxvZmY7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQXR0ZW51YXRpb247XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIENvbXBsZXRlIHJvb20gbW9kZWwgd2l0aCBlYXJseSBhbmQgbGF0ZSByZWZsZWN0aW9ucy5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IExhdGVSZWZsZWN0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5jb25zdCBFYXJseVJlZmxlY3Rpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEdlbmVyYXRlIGFic29ycHRpb24gY29lZmZpY2llbnRzIGZyb20gbWF0ZXJpYWwgbmFtZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9nZXRDb2VmZmljaWVudHNGcm9tTWF0ZXJpYWxzKG1hdGVyaWFscykge1xuICAvLyBJbml0aWFsaXplIGNvZWZmaWNpZW50cyB0byB1c2UgZGVmYXVsdHMuXG4gIGxldCBjb2VmZmljaWVudHMgPSB7fTtcbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgY29lZmZpY2llbnRzW3Byb3BlcnR5XSA9IFV0aWxzLlJPT01fTUFURVJJQUxfQ09FRkZJQ0lFTlRTW1xuICAgICAgICBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTW3Byb3BlcnR5XV07XG4gICAgfVxuICB9XG5cbiAgLy8gU2FuaXRpemUgbWF0ZXJpYWxzLlxuICBpZiAobWF0ZXJpYWxzID09IHVuZGVmaW5lZCkge1xuICAgIG1hdGVyaWFscyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24obWF0ZXJpYWxzLCBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKTtcbiAgfVxuXG4gIC8vIEFzc2lnbiBjb2VmZmljaWVudHMgdXNpbmcgcHJvdmlkZWQgbWF0ZXJpYWxzLlxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmXG4gICAgICAgIG1hdGVyaWFscy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIGlmIChtYXRlcmlhbHNbcHJvcGVydHldIGluIFV0aWxzLlJPT01fTUFURVJJQUxfQ09FRkZJQ0lFTlRTKSB7XG4gICAgICAgIGNvZWZmaWNpZW50c1twcm9wZXJ0eV0gPVxuICAgICAgICAgIFV0aWxzLlJPT01fTUFURVJJQUxfQ09FRkZJQ0lFTlRTW21hdGVyaWFsc1twcm9wZXJ0eV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMubG9nKCdNYXRlcmlhbCBcXFwiJyArIG1hdGVyaWFsc1twcm9wZXJ0eV0gKyAnXFxcIiBvbiB3YWxsIFxcXCInICtcbiAgICAgICAgICBwcm9wZXJ0eSArICdcXFwiIG5vdCBmb3VuZC4gVXNpbmcgXFxcIicgK1xuICAgICAgICAgIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFNbcHJvcGVydHldICsgJ1xcXCIuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLmxvZygnV2FsbCBcXFwiJyArIHByb3BlcnR5ICsgJ1xcXCIgaXMgbm90IGRlZmluZWQuIERlZmF1bHQgdXNlZC4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZWZmaWNpZW50cztcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBjb2VmZmljaWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29lZmZpY2llbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9zYW5pdGl6ZUNvZWZmaWNpZW50cyhjb2VmZmljaWVudHMpIHtcbiAgaWYgKGNvZWZmaWNpZW50cyA9PSB1bmRlZmluZWQpIHtcbiAgICBjb2VmZmljaWVudHMgPSB7fTtcbiAgfVxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKSB7XG4gICAgaWYgKCEoY29lZmZpY2llbnRzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkpIHtcbiAgICAgIC8vIElmIGVsZW1lbnQgaXMgbm90IHByZXNlbnQsIHVzZSBkZWZhdWx0IGNvZWZmaWNpZW50cy5cbiAgICAgIGNvZWZmaWNpZW50c1twcm9wZXJ0eV0gPSBVdGlscy5ST09NX01BVEVSSUFMX0NPRUZGSUNJRU5UU1tcbiAgICAgICAgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMU1twcm9wZXJ0eV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29lZmZpY2llbnRzO1xufVxuXG4vKipcbiAqIFNhbml0aXplIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfc2FuaXRpemVEaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgaWYgKGRpbWVuc2lvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGltZW5zaW9ucyA9IHt9O1xuICB9XG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TKSB7XG4gICAgaWYgKCEoZGltZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpKSB7XG4gICAgICBkaW1lbnNpb25zW3Byb3BlcnR5XSA9IFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpbWVuc2lvbnM7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBmcmVxdWVuY3ktZGVwZW5kZW50IHJldmVyYiBkdXJhdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvZWZmaWNpZW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkT2ZTb3VuZFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIF9nZXREdXJhdGlvbnNGcm9tUHJvcGVydGllcyhkaW1lbnNpb25zLCBjb2VmZmljaWVudHMsIHNwZWVkT2ZTb3VuZCkge1xuICBsZXQgZHVyYXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUyk7XG5cbiAgLy8gU2FuaXRpemUgaW5wdXRzLlxuICBkaW1lbnNpb25zID0gX3Nhbml0aXplRGltZW5zaW9ucyhkaW1lbnNpb25zKTtcbiAgY29lZmZpY2llbnRzID0gX3Nhbml0aXplQ29lZmZpY2llbnRzKGNvZWZmaWNpZW50cyk7XG4gIGlmIChzcGVlZE9mU291bmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgc3BlZWRPZlNvdW5kID0gVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORDtcbiAgfVxuXG4gIC8vIEFjb3VzdGljIGNvbnN0YW50LlxuICBsZXQgayA9IFV0aWxzLlRXRU5UWV9GT1VSX0xPRzEwIC8gc3BlZWRPZlNvdW5kO1xuXG4gIC8vIENvbXB1dGUgdm9sdW1lLCBza2lwIGlmIHJvb20gaXMgbm90IHByZXNlbnQuXG4gIGxldCB2b2x1bWUgPSBkaW1lbnNpb25zLndpZHRoICogZGltZW5zaW9ucy5oZWlnaHQgKiBkaW1lbnNpb25zLmRlcHRoO1xuICBpZiAodm9sdW1lIDwgVXRpbHMuUk9PTV9NSU5fVk9MVU1FKSB7XG4gICAgcmV0dXJuIGR1cmF0aW9ucztcbiAgfVxuXG4gIC8vIFJvb20gc3VyZmFjZSBhcmVhLlxuICBsZXQgbGVmdFJpZ2h0QXJlYSA9IGRpbWVuc2lvbnMud2lkdGggKiBkaW1lbnNpb25zLmhlaWdodDtcbiAgbGV0IGZsb29yQ2VpbGluZ0FyZWEgPSBkaW1lbnNpb25zLndpZHRoICogZGltZW5zaW9ucy5kZXB0aDtcbiAgbGV0IGZyb250QmFja0FyZWEgPSBkaW1lbnNpb25zLmRlcHRoICogZGltZW5zaW9ucy5oZWlnaHQ7XG4gIGxldCB0b3RhbEFyZWEgPSAyICogKGxlZnRSaWdodEFyZWEgKyBmbG9vckNlaWxpbmdBcmVhICsgZnJvbnRCYWNrQXJlYSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFM7IGkrKykge1xuICAgIC8vIEVmZmVjdGl2ZSBhYnNvcnB0aXZlIGFyZWEuXG4gICAgbGV0IGFic29yYnRpb25BcmVhID1cbiAgICAgIChjb2VmZmljaWVudHMubGVmdFtpXSArIGNvZWZmaWNpZW50cy5yaWdodFtpXSkgKiBsZWZ0UmlnaHRBcmVhICtcbiAgICAgIChjb2VmZmljaWVudHMuZG93bltpXSArIGNvZWZmaWNpZW50cy51cFtpXSkgKiBmbG9vckNlaWxpbmdBcmVhICtcbiAgICAgIChjb2VmZmljaWVudHMuZnJvbnRbaV0gKyBjb2VmZmljaWVudHMuYmFja1tpXSkgKiBmcm9udEJhY2tBcmVhO1xuICAgIGxldCBtZWFuQWJzb3JidGlvbkFyZWEgPSBhYnNvcmJ0aW9uQXJlYSAvIHRvdGFsQXJlYTtcblxuICAgIC8vIENvbXB1dGUgcmV2ZXJiZXJhdGlvbiB1c2luZyBFeXJpbmcgZXF1YXRpb24gWzFdLlxuICAgIC8vIFsxXSBCZXJhbmVrLCBMZW8gTC4gXCJBbmFseXNpcyBvZiBTYWJpbmUgYW5kIEV5cmluZyBlcXVhdGlvbnMgYW5kIHRoZWlyXG4gICAgLy8gICAgIGFwcGxpY2F0aW9uIHRvIGNvbmNlcnQgaGFsbCBhdWRpZW5jZSBhbmQgY2hhaXIgYWJzb3JwdGlvbi5cIiBUaGVcbiAgICAvLyAgICAgSm91cm5hbCBvZiB0aGUgQWNvdXN0aWNhbCBTb2NpZXR5IG9mIEFtZXJpY2EsIFZvbC4gMTIwLCBOby4gMy5cbiAgICAvLyAgICAgKDIwMDYpLCBwcC4gMTM5OS0xMzk5LlxuICAgIGR1cmF0aW9uc1tpXSA9IFV0aWxzLlJPT01fRVlSSU5HX0NPUlJFQ1RJT05fQ09FRkZJQ0lFTlQgKiBrICogdm9sdW1lIC9cbiAgICAgICgtdG90YWxBcmVhICogTWF0aC5sb2coMSAtIG1lYW5BYnNvcmJ0aW9uQXJlYSkgKyA0ICpcbiAgICAgIFV0aWxzLlJPT01fQUlSX0FCU09SUFRJT05fQ09FRkZJQ0lFTlRTW2ldICogdm9sdW1lKTtcbiAgfVxuICByZXR1cm4gZHVyYXRpb25zO1xufVxuXG5cbi8qKlxuICogQ29tcHV0ZSByZWZsZWN0aW9uIGNvZWZmaWNpZW50cyBmcm9tIGFic29ycHRpb24gY29lZmZpY2llbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGFic29ycHRpb25Db2VmZmljaWVudHNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2NvbXB1dGVSZWZsZWN0aW9uQ29lZmZpY2llbnRzKGFic29ycHRpb25Db2VmZmljaWVudHMpIHtcbiAgbGV0IHJlZmxlY3Rpb25Db2VmZmljaWVudHMgPSBbXTtcbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gICAgICAgIC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIC8vIENvbXB1dGUgYXZlcmFnZSBhYnNvcnB0aW9uIGNvZWZmaWNpZW50IChwZXIgd2FsbCkuXG4gICAgICByZWZsZWN0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XSA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IFV0aWxzLk5VTUJFUl9SRUZMRUNUSU9OX0FWRVJBR0lOR19CQU5EUzsgaisrKSB7XG4gICAgICAgIGxldCBiYW5kSW5kZXggPSBqICsgVXRpbHMuUk9PTV9TVEFSVElOR19BVkVSQUdJTkdfQkFORDtcbiAgICAgICAgcmVmbGVjdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV0gKz1cbiAgICAgICAgICBhYnNvcnB0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XVtiYW5kSW5kZXhdO1xuICAgICAgfVxuICAgICAgcmVmbGVjdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV0gLz1cbiAgICAgICAgVXRpbHMuTlVNQkVSX1JFRkxFQ1RJT05fQVZFUkFHSU5HX0JBTkRTO1xuXG4gICAgICAvLyBDb252ZXJ0IGFic29ycHRpb24gY29lZmZpY2llbnQgdG8gcmVmbGVjdGlvbiBjb2VmZmljaWVudC5cbiAgICAgIHJlZmxlY3Rpb25Db2VmZmljaWVudHNbcHJvcGVydHldID1cbiAgICAgICAgTWF0aC5zcXJ0KDEgLSByZWZsZWN0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZsZWN0aW9uQ29lZmZpY2llbnRzO1xufVxuXG5cbi8qKlxuICogQGNsYXNzIFJvb21cbiAqIEBkZXNjcmlwdGlvbiBNb2RlbCB0aGF0IG1hbmFnZXMgZWFybHkgYW5kIGxhdGUgcmVmbGVjdGlvbnMgdXNpbmcgYWNvdXN0aWNcbiAqIHByb3BlcnRpZXMgYW5kIGxpc3RlbmVyIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGEgcmVjdGFuZ3VsYXIgcm9vbS5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb25cbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS4gRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGltZW5zaW9ucyBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TIERFRkFVTFRfUk9PTV9ESU1FTlNJT05TfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLm1hdGVyaWFscyBOYW1lZCBhY291c3RpYyBtYXRlcmlhbHMgcGVyIHdhbGwuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMgREVGQVVMVF9ST09NX01BVEVSSUFMU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zcGVlZE9mU291bmRcbiAqIChpbiBtZXRlcnMvc2Vjb25kKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORCBERUZBVUxUX1NQRUVEX09GX1NPVU5EfS5cbiAqL1xuZnVuY3Rpb24gUm9vbShjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBFYXJseVJlZmxlY3Rpb25zIHtAbGluayBFYXJseVJlZmxlY3Rpb25zIEVhcmx5UmVmbGVjdGlvbnN9IHN1Ym1vZHVsZS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBlYXJseVxuICAgKiBAbWVtYmVyb2YgUm9vbVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBMYXRlUmVmbGVjdGlvbnMge0BsaW5rIExhdGVSZWZsZWN0aW9ucyBMYXRlUmVmbGVjdGlvbnN9IHN1Ym1vZHVsZS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBsYXRlXG4gICAqIEBtZW1iZXJvZiBSb29tXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIFJvb21cbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID0gVXRpbHMuREVGQVVMVF9QT1NJVElPTi5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLmRpbWVuc2lvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5kaW1lbnNpb25zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmRpbWVuc2lvbnMsIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TKTtcbiAgfVxuICBpZiAob3B0aW9ucy5tYXRlcmlhbHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5tYXRlcmlhbHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMubWF0ZXJpYWxzLCBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zcGVlZE9mU291bmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zcGVlZE9mU291bmQgPSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgcm9vbS1wcm9wZXJ0aWVzLXJlbGF0ZWQgYXJndW1lbnRzLlxuICBvcHRpb25zLmRpbWVuc2lvbnMgPSBfc2FuaXRpemVEaW1lbnNpb25zKG9wdGlvbnMuZGltZW5zaW9ucyk7XG4gIGxldCBhYnNvcnB0aW9uQ29lZmZpY2llbnRzID0gX2dldENvZWZmaWNpZW50c0Zyb21NYXRlcmlhbHMob3B0aW9ucy5tYXRlcmlhbHMpO1xuICBsZXQgcmVmbGVjdGlvbkNvZWZmaWNpZW50cyA9XG4gICAgX2NvbXB1dGVSZWZsZWN0aW9uQ29lZmZpY2llbnRzKGFic29ycHRpb25Db2VmZmljaWVudHMpO1xuICBsZXQgZHVyYXRpb25zID0gX2dldER1cmF0aW9uc0Zyb21Qcm9wZXJ0aWVzKG9wdGlvbnMuZGltZW5zaW9ucyxcbiAgICBhYnNvcnB0aW9uQ29lZmZpY2llbnRzLCBvcHRpb25zLnNwZWVkT2ZTb3VuZCk7XG5cbiAgLy8gQ29uc3RydWN0IHN1Ym1vZHVsZXMgZm9yIGVhcmx5IGFuZCBsYXRlIHJlZmxlY3Rpb25zLlxuICB0aGlzLmVhcmx5ID0gbmV3IEVhcmx5UmVmbGVjdGlvbnMoY29udGV4dCwge1xuICAgIGRpbWVuc2lvbnM6IG9wdGlvbnMuZGltZW5zaW9ucyxcbiAgICBjb2VmZmljaWVudHM6IHJlZmxlY3Rpb25Db2VmZmljaWVudHMsXG4gICAgc3BlZWRPZlNvdW5kOiBvcHRpb25zLnNwZWVkT2ZTb3VuZCxcbiAgICBsaXN0ZW5lclBvc2l0aW9uOiBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24sXG4gIH0pO1xuICB0aGlzLmxhdGUgPSBuZXcgTGF0ZVJlZmxlY3Rpb25zKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvbnM6IGR1cmF0aW9ucyxcbiAgfSk7XG5cbiAgdGhpcy5zcGVlZE9mU291bmQgPSBvcHRpb25zLnNwZWVkT2ZTb3VuZDtcblxuICAvLyBDb25zdHJ1Y3QgYXV4aWxsYXJ5IGF1ZGlvIG5vZGVzLlxuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLmVhcmx5Lm91dHB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgdGhpcy5fbWVyZ2VyID0gY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDQpO1xuXG4gIHRoaXMubGF0ZS5vdXRwdXQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuICB0aGlzLl9tZXJnZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJvb20ncyBkaW1lbnNpb25zIGFuZCB3YWxsIG1hdGVyaWFscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgREVGQVVMVF9ST09NX0RJTUVOU0lPTlN9LlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFscyBOYW1lZCBhY291c3RpYyBtYXRlcmlhbHMgcGVyIHdhbGwuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMgREVGQVVMVF9ST09NX01BVEVSSUFMU30uXG4gKi9cblJvb20ucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbihkaW1lbnNpb25zLCBtYXRlcmlhbHMpIHtcbiAgLy8gQ29tcHV0ZSBsYXRlIHJlc3BvbnNlLlxuICBsZXQgYWJzb3JwdGlvbkNvZWZmaWNpZW50cyA9IF9nZXRDb2VmZmljaWVudHNGcm9tTWF0ZXJpYWxzKG1hdGVyaWFscyk7XG4gIGxldCBkdXJhdGlvbnMgPSBfZ2V0RHVyYXRpb25zRnJvbVByb3BlcnRpZXMoZGltZW5zaW9ucyxcbiAgICBhYnNvcnB0aW9uQ29lZmZpY2llbnRzLCB0aGlzLnNwZWVkT2ZTb3VuZCk7XG4gIHRoaXMubGF0ZS5zZXREdXJhdGlvbnMoZHVyYXRpb25zKTtcblxuICAvLyBDb21wdXRlIGVhcmx5IHJlc3BvbnNlLlxuICB0aGlzLmVhcmx5LnNwZWVkT2ZTb3VuZCA9IHRoaXMuc3BlZWRPZlNvdW5kO1xuICBsZXQgcmVmbGVjdGlvbkNvZWZmaWNpZW50cyA9XG4gICAgX2NvbXB1dGVSZWZsZWN0aW9uQ29lZmZpY2llbnRzKGFic29ycHRpb25Db2VmZmljaWVudHMpO1xuICB0aGlzLmVhcmx5LnNldFJvb21Qcm9wZXJ0aWVzKGRpbWVuc2lvbnMsIHJlZmxlY3Rpb25Db2VmZmljaWVudHMpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5Sb29tLnByb3RvdHlwZS5zZXRMaXN0ZW5lclBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICB0aGlzLmVhcmx5LnNwZWVkT2ZTb3VuZCA9IHRoaXMuc3BlZWRPZlNvdW5kO1xuICB0aGlzLmVhcmx5LnNldExpc3RlbmVyUG9zaXRpb24oeCwgeSwgeik7XG5cbiAgLy8gRGlzYWJsZSByb29tIGVmZmVjdHMgaWYgdGhlIGxpc3RlbmVyIGlzIG91dHNpZGUgdGhlIHJvb20gYm91bmRhcmllcy5cbiAgbGV0IGRpc3RhbmNlID0gdGhpcy5nZXREaXN0YW5jZU91dHNpZGVSb29tKHgsIHksIHopO1xuICBsZXQgZ2FpbiA9IDE7XG4gIGlmIChkaXN0YW5jZSA+IFV0aWxzLkVQU0lMT05fRkxPQVQpIHtcbiAgICBnYWluID0gMSAtIGRpc3RhbmNlIC8gVXRpbHMuTElTVEVORVJfTUFYX09VVFNJREVfUk9PTV9ESVNUQU5DRTtcblxuICAgIC8vIENsYW1wIGdhaW4gYmV0d2VlbiAwIGFuZCAxLlxuICAgIGdhaW4gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBnYWluKSk7XG4gIH1cbiAgdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSA9IGdhaW47XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZSBkaXN0YW5jZSBvdXRzaWRlIHJvb20gb2YgcHJvdmlkZWQgcG9zaXRpb24gKGluIG1ldGVycykuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBEaXN0YW5jZSBvdXRzaWRlIHJvb20gKGluIG1ldGVycykuIFJldHVybnMgMCBpZiBpbnNpZGUgcm9vbS5cbiAqL1xuUm9vbS5wcm90b3R5cGUuZ2V0RGlzdGFuY2VPdXRzaWRlUm9vbSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgbGV0IGR4ID0gTWF0aC5tYXgoMCwgLXRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLndpZHRoIC0geCxcbiAgICB4IC0gdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMud2lkdGgpO1xuICAgIGxldCBkeSA9IE1hdGgubWF4KDAsIC10aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy5oZWlnaHQgLSB5LFxuICAgIHkgLSB0aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIGxldCBkeiA9IE1hdGgubWF4KDAsIC10aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy5kZXB0aCAtIHosXG4gICAgeiAtIHRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLmRlcHRoKTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJvb207XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIExhdGUgcmV2ZXJiZXJhdGlvbiBmaWx0ZXIgZm9yIEFtYmlzb25pYyBjb250ZW50LlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBMYXRlUmVmbGVjdGlvbnNcbiAqIEBkZXNjcmlwdGlvbiBMYXRlLXJlZmxlY3Rpb25zIHJldmVyYmVyYXRpb24gZmlsdGVyIGZvciBBbWJpc29uaWMgY29udGVudC5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuZHVyYXRpb25zXG4gKiBNdWx0aWJhbmQgUlQ2MCBkdXJhdGlvbnMgKGluIHNlY29uZHMpIGZvciBlYWNoIGZyZXF1ZW5jeSBiYW5kLCBsaXN0ZWQgYXNcbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTXG4gKiBGUkVRVURFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EU0VOQ1lfQkFORFN9LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9EVVJBVElPTlMgREVGQVVMVF9SRVZFUkJfRFVSQVRJT05TfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnByZWRlbGF5IFByZS1kZWxheSAoaW4gbWlsbGlzZWNvbmRzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfUFJFREVMQVkgREVGQVVMVF9SRVZFUkJfUFJFREVMQVl9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZ2FpbiBPdXRwdXQgZ2FpbiAobGluZWFyKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfR0FJTiBERUZBVUxUX1JFVkVSQl9HQUlOfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmJhbmR3aWR0aCBCYW5kd2lkdGggKGluIG9jdGF2ZXMpIGZvciBlYWNoIGZyZXF1ZW5jeVxuICogYmFuZC4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfQkFORFdJRFRIIERFRkFVTFRfUkVWRVJCX0JBTkRXSURUSH0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy50YWlsb25zZXQgTGVuZ3RoIChpbiBtaWxsaXNlY29uZHMpIG9mIGltcHVsc2VcbiAqIHJlc3BvbnNlIHRvIGFwcGx5IGEgaGFsZi1IYW5uIHdpbmRvdy4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfVEFJTF9PTlNFVCBERUZBVUxUX1JFVkVSQl9UQUlMX09OU0VUfS5cbiAqL1xuZnVuY3Rpb24gTGF0ZVJlZmxlY3Rpb25zKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgTGF0ZVJlZmxlY3Rpb25zXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBMYXRlUmVmbGVjdGlvbnNcbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmR1cmF0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmR1cmF0aW9ucyA9IFV0aWxzLkRFRkFVTFRfUkVWRVJCX0RVUkFUSU9OUy5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLnByZWRlbGF5ID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMucHJlZGVsYXkgPSBVdGlscy5ERUZBVUxUX1JFVkVSQl9QUkVERUxBWTtcbiAgfVxuICBpZiAob3B0aW9ucy5nYWluID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZ2FpbiA9IFV0aWxzLkRFRkFVTFRfUkVWRVJCX0dBSU47XG4gIH1cbiAgaWYgKG9wdGlvbnMuYmFuZHdpZHRoID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYmFuZHdpZHRoID0gVXRpbHMuREVGQVVMVF9SRVZFUkJfQkFORFdJRFRIO1xuICB9XG4gIGlmIChvcHRpb25zLnRhaWxvbnNldCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnRhaWxvbnNldCA9IFV0aWxzLkRFRkFVTFRfUkVWRVJCX1RBSUxfT05TRVQ7XG4gIH1cblxuICAvLyBBc3NpZ24gcHJlLWNvbXB1dGVkIHZhcmlhYmxlcy5cbiAgbGV0IGRlbGF5U2VjcyA9IG9wdGlvbnMucHJlZGVsYXkgLyAxMDAwO1xuICB0aGlzLl9iYW5kd2lkdGhDb2VmZiA9IG9wdGlvbnMuYmFuZHdpZHRoICogVXRpbHMuTE9HMl9ESVYyO1xuICB0aGlzLl90YWlsb25zZXRTYW1wbGVzID0gb3B0aW9ucy50YWlsb25zZXQgLyAxMDAwO1xuXG4gIC8vIENyZWF0ZSBub2Rlcy5cbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuaW5wdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fcHJlZGVsYXkgPSBjb250ZXh0LmNyZWF0ZURlbGF5KGRlbGF5U2Vjcyk7XG4gIHRoaXMuX2NvbnZvbHZlciA9IGNvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gU2V0IHJldmVyYiBhdHRlbnVhdGlvbi5cbiAgdGhpcy5vdXRwdXQuZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuZ2FpbjtcblxuICAvLyBEaXNhYmxlIG5vcm1hbGl6YXRpb24uXG4gIHRoaXMuX2NvbnZvbHZlci5ub3JtYWxpemUgPSBmYWxzZTtcblxuICAvLyBDb25uZWN0IG5vZGVzLlxuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fcHJlZGVsYXkpO1xuICB0aGlzLl9wcmVkZWxheS5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcik7XG4gIHRoaXMuX2NvbnZvbHZlci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblxuICAvLyBDb21wdXRlIElSIHVzaW5nIFJUNjAgdmFsdWVzLlxuICB0aGlzLnNldER1cmF0aW9ucyhvcHRpb25zLmR1cmF0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBSZS1jb21wdXRlIGEgbmV3IGltcHVsc2UgcmVzcG9uc2UgYnkgcHJvdmlkaW5nIE11bHRpYmFuZCBSVDYwIGR1cmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IGR1cmF0aW9uc1xuICogTXVsdGliYW5kIFJUNjAgZHVyYXRpb25zIChpbiBzZWNvbmRzKSBmb3IgZWFjaCBmcmVxdWVuY3kgYmFuZCwgbGlzdGVkIGFzXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EU1xuICogREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTfS5cbiAqL1xuTGF0ZVJlZmxlY3Rpb25zLnByb3RvdHlwZS5zZXREdXJhdGlvbnMgPSBmdW5jdGlvbihkdXJhdGlvbnMpIHtcbiAgaWYgKGR1cmF0aW9ucy5sZW5ndGggIT09IFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTKSB7XG4gICAgVXRpbHMubG9nKCdXYXJuaW5nOiBpbnZhbGlkIG51bWJlciBvZiBSVDYwIHZhbHVlcyBwcm92aWRlZCB0byByZXZlcmIuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ29tcHV0ZSBpbXB1bHNlIHJlc3BvbnNlLlxuICBsZXQgZHVyYXRpb25zU2FtcGxlcyA9XG4gICAgbmV3IEZsb2F0MzJBcnJheShVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUyk7XG4gICAgbGV0IHNhbXBsZVJhdGUgPSB0aGlzLl9jb250ZXh0LnNhbXBsZVJhdGU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBDbGFtcCB3aXRoaW4gc3VpdGFibGUgcmFuZ2UuXG4gICAgZHVyYXRpb25zW2ldID1cbiAgICAgIE1hdGgubWF4KDAsIE1hdGgubWluKFV0aWxzLkRFRkFVTFRfUkVWRVJCX01BWF9EVVJBVElPTiwgZHVyYXRpb25zW2ldKSk7XG5cbiAgICAvLyBDb252ZXJ0IHNlY29uZHMgdG8gc2FtcGxlcy5cbiAgICBkdXJhdGlvbnNTYW1wbGVzW2ldID0gTWF0aC5yb3VuZChkdXJhdGlvbnNbaV0gKiBzYW1wbGVSYXRlICpcbiAgICAgIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0RVUkFUSU9OX01VTFRJUExJRVIpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBtYXggUlQ2MCBsZW5ndGggaW4gc2FtcGxlcy5cbiAgbGV0IGR1cmF0aW9uc1NhbXBsZXNNYXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGR1cmF0aW9uc1NhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZHVyYXRpb25zU2FtcGxlc1tpXSA+IGR1cmF0aW9uc1NhbXBsZXNNYXgpIHtcbiAgICAgIGR1cmF0aW9uc1NhbXBsZXNNYXggPSBkdXJhdGlvbnNTYW1wbGVzW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNraXAgdGhpcyBzdGVwIGlmIHRoZXJlIGlzIG5vIHJldmVyYmVyYXRpb24gdG8gY29tcHV0ZS5cbiAgaWYgKGR1cmF0aW9uc1NhbXBsZXNNYXggPCAxKSB7XG4gICAgZHVyYXRpb25zU2FtcGxlc01heCA9IDE7XG4gIH1cblxuICAvLyBDcmVhdGUgaW1wdWxzZSByZXNwb25zZSBidWZmZXIuXG4gIGxldCBidWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCBkdXJhdGlvbnNTYW1wbGVzTWF4LCBzYW1wbGVSYXRlKTtcbiAgbGV0IGJ1ZmZlckRhdGEgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG5cbiAgLy8gQ3JlYXRlIG5vaXNlIHNpZ25hbCAoY29tcHV0ZWQgb25jZSwgcmVmZXJlbmNlZCBpbiBlYWNoIGJhbmQncyByb3V0aW5lKS5cbiAgbGV0IG5vaXNlU2lnbmFsID0gbmV3IEZsb2F0MzJBcnJheShkdXJhdGlvbnNTYW1wbGVzTWF4KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbnNTYW1wbGVzTWF4OyBpKyspIHtcbiAgICBub2lzZVNpZ25hbFtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGRlY2F5IHJhdGUgcGVyLWJhbmQgYW5kIGZpbHRlciB0aGUgZGVjYXlpbmcgbm9pc2Ugc2lnbmFsLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTOyBpKyspIHtcbiAgICAvLyBDb21wdXRlIGRlY2F5IHJhdGUuXG4gICAgbGV0IGRlY2F5UmF0ZSA9IC1VdGlscy5MT0cxMDAwIC8gZHVyYXRpb25zU2FtcGxlc1tpXTtcblxuICAgIC8vIENvbnN0cnVjdCBhIHN0YW5kYXJkIG9uZS16ZXJvLCB0d28tcG9sZSBiYW5kcGFzcyBmaWx0ZXI6XG4gICAgLy8gSCh6KSA9IChiMCAqIHpeMCArIGIxICogel4tMSArIGIyICogel4tMikgLyAoMSArIGExICogel4tMSArIGEyICogel4tMilcbiAgICBsZXQgb21lZ2EgPSBVdGlscy5UV09fUEkgKlxuICAgICAgVXRpbHMuREVGQVVMVF9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTW2ldIC8gc2FtcGxlUmF0ZTtcbiAgICBsZXQgc2luT21lZ2EgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgbGV0IGFscGhhID0gc2luT21lZ2EgKiBNYXRoLnNpbmgodGhpcy5fYmFuZHdpZHRoQ29lZmYgKiBvbWVnYSAvIHNpbk9tZWdhKTtcbiAgICBsZXQgYTBDb2VmZlJlY2lwcm9jYWwgPSAxIC8gKDEgKyBhbHBoYSk7XG4gICAgbGV0IGIwQ29lZmYgPSBhbHBoYSAqIGEwQ29lZmZSZWNpcHJvY2FsO1xuICAgIGxldCBhMUNvZWZmID0gLTIgKiBNYXRoLmNvcyhvbWVnYSkgKiBhMENvZWZmUmVjaXByb2NhbDtcbiAgICBsZXQgYTJDb2VmZiA9ICgxIC0gYWxwaGEpICogYTBDb2VmZlJlY2lwcm9jYWw7XG5cbiAgICAvLyBXZSBvcHRpbWl6ZSBzaW5jZSBiMiA9IC1iMCwgYjEgPSAwLlxuICAgIC8vIFVwZGF0ZSBlcXVhdGlvbiBmb3IgdHdvLXBvbGUgYmFuZHBhc3MgZmlsdGVyOlxuICAgIC8vICAgdVtuXSA9IHhbbl0gLSBhMSAqIHhbbi0xXSAtIGEyICogeFtuLTJdXG4gICAgLy8gICB5W25dID0gYjAgKiAodVtuXSAtIHVbbi0yXSlcbiAgICBsZXQgdW0xID0gMDtcbiAgICBsZXQgdW0yID0gMDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGR1cmF0aW9uc1NhbXBsZXNbaV07IGorKykge1xuICAgICAgLy8gRXhwb25lbnRpYWxseS1kZWNheWluZyB3aGl0ZSBub2lzZS5cbiAgICAgIGxldCB4ID0gbm9pc2VTaWduYWxbal0gKiBNYXRoLmV4cChkZWNheVJhdGUgKiBqKTtcblxuICAgICAgLy8gRmlsdGVyIHNpZ25hbCB3aXRoIGJhbmRwYXNzIGZpbHRlciBhbmQgYWRkIHRvIG91dHB1dC5cbiAgICAgIGxldCB1ID0geCAtIGExQ29lZmYgKiB1bTEgLSBhMkNvZWZmICogdW0yO1xuICAgICAgYnVmZmVyRGF0YVtqXSArPSBiMENvZWZmICogKHUgLSB1bTIpO1xuXG4gICAgICAvLyBVcGRhdGUgY29lZmZpY2llbnRzLlxuICAgICAgdW0yID0gdW0xO1xuICAgICAgdW0xID0gdTtcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIGFwcGx5IGhhbGYgb2YgYSBIYW5uIHdpbmRvdyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAvLyBpbXB1bHNlIHJlc3BvbnNlLlxuICBsZXQgaGFsZkhhbm5MZW5ndGggPVxuICAgIE1hdGgucm91bmQodGhpcy5fdGFpbG9uc2V0U2FtcGxlcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oYnVmZmVyRGF0YS5sZW5ndGgsIGhhbGZIYW5uTGVuZ3RoKTsgaSsrKSB7XG4gICAgbGV0IGhhbGZIYW5uID1cbiAgICAgIDAuNSAqICgxIC0gTWF0aC5jb3MoVXRpbHMuVFdPX1BJICogaSAvICgyICogaGFsZkhhbm5MZW5ndGggLSAxKSkpO1xuICAgICAgYnVmZmVyRGF0YVtpXSAqPSBoYWxmSGFubjtcbiAgfVxuICB0aGlzLl9jb252b2x2ZXIuYnVmZmVyID0gYnVmZmVyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExhdGVSZWZsZWN0aW9ucztcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUmF5LXRyYWNpbmctYmFzZWQgZWFybHkgcmVmbGVjdGlvbnMgbW9kZWwuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIEVhcmx5UmVmbGVjdGlvbnNcbiAqIEBkZXNjcmlwdGlvbiBSYXktdHJhY2luZy1iYXNlZCBlYXJseSByZWZsZWN0aW9ucyBtb2RlbC5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRpbWVuc2lvbnNcbiAqIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgREVGQVVMVF9ST09NX0RJTUVOU0lPTlN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29lZmZpY2llbnRzXG4gKiBGcmVxdWVuY3ktaW5kZXBlbmRlbnQgcmVmbGVjdGlvbiBjb2VmZnMgcGVyIHdhbGwuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAqIERFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRPZlNvdW5kXG4gKiAoaW4gbWV0ZXJzIC8gc2Vjb25kKS4gRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EXG4gKiBERUZBVUxUX1NQRUVEX09GX1NPVU5EfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb25cbiAqIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICovXG5mdW5jdGlvbiBFYXJseVJlZmxlY3Rpb25zKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIFRoZSByb29tJ3Mgc3BlZWQgb2Ygc291bmQgKGluIG1ldGVycy9zZWNvbmQpLlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IHNwZWVkT2ZTb3VuZFxuICAgKiBAbWVtYmVyb2YgRWFybHlSZWZsZWN0aW9uc1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIEVhcmx5UmVmbGVjdGlvbnNcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogRmlyc3Qtb3JkZXIgYW1iaXNvbmljICg0LWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgRWFybHlSZWZsZWN0aW9uc1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3BlZWRPZlNvdW5kID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc3BlZWRPZlNvdW5kID0gVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORDtcbiAgfVxuICBpZiAob3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9IFV0aWxzLkRFRkFVTFRfUE9TSVRJT04uc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jb2VmZmljaWVudHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5jb2VmZmljaWVudHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuY29lZmZpY2llbnRzLCBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKTtcbiAgfVxuXG4gIC8vIEFzc2lnbiByb29tJ3Mgc3BlZWQgb2Ygc291bmQuXG4gIHRoaXMuc3BlZWRPZlNvdW5kID0gb3B0aW9ucy5zcGVlZE9mU291bmQ7XG5cbiAgLy8gQ3JlYXRlIG5vZGVzLlxuICB0aGlzLmlucHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2xvd3Bhc3MgPSBjb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICB0aGlzLl9kZWxheXMgPSB7fTtcbiAgdGhpcy5fZ2FpbnMgPSB7fTsgLy8gZ2FpblBlcldhbGwgPSAoUmVmbGVjdGlvbkNvZWZmIC8gQXR0ZW51YXRpb24pXG4gIHRoaXMuX2ludmVydGVycyA9IHt9OyAvLyAzIG9mIHRoZXNlIGFyZSBuZWVkZWQgZm9yIHJpZ2h0L2JhY2svZG93biB3YWxscy5cbiAgdGhpcy5fbWVyZ2VyID0gY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDQpOyAvLyBGaXJzdC1vcmRlciBlbmNvZGluZyBvbmx5LlxuXG4gIC8vIENvbm5lY3QgYXVkaW8gZ3JhcGggZm9yIGVhY2ggd2FsbCByZWZsZWN0aW9uLlxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAgICAgICAgLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgdGhpcy5fZGVsYXlzW3Byb3BlcnR5XSA9XG4gICAgICAgIGNvbnRleHQuY3JlYXRlRGVsYXkoVXRpbHMuTUFYX0RVUkFUSU9OKTtcbiAgICAgIHRoaXMuX2dhaW5zW3Byb3BlcnR5XSA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9pbnZlcnRlcnMucmlnaHQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmRvd24gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmJhY2sgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBJbml0aWFsaXplIGxvd3Bhc3MgZmlsdGVyLlxuICB0aGlzLl9sb3dwYXNzLnR5cGUgPSAnbG93cGFzcyc7XG4gIHRoaXMuX2xvd3Bhc3MuZnJlcXVlbmN5LnZhbHVlID0gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NVVE9GRl9GUkVRVUVOQ1k7XG4gIHRoaXMuX2xvd3Bhc3MuUS52YWx1ZSA9IDA7XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbmNvZGVyIGRpcmVjdGlvbnMsIHNldCBkZWxheSB0aW1lcyBhbmQgZ2FpbnMgdG8gMC5cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gICAgICAgIC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIHRoaXMuX2RlbGF5c1twcm9wZXJ0eV0uZGVsYXlUaW1lLnZhbHVlID0gMDtcbiAgICAgIHRoaXMuX2dhaW5zW3Byb3BlcnR5XS5nYWluLnZhbHVlID0gMDtcbiAgICB9XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGludmVydGVycyBmb3Igb3Bwb3NpdGUgd2FsbHMgKCdyaWdodCcsICdkb3duJywgJ2JhY2snIG9ubHkpLlxuICB0aGlzLl9pbnZlcnRlcnMucmlnaHQuZ2Fpbi52YWx1ZSA9IC0xO1xuICB0aGlzLl9pbnZlcnRlcnMuZG93bi5nYWluLnZhbHVlID0gLTE7XG4gIHRoaXMuX2ludmVydGVycy5iYWNrLmdhaW4udmFsdWUgPSAtMTtcblxuICAvLyBDb25uZWN0IG5vZGVzLlxuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fbG93cGFzcyk7XG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICAgICAgICAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICB0aGlzLl9sb3dwYXNzLmNvbm5lY3QodGhpcy5fZGVsYXlzW3Byb3BlcnR5XSk7XG4gICAgICB0aGlzLl9kZWxheXNbcHJvcGVydHldLmNvbm5lY3QodGhpcy5fZ2FpbnNbcHJvcGVydHldKTtcbiAgICAgIHRoaXMuX2dhaW5zW3Byb3BlcnR5XS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29ubmVjdCBnYWlucyB0byBhbWJpc29uaWMgY2hhbm5lbCBvdXRwdXQuXG4gIC8vIExlZnQ6IFsxIDEgMCAwXVxuICAvLyBSaWdodDogWzEgLTEgMCAwXVxuICAvLyBVcDogWzEgMCAxIDBdXG4gIC8vIERvd246IFsxIDAgLTEgMF1cbiAgLy8gRnJvbnQ6IFsxIDAgMCAxXVxuICAvLyBCYWNrOiBbMSAwIDAgLTFdXG4gIHRoaXMuX2dhaW5zLmxlZnQuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuXG4gIHRoaXMuX2dhaW5zLnJpZ2h0LmNvbm5lY3QodGhpcy5faW52ZXJ0ZXJzLnJpZ2h0KTtcbiAgdGhpcy5faW52ZXJ0ZXJzLnJpZ2h0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblxuICB0aGlzLl9nYWlucy51cC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMik7XG5cbiAgdGhpcy5fZ2FpbnMuZG93bi5jb25uZWN0KHRoaXMuX2ludmVydGVycy5kb3duKTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmRvd24uY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDIpO1xuXG4gIHRoaXMuX2dhaW5zLmZyb250LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAzKTtcblxuICB0aGlzLl9nYWlucy5iYWNrLmNvbm5lY3QodGhpcy5faW52ZXJ0ZXJzLmJhY2spO1xuICB0aGlzLl9pbnZlcnRlcnMuYmFjay5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMyk7XG4gIHRoaXMuX21lcmdlci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblxuICAvLyBJbml0aWFsaXplLlxuICB0aGlzLl9saXN0ZW5lclBvc2l0aW9uID0gb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uO1xuICB0aGlzLnNldFJvb21Qcm9wZXJ0aWVzKG9wdGlvbnMuZGltZW5zaW9ucywgb3B0aW9ucy5jb2VmZmljaWVudHMpO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uIChpbiBtZXRlcnMpLFxuICogd2hlcmUgWzAsMCwwXSBpcyB0aGUgY2VudGVyIG9mIHRoZSByb29tLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICovXG5FYXJseVJlZmxlY3Rpb25zLnByb3RvdHlwZS5zZXRMaXN0ZW5lclBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAvLyBBc3NpZ24gbGlzdGVuZXIgcG9zaXRpb24uXG4gIHRoaXMuX2xpc3RlbmVyUG9zaXRpb24gPSBbeCwgeSwgel07XG5cbiAgLy8gRGV0ZXJtaW5lIGRpc3RhbmNlcyB0byBlYWNoIHdhbGwuXG4gIGxldCBkaXN0YW5jZXMgPSB7XG4gICAgbGVmdDogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMud2lkdGggKyB4KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gICAgcmlnaHQ6IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLndpZHRoIC0geCkgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICAgIGZyb250OiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy5kZXB0aCArIHopICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgICBiYWNrOiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy5kZXB0aCAtIHopICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgICBkb3duOiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy5oZWlnaHQgKyB5KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gICAgdXA6IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLmhlaWdodCAtIHkpICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgfTtcblxuICAvLyBBc3NpZ24gZGVsYXkgJiBhdHRlbnVhdGlvbiB2YWx1ZXMgdXNpbmcgZGlzdGFuY2VzLlxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAgICAgICAgLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgYXNzaWduIGRlbGF5IChpbiBzZWNvbmRzKS5cbiAgICAgIGxldCBkZWxheUluU2VjcyA9IGRpc3RhbmNlc1twcm9wZXJ0eV0gLyB0aGlzLnNwZWVkT2ZTb3VuZDtcbiAgICAgIHRoaXMuX2RlbGF5c1twcm9wZXJ0eV0uZGVsYXlUaW1lLnZhbHVlID0gZGVsYXlJblNlY3M7XG5cbiAgICAgIC8vIENvbXB1dGUgYW5kIGFzc2lnbiBnYWluLCB1c2VzIGxvZ2FyaXRobWljIHJvbGxvZmY6IFwiZyA9IFIgLyAoZCArIDEpXCJcbiAgICAgIGxldCBhdHRlbnVhdGlvbiA9IHRoaXMuX2NvZWZmaWNpZW50c1twcm9wZXJ0eV0gLyBkaXN0YW5jZXNbcHJvcGVydHldO1xuICAgICAgdGhpcy5fZ2FpbnNbcHJvcGVydHldLmdhaW4udmFsdWUgPSBhdHRlbnVhdGlvbjtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJvb20ncyBwcm9wZXJ0aWVzIHdoaWNoIGRldGVybWluZXMgdGhlIGNoYXJhY3RlcmlzdGljcyBvZlxuICogcmVmbGVjdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uc1xuICogUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyBERUZBVUxUX1JPT01fRElNRU5TSU9OU30uXG4gKiBAcGFyYW0ge09iamVjdH0gY29lZmZpY2llbnRzXG4gKiBGcmVxdWVuY3ktaW5kZXBlbmRlbnQgcmVmbGVjdGlvbiBjb2VmZnMgcGVyIHdhbGwuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAqIERFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFN9LlxuICovXG5FYXJseVJlZmxlY3Rpb25zLnByb3RvdHlwZS5zZXRSb29tUHJvcGVydGllcyA9IGZ1bmN0aW9uKGRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50cykge1xuICBpZiAoZGltZW5zaW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBkaW1lbnNpb25zID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihkaW1lbnNpb25zLCBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyk7XG4gIH1cbiAgaWYgKGNvZWZmaWNpZW50cyA9PSB1bmRlZmluZWQpIHtcbiAgICBjb2VmZmljaWVudHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKGNvZWZmaWNpZW50cywgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUyk7XG4gIH1cbiAgdGhpcy5fY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xuXG4gIC8vIFNhbml0aXplIGRpbWVuc2lvbnMgYW5kIHN0b3JlIGhhbGYtZGltZW5zaW9ucy5cbiAgdGhpcy5faGFsZkRpbWVuc2lvbnMgPSB7fTtcbiAgdGhpcy5faGFsZkRpbWVuc2lvbnMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICogMC41O1xuICB0aGlzLl9oYWxmRGltZW5zaW9ucy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIDAuNTtcbiAgdGhpcy5faGFsZkRpbWVuc2lvbnMuZGVwdGggPSBkaW1lbnNpb25zLmRlcHRoICogMC41O1xuXG4gIC8vIFVwZGF0ZSBsaXN0ZW5lciBwb3NpdGlvbiB3aXRoIG5ldyByb29tIHByb3BlcnRpZXMuXG4gIHRoaXMuc2V0TGlzdGVuZXJQb3NpdGlvbih0aGlzLl9saXN0ZW5lclBvc2l0aW9uWzBdLFxuICAgIHRoaXMuX2xpc3RlbmVyUG9zaXRpb25bMV0sIHRoaXMuX2xpc3RlbmVyUG9zaXRpb25bMl0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEVhcmx5UmVmbGVjdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBQcmltYXJ5IG5hbWVzcGFjZSBmb3IgUmVzb25hbmNlQXVkaW8gbGlicmFyeS5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cbiBcblxuXG4vLyBNYWluIG1vZHVsZS5cbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG4vLyBUZXN0YWJsZSBTdWJtb2R1bGVzLlxuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5BdHRlbnVhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkRpcmVjdGl2aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uRWFybHlSZWZsZWN0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5MYXRlUmVmbGVjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5MaXN0ZW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLlJvb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5Tb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5UYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLlZlcnNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFJlc29uYW5jZUF1ZGlvIGxpYnJhcnkgbmFtZSBzcGFjZSBhbmQgY29tbW9uIHV0aWxpdGllcy5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IExpc3RlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmNvbnN0IFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5jb25zdCBSb29tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmNvbnN0IEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIFJlc29uYW5jZUF1ZGlvXG4gKiBAZGVzY3JpcHRpb24gTWFpbiBjbGFzcyBmb3IgbWFuYWdpbmcgc291cmNlcywgcm9vbSBhbmQgbGlzdGVuZXIgbW9kZWxzLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYW1iaXNvbmljT3JkZXJcbiAqIERlc2lyZWQgYW1iaXNvbmljIE9yZGVyLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUiBERUZBVUxUX0FNQklTT05JQ19PUkRFUn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLmxpc3RlbmVyRm9yd2FyZFxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCBmb3J3YXJkIHZlY3Rvci5cbiAqIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9GT1JXQVJEIERFRkFVTFRfRk9SV0FSRH0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5saXN0ZW5lclVwXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIHVwIHZlY3Rvci5cbiAqIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9VUCBERUZBVUxUX1VQfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRpbWVuc2lvbnMgUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyBERUZBVUxUX1JPT01fRElNRU5TSU9OU30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5tYXRlcmlhbHMgTmFtZWQgYWNvdXN0aWMgbWF0ZXJpYWxzIHBlciB3YWxsLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTIERFRkFVTFRfUk9PTV9NQVRFUklBTFN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRPZlNvdW5kXG4gKiAoaW4gbWV0ZXJzL3NlY29uZCkuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQgREVGQVVMVF9TUEVFRF9PRl9TT1VORH0uXG4gKi9cbmZ1bmN0aW9uIFJlc29uYW5jZUF1ZGlvKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIEJpbmF1cmFsbHktcmVuZGVyZWQgc3RlcmVvICgyLWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgUmVzb25hbmNlQXVkaW9cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX1cbiAgICogKEZvciByZW5kZXJpbmcgaW5wdXQgc291bmRmaWVsZHMpLlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGFtYmlzb25pY0lucHV0XG4gICAqIEBtZW1iZXJvZiBSZXNvbmFuY2VBdWRpb1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX1cbiAgICogKEZvciBhbGxvd2luZyBleHRlcm5hbCByZW5kZXJpbmcgLyBwb3N0LXByb2Nlc3NpbmcpLlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGFtYmlzb25pY091dHB1dFxuICAgKiBAbWVtYmVyb2YgUmVzb25hbmNlQXVkaW9cbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmFtYmlzb25pY09yZGVyID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUjtcbiAgfVxuICBpZiAob3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9IFV0aWxzLkRFRkFVTFRfUE9TSVRJT04uc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5saXN0ZW5lckZvcndhcmQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5saXN0ZW5lckZvcndhcmQgPSBVdGlscy5ERUZBVUxUX0ZPUldBUkQuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5saXN0ZW5lclVwID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubGlzdGVuZXJVcCA9IFV0aWxzLkRFRkFVTFRfVVAuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5kaW1lbnNpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZGltZW5zaW9ucyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5kaW1lbnNpb25zLCBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF0ZXJpYWxzID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWF0ZXJpYWxzID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLm1hdGVyaWFscywgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3BlZWRPZlNvdW5kID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc3BlZWRPZlNvdW5kID0gVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBtZW1iZXIgc3VibW9kdWxlcy5cbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPSBFbmNvZGVyLnZhbGlkYXRlQW1iaXNvbmljT3JkZXIob3B0aW9ucy5hbWJpc29uaWNPcmRlcik7XG4gIHRoaXMuX3NvdXJjZXMgPSBbXTtcbiAgdGhpcy5fcm9vbSA9IG5ldyBSb29tKGNvbnRleHQsIHtcbiAgICBsaXN0ZW5lclBvc2l0aW9uOiBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24sXG4gICAgZGltZW5zaW9uczogb3B0aW9ucy5kaW1lbnNpb25zLFxuICAgIG1hdGVyaWFsczogb3B0aW9ucy5tYXRlcmlhbHMsXG4gICAgc3BlZWRPZlNvdW5kOiBvcHRpb25zLnNwZWVkT2ZTb3VuZCxcbiAgfSk7XG4gIHRoaXMuX2xpc3RlbmVyID0gbmV3IExpc3RlbmVyKGNvbnRleHQsIHtcbiAgICBhbWJpc29uaWNPcmRlcjogb3B0aW9ucy5hbWJpc29uaWNPcmRlcixcbiAgICBwb3NpdGlvbjogb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uLFxuICAgIGZvcndhcmQ6IG9wdGlvbnMubGlzdGVuZXJGb3J3YXJkLFxuICAgIHVwOiBvcHRpb25zLmxpc3RlbmVyVXAsXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBhdXhpbGxhcnkgYXVkaW8gbm9kZXMuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLmFtYmlzb25pY091dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLmFtYmlzb25pY0lucHV0ID0gdGhpcy5fbGlzdGVuZXIuaW5wdXQ7XG5cbiAgLy8gQ29ubmVjdCBhdWRpbyBncmFwaC5cbiAgdGhpcy5fcm9vbS5vdXRwdXQuY29ubmVjdCh0aGlzLl9saXN0ZW5lci5pbnB1dCk7XG4gIHRoaXMuX2xpc3RlbmVyLm91dHB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgdGhpcy5fbGlzdGVuZXIuYW1iaXNvbmljT3V0cHV0LmNvbm5lY3QodGhpcy5hbWJpc29uaWNPdXRwdXQpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNvdXJjZSBmb3IgdGhlIHNjZW5lLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnBvc2l0aW9uXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5mb3J3YXJkXG4gKiBUaGUgc291cmNlJ3MgaW5pdGlhbCBmb3J3YXJkIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9GT1JXQVJEIERFRkFVTFRfRk9SV0FSRH0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy51cFxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgdXAgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1VQIERFRkFVTFRfVVB9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWluRGlzdGFuY2VcbiAqIE1pbi4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFIERFRkFVTFRfTUlOX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1heERpc3RhbmNlXG4gKiBNYXguIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRSBERUZBVUxUX01BWF9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5yb2xsb2ZmXG4gKiBSb2xsb2ZmIG1vZGVsIHRvIHVzZSwgY2hvc2VuIGZyb20gb3B0aW9ucyBpblxuICoge0BsaW5rY29kZSBVdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyBBVFRFTlVBVElPTl9ST0xMT0ZGU30uIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRiBERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkZ9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZ2FpbiBJbnB1dCBnYWluIChsaW5lYXIpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NPVVJDRV9HQUlOIERFRkFVTFRfU09VUkNFX0dBSU59LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYWxwaGEgRGlyZWN0aXZpdHkgYWxwaGEuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEEgREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zaGFycG5lc3MgRGlyZWN0aXZpdHkgc2hhcnBuZXNzLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTU1xuICogREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1N9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc291cmNlV2lkdGhcbiAqIFNvdXJjZSB3aWR0aCAoaW4gZGVncmVlcykuIFdoZXJlIDAgZGVncmVlcyBpcyBhIHBvaW50IHNvdXJjZSBhbmQgMzYwIGRlZ3JlZXNcbiAqIGlzIGFuIG9tbmlkaXJlY3Rpb25hbCBzb3VyY2UuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIIERFRkFVTFRfU09VUkNFX1dJRFRIfS5cbiAqIEByZXR1cm4ge1NvdXJjZX1cbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLmNyZWF0ZVNvdXJjZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLy8gQ3JlYXRlIGEgc291cmNlIGFuZCBwdXNoIGl0IHRvIHRoZSBpbnRlcm5hbCBzb3VyY2VzIGFycmF5LCByZXR1cm5pbmdcbiAgLy8gdGhlIG9iamVjdCdzIHJlZmVyZW5jZSB0byB0aGUgdXNlci5cbiAgbGV0IHNvdXJjZSA9IG5ldyBTb3VyY2UodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3NvdXJjZXNbdGhpcy5fc291cmNlcy5sZW5ndGhdID0gc291cmNlO1xuICByZXR1cm4gc291cmNlO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc2NlbmUncyBkZXNpcmVkIGFtYmlzb25pYyBvcmRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciBEZXNpcmVkIGFtYmlzb25pYyBvcmRlci5cbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldEFtYmlzb25pY09yZGVyID0gZnVuY3Rpb24oYW1iaXNvbmljT3JkZXIpIHtcbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPSBFbmNvZGVyLnZhbGlkYXRlQW1iaXNvbmljT3JkZXIoYW1iaXNvbmljT3JkZXIpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm9vbSdzIGRpbWVuc2lvbnMgYW5kIHdhbGwgbWF0ZXJpYWxzLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnMgUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFscyBOYW1lZCBhY291c3RpYyBtYXRlcmlhbHMgcGVyIHdhbGwuXG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRSb29tUHJvcGVydGllcyA9IGZ1bmN0aW9uKGRpbWVuc2lvbnMsIG1hdGVyaWFscykge1xuICB0aGlzLl9yb29tLnNldFByb3BlcnRpZXMoZGltZW5zaW9ucywgbWF0ZXJpYWxzKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldExpc3RlbmVyUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIC8vIFVwZGF0ZSBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMF0gPSB4O1xuICB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblsxXSA9IHk7XG4gIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzJdID0gejtcbiAgdGhpcy5fcm9vbS5zZXRMaXN0ZW5lclBvc2l0aW9uKHgsIHksIHopO1xuXG4gIC8vIFVwZGF0ZSBzb3VyY2VzIHdpdGggbmV3IGxpc3RlbmVyIHBvc2l0aW9uLlxuICB0aGlzLl9zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICBlbGVtZW50Ll91cGRhdGUoKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UncyBvcmllbnRhdGlvbiB1c2luZyBmb3J3YXJkIGFuZCB1cCB2ZWN0b3JzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRYXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFlcbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWlxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWFxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWVxuICogQHBhcmFtIHtOdW1iZXJ9IHVwWlxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0TGlzdGVuZXJPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGZvcndhcmRYLCBmb3J3YXJkWSxcbiAgZm9yd2FyZFosIHVwWCwgdXBZLCB1cFopIHtcbiAgdGhpcy5fbGlzdGVuZXIuc2V0T3JpZW50YXRpb24oZm9yd2FyZFgsIGZvcndhcmRZLCBmb3J3YXJkWiwgdXBYLCB1cFksIHVwWik7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiB1c2luZyBhIFRocmVlLmpzIE1hdHJpeDQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG1hdHJpeFxuICogVGhlIFRocmVlLmpzIE1hdHJpeDQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbGlzdGVuZXIncyB3b3JsZCB0cmFuc2Zvcm0uXG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRMaXN0ZW5lckZyb21NYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgdGhpcy5fbGlzdGVuZXIuc2V0RnJvbU1hdHJpeChtYXRyaXgpO1xuXG4gIC8vIFVwZGF0ZSB0aGUgcmVzdCBvZiB0aGUgc2NlbmUgdXNpbmcgbmV3IGxpc3RlbmVyIHBvc2l0aW9uLlxuICB0aGlzLnNldExpc3RlbmVyUG9zaXRpb24odGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMF0sXG4gICAgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMV0sIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzJdKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNwZWVkIG9mIHNvdW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkT2ZTb3VuZFxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0U3BlZWRPZlNvdW5kID0gZnVuY3Rpb24oc3BlZWRPZlNvdW5kKSB7XG4gIHRoaXMuX3Jvb20uc3BlZWRPZlNvdW5kID0gc3BlZWRPZlNvdW5kO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc29uYW5jZUF1ZGlvO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHJ1ZSlcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSBsaWJyYXJ5IGNvbW1vbiB1dGlsaXRpZXMuXG4gKi9cblxuXG4vKipcbiAqIE9tbml0b25lIGxpYnJhcnkgbG9nZ2luZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBNZXNzYWdlIHRvIGJlIHByaW50ZWQgb3V0LlxuICovXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkod2luZG93LmNvbnNvbGUsIFtcbiAgICAnJWNbT21uaXRvbmVdJWMgJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpICtcbiAgICAgICAgJyAlYyhAJyArIHBlcmZvcm1hbmNlLm5vdygpLnRvRml4ZWQoMikgKyAnbXMpJyxcbiAgICAnYmFja2dyb3VuZDogI0JCREVGQjsgY29sb3I6ICNGRjU3MjI7IGZvbnQtd2VpZ2h0OiA1MDAnLCAnZm9udC13ZWlnaHQ6IDMwMCcsXG4gICAgJ2NvbG9yOiAjQUFBJyxcbiAgXSk7XG59O1xuXG5cbi8qKlxuICogT21uaXRvbmUgbGlicmFyeSBlcnJvci10aHJvd2luZyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBNZXNzYWdlIHRvIGJlIHByaW50ZWQgb3V0LlxuICovXG5leHBvcnRzLnRocm93ID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5jb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBbXG4gICAgJyVjW09tbml0b25lXSVjICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKSArXG4gICAgICAgICcgJWMoQCcgKyBwZXJmb3JtYW5jZS5ub3coKS50b0ZpeGVkKDIpICsgJ21zKScsXG4gICAgJ2JhY2tncm91bmQ6ICNDNjI4Mjg7IGNvbG9yOiAjRkZFQkVFOyBmb250LXdlaWdodDogODAwJywgJ2ZvbnQtd2VpZ2h0OiA0MDAnLFxuICAgICdjb2xvcjogI0FBQScsXG4gIF0pO1xuXG4gIHRocm93IG5ldyBFcnJvcihmYWxzZSk7XG59O1xuXG5cbi8vIFN0YXRpYyB0ZW1wIHN0b3JhZ2UgZm9yIG1hdHJpeCBpbnZlcnNpb24uXG5sZXQgYTAwO1xubGV0IGEwMTtcbmxldCBhMDI7XG5sZXQgYTAzO1xubGV0IGExMDtcbmxldCBhMTE7XG5sZXQgYTEyO1xubGV0IGExMztcbmxldCBhMjA7XG5sZXQgYTIxO1xubGV0IGEyMjtcbmxldCBhMjM7XG5sZXQgYTMwO1xubGV0IGEzMTtcbmxldCBhMzI7XG5sZXQgYTMzO1xubGV0IGIwMDtcbmxldCBiMDE7XG5sZXQgYjAyO1xubGV0IGIwMztcbmxldCBiMDQ7XG5sZXQgYjA1O1xubGV0IGIwNjtcbmxldCBiMDc7XG5sZXQgYjA4O1xubGV0IGIwOTtcbmxldCBiMTA7XG5sZXQgYjExO1xubGV0IGRldDtcblxuXG4vKipcbiAqIEEgNHg0IG1hdHJpeCBpbnZlcnNpb24gdXRpbGl0eS4gVGhpcyBkb2VzIG5vdCBoYW5kbGUgdGhlIGNhc2Ugd2hlbiB0aGVcbiAqIGFyZ3VtZW50cyBhcmUgbm90IHByb3BlciA0eDQgbWF0cmljZXMuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3V0ICAgVGhlIGludmVydGVkIHJlc3VsdC5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhICAgICBUaGUgc291cmNlIG1hdHJpeC5cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gb3V0XG4gKi9cbmV4cG9ydHMuaW52ZXJ0TWF0cml4NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBhMDAgPSBhWzBdO1xuICBhMDEgPSBhWzFdO1xuICBhMDIgPSBhWzJdO1xuICBhMDMgPSBhWzNdO1xuICBhMTAgPSBhWzRdO1xuICBhMTEgPSBhWzVdO1xuICBhMTIgPSBhWzZdO1xuICBhMTMgPSBhWzddO1xuICBhMjAgPSBhWzhdO1xuICBhMjEgPSBhWzldO1xuICBhMjIgPSBhWzEwXTtcbiAgYTIzID0gYVsxMV07XG4gIGEzMCA9IGFbMTJdO1xuICBhMzEgPSBhWzEzXTtcbiAgYTMyID0gYVsxNF07XG4gIGEzMyA9IGFbMTVdO1xuICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGRlZmluZWQgaW4gdGhlIEVOVU0gZGljdGlvbmFyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnVtRGljdGlvbmFyeSAtIEVOVU0gZGljdGlvbmFyeS5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZW50cnlWYWx1ZSAtIGEgdmFsdWUgdG8gcHJvYmUuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzRGVmaW5lZEVOVU1FbnRyeSA9IGZ1bmN0aW9uKGVudW1EaWN0aW9uYXJ5LCBlbnRyeVZhbHVlKSB7XG4gIGZvciAobGV0IGVudW1LZXkgaW4gZW51bURpY3Rpb25hcnkpIHtcbiAgICBpZiAoZW50cnlWYWx1ZSA9PT0gZW51bURpY3Rpb25hcnlbZW51bUtleV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBIGNvbnRleHQgb2JqZWN0IHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAvLyBUT0RPKGhvY2gpOiBVcGRhdGUgdGhpcyB3aGVuIEJhc2VBdWRpb0NvbnRleHQgaXMgYXZhaWxhYmxlIGZvciBhbGxcbiAgLy8gYnJvd3NlcnMuXG4gIHJldHVybiBjb250ZXh0IGluc3RhbmNlb2YgQXVkaW9Db250ZXh0IHx8XG4gICAgY29udGV4dCBpbnN0YW5jZW9mIE9mZmxpbmVBdWRpb0NvbnRleHQ7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbGlkIEF1ZGlvQnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGF1ZGlvQnVmZmVyIEFuIEF1ZGlvQnVmZmVyIG9iamVjdCB0byBiZSBjaGVja2VkLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0F1ZGlvQnVmZmVyID0gZnVuY3Rpb24oYXVkaW9CdWZmZXIpIHtcbiAgcmV0dXJuIGF1ZGlvQnVmZmVyIGluc3RhbmNlb2YgQXVkaW9CdWZmZXI7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBjaGFubmVsLXdpc2UgbWVyZ2Ugb24gbXVsdGlwbGUgQXVkaW9CdWZmZXJzLiBUaGUgc2FtcGxlIHJhdGUgYW5kXG4gKiB0aGUgbGVuZ3RoIG9mIGJ1ZmZlcnMgdG8gYmUgbWVyZ2VkIG11c3QgYmUgaWRlbnRpY2FsLlxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBidWZmZXJMaXN0IC0gQW4gYXJyYXkgb2YgQXVkaW9CdWZmZXJzIHRvIGJlIG1lcmdlZFxuICogY2hhbm5lbC13aXNlLlxuICogQHJldHVybiB7QXVkaW9CdWZmZXJ9IC0gQSBzaW5nbGUgbWVyZ2VkIEF1ZGlvQnVmZmVyLlxuICovXG5leHBvcnRzLm1lcmdlQnVmZmVyTGlzdEJ5Q2hhbm5lbCA9IGZ1bmN0aW9uKGNvbnRleHQsIGJ1ZmZlckxpc3QpIHtcbiAgY29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyTGlzdFswXS5sZW5ndGg7XG4gIGNvbnN0IGJ1ZmZlclNhbXBsZVJhdGUgPSBidWZmZXJMaXN0WzBdLnNhbXBsZVJhdGU7XG4gIGxldCBidWZmZXJOdW1iZXJPZkNoYW5uZWwgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChidWZmZXJOdW1iZXJPZkNoYW5uZWwgPiAzMikge1xuICAgICAgZXhwb3J0cy50aHJvdygnVXRpbHMubWVyZ2VCdWZmZXI6IE51bWJlciBvZiBjaGFubmVscyBjYW5ub3QgZXhjZWVkIDMyLicgK1xuICAgICAgICAgICcoZ290ICcgKyBidWZmZXJOdW1iZXJPZkNoYW5uZWwgKyAnKScpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyTGVuZ3RoICE9PSBidWZmZXJMaXN0W2ldLmxlbmd0aCkge1xuICAgICAgZXhwb3J0cy50aHJvdygnVXRpbHMubWVyZ2VCdWZmZXI6IEF1ZGlvQnVmZmVyIGxlbmd0aHMgYXJlICcgK1xuICAgICAgICAgICdpbmNvbnNpc3RlbnQuIChleHBlY3RlZCAnICsgYnVmZmVyTGVuZ3RoICsgJyBidXQgZ290ICcgK1xuICAgICAgICAgIGJ1ZmZlckxpc3RbaV0ubGVuZ3RoICsgJyknKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlclNhbXBsZVJhdGUgIT09IGJ1ZmZlckxpc3RbaV0uc2FtcGxlUmF0ZSkge1xuICAgICAgZXhwb3J0cy50aHJvdygnVXRpbHMubWVyZ2VCdWZmZXI6IEF1ZGlvQnVmZmVyIHNhbXBsZSByYXRlcyBhcmUgJyArXG4gICAgICAgICAgJ2luY29uc2lzdGVudC4gKGV4cGVjdGVkICcgKyBidWZmZXJTYW1wbGVSYXRlICsgJyBidXQgZ290ICcgK1xuICAgICAgICAgIGJ1ZmZlckxpc3RbaV0uc2FtcGxlUmF0ZSArICcpJyk7XG4gICAgfVxuICAgIGJ1ZmZlck51bWJlck9mQ2hhbm5lbCArPSBidWZmZXJMaXN0W2ldLm51bWJlck9mQ2hhbm5lbHM7XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlcihidWZmZXJOdW1iZXJPZkNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyU2FtcGxlUmF0ZSk7XG4gIGxldCBkZXN0aW5hdGlvbkNoYW5uZWxJbmRleCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnVmZmVyTGlzdFtpXS5udW1iZXJPZkNoYW5uZWxzOyArK2opIHtcbiAgICAgIGJ1ZmZlci5nZXRDaGFubmVsRGF0YShkZXN0aW5hdGlvbkNoYW5uZWxJbmRleCsrKS5zZXQoXG4gICAgICAgICAgYnVmZmVyTGlzdFtpXS5nZXRDaGFubmVsRGF0YShqKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtIGNoYW5uZWwtd2lzZSBzcGxpdCBieSB0aGUgZ2l2ZW4gY2hhbm5lbCBjb3VudC4gRm9yIGV4YW1wbGUsXG4gKiAxIHggQXVkaW9CdWZmZXIoOCkgLT4gc3BsaXRCdWZmZXIoY29udGV4dCwgYnVmZmVyLCAyKSAtPiA0IHggQXVkaW9CdWZmZXIoMikuXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBhdWRpb0J1ZmZlciAtIEFuIEF1ZGlvQnVmZmVyIHRvIGJlIHNwbGl0dGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwbGl0QnkgLSBOdW1iZXIgb2YgY2hhbm5lbHMgdG8gYmUgc3BsaXR0ZWQuXG4gKiBAcmV0dXJuIHtBdWRpb0J1ZmZlcltdfSAtIEFuIGFycmF5IG9mIHNwbGl0dGVkIEF1ZGlvQnVmZmVycy5cbiAqL1xuZXhwb3J0cy5zcGxpdEJ1ZmZlcmJ5Q2hhbm5lbCA9IGZ1bmN0aW9uKGNvbnRleHQsIGF1ZGlvQnVmZmVyLCBzcGxpdEJ5KSB7XG4gIGlmIChhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzIDw9IHNwbGl0QnkpIHtcbiAgICBleHBvcnRzLnRocm93KCdVdGlscy5zcGxpdEJ1ZmZlcjogSW5zdWZmaWNpZW50IG51bWJlciBvZiBjaGFubmVscy4gKCcgK1xuICAgICAgICBhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzICsgJyBzcGxpdHRlZCBieSAnICsgc3BsaXRCeSArICcpJyk7XG4gIH1cblxuICBsZXQgYnVmZmxlckxpc3QgPSBbXTtcbiAgbGV0IHNvdXJjZUNoYW5uZWxJbmRleCA9IDA7XG4gIGNvbnN0IG51bWJlck9mU3BsaXR0ZWRCdWZmZXIgPVxuICAgICAgTWF0aC5jZWlsKGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgLyBzcGxpdEJ5KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlNwbGl0dGVkQnVmZmVyOyArK2kpIHtcbiAgICBsZXQgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoc3BsaXRCeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdWRpb0J1ZmZlci5zYW1wbGVSYXRlKTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwbGl0Qnk7ICsraikge1xuICAgICAgaWYgKHNvdXJjZUNoYW5uZWxJbmRleCA8IGF1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHMpIHtcbiAgICAgICAgYnVmZmVyLmdldENoYW5uZWxEYXRhKGopLnNldChcbiAgICAgICAgICBhdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShzb3VyY2VDaGFubmVsSW5kZXgrKykpO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmbGVyTGlzdC5wdXNoKGJ1ZmZlcik7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyTGlzdDtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0cyBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gQXJyYXlCdWZmZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyaW5nIC0gQmFzZTY0LWVuY2RvZWQgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXlCeXVmZmVyfSBDb252ZXJ0ZWQgQXJyYXlCdWZmZXIgb2JqZWN0LlxuICovXG5leHBvcnRzLmdldEFycmF5QnVmZmVyRnJvbUJhc2U2NFN0cmluZyA9IGZ1bmN0aW9uKGJhc2U2NFN0cmluZykge1xuICBsZXQgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IoYmFzZTY0U3RyaW5nKTtcbiAgbGV0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICBieXRlQXJyYXkuZm9yRWFjaChcbiAgICAodmFsdWUsIGluZGV4KSA9PiBieXRlQXJyYXlbaW5kZXhdID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpKTtcbiAgcmV0dXJuIGJ5dGVBcnJheS5idWZmZXI7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFN0cmVhbWxpbmVkIEF1ZGlvQnVmZmVyIGxvYWRlci5cbiAqL1xuXG5cblxuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ30gQnVmZmVyRGF0YVR5cGVcbiAqL1xuXG4vKipcbiAqIEJ1ZmZlciBkYXRhIHR5cGUgZm9yIEVOVU0uXG4gKiBAZW51bSB7QnVmZmVyRGF0YVR5cGV9XG4gKi9cbmNvbnN0IEJ1ZmZlckRhdGFUeXBlID0ge1xuICAvKiogQHR5cGUge3N0cmluZ30gVGhlIGRhdGEgY29udGFpbnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLi4gKi9cbiAgQkFTRTY0OiAnYmFzZTY0JyxcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBkYXRhIGlzIGEgVVJMIGZvciBhdWRpbyBmaWxlLiAqL1xuICBVUkw6ICd1cmwnLFxufTtcblxuXG4vKipcbiAqIEJ1ZmZlckxpc3Qgb2JqZWN0IG1hbmFuZ2VzIHRoZSBhc3luYyBsb2FkaW5nL2RlY29kaW5nIG9mIG11bHRpcGxlXG4gKiBBdWRpb0J1ZmZlcnMgZnJvbSBtdWx0aXBsZSBVUkxzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBidWZmZXJEYXRhIC0gQW4gb3JkZXJlZCBsaXN0IG9mIFVSTHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kYXRhVHlwZT0nYmFzZTY0J10gLSBCdWZmZXJEYXRhVHlwZSBzcGVjaWZpZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZlcmJvc2U9ZmFsc2VdIC0gTG9nIHZlcmJvc2l0eS4gfHRydWV8IHByaW50cyB0aGVcbiAqIGluZGl2aWR1YWwgbWVzc2FnZSBmcm9tIGVhY2ggVVJMIGFuZCBBdWRpb0J1ZmZlci5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyTGlzdChjb250ZXh0LCBidWZmZXJEYXRhLCBvcHRpb25zKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBVdGlscy5pc0F1ZGlvQ29udGV4dChjb250ZXh0KSA/XG4gICAgICBjb250ZXh0IDpcbiAgICAgIFV0aWxzLnRocm93KCdCdWZmZXJMaXN0OiBJbnZhbGlkIEJhc2VBdWRpb0NvbnRleHQuJyk7XG5cbiAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICBkYXRhVHlwZTogQnVmZmVyRGF0YVR5cGUuQkFTRTY0LFxuICAgIHZlcmJvc2U6IGZhbHNlLFxuICB9O1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZGF0YVR5cGUgJiZcbiAgICAgICAgVXRpbHMuaXNEZWZpbmVkRU5VTUVudHJ5KEJ1ZmZlckRhdGFUeXBlLCBvcHRpb25zLmRhdGFUeXBlKSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5kYXRhVHlwZSA9IG9wdGlvbnMuZGF0YVR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMudmVyYm9zZSA9IEJvb2xlYW4ob3B0aW9ucy52ZXJib3NlKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9idWZmZXJMaXN0ID0gW107XG4gIHRoaXMuX2J1ZmZlckRhdGEgPSB0aGlzLl9vcHRpb25zLmRhdGFUeXBlID09PSBCdWZmZXJEYXRhVHlwZS5CQVNFNjRcbiAgICAgID8gYnVmZmVyRGF0YVxuICAgICAgOiBidWZmZXJEYXRhLnNsaWNlKDApO1xuICB0aGlzLl9udW1iZXJPZlRhc2tzID0gdGhpcy5fYnVmZmVyRGF0YS5sZW5ndGg7XG5cbiAgdGhpcy5fcmVzb2x2ZUhhbmRsZXIgPSBudWxsO1xuICB0aGlzLl9yZWplY3RIYW5kbGVyID0gbmV3IEZ1bmN0aW9uKCk7XG59XG5cblxuLyoqXG4gKiBTdGFydHMgQXVkaW9CdWZmZXIgbG9hZGluZyB0YXNrcy5cbiAqIEByZXR1cm4ge1Byb21pc2U8QXVkaW9CdWZmZXJbXT59IFRoZSBwcm9taXNlIHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2ZcbiAqIEF1ZGlvQnVmZmVyLlxuICovXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSh0aGlzLl9wcm9taXNlR2VuZXJhdG9yLmJpbmQodGhpcykpO1xufTtcblxuXG4vKipcbiAqIFByb21pc2UgYXJndW1lbnQgZ2VuZXJhdG9yLiBJbnRlcm5hbGx5IHN0YXJ0cyBtdWx0aXBsZSBhc3luYyBsb2FkaW5nIHRhc2tzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmUgUHJvbWlzZSByZXNvbHZlci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlamVjdCBQcm9taXNlIHJlamVjdC5cbiAqL1xuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3Byb21pc2VHZW5lcmF0b3IgPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgVXRpbHMudGhyb3coJ0J1ZmZlckxpc3Q6IEludmFsaWQgUHJvbWlzZSByZXNvbHZlci4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9yZXNvbHZlSGFuZGxlciA9IHJlc29sdmU7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3JlamVjdEhhbmRsZXIgPSByZWplY3Q7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZmZlckRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9vcHRpb25zLmRhdGFUeXBlID09PSBCdWZmZXJEYXRhVHlwZS5CQVNFNjRcbiAgICAgICAgPyB0aGlzLl9sYXVuY2hBc3luY0xvYWRUYXNrKGkpXG4gICAgICAgIDogdGhpcy5fbGF1bmNoQXN5bmNMb2FkVGFza1hIUihpKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJ1biBhc3luYyBsb2FkaW5nIHRhc2sgZm9yIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGFza0lkIFRhc2sgSUQgbnVtYmVyIGZyb20gdGhlIG9yZGVyZWQgbGlzdCB8YnVmZmVyRGF0YXwuXG4gKi9cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9sYXVuY2hBc3luY0xvYWRUYXNrID0gZnVuY3Rpb24odGFza0lkKSB7XG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICB0aGlzLl9jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShcbiAgICAgIFV0aWxzLmdldEFycmF5QnVmZmVyRnJvbUJhc2U2NFN0cmluZyh0aGlzLl9idWZmZXJEYXRhW3Rhc2tJZF0pLFxuICAgICAgZnVuY3Rpb24oYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgdGhhdC5fdXBkYXRlUHJvZ3Jlc3ModGFza0lkLCBhdWRpb0J1ZmZlcik7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRoYXQuX3VwZGF0ZVByb2dyZXNzKHRhc2tJZCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQnVmZmVyTGlzdDogZGVjb2RpbmcgQXJyYXlCeWZmZXIoXCInICsgdGFza0lkICtcbiAgICAgICAgICAgICdcIiBmcm9tIEJhc2U2NC1lbmNvZGVkIGRhdGEgZmFpbGVkLiAoJyArIGVycm9yTWVzc2FnZSArICcpJztcbiAgICAgICAgVXRpbHMudGhyb3cobWVzc2FnZSk7XG4gICAgICAgIHRoYXQuX3JlamVjdEhhbmRsZXIobWVzc2FnZSk7XG4gICAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdW4gYXN5bmMgbG9hZGluZyB0YXNrIHZpYSBYSFIgZm9yIGF1ZGlvIGZpbGUgVVJMcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdGFza0lkIFRhc2sgSUQgbnVtYmVyIGZyb20gdGhlIG9yZGVyZWQgbGlzdCB8YnVmZmVyRGF0YXwuXG4gKi9cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9sYXVuY2hBc3luY0xvYWRUYXNrWEhSID0gZnVuY3Rpb24odGFza0lkKSB7XG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB4aHIub3BlbignR0VUJywgdGhpcy5fYnVmZmVyRGF0YVt0YXNrSWRdKTtcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICB0aGF0Ll9jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShcbiAgICAgICAgICB4aHIucmVzcG9uc2UsXG4gICAgICAgICAgZnVuY3Rpb24oYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgIHRoYXQuX3VwZGF0ZVByb2dyZXNzKHRhc2tJZCwgYXVkaW9CdWZmZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGF0Ll91cGRhdGVQcm9ncmVzcyh0YXNrSWQsIG51bGwpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdCdWZmZXJMaXN0OiBkZWNvZGluZyBcIicgK1xuICAgICAgICAgICAgICAgIHRoYXQuX2J1ZmZlckRhdGFbdGFza0lkXSArICdcIiBmYWlsZWQuICgnICsgZXJyb3JNZXNzYWdlICsgJyknO1xuICAgICAgICAgICAgVXRpbHMudGhyb3cobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGF0Ll9yZWplY3RIYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0J1ZmZlckxpc3Q6IFhIUiBlcnJvciB3aGlsZSBsb2FkaW5nIFwiJyArXG4gICAgICAgICAgdGhhdC5fYnVmZmVyRGF0YVt0YXNrSWRdICsgJygnICsgeGhyLnN0YXR1c1RleHQgKyAnKSc7XG4gICAgICBVdGlscy50aHJvdyhtZXNzYWdlKTtcbiAgICAgIHRoYXQuX3JlamVjdEhhbmRsZXIobWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBVdGlscy50aHJvdyhcbiAgICAgICAgJ0J1ZmZlckxpc3Q6IFhIUiBuZXR3b3JrIGZhaWxlZCBvbiBsb2FkaW5nIFwiJyArXG4gICAgICAgIHRoYXQuX2J1ZmZlckRhdGFbdGFza0lkXSArICdcIi4nKTtcbiAgICB0aGF0Ll91cGRhdGVQcm9ncmVzcyh0YXNrSWQsIG51bGwpO1xuICAgIHRoYXQuX3JlamVjdEhhbmRsZXIoKTtcbiAgfTtcblxuICB4aHIuc2VuZCgpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG92ZXJhbGwgcHJvZ3Jlc3Mgb24gbG9hZGluZyB0YXNrcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0YXNrSWQgVGFzayBJRCBudW1iZXIuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBhdWRpb0J1ZmZlciBEZWNvZGVkIEF1ZGlvQnVmZmVyIG9iamVjdC5cbiAqL1xuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24odGFza0lkLCBhdWRpb0J1ZmZlcikge1xuICB0aGlzLl9idWZmZXJMaXN0W3Rhc2tJZF0gPSBhdWRpb0J1ZmZlcjtcblxuICBpZiAodGhpcy5fb3B0aW9ucy52ZXJib3NlKSB7XG4gICAgbGV0IG1lc3NhZ2VTdHJpbmcgPSB0aGlzLl9vcHRpb25zLmRhdGFUeXBlID09PSBCdWZmZXJEYXRhVHlwZS5CQVNFNjRcbiAgICAgICAgPyAnQXJyYXlCdWZmZXIoJyArIHRhc2tJZCArICcpIGZyb20gQmFzZTY0LWVuY29kZWQgSFJJUidcbiAgICAgICAgOiAnXCInICsgdGhpcy5fYnVmZmVyRGF0YVt0YXNrSWRdICsgJ1wiJztcbiAgICBVdGlscy5sb2coJ0J1ZmZlckxpc3Q6ICcgKyBtZXNzYWdlU3RyaW5nICsgJyBzdWNjZXNzZnVsbHkgbG9hZGVkLicpO1xuICB9XG5cbiAgaWYgKC0tdGhpcy5fbnVtYmVyT2ZUYXNrcyA9PT0gMCkge1xuICAgIGxldCBtZXNzYWdlU3RyaW5nID0gdGhpcy5fb3B0aW9ucy5kYXRhVHlwZSA9PT0gQnVmZmVyRGF0YVR5cGUuQkFTRTY0XG4gICAgICAgID8gdGhpcy5fYnVmZmVyRGF0YS5sZW5ndGggKyAnIEF1ZGlvQnVmZmVycyBmcm9tIEJhc2U2NC1lbmNvZGVkIEhSSVJzJ1xuICAgICAgICA6IHRoaXMuX2J1ZmZlckRhdGEubGVuZ3RoICsgJyBmaWxlcyB2aWEgWEhSJztcbiAgICBVdGlscy5sb2coJ0J1ZmZlckxpc3Q6ICcgKyBtZXNzYWdlU3RyaW5nICsgJyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgIHRoaXMuX3Jlc29sdmVIYW5kbGVyKHRoaXMuX2J1ZmZlckxpc3QpO1xuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdDtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBBbiBhdWRpbyBjaGFubmVsIHJvdXRlciB0byByZXNvbHZlIGRpZmZlcmVudCBjaGFubmVsIGxheW91dHMgYmV0d2VlblxuICogYnJvd3NlcnMuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7TnVtYmVyW119IENoYW5uZWxNYXBcbiAqL1xuXG4vKipcbiAqIENoYW5uZWwgbWFwIGRpY3Rpb25hcnkgRU5VTS5cbiAqIEBlbnVtIHtDaGFubmVsTWFwfVxuICovXG5jb25zdCBDaGFubmVsTWFwID0ge1xuICAvKiogQHR5cGUge051bWJlcltdfSAtIEFDTiBjaGFubmVsIG1hcCBmb3IgQ2hyb21lIGFuZCBGaXJlRm94LiAoRkZNUEVHKSAqL1xuICBERUZBVUxUOiBbMCwgMSwgMiwgM10sXG4gIC8qKiBAdHlwZSB7TnVtYmVyW119IC0gU2FmYXJpJ3MgNC1jaGFubmVsIG1hcCBmb3IgQUFDIGNvZGVjLiAqL1xuICBTQUZBUkk6IFsyLCAwLCAxLCAzXSxcbiAgLyoqIEB0eXBlIHtOdW1iZXJbXX0gLSBBQ04gPiBGdU1hIGNvbnZlcnNpb24gbWFwLiAqL1xuICBGVU1BOiBbMCwgMywgMSwgMl0sXG59O1xuXG5cbi8qKlxuICogQ2hhbm5lbCByb3V0ZXIgZm9yIEZPQSBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcltdfSBjaGFubmVsTWFwIC0gUm91dGluZyBkZXN0aW5hdGlvbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gRk9BUm91dGVyKGNvbnRleHQsIGNoYW5uZWxNYXApIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5fbWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDQpO1xuXG4gIC8vIGlucHV0L291dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX3NwbGl0dGVyO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX21lcmdlcjtcblxuICB0aGlzLnNldENoYW5uZWxNYXAoY2hhbm5lbE1hcCB8fCBDaGFubmVsTWFwLkRFRkFVTFQpO1xufVxuXG5cbi8qKlxuICogU2V0cyBjaGFubmVsIG1hcC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IGNoYW5uZWxNYXAgLSBBIG5ldyBjaGFubmVsIG1hcCBmb3IgRk9BIHN0cmVhbS5cbiAqL1xuRk9BUm91dGVyLnByb3RvdHlwZS5zZXRDaGFubmVsTWFwID0gZnVuY3Rpb24oY2hhbm5lbE1hcCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhbm5lbE1hcCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jaGFubmVsTWFwID0gY2hhbm5lbE1hcDtcbiAgdGhpcy5fc3BsaXR0ZXIuZGlzY29ubmVjdCgpO1xuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgdGhpcy5fY2hhbm5lbE1hcFswXSk7XG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAxLCB0aGlzLl9jaGFubmVsTWFwWzFdKTtcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDIsIHRoaXMuX2NoYW5uZWxNYXBbMl0pO1xuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMywgdGhpcy5fY2hhbm5lbE1hcFszXSk7XG59O1xuXG5cbi8qKlxuICogU3RhdGljIGNoYW5uZWwgbWFwIEVOVU0uXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7Q2hhbm5lbE1hcH1cbiAqL1xuRk9BUm91dGVyLkNoYW5uZWxNYXAgPSBDaGFubmVsTWFwO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BUm91dGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFNvdW5kIGZpZWxkIHJvdGF0b3IgZm9yIGZpcnN0LW9yZGVyLWFtYmlzb25pY3MgZGVjb2RpbmcuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBGaXJzdC1vcmRlci1hbWJpc29uaWMgZGVjb2RlciBiYXNlZCBvbiBnYWluIG5vZGUgbmV0d29yay5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gRk9BUm90YXRvcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX2luWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9pblogPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faW5YID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX20wID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX20xID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX20yID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX20zID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX200ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX201ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX202ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX203ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX204ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX291dFkgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fb3V0WiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9vdXRYID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX21lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcig0KTtcblxuICAvLyBBQ04gY2hhbm5lbCBvcmRlcmluZzogWzEsIDIsIDNdID0+IFstWSwgWiwgLVhdXG4gIC8vIFkgKGZyb20gY2hhbm5lbCAxKVxuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2luWSwgMSk7XG4gIC8vIFogKGZyb20gY2hhbm5lbCAyKVxuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2luWiwgMik7XG4gIC8vIFggKGZyb20gY2hhbm5lbCAzKVxuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2luWCwgMyk7XG4gIHRoaXMuX2luWS5nYWluLnZhbHVlID0gLTE7XG4gIHRoaXMuX2luWC5nYWluLnZhbHVlID0gLTE7XG5cbiAgLy8gQXBwbHkgdGhlIHJvdGF0aW9uIGluIHRoZSB3b3JsZCBzcGFjZS5cbiAgLy8gfFl8ICAgfCBtMCAgbTMgIG02IHwgICB8IFkgKiBtMCArIFogKiBtMyArIFggKiBtNiB8ICAgfCBZciB8XG4gIC8vIHxafCAqIHwgbTEgIG00ICBtNyB8ID0gfCBZICogbTEgKyBaICogbTQgKyBYICogbTcgfCA9IHwgWnIgfFxuICAvLyB8WHwgICB8IG0yICBtNSAgbTggfCAgIHwgWSAqIG0yICsgWiAqIG01ICsgWCAqIG04IHwgICB8IFhyIHxcbiAgdGhpcy5faW5ZLmNvbm5lY3QodGhpcy5fbTApO1xuICB0aGlzLl9pblkuY29ubmVjdCh0aGlzLl9tMSk7XG4gIHRoaXMuX2luWS5jb25uZWN0KHRoaXMuX20yKTtcbiAgdGhpcy5faW5aLmNvbm5lY3QodGhpcy5fbTMpO1xuICB0aGlzLl9pblouY29ubmVjdCh0aGlzLl9tNCk7XG4gIHRoaXMuX2luWi5jb25uZWN0KHRoaXMuX201KTtcbiAgdGhpcy5faW5YLmNvbm5lY3QodGhpcy5fbTYpO1xuICB0aGlzLl9pblguY29ubmVjdCh0aGlzLl9tNyk7XG4gIHRoaXMuX2luWC5jb25uZWN0KHRoaXMuX204KTtcbiAgdGhpcy5fbTAuY29ubmVjdCh0aGlzLl9vdXRZKTtcbiAgdGhpcy5fbTEuY29ubmVjdCh0aGlzLl9vdXRaKTtcbiAgdGhpcy5fbTIuY29ubmVjdCh0aGlzLl9vdXRYKTtcbiAgdGhpcy5fbTMuY29ubmVjdCh0aGlzLl9vdXRZKTtcbiAgdGhpcy5fbTQuY29ubmVjdCh0aGlzLl9vdXRaKTtcbiAgdGhpcy5fbTUuY29ubmVjdCh0aGlzLl9vdXRYKTtcbiAgdGhpcy5fbTYuY29ubmVjdCh0aGlzLl9vdXRZKTtcbiAgdGhpcy5fbTcuY29ubmVjdCh0aGlzLl9vdXRaKTtcbiAgdGhpcy5fbTguY29ubmVjdCh0aGlzLl9vdXRYKTtcblxuICAvLyBUcmFuc2Zvcm0gMzogd29ybGQgc3BhY2UgdG8gYXVkaW8gc3BhY2UuXG4gIC8vIFcgLT4gVyAodG8gY2hhbm5lbCAwKVxuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG4gIC8vIFkgKHRvIGNoYW5uZWwgMSlcbiAgdGhpcy5fb3V0WS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMSk7XG4gIC8vIFogKHRvIGNoYW5uZWwgMilcbiAgdGhpcy5fb3V0Wi5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMik7XG4gIC8vIFggKHRvIGNoYW5uZWwgMylcbiAgdGhpcy5fb3V0WC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMyk7XG4gIHRoaXMuX291dFkuZ2Fpbi52YWx1ZSA9IC0xO1xuICB0aGlzLl9vdXRYLmdhaW4udmFsdWUgPSAtMTtcblxuICB0aGlzLnNldFJvdGF0aW9uTWF0cml4MyhuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSkpO1xuXG4gIC8vIGlucHV0L291dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX3NwbGl0dGVyO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX21lcmdlcjtcbn1cblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDN4MyBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDMgLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJvdGF0b3IucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4Mykge1xuICB0aGlzLl9tMC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzBdO1xuICB0aGlzLl9tMS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzFdO1xuICB0aGlzLl9tMi5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzJdO1xuICB0aGlzLl9tMy5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzNdO1xuICB0aGlzLl9tNC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzRdO1xuICB0aGlzLl9tNS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzVdO1xuICB0aGlzLl9tNi5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzZdO1xuICB0aGlzLl9tNy5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzddO1xuICB0aGlzLl9tOC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXgzWzhdO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDR4NCBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDQgLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJvdGF0b3IucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4NCkge1xuICB0aGlzLl9tMC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzBdO1xuICB0aGlzLl9tMS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzFdO1xuICB0aGlzLl9tMi5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzJdO1xuICB0aGlzLl9tMy5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzRdO1xuICB0aGlzLl9tNC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzVdO1xuICB0aGlzLl9tNS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzZdO1xuICB0aGlzLl9tNi5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzhdO1xuICB0aGlzLl9tNy5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzldO1xuICB0aGlzLl9tOC5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzEwXTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJvdGF0b3IucHJvdG90eXBlLmdldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHRoaXMuX20wLmdhaW4udmFsdWUsIHRoaXMuX20xLmdhaW4udmFsdWUsIHRoaXMuX20yLmdhaW4udmFsdWUsXG4gICAgdGhpcy5fbTMuZ2Fpbi52YWx1ZSwgdGhpcy5fbTQuZ2Fpbi52YWx1ZSwgdGhpcy5fbTUuZ2Fpbi52YWx1ZSxcbiAgICB0aGlzLl9tNi5nYWluLnZhbHVlLCB0aGlzLl9tNy5nYWluLnZhbHVlLCB0aGlzLl9tOC5nYWluLnZhbHVlLFxuICBdO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgNHg0IHJvdGF0aW9uIG1hdHJpeC5cbiAqIEByZXR1cm4ge051bWJlcltdfSAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUm90YXRvci5wcm90b3R5cGUuZ2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24oKSB7XG4gIGxldCByb3RhdGlvbk1hdHJpeDQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgcm90YXRpb25NYXRyaXg0WzBdID0gdGhpcy5fbTAuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzFdID0gdGhpcy5fbTEuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzJdID0gdGhpcy5fbTIuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzRdID0gdGhpcy5fbTMuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzVdID0gdGhpcy5fbTQuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzZdID0gdGhpcy5fbTUuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzhdID0gdGhpcy5fbTYuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzldID0gdGhpcy5fbTcuZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzEwXSA9IHRoaXMuX204LmdhaW4udmFsdWU7XG4gIHJldHVybiByb3RhdGlvbk1hdHJpeDQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BUm90YXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIEEgY29sbGVjdGlvbiBvZiBjb252b2x2ZXJzLiBDYW4gYmUgdXNlZCBmb3IgdGhlIG9wdGltaXplZCBGT0EgYmluYXVyYWxcbiAqIHJlbmRlcmluZy4gKGUuZy4gU0gtTWF4UmUgSFJURnMpXG4gKi9cblxuXG5cblxuLyoqXG4gKiBGT0FDb252b2x2ZXIuIEEgY29sbGVjdGlvbiBvZiAyIHN0ZXJlbyBjb252b2x2ZXJzIGZvciA0LWNoYW5uZWwgRk9BIHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IFRoZSBhc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gW2hyaXJCdWZmZXJMaXN0XSAtIEFuIG9yZGVyZWQtbGlzdCBvZiBzdGVyZW9cbiAqIEF1ZGlvQnVmZmVycyBmb3IgY29udm9sdXRpb24uIChpLmUuIDIgc3RlcmVvIEF1ZGlvQnVmZmVycyBmb3IgRk9BKVxuICovXG5mdW5jdGlvbiBGT0FDb252b2x2ZXIoY29udGV4dCwgaHJpckJ1ZmZlckxpc3QpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2lzQnVmZmVyTG9hZGVkID0gZmFsc2U7XG5cbiAgdGhpcy5fYnVpbGRBdWRpb0dyYXBoKCk7XG5cbiAgaWYgKGhyaXJCdWZmZXJMaXN0KSB7XG4gICAgdGhpcy5zZXRIUklSQnVmZmVyTGlzdChocmlyQnVmZmVyTGlzdCk7XG4gIH1cblxuICB0aGlzLmVuYWJsZSgpO1xufVxuXG5cbi8qKlxuICogQnVpbGQgdGhlIGludGVybmFsIGF1ZGlvIGdyYXBoLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkZPQUNvbnZvbHZlci5wcm90b3R5cGUuX2J1aWxkQXVkaW9HcmFwaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zcGxpdHRlcldZWlggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5fbWVyZ2VyV1kgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gIHRoaXMuX21lcmdlclpYID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICB0aGlzLl9jb252b2x2ZXJXWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gIHRoaXMuX2NvbnZvbHZlclpYID0gdGhpcy5fY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICB0aGlzLl9zcGxpdHRlclpYID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG4gIHRoaXMuX2ludmVydGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX21lcmdlckJpbmF1cmFsID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICB0aGlzLl9zdW1taW5nQnVzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gR3JvdXAgVyBhbmQgWSwgdGhlbiBaIGFuZCBYLlxuICB0aGlzLl9zcGxpdHRlcldZWlguY29ubmVjdCh0aGlzLl9tZXJnZXJXWSwgMCwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyV1laWC5jb25uZWN0KHRoaXMuX21lcmdlcldZLCAxLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWVpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyWlgsIDIsIDApO1xuICB0aGlzLl9zcGxpdHRlcldZWlguY29ubmVjdCh0aGlzLl9tZXJnZXJaWCwgMywgMSk7XG5cbiAgLy8gQ3JlYXRlIGEgbmV0d29yayBvZiBjb252b2x2ZXJzIHVzaW5nIHNwbGl0dGVyL21lcmdlci5cbiAgdGhpcy5fbWVyZ2VyV1kuY29ubmVjdCh0aGlzLl9jb252b2x2ZXJXWSk7XG4gIHRoaXMuX21lcmdlclpYLmNvbm5lY3QodGhpcy5fY29udm9sdmVyWlgpO1xuICB0aGlzLl9jb252b2x2ZXJXWS5jb25uZWN0KHRoaXMuX3NwbGl0dGVyV1kpO1xuICB0aGlzLl9jb252b2x2ZXJaWC5jb25uZWN0KHRoaXMuX3NwbGl0dGVyWlgpO1xuICB0aGlzLl9zcGxpdHRlcldZLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDAsIDApO1xuICB0aGlzLl9zcGxpdHRlcldZLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDAsIDEpO1xuICB0aGlzLl9zcGxpdHRlcldZLmNvbm5lY3QodGhpcy5fbWVyZ2VyQmluYXVyYWwsIDEsIDApO1xuICB0aGlzLl9zcGxpdHRlcldZLmNvbm5lY3QodGhpcy5faW52ZXJ0ZXIsIDEsIDApO1xuICB0aGlzLl9pbnZlcnRlci5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAwLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJaWC5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAwLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJaWC5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAwLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJaWC5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAxLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJaWC5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAxLCAxKTtcblxuICAvLyBCeSBkZWZhdWx0LCBXZWJBdWRpbydzIGNvbnZvbHZlciBkb2VzIHRoZSBub3JtYWxpemF0aW9uIGJhc2VkIG9uIElSJ3NcbiAgLy8gZW5lcmd5LiBGb3IgdGhlIHByZWNpc2UgY29udm9sdXRpb24sIGl0IG11c3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRoZSBidWZmZXJcbiAgLy8gYXNzaWdubWVudC5cbiAgdGhpcy5fY29udm9sdmVyV1kubm9ybWFsaXplID0gZmFsc2U7XG4gIHRoaXMuX2NvbnZvbHZlclpYLm5vcm1hbGl6ZSA9IGZhbHNlO1xuXG4gIC8vIEZvciBhc3ltbWV0cmljIGRlZ3JlZS5cbiAgdGhpcy5faW52ZXJ0ZXIuZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gIC8vIElucHV0L291dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX3NwbGl0dGVyV1laWDtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9zdW1taW5nQnVzO1xufTtcblxuXG4vKipcbiAqIEFzc2lnbnMgMiBIUklSIEF1ZGlvQnVmZmVycyB0byAyIGNvbnZvbHZlcnM6IE5vdGUgdGhhdCB3ZSB1c2UgMiBzdGVyZW9cbiAqIGNvbnZvbHV0aW9ucyBmb3IgNC1jaGFubmVsIGRpcmVjdCBjb252b2x1dGlvbi4gVXNpbmcgbW9ubyBjb252b2x2ZXIgb3JcbiAqIDQtY2hhbm5lbCBjb252b2x2ZXIgaXMgbm90IHZpYWJsZSBiZWNhdXNlIG1vbm8gY29udm9sdXRpb24gd2FzdGVmdWxseVxuICogcHJvZHVjZXMgdGhlIHN0ZXJlbyBvdXRwdXRzLCBhbmQgdGhlIDQtY2ggY29udm9sdmVyIGRvZXMgY3Jvc3MtY2hhbm5lbFxuICogY29udm9sdXRpb24uIChTZWUgV2ViIEF1ZGlvIEFQSSBzcGVjKVxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBocmlyQnVmZmVyTGlzdCAtIEFuIGFycmF5IG9mIHN0ZXJlbyBBdWRpb0J1ZmZlcnMgZm9yXG4gKiBjb252b2x2ZXJzLlxuICovXG5GT0FDb252b2x2ZXIucHJvdG90eXBlLnNldEhSSVJCdWZmZXJMaXN0ID0gZnVuY3Rpb24oaHJpckJ1ZmZlckxpc3QpIHtcbiAgLy8gQWZ0ZXIgdGhlc2UgYXNzaWdubWVudHMsIHRoZSBjaGFubmVsIGRhdGEgaW4gdGhlIGJ1ZmZlciBpcyBpbW11dGFibGUgaW5cbiAgLy8gRmlyZUZveC4gKGkuZS4gbmV1dGVyZWQpIFNvIHdlIHNob3VsZCBhdm9pZCByZS1hc3NpZ25pbmcgYnVmZmVycywgb3RoZXJ3aXNlXG4gIC8vIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAgaWYgKHRoaXMuX2lzQnVmZmVyTG9hZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY29udm9sdmVyV1kuYnVmZmVyID0gaHJpckJ1ZmZlckxpc3RbMF07XG4gIHRoaXMuX2NvbnZvbHZlclpYLmJ1ZmZlciA9IGhyaXJCdWZmZXJMaXN0WzFdO1xuICB0aGlzLl9pc0J1ZmZlckxvYWRlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogRW5hYmxlIEZPQUNvbnZvbHZlciBpbnN0YW5jZS4gVGhlIGF1ZGlvIGdyYXBoIHdpbGwgYmUgYWN0aXZhdGVkIGFuZCBwdWxsZWQgYnlcbiAqIHRoZSBXZWJBdWRpbyBlbmdpbmUuIChpLmUuIGNvbnN1bWUgQ1BVIGN5Y2xlKVxuICovXG5GT0FDb252b2x2ZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tZXJnZXJCaW5hdXJhbC5jb25uZWN0KHRoaXMuX3N1bW1pbmdCdXMpO1xuICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIERpc2FibGUgRk9BQ29udm9sdmVyIGluc3RhbmNlLiBUaGUgaW5uZXIgZ3JhcGggd2lsbCBiZSBkaXNjb25uZWN0ZWQgZnJvbSB0aGVcbiAqIGF1ZGlvIGRlc3RpbmF0aW9uLCB0aHVzIG5vIENQVSBjeWNsZSB3aWxsIGJlIGNvbnN1bWVkLlxuICovXG5GT0FDb252b2x2ZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbWVyZ2VyQmluYXVyYWwuZGlzY29ubmVjdCgpO1xuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FDb252b2x2ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBERVBSRUNBVEVEIGF0IFYxLiBBdWRpbyBidWZmZXIgbG9hZGluZyB1dGlsaXR5LlxuICovXG5cblxuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8qKlxuICogU3RyZWFtbGluZWQgYXVkaW8gZmlsZSBsb2FkZXIgc3VwcG9ydHMgUHJvbWlzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0ICAgICAgICAgIEF1ZGlvQ29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGF1ZGlvRmlsZURhdGEgICAgQXVkaW8gZmlsZSBpbmZvIGFzIFt7bmFtZSwgdXJsfV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgICAgICAgIFJlc29sdXRpb24gaGFuZGxlciBmb3IgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCAgICAgICAgIFJlamVjdGlvbiBoYW5kbGVyIGZvciBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZ3Jlc3MgICAgICAgUHJvZ3Jlc3MgZXZlbnQgaGFuZGxlci5cbiAqL1xuZnVuY3Rpb24gQXVkaW9CdWZmZXJNYW5hZ2VyKGNvbnRleHQsIGF1ZGlvRmlsZURhdGEsIHJlc29sdmUsIHJlamVjdCwgcHJvZ3Jlc3MpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5fYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5fbG9hZGluZ1Rhc2tzID0ge307XG5cbiAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgdGhpcy5fcHJvZ3Jlc3MgPSBwcm9ncmVzcztcblxuICAvLyBJdGVyYXRpbmcgZmlsZSBsb2FkaW5nLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvRmlsZURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF1ZGlvRmlsZURhdGFbaV07XG5cbiAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlcyBmaWxlbmFtZSBhbmQgcXVpdCBpZiBpdCBoYXBwZW5zLlxuICAgIGlmICh0aGlzLl9sb2FkaW5nVGFza3MuaGFzT3duUHJvcGVydHkoZmlsZUluZm8ubmFtZSkpIHtcbiAgICAgIFV0aWxzLmxvZygnRHVwbGljYXRlZCBmaWxlbmFtZSB3aGVuIGxvYWRpbmc6ICcgKyBmaWxlSW5mby5uYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYXJrIGl0IGFzIHBlbmRpbmcgKDApXG4gICAgdGhpcy5fbG9hZGluZ1Rhc2tzW2ZpbGVJbmZvLm5hbWVdID0gMDtcbiAgICB0aGlzLl9sb2FkQXVkaW9GaWxlKGZpbGVJbmZvKTtcbiAgfVxufVxuXG5BdWRpb0J1ZmZlck1hbmFnZXIucHJvdG90eXBlLl9sb2FkQXVkaW9GaWxlID0gZnVuY3Rpb24oZmlsZUluZm8pIHtcbiAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhoci5vcGVuKCdHRVQnLCBmaWxlSW5mby51cmwpO1xuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHRoYXQuX2NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHhoci5yZXNwb25zZSxcbiAgICAgICAgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgLy8gVXRpbHMubG9nKCdGaWxlIGxvYWRlZDogJyArIGZpbGVJbmZvLnVybCk7XG4gICAgICAgICAgdGhhdC5fZG9uZShmaWxlSW5mby5uYW1lLCBidWZmZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgVXRpbHMubG9nKCdEZWNvZGluZyBmYWlsdXJlOiAnXG4gICAgICAgICAgICArIGZpbGVJbmZvLnVybCArICcgKCcgKyBtZXNzYWdlICsgJyknKTtcbiAgICAgICAgICB0aGF0Ll9kb25lKGZpbGVJbmZvLm5hbWUsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMubG9nKCdYSFIgRXJyb3I6ICcgKyBmaWxlSW5mby51cmwgKyAnICgnICsgeGhyLnN0YXR1c1RleHRcbiAgICAgICAgKyAnKScpO1xuICAgICAgdGhhdC5fZG9uZShmaWxlSW5mby5uYW1lLCBudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETzogZmV0Y2ggbG9jYWwgcmVzb3VyY2VzIGlmIFhIUiBmYWlscy5cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgIFV0aWxzLmxvZygnWEhSIE5ldHdvcmsgZmFpbHVyZTogJyArIGZpbGVJbmZvLnVybCk7XG4gICAgdGhhdC5fZG9uZShmaWxlSW5mby5uYW1lLCBudWxsKTtcbiAgfTtcblxuICB4aHIuc2VuZCgpO1xufTtcblxuQXVkaW9CdWZmZXJNYW5hZ2VyLnByb3RvdHlwZS5fZG9uZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBidWZmZXIpIHtcbiAgLy8gTGFiZWwgdGhlIGxvYWRpbmcgdGFzay5cbiAgdGhpcy5fbG9hZGluZ1Rhc2tzW2ZpbGVuYW1lXSA9IGJ1ZmZlciAhPT0gbnVsbCA/ICdsb2FkZWQnIDogJ2ZhaWxlZCc7XG5cbiAgLy8gQSBmYWlsZWQgdGFzayB3aWxsIGJlIGEgbnVsbCBidWZmZXIuXG4gIHRoaXMuX2J1ZmZlcnMuc2V0KGZpbGVuYW1lLCBidWZmZXIpO1xuXG4gIHRoaXMuX3VwZGF0ZVByb2dyZXNzKGZpbGVuYW1lKTtcbn07XG5cbkF1ZGlvQnVmZmVyTWFuYWdlci5wcm90b3R5cGUuX3VwZGF0ZVByb2dyZXNzID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgbGV0IG51bWJlck9mRmluaXNoZWRUYXNrcyA9IDA7XG4gIGxldCBudW1iZXJPZkZhaWxlZFRhc2sgPSAwO1xuICBsZXQgbnVtYmVyT2ZUYXNrcyA9IDA7XG5cbiAgZm9yIChjb25zdCB0YXNrIGluIHRoaXMuX2xvYWRpbmdUYXNrcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fbG9hZGluZ1Rhc2tzLCB0YXNrKSkge1xuICAgICAgbnVtYmVyT2ZUYXNrcysrO1xuICAgICAgaWYgKHRoaXMuX2xvYWRpbmdUYXNrc1t0YXNrXSA9PT0gJ2xvYWRlZCcpIHtcbiAgICAgICAgbnVtYmVyT2ZGaW5pc2hlZFRhc2tzKys7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvYWRpbmdUYXNrc1t0YXNrXSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgbnVtYmVyT2ZGYWlsZWRUYXNrKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9wcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX3Byb2dyZXNzKGZpbGVuYW1lLCBudW1iZXJPZkZpbmlzaGVkVGFza3MsIG51bWJlck9mVGFza3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChudW1iZXJPZkZpbmlzaGVkVGFza3MgPT09IG51bWJlck9mVGFza3MpIHtcbiAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX2J1ZmZlcnMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChudW1iZXJPZkZpbmlzaGVkVGFza3MgKyBudW1iZXJPZkZhaWxlZFRhc2sgPT09IG51bWJlck9mVGFza3MpIHtcbiAgICB0aGlzLl9yZWplY3QodGhpcy5fYnVmZmVycyk7XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1ZGlvQnVmZmVyTWFuYWdlcjtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIFBoYXNlIG1hdGNoZWQgZmlsdGVyIGZvciBmaXJzdC1vcmRlci1hbWJpc29uaWNzIGRlY29kaW5nLlxuICovXG5cblxuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLy8gU3RhdGljIHBhcmFtZXRlcnMuXG5jb25zdCBDUk9TU09WRVJfRlJFUVVFTkNZID0gNjkwO1xuY29uc3QgR0FJTl9DT0VGRklDSUVOVFMgPSBbMS40MTQyLCAwLjgxNjYsIDAuODE2NiwgMC44MTY2XTtcblxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBjb2VmZmljaWVudHMgZm9yIGR1YWwgYmFuZCBmaWx0ZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gY3Jvc3NvdmVyRnJlcXVlbmN5XG4gKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZVxuICogQHJldHVybiB7T2JqZWN0fSBGaWx0ZXIgY29lZmZpY2llbnRzLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUR1YWxCYW5kQ29lZmZpY2llbnRzKGNyb3Nzb3ZlckZyZXF1ZW5jeSwgc2FtcGxlUmF0ZSkge1xuICBjb25zdCBrID0gTWF0aC50YW4oTWF0aC5QSSAqIGNyb3Nzb3ZlckZyZXF1ZW5jeSAvIHNhbXBsZVJhdGUpO1xuICBjb25zdCBrMiA9IGsgKiBrO1xuICBjb25zdCBkZW5vbWluYXRvciA9IGsyICsgMiAqIGsgKyAxO1xuXG4gIHJldHVybiB7XG4gICAgbG93cGFzc0E6IFsxLCAyICogKGsyIC0gMSkgLyBkZW5vbWluYXRvciwgKGsyIC0gMiAqIGsgKyAxKSAvIGRlbm9taW5hdG9yXSxcbiAgICBsb3dwYXNzQjogW2syIC8gZGVub21pbmF0b3IsIDIgKiBrMiAvIGRlbm9taW5hdG9yLCBrMiAvIGRlbm9taW5hdG9yXSxcbiAgICBoaXBhc3NBOiBbMSwgMiAqIChrMiAtIDEpIC8gZGVub21pbmF0b3IsIChrMiAtIDIgKiBrICsgMSkgLyBkZW5vbWluYXRvcl0sXG4gICAgaGlwYXNzQjogWzEgLyBkZW5vbWluYXRvciwgLTIgKiAxIC8gZGVub21pbmF0b3IsIDEgLyBkZW5vbWluYXRvcl0sXG4gIH07XG59XG5cblxuLyoqXG4gKiBGT0FQaGFzZU1hdGNoZWRGaWx0ZXI6IEEgc2V0IG9mIGZpbHRlcnMgKExQL0hQKSB3aXRoIGEgY3Jvc3NvdmVyIGZyZXF1ZW5jeSB0b1xuICogY29tcGVuc2F0ZSB0aGUgZ2FpbiBvZiBoaWdoIGZyZXF1ZW5jeSBjb250ZW50cyB3aXRob3V0IGEgcGhhc2UgZGlmZmVyZW5jZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gRk9BUGhhc2VNYXRjaGVkRmlsdGVyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5faW5wdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICBpZiAoIXRoaXMuX2NvbnRleHQuY3JlYXRlSUlSRmlsdGVyKSB7XG4gICAgVXRpbHMubG9nKCdJSVIgZmlsdGVyIGlzIG1pc3NpbmcuIFVzaW5nIEJpcXVhZCBmaWx0ZXIgaW5zdGVhZC4nKTtcbiAgICB0aGlzLl9scGYgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgIHRoaXMuX2hwZiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgdGhpcy5fbHBmLmZyZXF1ZW5jeS52YWx1ZSA9IENST1NTT1ZFUl9GUkVRVUVOQ1k7XG4gICAgdGhpcy5faHBmLmZyZXF1ZW5jeS52YWx1ZSA9IENST1NTT1ZFUl9GUkVRVUVOQ1k7XG4gICAgdGhpcy5faHBmLnR5cGUgPSAnaGlnaHBhc3MnO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZWYgPSBnZW5lcmF0ZUR1YWxCYW5kQ29lZmZpY2llbnRzKENST1NTT1ZFUl9GUkVRVUVOQ1ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlKTtcbiAgICB0aGlzLl9scGYgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUlJUkZpbHRlcihjb2VmLmxvd3Bhc3NCLCBjb2VmLmxvd3Bhc3NBKTtcbiAgICB0aGlzLl9ocGYgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUlJUkZpbHRlcihjb2VmLmhpcGFzc0IsIGNvZWYuaGlwYXNzQSk7XG4gIH1cblxuICB0aGlzLl9zcGxpdHRlckxvdyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9zcGxpdHRlckhpZ2ggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5fZ2FpbkhpZ2hXID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2dhaW5IaWdoWSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9nYWluSGlnaFogPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fZ2FpbkhpZ2hYID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX21lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcig0KTtcblxuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2hwZik7XG4gIHRoaXMuX2hwZi5jb25uZWN0KHRoaXMuX3NwbGl0dGVySGlnaCk7XG4gIHRoaXMuX3NwbGl0dGVySGlnaC5jb25uZWN0KHRoaXMuX2dhaW5IaWdoVywgMCk7XG4gIHRoaXMuX3NwbGl0dGVySGlnaC5jb25uZWN0KHRoaXMuX2dhaW5IaWdoWSwgMSk7XG4gIHRoaXMuX3NwbGl0dGVySGlnaC5jb25uZWN0KHRoaXMuX2dhaW5IaWdoWiwgMik7XG4gIHRoaXMuX3NwbGl0dGVySGlnaC5jb25uZWN0KHRoaXMuX2dhaW5IaWdoWCwgMyk7XG4gIHRoaXMuX2dhaW5IaWdoVy5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG4gIHRoaXMuX2dhaW5IaWdoWS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMSk7XG4gIHRoaXMuX2dhaW5IaWdoWi5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMik7XG4gIHRoaXMuX2dhaW5IaWdoWC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMyk7XG5cbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9scGYpO1xuICB0aGlzLl9scGYuY29ubmVjdCh0aGlzLl9zcGxpdHRlckxvdyk7XG4gIHRoaXMuX3NwbGl0dGVyTG93LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJMb3cuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDEsIDEpO1xuICB0aGlzLl9zcGxpdHRlckxvdy5jb25uZWN0KHRoaXMuX21lcmdlciwgMiwgMik7XG4gIHRoaXMuX3NwbGl0dGVyTG93LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAzLCAzKTtcblxuICAvLyBBcHBseSBnYWluIGNvcnJlY3Rpb24gdG8gaGktcGFzc2VkIHByZXNzdXJlIGFuZCB2ZWxvY2l0eSBjb21wb25lbnRzOlxuICAvLyBJbnZlcnRpbmcgc2lnbiBpcyBuZWNlc3NhcnkgYXMgdGhlIGxvdy1wYXNzZWQgYW5kIGhpZ2gtcGFzc2VkIHBvcnRpb24gYXJlXG4gIC8vIG91dC1vZi1waGFzZSBhZnRlciB0aGUgZmlsdGVyaW5nLlxuICBjb25zdCBub3cgPSB0aGlzLl9jb250ZXh0LmN1cnJlbnRUaW1lO1xuICB0aGlzLl9nYWluSGlnaFcuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgtMSAqIEdBSU5fQ09FRkZJQ0lFTlRTWzBdLCBub3cpO1xuICB0aGlzLl9nYWluSGlnaFkuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgtMSAqIEdBSU5fQ09FRkZJQ0lFTlRTWzFdLCBub3cpO1xuICB0aGlzLl9nYWluSGlnaFouZ2Fpbi5zZXRWYWx1ZUF0VGltZSgtMSAqIEdBSU5fQ09FRkZJQ0lFTlRTWzJdLCBub3cpO1xuICB0aGlzLl9nYWluSGlnaFguZ2Fpbi5zZXRWYWx1ZUF0VGltZSgtMSAqIEdBSU5fQ09FRkZJQ0lFTlRTWzNdLCBub3cpO1xuXG4gIC8vIElucHV0L291dHB1dCBQcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2lucHV0O1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX21lcmdlcjtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVBoYXNlTWF0Y2hlZEZpbHRlcjtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIFZpcnR1YWwgc3BlYWtlciBhYnN0cmFjdGlvbiBmb3IgZmlyc3Qtb3JkZXItYW1iaXNvbmljcyBkZWNvZGluZy5cbiAqL1xuXG5cblxuXG4vKipcbiAqIERFUFJFQ0FURUQgYXQgVjE6IEEgdmlydHVhbCBzcGVha2VyIHdpdGggYW1iaXNvbmljIGRlY29kaW5nIGdhaW4gY29lZmZpY2llbnRzXG4gKiBhbmQgSFJURiBjb252b2x1dGlvbiBmb3IgZmlyc3Qtb3JkZXItYW1iaXNvbmljcyBzdHJlYW0uIE5vdGUgdGhhdCB0aGVcbiAqIHN1YmdyYXBoIGRpcmVjdGx5IGNvbm5lY3RzIHRvIGNvbnRleHQncyBkZXN0aW5hdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3Igc3BlYWtlci5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG9wdGlvbnMuY29lZmZpY2llbnRzIC0gRGVjb2RpbmcgY29lZmZpY2llbnRzIGZvciAoVyxZLFosWCkuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBvcHRpb25zLklSIC0gU3RlcmVvIElSIGJ1ZmZlciBmb3IgSFJURiBjb252b2x1dGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmdhaW4gLSBQb3N0LWdhaW4gZm9yIHRoZSBzcGVha2VyLlxuICovXG5mdW5jdGlvbiBGT0FWaXJ0dWFsU3BlYWtlcihjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLklSLm51bWJlck9mQ2hhbm5lbHMgIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lSIGRvZXMgbm90IGhhdmUgMiBjaGFubmVscy4gY2Fubm90IHByb2NlZWQuJyk7XG4gIH1cblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5faW5wdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5fY1cgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fY1kgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fY1ogPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fY1ggPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fY29udm9sdmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgdGhpcy5fZ2FpbiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5fY1csIDApO1xuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2NZLCAxKTtcbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9jWiwgMik7XG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5fY1gsIDMpO1xuICB0aGlzLl9jVy5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcik7XG4gIHRoaXMuX2NZLmNvbm5lY3QodGhpcy5fY29udm9sdmVyKTtcbiAgdGhpcy5fY1ouY29ubmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuICB0aGlzLl9jWC5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcik7XG4gIHRoaXMuX2NvbnZvbHZlci5jb25uZWN0KHRoaXMuX2dhaW4pO1xuICB0aGlzLl9nYWluLmNvbm5lY3QodGhpcy5fY29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgdGhpcy5lbmFibGUoKTtcblxuICB0aGlzLl9jb252b2x2ZXIubm9ybWFsaXplID0gZmFsc2U7XG4gIHRoaXMuX2NvbnZvbHZlci5idWZmZXIgPSBvcHRpb25zLklSO1xuICB0aGlzLl9nYWluLmdhaW4udmFsdWUgPSBvcHRpb25zLmdhaW47XG5cbiAgLy8gU2V0IGdhaW4gY29lZmZpY2llbnRzIGZvciBGT0EgYW1iaXNvbmljIHN0cmVhbXMuXG4gIHRoaXMuX2NXLmdhaW4udmFsdWUgPSBvcHRpb25zLmNvZWZmaWNpZW50c1swXTtcbiAgdGhpcy5fY1kuZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuY29lZmZpY2llbnRzWzFdO1xuICB0aGlzLl9jWi5nYWluLnZhbHVlID0gb3B0aW9ucy5jb2VmZmljaWVudHNbMl07XG4gIHRoaXMuX2NYLmdhaW4udmFsdWUgPSBvcHRpb25zLmNvZWZmaWNpZW50c1szXTtcblxuICAvLyBJbnB1dCBwcm94eS4gT3V0cHV0IGRpcmVjdGx5IGNvbm5lY3RzIHRvIHRoZSBkZXN0aW5hdGlvbi5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2lucHV0O1xufVxuXG5cbkZPQVZpcnR1YWxTcGVha2VyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZ2Fpbi5jb25uZWN0KHRoaXMuX2NvbnRleHQuZGVzdGluYXRpb24pO1xuICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xufTtcblxuXG5GT0FWaXJ0dWFsU3BlYWtlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9nYWluLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BVmlydHVhbFNwZWFrZXI7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBBIGNvbGxlY3Rpb24gb2YgY29udm9sdmVycy4gQ2FuIGJlIHVzZWQgZm9yIHRoZSBvcHRpbWl6ZWQgSE9BIGJpbmF1cmFsXG4gKiByZW5kZXJpbmcuIChlLmcuIFNILU1heFJlIEhSVEZzKVxuICovXG5cblxuXG5cbi8qKlxuICogQSBjb252b2x2ZXIgbmV0d29yayBmb3IgTi1jaGFubmVsIEhPQSBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgLSBBbWJpc29uaWMgb3JkZXIuICgyIG9yIDMpXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IFtocmlyQnVmZmVyTGlzdF0gLSBBbiBvcmRlcmVkLWxpc3Qgb2Ygc3RlcmVvXG4gKiBBdWRpb0J1ZmZlcnMgZm9yIGNvbnZvbHV0aW9uLiAoU09BOiA1IEF1ZGlvQnVmZmVycywgVE9BOiA4IEF1ZGlvQnVmZmVycylcbiAqL1xuZnVuY3Rpb24gSE9BQ29udm9sdmVyKGNvbnRleHQsIGFtYmlzb25pY09yZGVyLCBocmlyQnVmZmVyTGlzdCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5faXNCdWZmZXJMb2FkZWQgPSBmYWxzZTtcblxuICAvLyBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzIEsgYmFzZWQgb24gdGhlIGFtYmlzb25pYyBvcmRlciBOIHdoZXJlIEsgPSAoTisxKV4yLlxuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9IGFtYmlzb25pY09yZGVyO1xuICB0aGlzLl9udW1iZXJPZkNoYW5uZWxzID1cbiAgICAgICh0aGlzLl9hbWJpc29uaWNPcmRlciArIDEpICogKHRoaXMuX2FtYmlzb25pY09yZGVyICsgMSk7XG5cbiAgdGhpcy5fYnVpbGRBdWRpb0dyYXBoKCk7XG4gIGlmIChocmlyQnVmZmVyTGlzdCkge1xuICAgIHRoaXMuc2V0SFJJUkJ1ZmZlckxpc3QoaHJpckJ1ZmZlckxpc3QpO1xuICB9XG5cbiAgdGhpcy5lbmFibGUoKTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkIHRoZSBpbnRlcm5hbCBhdWRpbyBncmFwaC5cbiAqIEZvciBUT0EgY29udm9sdXRpb246XG4gKiAgIGlucHV0IC0+IHNwbGl0dGVyKDE2KSAtWzAsMV0tPiBtZXJnZXIoMikgLT4gY29udm9sdmVyKDIpIC0+IHNwbGl0dGVyKDIpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAtWzIsM10tPiBtZXJnZXIoMikgLT4gY29udm9sdmVyKDIpIC0+IHNwbGl0dGVyKDIpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAtWzQsNV0tPiAuLi4gKDYgbW9yZSwgOCBicmFuY2hlcyB0b3RhbClcbiAqIEBwcml2YXRlXG4gKi9cbkhPQUNvbnZvbHZlci5wcm90b3R5cGUuX2J1aWxkQXVkaW9HcmFwaCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBudW1iZXJPZlN0ZXJlb0NoYW5uZWxzID0gTWF0aC5jZWlsKHRoaXMuX251bWJlck9mQ2hhbm5lbHMgLyAyKTtcblxuICB0aGlzLl9pbnB1dFNwbGl0dGVyID1cbiAgICAgIHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKHRoaXMuX251bWJlck9mQ2hhbm5lbHMpO1xuICB0aGlzLl9zdGVyZW9NZXJnZXJzID0gW107XG4gIHRoaXMuX2NvbnZvbHZlcnMgPSBbXTtcbiAgdGhpcy5fc3RlcmVvU3BsaXR0ZXJzID0gW107XG4gIHRoaXMuX3Bvc2l0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fbmVnYXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9pbnZlcnRlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9iaW5hdXJhbE1lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiAgdGhpcy5fb3V0cHV0R2FpbiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdGVyZW9DaGFubmVsczsgKytpKSB7XG4gICAgdGhpcy5fc3RlcmVvTWVyZ2Vyc1tpXSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiAgICB0aGlzLl9jb252b2x2ZXJzW2ldID0gdGhpcy5fY29udGV4dC5jcmVhdGVDb252b2x2ZXIoKTtcbiAgICB0aGlzLl9zdGVyZW9TcGxpdHRlcnNbaV0gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiAgICB0aGlzLl9jb252b2x2ZXJzW2ldLm5vcm1hbGl6ZSA9IGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgbCA9IDA7IGwgPD0gdGhpcy5fYW1iaXNvbmljT3JkZXI7ICsrbCkge1xuICAgIGZvciAobGV0IG0gPSAtbDsgbSA8PSBsOyBtKyspIHtcbiAgICAgIC8vIFdlIGNvbXB1dGUgdGhlIEFDTiBpbmRleCAoaykgb2YgYW1iaXNvbmljcyBjaGFubmVsIHVzaW5nIHRoZSBkZWdyZWUgKGwpXG4gICAgICAvLyBhbmQgaW5kZXggKG0pOiBrID0gbF4yICsgbCArIG1cbiAgICAgIGNvbnN0IGFjbkluZGV4ID0gbCAqIGwgKyBsICsgbTtcbiAgICAgIGNvbnN0IHN0ZXJlb0luZGV4ID0gTWF0aC5mbG9vcihhY25JbmRleCAvIDIpO1xuXG4gICAgICAvLyBTcGxpdCBjaGFubmVscyBmcm9tIGlucHV0IGludG8gYXJyYXkgb2Ygc3RlcmVvIGNvbnZvbHZlcnMuXG4gICAgICAvLyBUaGVuIGNyZWF0ZSBhIG5ldHdvcmsgb2YgbWVyZ2VycyB0aGF0IHByb2R1Y2VzIHRoZSBzdGVyZW8gb3V0cHV0LlxuICAgICAgdGhpcy5faW5wdXRTcGxpdHRlci5jb25uZWN0KFxuICAgICAgICAgIHRoaXMuX3N0ZXJlb01lcmdlcnNbc3RlcmVvSW5kZXhdLCBhY25JbmRleCwgYWNuSW5kZXggJSAyKTtcbiAgICAgIHRoaXMuX3N0ZXJlb01lcmdlcnNbc3RlcmVvSW5kZXhdLmNvbm5lY3QodGhpcy5fY29udm9sdmVyc1tzdGVyZW9JbmRleF0pO1xuICAgICAgdGhpcy5fY29udm9sdmVyc1tzdGVyZW9JbmRleF0uY29ubmVjdCh0aGlzLl9zdGVyZW9TcGxpdHRlcnNbc3RlcmVvSW5kZXhdKTtcblxuICAgICAgLy8gUG9zaXRpdmUgaW5kZXggKG0gPj0gMCkgc3BoZXJpY2FsIGhhcm1vbmljcyBhcmUgc3ltbWV0cmljYWwgYXJvdW5kIHRoZVxuICAgICAgLy8gZnJvbnQgYXhpcywgd2hpbGUgbmVnYXRpdmUgaW5kZXggKG0gPCAwKSBzcGhlcmljYWwgaGFybW9uaWNzIGFyZVxuICAgICAgLy8gYW50aS1zeW1tZXRyaWNhbCBhcm91bmQgdGhlIGZyb250IGF4aXMuIFdlIHdpbGwgZXhwbG9pdCB0aGlzIHN5bW1ldHJ5XG4gICAgICAvLyB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBjb252b2x1dGlvbnMgcmVxdWlyZWQgd2hlbiByZW5kZXJpbmcgdG8gYVxuICAgICAgLy8gc3ltbWV0cmljYWwgYmluYXVyYWwgcmVuZGVyZXIuXG4gICAgICBpZiAobSA+PSAwKSB7XG4gICAgICAgIHRoaXMuX3N0ZXJlb1NwbGl0dGVyc1tzdGVyZW9JbmRleF0uY29ubmVjdChcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MsIGFjbkluZGV4ICUgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGVyZW9TcGxpdHRlcnNbc3RlcmVvSW5kZXhdLmNvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLl9uZWdhdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLCBhY25JbmRleCAlIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3Bvc2l0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MuY29ubmVjdCh0aGlzLl9iaW5hdXJhbE1lcmdlciwgMCwgMCk7XG4gIHRoaXMuX3Bvc2l0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MuY29ubmVjdCh0aGlzLl9iaW5hdXJhbE1lcmdlciwgMCwgMSk7XG4gIHRoaXMuX25lZ2F0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MuY29ubmVjdCh0aGlzLl9iaW5hdXJhbE1lcmdlciwgMCwgMCk7XG4gIHRoaXMuX25lZ2F0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MuY29ubmVjdCh0aGlzLl9pbnZlcnRlcik7XG4gIHRoaXMuX2ludmVydGVyLmNvbm5lY3QodGhpcy5fYmluYXVyYWxNZXJnZXIsIDAsIDEpO1xuXG4gIC8vIEZvciBhc3ltbWV0cmljIGluZGV4LlxuICB0aGlzLl9pbnZlcnRlci5nYWluLnZhbHVlID0gLTE7XG5cbiAgLy8gSW5wdXQvT3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5faW5wdXRTcGxpdHRlcjtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9vdXRwdXRHYWluO1xufTtcblxuXG4vKipcbiAqIEFzc2lnbnMgTiBIUklSIEF1ZGlvQnVmZmVycyB0byBOIGNvbnZvbHZlcnM6IE5vdGUgdGhhdCB3ZSB1c2UgMiBzdGVyZW9cbiAqIGNvbnZvbHV0aW9ucyBmb3IgNC1jaGFubmVsIGRpcmVjdCBjb252b2x1dGlvbi4gVXNpbmcgbW9ubyBjb252b2x2ZXIgb3JcbiAqIDQtY2hhbm5lbCBjb252b2x2ZXIgaXMgbm90IHZpYWJsZSBiZWNhdXNlIG1vbm8gY29udm9sdXRpb24gd2FzdGVmdWxseVxuICogcHJvZHVjZXMgdGhlIHN0ZXJlbyBvdXRwdXRzLCBhbmQgdGhlIDQtY2ggY29udm9sdmVyIGRvZXMgY3Jvc3MtY2hhbm5lbFxuICogY29udm9sdXRpb24uIChTZWUgV2ViIEF1ZGlvIEFQSSBzcGVjKVxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBocmlyQnVmZmVyTGlzdCAtIEFuIGFycmF5IG9mIHN0ZXJlbyBBdWRpb0J1ZmZlcnMgZm9yXG4gKiBjb252b2x2ZXJzLlxuICovXG5IT0FDb252b2x2ZXIucHJvdG90eXBlLnNldEhSSVJCdWZmZXJMaXN0ID0gZnVuY3Rpb24oaHJpckJ1ZmZlckxpc3QpIHtcbiAgLy8gQWZ0ZXIgdGhlc2UgYXNzaWdubWVudHMsIHRoZSBjaGFubmVsIGRhdGEgaW4gdGhlIGJ1ZmZlciBpcyBpbW11dGFibGUgaW5cbiAgLy8gRmlyZUZveC4gKGkuZS4gbmV1dGVyZWQpIFNvIHdlIHNob3VsZCBhdm9pZCByZS1hc3NpZ25pbmcgYnVmZmVycywgb3RoZXJ3aXNlXG4gIC8vIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAgaWYgKHRoaXMuX2lzQnVmZmVyTG9hZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBocmlyQnVmZmVyTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX2NvbnZvbHZlcnNbaV0uYnVmZmVyID0gaHJpckJ1ZmZlckxpc3RbaV07XG4gIH1cblxuICB0aGlzLl9pc0J1ZmZlckxvYWRlZCA9IHRydWU7XG59O1xuXG5cbi8qKlxuICogRW5hYmxlIEhPQUNvbnZvbHZlciBpbnN0YW5jZS4gVGhlIGF1ZGlvIGdyYXBoIHdpbGwgYmUgYWN0aXZhdGVkIGFuZCBwdWxsZWQgYnlcbiAqIHRoZSBXZWJBdWRpbyBlbmdpbmUuIChpLmUuIGNvbnN1bWUgQ1BVIGN5Y2xlKVxuICovXG5IT0FDb252b2x2ZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5hdXJhbE1lcmdlci5jb25uZWN0KHRoaXMuX291dHB1dEdhaW4pO1xuICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIERpc2FibGUgSE9BQ29udm9sdmVyIGluc3RhbmNlLiBUaGUgaW5uZXIgZ3JhcGggd2lsbCBiZSBkaXNjb25uZWN0ZWQgZnJvbSB0aGVcbiAqIGF1ZGlvIGRlc3RpbmF0aW9uLCB0aHVzIG5vIENQVSBjeWNsZSB3aWxsIGJlIGNvbnN1bWVkLlxuICovXG5IT0FDb252b2x2ZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYmluYXVyYWxNZXJnZXIuZGlzY29ubmVjdCgpO1xuICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIT0FDb252b2x2ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgU291bmQgZmllbGQgcm90YXRvciBmb3IgaGlnaGVyLW9yZGVyLWFtYmlzb25pY3MgZGVjb2RpbmcuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBLcm9uZWNrZXIgRGVsdGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0S3JvbmVja2VyRGVsdGEoaSwgaikge1xuICByZXR1cm4gaSA9PT0gaiA/IDEgOiAwO1xufVxuXG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdXMgdG8gYWNjZXNzIGEgbWF0cml4IGFycmF5IGluIHRoZSBzYW1lXG4gKiBtYW5uZXIsIGFzc3VtaW5nIGl0IGlzIGEgKDJsKzEpeCgybCsxKSBtYXRyaXguIFsyXSB1c2VzIGFuIG9kZCBjb252ZW50aW9uIG9mXG4gKiByZWZlcnJpbmcgdG8gdGhlIHJvd3MgYW5kIGNvbHVtbnMgdXNpbmcgY2VudGVyZWQgaW5kaWNlcywgc28gdGhlIG1pZGRsZSByb3dcbiAqIGFuZCBjb2x1bW4gYXJlICgwLCAwKSBhbmQgdGhlIHVwcGVyIGxlZnQgd291bGQgaGF2ZSBuZWdhdGl2ZSBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gZ2FpblZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwsIGksIGosIGdhaW5WYWx1ZSkge1xuICBjb25zdCBpbmRleCA9IChqICsgbCkgKiAoMiAqIGwgKyAxKSArIChpICsgbCk7XG4gIC8vIFJvdy13aXNlIGluZGV4aW5nLlxuICBtYXRyaXhbbCAtIDFdW2luZGV4XS5nYWluLnZhbHVlID0gZ2FpblZhbHVlO1xufVxuXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB1cyB0byBhY2Nlc3MgYSBtYXRyaXggYXJyYXkgaW4gdGhlIHNhbWVcbiAqIG1hbm5lciwgYXNzdW1pbmcgaXQgaXMgYSAoMmwrMSkgeCAoMmwrMSkgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCwgaSwgaikge1xuICAvLyBSb3ctd2lzZSBpbmRleGluZy5cbiAgY29uc3QgaW5kZXggPSAoaiArIGwpICogKDIgKiBsICsgMSkgKyAoaSArIGwpO1xuICByZXR1cm4gbWF0cml4W2wgLSAxXVtpbmRleF0uZ2Fpbi52YWx1ZTtcbn1cblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBkZWZpbmVkIGluIFsyXSB0aGF0IGlzIHVzZWQgYnkgdGhlIGZ1bmN0aW9ucyBVLCBWLCBXLlxuICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBvbiBpdHMgb3duLCBhcyBVLCBWLCBhbmQgVyAoYW5kIHRoZWlyIGNvZWZmaWNpZW50cylcbiAqIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGUgbWF0cml4IGVsZW1lbnRzIHRvIGFjY2VzcyBhcmd1bWVudHMgfGF8IGFuZCB8YnwuXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UChtYXRyaXgsIGksIGEsIGIsIGwpIHtcbiAgaWYgKGIgPT09IGwpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgMSwgaSwgMSkgKlxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsIC0gMSwgYSwgbCAtIDEpIC1cbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgMSwgaSwgLTEpICpcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCAtIDEsIGEsIC1sICsgMSk7XG4gIH0gZWxzZSBpZiAoYiA9PT0gLWwpIHtcbiAgICByZXR1cm4gZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgMSwgaSwgMSkgKlxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsIC0gMSwgYSwgLWwgKyAxKSArXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIDEsIGksIC0xKSAqXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwgLSAxLCBhLCBsIC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIDEsIGksIDApICpcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCAtIDEsIGEsIGIpO1xuICB9XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIFUsIFYsIGFuZCBXIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgY29ycmVzcG9uZGluZ2x5XG4gKiBuYW1lZCBjb2VmZmljaWVudCB1LCB2LCB3IGZyb20gdGhlIGZ1bmN0aW9uIENvbXB1dGVVVldDb2VmZigpIGlzIG5vbi16ZXJvLlxuICogV2hlbiB0aGUgY29lZmZpY2llbnQgaXMgMCwgdGhlc2Ugd291bGQgYXR0ZW1wdCB0byBhY2Nlc3MgbWF0cml4IGVsZW1lbnRzIHRoYXRcbiAqIGFyZSBvdXQgb2YgYm91bmRzLiBUaGUgdmVjdG9yIG9mIHJvdGF0aW9ucywgfHJ8LCBtdXN0IGhhdmUgdGhlIHxsIC0gMXxcbiAqIHByZXZpb3VzbHkgY29tcGxldGVkIGJhbmQgcm90YXRpb25zLiBUaGVzZSBmdW5jdGlvbnMgYXJlIHZhbGlkIGZvciB8bCA+PSAyfC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFUobWF0cml4LCBtLCBuLCBsKSB7XG4gIC8vIEFsdGhvdWdoIFsxLCAyXSBzcGxpdCBVIGludG8gdGhyZWUgY2FzZXMgZm9yIG0gPT0gMCwgbSA8IDAsIG0gPiAwXG4gIC8vIHRoZSBhY3R1YWwgdmFsdWVzIGFyZSB0aGUgc2FtZSBmb3IgYWxsIHRocmVlIGNhc2VzLlxuICByZXR1cm4gZ2V0UChtYXRyaXgsIDAsIG0sIG4sIGwpO1xufVxuXG5cbi8qKlxuICogVGhlIGZ1bmN0aW9ucyBVLCBWLCBhbmQgVyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIGNvcnJlc3BvbmRpbmdseVxuICogbmFtZWQgY29lZmZpY2llbnQgdSwgdiwgdyBmcm9tIHRoZSBmdW5jdGlvbiBDb21wdXRlVVZXQ29lZmYoKSBpcyBub24temVyby5cbiAqIFdoZW4gdGhlIGNvZWZmaWNpZW50IGlzIDAsIHRoZXNlIHdvdWxkIGF0dGVtcHQgdG8gYWNjZXNzIG1hdHJpeCBlbGVtZW50cyB0aGF0XG4gKiBhcmUgb3V0IG9mIGJvdW5kcy4gVGhlIHZlY3RvciBvZiByb3RhdGlvbnMsIHxyfCwgbXVzdCBoYXZlIHRoZSB8bCAtIDF8XG4gKiBwcmV2aW91c2x5IGNvbXBsZXRlZCBiYW5kIHJvdGF0aW9ucy4gVGhlc2UgZnVuY3Rpb25zIGFyZSB2YWxpZCBmb3IgfGwgPj0gMnwuXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRWKG1hdHJpeCwgbSwgbiwgbCkge1xuICBpZiAobSA9PT0gMCkge1xuICAgIHJldHVybiBnZXRQKG1hdHJpeCwgMSwgMSwgbiwgbCkgKyBnZXRQKG1hdHJpeCwgLTEsIC0xLCBuLCBsKTtcbiAgfSBlbHNlIGlmIChtID4gMCkge1xuICAgIGNvbnN0IGQgPSBnZXRLcm9uZWNrZXJEZWx0YShtLCAxKTtcbiAgICByZXR1cm4gZ2V0UChtYXRyaXgsIDEsIG0gLSAxLCBuLCBsKSAqIE1hdGguc3FydCgxICsgZCkgLVxuICAgICAgICBnZXRQKG1hdHJpeCwgLTEsIC1tICsgMSwgbiwgbCkgKiAoMSAtIGQpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vdGUgdGhlcmUgaXMgYXBwYXJlbnQgZXJyYXRhIGluIFsxLDIsMmJdIGRlYWxpbmcgd2l0aCB0aGlzIHBhcnRpY3VsYXJcbiAgICAvLyBjYXNlLiBbMmJdIHdyaXRlcyBpdCBzaG91bGQgYmUgUCooMS1kKStQKigxLWQpXjAuNVxuICAgIC8vIFsxXSB3cml0ZXMgaXQgYXMgUCooMStkKStQKigxLWQpXjAuNSwgYnV0IGdvaW5nIHRocm91Z2ggdGhlIG1hdGggYnkgaGFuZCxcbiAgICAvLyB5b3UgbXVzdCBoYXZlIGl0IGFzIFAqKDEtZCkrUCooMStkKV4wLjUgdG8gZm9ybSBhIDJeLjUgdGVybSwgd2hpY2hcbiAgICAvLyBwYXJhbGxlbHMgdGhlIGNhc2Ugd2hlcmUgbSA+IDAuXG4gICAgY29uc3QgZCA9IGdldEtyb25lY2tlckRlbHRhKG0sIC0xKTtcbiAgICByZXR1cm4gZ2V0UChtYXRyaXgsIDEsIG0gKyAxLCBuLCBsKSAqICgxIC0gZCkgK1xuICAgICAgICBnZXRQKG1hdHJpeCwgLTEsIC1tIC0gMSwgbiwgbCkgKiBNYXRoLnNxcnQoMSArIGQpO1xuICB9XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIFUsIFYsIGFuZCBXIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgY29ycmVzcG9uZGluZ2x5XG4gKiBuYW1lZCBjb2VmZmljaWVudCB1LCB2LCB3IGZyb20gdGhlIGZ1bmN0aW9uIENvbXB1dGVVVldDb2VmZigpIGlzIG5vbi16ZXJvLlxuICogV2hlbiB0aGUgY29lZmZpY2llbnQgaXMgMCwgdGhlc2Ugd291bGQgYXR0ZW1wdCB0byBhY2Nlc3MgbWF0cml4IGVsZW1lbnRzIHRoYXRcbiAqIGFyZSBvdXQgb2YgYm91bmRzLiBUaGUgdmVjdG9yIG9mIHJvdGF0aW9ucywgfHJ8LCBtdXN0IGhhdmUgdGhlIHxsIC0gMXxcbiAqIHByZXZpb3VzbHkgY29tcGxldGVkIGJhbmQgcm90YXRpb25zLiBUaGVzZSBmdW5jdGlvbnMgYXJlIHZhbGlkIGZvciB8bCA+PSAyfC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRXKG1hdHJpeCwgbSwgbiwgbCkge1xuICAvLyBXaGVuZXZlciB0aGlzIGhhcHBlbnMsIHcgaXMgYWxzbyAwIHNvIFcgY2FuIGJlIGFueXRoaW5nLlxuICBpZiAobSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIG0gPiAwID8gZ2V0UChtYXRyaXgsIDEsIG0gKyAxLCBuLCBsKSArIGdldFAobWF0cml4LCAtMSwgLW0gLSAxLCBuLCBsKSA6XG4gICAgICAgICAgICAgICAgIGdldFAobWF0cml4LCAxLCBtIC0gMSwgbiwgbCkgLSBnZXRQKG1hdHJpeCwgLTEsIC1tICsgMSwgbiwgbCk7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb2VmZmljaWVudHMgYXBwbGllZCB0byB0aGUgVSwgViwgYW5kIFcgZnVuY3Rpb25zLiBCZWNhdXNlXG4gKiB0aGVpciBlcXVhdGlvbnMgc2hhcmUgbWFueSBjb21tb24gdGVybXMgdGhleSBhcmUgY29tcHV0ZWQgc2ltdWx0YW5lb3VzbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcmV0dXJuIHtBcnJheX0gMyBjb2VmZmljaWVudHMgZm9yIFUsIFYgYW5kIFcgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBjb21wdXRlVVZXQ29lZmYobSwgbiwgbCkge1xuICBjb25zdCBkID0gZ2V0S3JvbmVja2VyRGVsdGEobSwgMCk7XG4gIGNvbnN0IHJlY2lwcm9jYWxEZW5vbWluYXRvciA9XG4gICAgICBNYXRoLmFicyhuKSA9PT0gbCA/IDEgLyAoMiAqIGwgKiAoMiAqIGwgLSAxKSkgOiAxIC8gKChsICsgbikgKiAobCAtIG4pKTtcblxuICByZXR1cm4gW1xuICAgIE1hdGguc3FydCgobCArIG0pICogKGwgLSBtKSAqIHJlY2lwcm9jYWxEZW5vbWluYXRvciksXG4gICAgMC41ICogKDEgLSAyICogZCkgKiBNYXRoLnNxcnQoKDEgKyBkKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGwgKyBNYXRoLmFicyhtKSAtIDEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobCArIE1hdGguYWJzKG0pKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjaXByb2NhbERlbm9taW5hdG9yKSxcbiAgICAtMC41ICogKDEgLSBkKSAqIE1hdGguc3FydCgobCAtIE1hdGguYWJzKG0pIC0gMSkgKiAobCAtIE1hdGguYWJzKG0pKSkgKlxuICAgICAgICByZWNpcHJvY2FsRGVub21pbmF0b3IsXG4gIF07XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSAoMmwrMSkgeCAoMmwrMSkgcm90YXRpb24gbWF0cml4IGZvciB0aGUgYmFuZCBsLlxuICogVGhpcyB1c2VzIHRoZSBtYXRyaWNlcyBjb21wdXRlZCBmb3IgYmFuZCAxIGFuZCBiYW5kIGwtMSB0byBjb21wdXRlIHRoZVxuICogbWF0cml4IGZvciBiYW5kIGwuIHxyb3RhdGlvbnN8IG11c3QgY29udGFpbiB0aGUgcHJldmlvdXNseSBjb21wdXRlZCBsLTFcbiAqIHJvdGF0aW9uIG1hdHJpY2VzLlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjb21lcyBmcm9tIHAuIDUgKDYzNDYpLCBUYWJsZSAxIGFuZCAyIGluIFsyXSB0YWtpbmdcbiAqIGludG8gYWNjb3VudCB0aGUgY29ycmVjdGlvbnMgZnJvbSBbMmJdLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCB3aGVyZVxuICogbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICovXG5mdW5jdGlvbiBjb21wdXRlQmFuZFJvdGF0aW9uKG1hdHJpeCwgbCkge1xuICAvLyBUaGUgbHRoIGJhbmQgcm90YXRpb24gbWF0cml4IGhhcyByb3dzIGFuZCBjb2x1bW5zIGVxdWFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgLy8gY29lZmZpY2llbnRzIHdpdGhpbiB0aGF0IGJhbmQgKC1sIDw9IG0gPD0gbCBpbXBsaWVzIDJsICsgMSBjb2VmZmljaWVudHMpLlxuICBmb3IgKGxldCBtID0gLWw7IG0gPD0gbDsgbSsrKSB7XG4gICAgZm9yIChsZXQgbiA9IC1sOyBuIDw9IGw7IG4rKykge1xuICAgICAgY29uc3QgdXZ3Q29lZmZpY2llbnRzID0gY29tcHV0ZVVWV0NvZWZmKG0sIG4sIGwpO1xuXG4gICAgICAvLyBUaGUgZnVuY3Rpb25zIFUsIFYsIFcgYXJlIG9ubHkgc2FmZSB0byBjYWxsIGlmIHRoZSBjb2VmZmljaWVudHNcbiAgICAgIC8vIHUsIHYsIHcgYXJlIG5vdCB6ZXJvLlxuICAgICAgaWYgKE1hdGguYWJzKHV2d0NvZWZmaWNpZW50c1swXSkgPiAwKSB7XG4gICAgICAgIHV2d0NvZWZmaWNpZW50c1swXSAqPSBnZXRVKG1hdHJpeCwgbSwgbiwgbCk7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnModXZ3Q29lZmZpY2llbnRzWzFdKSA+IDApIHtcbiAgICAgICAgdXZ3Q29lZmZpY2llbnRzWzFdICo9IGdldFYobWF0cml4LCBtLCBuLCBsKTtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyh1dndDb2VmZmljaWVudHNbMl0pID4gMCkge1xuICAgICAgICB1dndDb2VmZmljaWVudHNbMl0gKj0gZ2V0VyhtYXRyaXgsIG0sIG4sIGwpO1xuICAgICAgfVxuXG4gICAgICBzZXRDZW50ZXJlZEVsZW1lbnQoXG4gICAgICAgICAgbWF0cml4LCBsLCBtLCBuLFxuICAgICAgICAgIHV2d0NvZWZmaWNpZW50c1swXSArIHV2d0NvZWZmaWNpZW50c1sxXSArIHV2d0NvZWZmaWNpZW50c1syXSk7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBDb21wdXRlIHRoZSBIT0Egcm90YXRpb24gbWF0cml4IGFmdGVyIHNldHRpbmcgdGhlIHRyYW5zZm9ybSBtYXRyaXguXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICovXG5mdW5jdGlvbiBjb21wdXRlSE9BTWF0cmljZXMobWF0cml4KSB7XG4gIC8vIFdlIHN0YXJ0IGJ5IGNvbXB1dGluZyB0aGUgMm5kLW9yZGVyIG1hdHJpeCBmcm9tIHRoZSAxc3Qtb3JkZXIgbWF0cml4LlxuICBmb3IgKGxldCBpID0gMjsgaSA8PSBtYXRyaXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb21wdXRlQmFuZFJvdGF0aW9uKG1hdHJpeCwgaSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEhpZ2hlci1vcmRlci1hbWJpc29uaWMgZGVjb2RlciBiYXNlZCBvbiBnYWluIG5vZGUgbmV0d29yay4gV2UgZXhwZWN0XG4gKiB0aGUgb3JkZXIgb2YgdGhlIGNoYW5uZWxzIHRvIGNvbmZvcm0gdG8gQUNOIG9yZGVyaW5nLiBCZWxvdyBhcmUgdGhlIGhlbHBlclxuICogbWV0aG9kcyB0byBjb21wdXRlIFNIIHJvdGF0aW9uIHVzaW5nIHJlY3Vyc2lvbi4gVGhlIGNvZGUgdXNlcyBtYXRocyBkZXNjcmliZWRcbiAqIGluIHRoZSBmb2xsb3dpbmcgcGFwZXJzOlxuICogIFsxXSBSLiBHcmVlbiwgXCJTcGhlcmljYWwgSGFybW9uaWMgTGlnaHRpbmc6IFRoZSBHcml0dHkgRGV0YWlsc1wiLCBHREMgMjAwMyxcbiAqICAgICAgaHR0cDovL3d3dy5yZXNlYXJjaC5zY2VhLmNvbS9nZGMyMDAzL3NwaGVyaWNhbC1oYXJtb25pYy1saWdodGluZy5wZGZcbiAqICBbMl0gSi4gSXZhbmljIGFuZCBLLiBSdWVkZW5iZXJnLCBcIlJvdGF0aW9uIE1hdHJpY2VzIGZvciBSZWFsXG4gKiAgICAgIFNwaGVyaWNhbCBIYXJtb25pY3MuIERpcmVjdCBEZXRlcm1pbmF0aW9uIGJ5IFJlY3Vyc2lvblwiLCBKLiBQaHlzLlxuICogICAgICBDaGVtLiwgdm9sLiAxMDAsIG5vLiAxNSwgcHAuIDYzNDItNjM0NywgMTk5Ni5cbiAqICAgICAgaHR0cDovL3B1YnMuYWNzLm9yZy9kb2kvcGRmLzEwLjEwMjEvanA5NTMzNTB1XG4gKiAgWzJiXSBDb3JyZWN0aW9ucyB0byBpbml0aWFsIHB1YmxpY2F0aW9uOlxuICogICAgICAgaHR0cDovL3B1YnMuYWNzLm9yZy9kb2kvcGRmLzEwLjEwMjEvanA5ODMzMzUwXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgLSBBbWJpc29uaWMgb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIEhPQVJvdGF0b3IoY29udGV4dCwgYW1iaXNvbmljT3JkZXIpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID0gYW1iaXNvbmljT3JkZXI7XG5cbiAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlIG51bWJlciBvZiBjaGFubmVscyBLIGJhc2VkIG9uIHRoZSBhbWJpc29uaWMgb3JkZXJcbiAgLy8gTiB3aGVyZSBLID0gKE4gKyAxKV4yLlxuICBjb25zdCBudW1iZXJPZkNoYW5uZWxzID0gKGFtYmlzb25pY09yZGVyICsgMSkgKiAoYW1iaXNvbmljT3JkZXIgKyAxKTtcblxuICB0aGlzLl9zcGxpdHRlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKG51bWJlck9mQ2hhbm5lbHMpO1xuICB0aGlzLl9tZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIobnVtYmVyT2ZDaGFubmVscyk7XG5cbiAgLy8gQ3JlYXRlIGEgc2V0IG9mIHBlci1vcmRlciByb3RhdGlvbiBtYXRyaWNlcyB1c2luZyBnYWluIG5vZGVzLlxuICB0aGlzLl9nYWluTm9kZU1hdHJpeCA9IFtdO1xuICBsZXQgb3JkZXJPZmZzZXQ7XG4gIGxldCByb3dzO1xuICBsZXQgaW5wdXRJbmRleDtcbiAgbGV0IG91dHB1dEluZGV4O1xuICBsZXQgbWF0cml4SW5kZXg7XG4gIGZvciAobGV0IGkgPSAxOyBpIDw9IGFtYmlzb25pY09yZGVyOyBpKyspIHtcbiAgICAvLyBFYWNoIGFtYmlzb25pYyBvcmRlciByZXF1aXJlcyBhIHNlcGFyYXRlICgybCArIDEpIHggKDJsICsgMSkgcm90YXRpb25cbiAgICAvLyBtYXRyaXguIFdlIGNvbXB1dGUgdGhlIG9mZnNldCB2YWx1ZSBhcyB0aGUgZmlyc3QgY2hhbm5lbCBpbmRleCBvZiB0aGVcbiAgICAvLyBjdXJyZW50IG9yZGVyIHdoZXJlXG4gICAgLy8gICBrX2xhc3QgPSBsXjIgKyBsICsgbSxcbiAgICAvLyBhbmQgbSA9IC1sXG4gICAgLy8gICBrX2xhc3QgPSBsXjJcbiAgICBvcmRlck9mZnNldCA9IGkgKiBpO1xuXG4gICAgLy8gVXNlcyByb3ctbWFqb3IgaW5kZXhpbmcuXG4gICAgcm93cyA9ICgyICogaSArIDEpO1xuXG4gICAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbaSAtIDFdID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcbiAgICAgIGlucHV0SW5kZXggPSBvcmRlck9mZnNldCArIGo7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJvd3M7IGsrKykge1xuICAgICAgICBvdXRwdXRJbmRleCA9IG9yZGVyT2Zmc2V0ICsgaztcbiAgICAgICAgbWF0cml4SW5kZXggPSBqICogcm93cyArIGs7XG4gICAgICAgIHRoaXMuX2dhaW5Ob2RlTWF0cml4W2kgLSAxXVttYXRyaXhJbmRleF0gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdChcbiAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlTWF0cml4W2kgLSAxXVttYXRyaXhJbmRleF0sIGlucHV0SW5kZXgpO1xuICAgICAgICB0aGlzLl9nYWluTm9kZU1hdHJpeFtpIC0gMV1bbWF0cml4SW5kZXhdLmNvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLl9tZXJnZXIsIDAsIG91dHB1dEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBXLWNoYW5uZWwgaXMgbm90IGludm9sdmVkIGluIHJvdGF0aW9uLCBza2lwIHN0cmFpZ2h0IHRvIG91cHV0LlxuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG5cbiAgLy8gRGVmYXVsdCBJZGVudGl0eSBtYXRyaXguXG4gIHRoaXMuc2V0Um90YXRpb25NYXRyaXgzKG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdKSk7XG5cbiAgLy8gSW5wdXQvT3V0cHV0IHByb3h5LlxuICB0aGlzLmlucHV0ID0gdGhpcy5fc3BsaXR0ZXI7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fbWVyZ2VyO1xufVxuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggM3gzIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4MyAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUm90YXRvci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXgzID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXgzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgKytpKSB7XG4gICAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1baV0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1tpXTtcbiAgfVxuICBjb21wdXRlSE9BTWF0cmljZXModGhpcy5fZ2Fpbk5vZGVNYXRyaXgpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDR4NCBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDQgLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJvdGF0b3IucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4NCkge1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVswXS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzBdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVsxXS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzFdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVsyXS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzJdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVszXS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzRdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs0XS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzVdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs1XS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzZdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs2XS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzhdO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs3XS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzldO1xuICB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs4XS5nYWluLnZhbHVlID0gcm90YXRpb25NYXRyaXg0WzEwXTtcbiAgY29tcHV0ZUhPQU1hdHJpY2VzKHRoaXMuX2dhaW5Ob2RlTWF0cml4KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJvdGF0b3IucHJvdG90eXBlLmdldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcm90YXRpb25NYXRyaXgzID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyArK2kpIHtcbiAgICByb3RhdGlvbk1hdHJpeDNbaV0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVtpXS5nYWluLnZhbHVlO1xuICB9XG4gIHJldHVybiByb3RhdGlvbk1hdHJpeDM7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCA0eDQgcm90YXRpb24gbWF0cml4LlxuICogQHJldHVybiB7TnVtYmVyW119IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSb3RhdG9yLnByb3RvdHlwZS5nZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJvdGF0aW9uTWF0cml4NCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICByb3RhdGlvbk1hdHJpeDRbMF0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVswXS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMV0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVsxXS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMl0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVsyXS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNF0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVszXS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNV0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs0XS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbNl0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs1XS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbOF0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs2XS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbOV0gPSB0aGlzLl9nYWluTm9kZU1hdHJpeFswXVs3XS5nYWluLnZhbHVlO1xuICByb3RhdGlvbk1hdHJpeDRbMTBdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bOF0uZ2Fpbi52YWx1ZTtcbiAgcmV0dXJuIHJvdGF0aW9uTWF0cml4NDtcbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgYW1iaXNvbmljIG9yZGVyLlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5IT0FSb3RhdG9yLnByb3RvdHlwZS5nZXRBbWJpc29uaWNPcmRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYW1iaXNvbmljT3JkZXI7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSE9BUm90YXRvcjtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIE5hbWVzcGFjZSBmb3IgT21uaXRvbmUgbGlicmFyeS5cbiAqL1xuXG5cblxuXG5leHBvcnRzLk9tbml0b25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIGxpYnJhcnkgbmFtZSBzcGFjZSBhbmQgdXNlci1mYWNpbmcgQVBJcy5cbiAqL1xuXG5cblxuXG5jb25zdCBCdWZmZXJMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IEZPQUNvbnZvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5jb25zdCBGT0FEZWNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5jb25zdCBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuY29uc3QgRk9BUmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbmNvbnN0IEZPQVJvdGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuY29uc3QgRk9BUm91dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmNvbnN0IEZPQVZpcnR1YWxTcGVha2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmNvbnN0IEhPQUNvbnZvbHZlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5jb25zdCBIT0FSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuY29uc3QgSE9BUm90YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5jb25zdCBQb2x5ZmlsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuY29uc3QgVmVyc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG4vLyBERVBSRUNBVEVEIGluIFYxLCBpbiBmYXZvciBvZiBCdWZmZXJMaXN0LlxuY29uc3QgQXVkaW9CdWZmZXJNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuXG4vKipcbiAqIE9tbml0b25lIG5hbWVzcGFjZS5cbiAqIEBuYW1lc3BhY2VcbiAqL1xubGV0IE9tbml0b25lID0ge307XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCcm93c2VySW5mb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBCcm93c2VyIG5hbWUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbiAtIEJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWlucyB0aGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lIGFuZCB2ZXJzaW9uLlxuICogQG1lbWJlck9mIE9tbml0b25lXG4gKiBAc3RhdGljIHtCcm93c2VySW5mb31cbiAqL1xuT21uaXRvbmUuYnJvd3NlckluZm8gPSBQb2x5ZmlsbC5nZXRCcm93c2VySW5mbygpO1xuXG5cbi8vIERFUFJFQ0FURUQgaW4gVjEuIERPLiBOT1QuIFVTRS5cbk9tbml0b25lLmxvYWRBdWRpb0J1ZmZlcnMgPSBmdW5jdGlvbihjb250ZXh0LCBzcGVha2VyRGF0YSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbmV3IEF1ZGlvQnVmZmVyTWFuYWdlcihjb250ZXh0LCBzcGVha2VyRGF0YSwgZnVuY3Rpb24oYnVmZmVycykge1xuICAgICAgcmVzb2x2ZShidWZmZXJzKTtcbiAgICB9LCByZWplY3QpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgYXN5bmMgbG9hZGluZy9kZWNvZGluZyBvZiBtdWx0aXBsZSBBdWRpb0J1ZmZlcnMgZnJvbSBtdWx0aXBsZVxuICogVVJMcy5cbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGJ1ZmZlckRhdGEgLSBBbiBvcmRlcmVkIGxpc3Qgb2YgVVJMcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBCdWZmZXJMaXN0IG9wdGlvbnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGF0YVR5cGU9J3VybCddIC0gQnVmZmVyTGlzdCBkYXRhIHR5cGUuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEF1ZGlvQnVmZmVyW10+fSAtIFRoZSBwcm9taXNlIHJlc29sdmVzIHdpdGggYW4gYXJyYXkgb2ZcbiAqIEF1ZGlvQnVmZmVyLlxuICovXG5PbW5pdG9uZS5jcmVhdGVCdWZmZXJMaXN0ID0gZnVuY3Rpb24oY29udGV4dCwgYnVmZmVyRGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBidWZmZXJMaXN0ID1cbiAgICAgIG5ldyBCdWZmZXJMaXN0KGNvbnRleHQsIGJ1ZmZlckRhdGEsIG9wdGlvbnMgfHwge2RhdGFUeXBlOiAndXJsJ30pO1xuICByZXR1cm4gYnVmZmVyTGlzdC5sb2FkKCk7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBjaGFubmVsLXdpc2UgbWVyZ2Ugb24gbXVsdGlwbGUgQXVkaW9CdWZmZXJzLiBUaGUgc2FtcGxlIHJhdGUgYW5kXG4gKiB0aGUgbGVuZ3RoIG9mIGJ1ZmZlcnMgdG8gYmUgbWVyZ2VkIG11c3QgYmUgaWRlbnRpY2FsLlxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IGJ1ZmZlckxpc3QgLSBBbiBhcnJheSBvZiBBdWRpb0J1ZmZlcnMgdG8gYmUgbWVyZ2VkXG4gKiBjaGFubmVsLXdpc2UuXG4gKiBAcmV0dXJuIHtBdWRpb0J1ZmZlcn0gLSBBIHNpbmdsZSBtZXJnZWQgQXVkaW9CdWZmZXIuXG4gKi9cbk9tbml0b25lLm1lcmdlQnVmZmVyTGlzdEJ5Q2hhbm5lbCA9IFV0aWxzLm1lcmdlQnVmZmVyTGlzdEJ5Q2hhbm5lbDtcblxuXG4vKipcbiAqIFBlcmZvcm0gY2hhbm5lbC13aXNlIHNwbGl0IGJ5IHRoZSBnaXZlbiBjaGFubmVsIGNvdW50LiBGb3IgZXhhbXBsZSxcbiAqIDEgeCBBdWRpb0J1ZmZlcig4KSAtPiBzcGxpdEJ1ZmZlcihjb250ZXh0LCBidWZmZXIsIDIpIC0+IDQgeCBBdWRpb0J1ZmZlcigyKS5cbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYXVkaW9CdWZmZXIgLSBBbiBBdWRpb0J1ZmZlciB0byBiZSBzcGxpdHRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGxpdEJ5IC0gTnVtYmVyIG9mIGNoYW5uZWxzIHRvIGJlIHNwbGl0dGVkLlxuICogQHJldHVybiB7QXVkaW9CdWZmZXJbXX0gLSBBbiBhcnJheSBvZiBzcGxpdHRlZCBBdWRpb0J1ZmZlcnMuXG4gKi9cbk9tbml0b25lLnNwbGl0QnVmZmVyYnlDaGFubmVsID0gVXRpbHMuc3BsaXRCdWZmZXJieUNoYW5uZWw7XG5cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEZPQSBDb252b2x2ZXIuXG4gKiBAc2VlIEZPQUNvbnZvbHZlclxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IFRoZSBhc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gW2hyaXJCdWZmZXJMaXN0XSAtIEFuIG9yZGVyZWQtbGlzdCBvZiBzdGVyZW9cbiAqIEByZXR1cm4ge0ZPQUNvbnZvbHZlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BQ29udm9sdmVyID0gZnVuY3Rpb24oY29udGV4dCwgaHJpckJ1ZmZlckxpc3QpIHtcbiAgcmV0dXJuIG5ldyBGT0FDb252b2x2ZXIoY29udGV4dCwgaHJpckJ1ZmZlckxpc3QpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBGT0EgUm91dGVyLlxuICogQHNlZSBGT0FSb3V0ZXJcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcltdfSBjaGFubmVsTWFwIC0gUm91dGluZyBkZXN0aW5hdGlvbiBhcnJheS5cbiAqIEByZXR1cm4ge0ZPQVJvdXRlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BUm91dGVyID0gZnVuY3Rpb24oY29udGV4dCwgY2hhbm5lbE1hcCkge1xuICByZXR1cm4gbmV3IEZPQVJvdXRlcihjb250ZXh0LCBjaGFubmVsTWFwKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRk9BIFJvdGF0b3IuXG4gKiBAc2VlIEZPQVJvdGF0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcmV0dXJuIHtGT0FSb3RhdG9yfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FSb3RhdG9yID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEZPQVJvdGF0b3IoY29udGV4dCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEZPQVBoYXNlTWF0Y2hlZEZpbHRlci5cbiAqIEBpZ25vcmVcbiAqIEBzZWUgRk9BUGhhc2VNYXRjaGVkRmlsdGVyXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHJldHVybiB7Rk9BUGhhc2VNYXRjaGVkRmlsdGVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FQaGFzZU1hdGNoZWRGaWx0ZXIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgRk9BUGhhc2VNYXRjaGVkRmlsdGVyKGNvbnRleHQpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBGT0FWaXJ0dWFsU3BlYWtlci4gRm9yIHBhcmFtZXRlcnMsIHJlZmVyIHRoZVxuICogZGVmaW5pdGlvbiBvZiBWaXJ0dWFsU3BlYWtlciBjbGFzcy5cbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJuIHtGT0FWaXJ0dWFsU3BlYWtlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BVmlydHVhbFNwZWFrZXIgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgRk9BVmlydHVhbFNwZWFrZXIoY29udGV4dCwgb3B0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogREVQUkVDQVRFRC4gVXNlIEZPQVJlbmRlcmVyIGluc3RhbmNlLlxuICogQHNlZSBGT0FSZW5kZXJlclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gdmlkZW9FbGVtZW50IC0gVmlkZW8gb3IgQXVkaW8gRE9NIGVsZW1lbnQgdG8gYmUgc3RyZWFtZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIEZPQSBkZWNvZGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYmFzZVJlc291cmNlVXJsIC0gQmFzZSBVUkwgZm9yIHJlc291cmNlcy5cbiAqIChiYXNlIHBhdGggZm9yIEhSSVIgZmlsZXMpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zdEdhaW49MjYuMF0gLSBQb3N0LWRlY29kaW5nIGdhaW4gY29tcGVuc2F0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucm91dGluZ0Rlc3RpbmF0aW9uXSAgQ3VzdG9tIGNoYW5uZWwgbGF5b3V0LlxuICogQHJldHVybiB7Rk9BRGVjb2Rlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BRGVjb2RlciA9IGZ1bmN0aW9uKGNvbnRleHQsIHZpZGVvRWxlbWVudCwgb3B0aW9ucykge1xuICBVdGlscy5sb2coJ1dBUk5JTkc6IEZPQURlY29kZXIgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBGT0FSZW5kZXJlci4nKTtcbiAgcmV0dXJuIG5ldyBGT0FEZWNvZGVyKGNvbnRleHQsIHZpZGVvRWxlbWVudCwgb3B0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgRk9BUmVuZGVyZXIsIHRoZSBmaXJzdC1vcmRlciBhbWJpc29uaWMgZGVjb2RlciBhbmQgdGhlIG9wdGltaXplZFxuICogYmluYXVyYWwgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5jaGFubmVsTWFwXSAtIEN1c3RvbSBjaGFubmVsIHJvdXRpbmcgbWFwLiBVc2VmdWwgZm9yXG4gKiBoYW5kbGluZyB0aGUgaW5jb25zaXN0ZW5jeSBpbiBicm93c2VyJ3MgbXVsdGljaGFubmVsIGF1ZGlvIGRlY29kaW5nLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5ocmlyUGF0aExpc3RdIC0gQSBsaXN0IG9mIHBhdGhzIHRvIEhSSVIgZmlsZXMuIEl0XG4gKiBvdmVycmlkZXMgdGhlIGludGVybmFsIEhSSVIgbGlzdCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gW2NvbmZpZy5yZW5kZXJpbmdNb2RlPSdhbWJpc29uaWMnXSAtIFJlbmRlcmluZyBtb2RlLlxuICogQHJldHVybiB7Rk9BUmVuZGVyZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQVJlbmRlcmVyID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG4gIHJldHVybiBuZXcgRk9BUmVuZGVyZXIoY29udGV4dCwgY29uZmlnKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIEhPQVJvdGF0b3IgZm9yIGhpZ2hlci1vcmRlciBhbWJpc29uaWNzIHJvdGF0aW9uLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciAtIEFtYmlzb25pYyBvcmRlci5cbiAqIEByZXR1cm4ge0hPQVJvdGF0b3J9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUhPQVJvdGF0b3IgPSBmdW5jdGlvbihjb250ZXh0LCBhbWJpc29uaWNPcmRlcikge1xuICByZXR1cm4gbmV3IEhPQVJvdGF0b3IoY29udGV4dCwgYW1iaXNvbmljT3JkZXIpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgSE9BQ29udm9sdmVyIHBlcmZvcm1zIHRoZSBtdWx0aS1jaGFubmVsIGNvbnZvbHV0aW9uIGZvciB0aGUgb3B0bWl6ZWRcbiAqIGJpbmF1cmFsIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgLSBBbWJpc29uaWMgb3JkZXIuICgyIG9yIDMpXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IFtocmlyQnVmZmVyTGlzdF0gLSBBbiBvcmRlcmVkLWxpc3Qgb2Ygc3RlcmVvXG4gKiBBdWRpb0J1ZmZlcnMgZm9yIGNvbnZvbHV0aW9uLiAoU09BOiA1IEF1ZGlvQnVmZmVycywgVE9BOiA4IEF1ZGlvQnVmZmVycylcbiAqIEByZXR1cm4ge0hPQUNvbnZvdmxlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlSE9BQ29udm9sdmVyID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgYW1iaXNvbmljT3JkZXIsIGhyaXJCdWZmZXJMaXN0KSB7XG4gIHJldHVybiBuZXcgSE9BQ29udm9sdmVyKGNvbnRleHQsIGFtYmlzb25pY09yZGVyLCBocmlyQnVmZmVyTGlzdCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBIT0FSZW5kZXJlciBmb3IgaGlnaGVyLW9yZGVyIGFtYmlzb25pYyBkZWNvZGluZyBhbmQgdGhlIG9wdGltaXplZFxuICogYmluYXVyYWwgcmVuZGVyaW5nLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmFtYmlzb25pY09yZGVyPTNdIC0gQW1iaXNvbmljIG9yZGVyLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5ocmlyUGF0aExpc3RdIC0gQSBsaXN0IG9mIHBhdGhzIHRvIEhSSVIgZmlsZXMuIEl0XG4gKiBvdmVycmlkZXMgdGhlIGludGVybmFsIEhSSVIgbGlzdCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gW2NvbmZpZy5yZW5kZXJpbmdNb2RlPSdhbWJpc29uaWMnXSAtIFJlbmRlcmluZyBtb2RlLlxuICogQHJldHVybiB7SE9BUmVuZGVyZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUhPQVJlbmRlcmVyID0gZnVuY3Rpb24oY29udGV4dCwgY29uZmlnKSB7XG4gIHJldHVybiBuZXcgSE9BUmVuZGVyZXIoY29udGV4dCwgY29uZmlnKTtcbn07XG5cblxuLy8gSGFuZGxlciBQcmVsb2FkIFRhc2tzLlxuLy8gLSBEZXRlY3RzIHRoZSBicm93c2VyIGluZm9ybWF0aW9uLlxuLy8gLSBQcmludHMgb3V0IHRoZSB2ZXJzaW9uIG51bWJlci5cbihmdW5jdGlvbigpIHtcbiAgVXRpbHMubG9nKCdWZXJzaW9uICcgKyBWZXJzaW9uICsgJyAocnVubmluZyAnICtcbiAgICAgIE9tbml0b25lLmJyb3dzZXJJbmZvLm5hbWUgKyAnICcgKyBPbW5pdG9uZS5icm93c2VySW5mby52ZXJzaW9uICtcbiAgICAgICcgb24gJyArIE9tbml0b25lLmJyb3dzZXJJbmZvLnBsYXRmb3JtICsnKScpO1xuICBpZiAoT21uaXRvbmUuYnJvd3NlckluZm8ubmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2FmYXJpJykge1xuICAgIFBvbHlmaWxsLnBhdGNoU2FmYXJpKCk7XG4gICAgVXRpbHMubG9nKE9tbml0b25lLmJyb3dzZXJJbmZvLm5hbWUgKyAnIGRldGVjdGVkLiBBcHBsaXlpbmcgcG9seWZpbGwuLi4nKTtcbiAgfVxufSkoKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE9tbml0b25lO1xuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIEZPQSBkZWNvZGVyLCBERVBSRUNBVEVEIGluIGZhdm9yIG9mIEZPQVJlbmRlcmVyLlxuICovXG5cblxuXG5jb25zdCBBdWRpb0J1ZmZlck1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuY29uc3QgRk9BUm91dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmNvbnN0IEZPQVJvdGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuY29uc3QgRk9BUGhhc2VNYXRjaGVkRmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmNvbnN0IEZPQVZpcnR1YWxTcGVha2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmNvbnN0IEZPQVNwZWFrZXJEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEJ5IGRlZmF1bHQsIE9tbml0b25lIGZldGNoZXMgSVIgZnJvbSB0aGUgc3BhdGlhbCBtZWRpYSByZXBvc2l0b3J5LlxuY29uc3QgSFJURlNFVF9VUkwgPSAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0dvb2dsZUNocm9tZS9vbW5pdG9uZS9tYXN0ZXIvYnVpbGQvcmVzb3VyY2VzLyc7XG5cbi8vIFBvc3QgZ2FpbiBjb21wZW5zYXRpb24gdmFsdWUuXG5sZXQgUE9TVF9HQUlOX0RCID0gMDtcblxuXG4vKipcbiAqIE9tbml0b25lIEZPQSBkZWNvZGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtWaWRlb0VsZW1lbnR9IHZpZGVvRWxlbWVudCAtIFRhcmdldCB2aWRlbyAob3IgYXVkaW8pIGVsZW1lbnQgZm9yXG4gKiBzdHJlYW1pbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuSFJURlNldFVybCAtIEJhc2UgVVJMIGZvciB0aGUgY3ViZSBIUlRGIHNldHMuXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wb3N0R2FpbkRCIC0gUG9zdC1kZWNvZGluZyBnYWluIGNvbXBlbnNhdGlvbiBpbiBkQi5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG9wdGlvbnMuY2hhbm5lbE1hcCAtIEN1c3RvbSBjaGFubmVsIG1hcC5cbiAqL1xuZnVuY3Rpb24gRk9BRGVjb2Rlcihjb250ZXh0LCB2aWRlb0VsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdGhpcy5faXNEZWNvZGVyUmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3ZpZGVvRWxlbWVudCA9IHZpZGVvRWxlbWVudDtcbiAgdGhpcy5fZGVjb2RpbmdNb2RlID0gJ2FtYmlzb25pYyc7XG5cbiAgdGhpcy5fcG9zdEdhaW5EQiA9IFBPU1RfR0FJTl9EQjtcbiAgdGhpcy5fSFJURlNldFVybCA9IEhSVEZTRVRfVVJMO1xuICB0aGlzLl9jaGFubmVsTWFwID0gRk9BUm91dGVyLkNoYW5uZWxNYXAuREVGQVVMVDsgLy8gQUNOXG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wb3N0R2FpbkRCKSB7XG4gICAgICB0aGlzLl9wb3N0R2FpbkRCID0gb3B0aW9ucy5wb3N0R2FpbkRCO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5IUlRGU2V0VXJsKSB7XG4gICAgICB0aGlzLl9IUlRGU2V0VXJsID0gb3B0aW9ucy5IUlRGU2V0VXJsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jaGFubmVsTWFwKSB7XG4gICAgICB0aGlzLl9jaGFubmVsTWFwID0gb3B0aW9ucy5jaGFubmVsTWFwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYXJyYW5nZSBzcGVha2VyIGRhdGEgYmFzZWQgb24gfG9wdGlvbnMuSFJURlNldFVybHwuXG4gIHRoaXMuX3NwZWFrZXJEYXRhID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgRk9BU3BlYWtlckRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9zcGVha2VyRGF0YS5wdXNoKHtcbiAgICAgIG5hbWU6IEZPQVNwZWFrZXJEYXRhW2ldLm5hbWUsXG4gICAgICB1cmw6IHRoaXMuX0hSVEZTZXRVcmwgKyAnLycgKyBGT0FTcGVha2VyRGF0YVtpXS51cmwsXG4gICAgICBjb2VmOiBGT0FTcGVha2VyRGF0YVtpXS5jb2VmLFxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fdGVtcE1hdHJpeDQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbn1cblxuXG4vKipcbiAqIEluaXRpYWxpemUgYW5kIGxvYWQgdGhlIHJlc291cmNlcyBmb3IgdGhlIGRlY29kZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbkZPQURlY29kZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgVXRpbHMubG9nKCdJbml0aWFsaXppbmcuLi4gKG1vZGU6ICcgKyB0aGlzLl9kZWNvZGluZ01vZGUgKyAnKScpO1xuXG4gIC8vIFJlcm91dGluZyBjaGFubmVscyBpZiBuZWNlc3NhcnkuXG4gIGxldCBjaGFubmVsTWFwU3RyaW5nID0gdGhpcy5fY2hhbm5lbE1hcC50b1N0cmluZygpO1xuICBsZXQgZGVmYXVsdENoYW5uZWxNYXBTdHJpbmcgPSBGT0FSb3V0ZXIuQ2hhbm5lbE1hcC5ERUZBVUxULnRvU3RyaW5nKCk7XG4gIGlmIChjaGFubmVsTWFwU3RyaW5nICE9PSBkZWZhdWx0Q2hhbm5lbE1hcFN0cmluZykge1xuICAgIFV0aWxzLmxvZygnUmVtYXBwaW5nIGNoYW5uZWxzIChbJyArIGRlZmF1bHRDaGFubmVsTWFwU3RyaW5nICsgJ10gLT4gWydcbiAgICAgICsgY2hhbm5lbE1hcFN0cmluZyArICddKScpO1xuICB9XG5cbiAgdGhpcy5fYXVkaW9FbGVtZW50U291cmNlID1cbiAgICAgIHRoaXMuX2NvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKHRoaXMuX3ZpZGVvRWxlbWVudCk7XG4gIHRoaXMuX2ZvYVJvdXRlciA9IG5ldyBGT0FSb3V0ZXIodGhpcy5fY29udGV4dCwgdGhpcy5fY2hhbm5lbE1hcCk7XG4gIHRoaXMuX2ZvYVJvdGF0b3IgPSBuZXcgRk9BUm90YXRvcih0aGlzLl9jb250ZXh0KTtcbiAgdGhpcy5fZm9hUGhhc2VNYXRjaGVkRmlsdGVyID0gbmV3IEZPQVBoYXNlTWF0Y2hlZEZpbHRlcih0aGlzLl9jb250ZXh0KTtcblxuICB0aGlzLl9hdWRpb0VsZW1lbnRTb3VyY2UuY29ubmVjdCh0aGlzLl9mb2FSb3V0ZXIuaW5wdXQpO1xuICB0aGlzLl9mb2FSb3V0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5fZm9hUm90YXRvci5pbnB1dCk7XG4gIHRoaXMuX2ZvYVJvdGF0b3Iub3V0cHV0LmNvbm5lY3QodGhpcy5fZm9hUGhhc2VNYXRjaGVkRmlsdGVyLmlucHV0KTtcblxuICB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnMgPSBbXTtcblxuICAvLyBCeXBhc3Mgc2lnbmFsIHBhdGguXG4gIHRoaXMuX2J5cGFzcyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9hdWRpb0VsZW1lbnRTb3VyY2UuY29ubmVjdCh0aGlzLl9ieXBhc3MpO1xuXG4gIC8vIEdldCB0aGUgbGluZWFyIGFtcGxpdHVkZSBmcm9tIHRoZSBwb3N0IGdhaW4gb3B0aW9uLCB3aGljaCBpcyBpbiBkZWNpYmVsLlxuICBjb25zdCBwb3N0R2FpbkxpbmVhciA9IE1hdGgucG93KDEwLCB0aGlzLl9wb3N0R2FpbkRCLzIwKTtcbiAgVXRpbHMubG9nKCdHYWluIGNvbXBlbnNhdGlvbjogJyArIHBvc3RHYWluTGluZWFyICsgJyAoJyArIHRoaXMuX3Bvc3RHYWluREJcbiAgICArICdkQiknKTtcblxuICAvLyBUaGlzIHJldHVybnMgYSBwcm9taXNlIHNvIGRldmVsb3BlcnMgY2FuIHVzZSB0aGUgZGVjb2RlciB3aGVuIGl0IGlzIHJlYWR5LlxuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG5ldyBBdWRpb0J1ZmZlck1hbmFnZXIodGhhdC5fY29udGV4dCwgdGhhdC5fc3BlYWtlckRhdGEsXG4gICAgICBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhhdC5fc3BlYWtlckRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGF0Ll9mb2FWaXJ0dWFsU3BlYWtlcnNbaV0gPSBuZXcgRk9BVmlydHVhbFNwZWFrZXIodGhhdC5fY29udGV4dCwge1xuICAgICAgICAgICAgY29lZmZpY2llbnRzOiB0aGF0Ll9zcGVha2VyRGF0YVtpXS5jb2VmLFxuICAgICAgICAgICAgSVI6IGJ1ZmZlcnMuZ2V0KHRoYXQuX3NwZWFrZXJEYXRhW2ldLm5hbWUpLFxuICAgICAgICAgICAgZ2FpbjogcG9zdEdhaW5MaW5lYXIsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGF0Ll9mb2FQaGFzZU1hdGNoZWRGaWx0ZXIub3V0cHV0LmNvbm5lY3QoXG4gICAgICAgICAgICB0aGF0Ll9mb2FWaXJ0dWFsU3BlYWtlcnNbaV0uaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBkZWNvZGluZyBtb2RlLlxuICAgICAgICB0aGF0LnNldE1vZGUodGhhdC5fZGVjb2RpbmdNb2RlKTtcbiAgICAgICAgdGhhdC5faXNEZWNvZGVyUmVhZHkgPSB0cnVlO1xuICAgICAgICBVdGlscy5sb2coJ0hSVEYgSVJzIGFyZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5LiBUaGUgZGVjb2RlciBpcyByZWFkeS4nKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwgcmVqZWN0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcm90YXRpb24gbWF0cml4IGZvciB0aGUgc291bmQgZmllbGQgcm90YXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSByb3RhdGlvbk1hdHJpeCAgICAgIDN4MyByb3RhdGlvbiBtYXRyaXggKHJvdy1tYWpvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXByZXNlbnRhdGlvbilcbiAqL1xuRk9BRGVjb2Rlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXggPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeCkge1xuICB0aGlzLl9mb2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uTWF0cml4KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHJvdGF0aW9uIG1hdHJpeCBmcm9tIGEgVGhyZWUuanMgY2FtZXJhIG9iamVjdC5cbiAqIEBwYXJhbSAge09iamVjdH0gY2FtZXJhTWF0cml4ICAgICAgVGhlIE1hdHJpeDQgb2JlamN0IG9mIFRocmVlLmpzIHRoZSBjYW1lcmEuXG4gKi9cbkZPQURlY29kZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4RnJvbUNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYU1hdHJpeCkge1xuICAvLyBFeHRyYWN0IHRoZSBpbm5lciBhcnJheSBlbGVtZW50cyBhbmQgaW52ZXJzZS4gKFRoZSBhY3R1YWwgdmlldyByb3RhdGlvbiBpc1xuICAvLyB0aGUgb3Bwb3NpdGUgb2YgdGhlIGNhbWVyYSBtb3ZlbWVudC4pXG4gIFV0aWxzLmludmVydE1hdHJpeDQodGhpcy5fdGVtcE1hdHJpeDQsIGNhbWVyYU1hdHJpeC5lbGVtZW50cyk7XG4gIHRoaXMuX2ZvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXg0KHRoaXMuX3RlbXBNYXRyaXg0KTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZWNvZGluZyBtb2RlLlxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgICAgICAgICAgICAgICBEZWNvZGluZyBtb2RlLiBXaGVuIHRoZSBtb2RlIGlzICdieXBhc3MnXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBkZWNvZGVyIGlzIGRpc2FibGVkIGFuZCBieXBhc3MgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0IHN0cmVhbSB0byB0aGUgb3V0cHV0LiBTZXR0aW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlIHRvICdhbWJpc29uaWMnIGFjdGl2YXRlcyB0aGUgZGVjb2Rlci5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiB0aGUgbW9kZSBpcyAnb2ZmJywgYWxsIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nIGlzIGNvbXBsZXRlbHkgdHVybmVkIG9mZiBzYXZpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIENQVSBwb3dlci5cbiAqL1xuRk9BRGVjb2Rlci5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT09IHRoaXMuX2RlY29kaW5nTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2J5cGFzcyc6XG4gICAgICB0aGlzLl9kZWNvZGluZ01vZGUgPSAnYnlwYXNzJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vyc1tpXS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ieXBhc3MuY29ubmVjdCh0aGlzLl9jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYW1iaXNvbmljJzpcbiAgICAgIHRoaXMuX2RlY29kaW5nTW9kZSA9ICdhbWJpc29uaWMnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzW2ldLmVuYWJsZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb2ZmJzpcbiAgICAgIHRoaXMuX2RlY29kaW5nTW9kZSA9ICdvZmYnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzW2ldLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIFV0aWxzLmxvZygnRGVjb2RpbmcgbW9kZSBjaGFuZ2VkLiAoJyArIG1vZGUgKyAnKScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGT0FEZWNvZGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBUaGUgZGF0YSBmb3IgRk9BVmlydHVhbFNwZWFrZXIuIEVhY2ggZW50cnkgY29udGFpbnMgdGhlIFVSTCBmb3IgSVIgZmlsZXMgYW5kXG4gKiB0aGUgZ2FpbiBjb2VmZmljaWVudHMgZm9yIHRoZSBhc3NvY2lhdGVkIElSIGZpbGVzLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mXG4gKiBjb2VmZmljaWVudHMgZm9sbG93cyB0aGUgQUNOIGNoYW5uZWwgb3JkZXJpbmcuIChXLFksWixYKVxuICogQHR5cGUge09iamVjdFtdfVxuICovXG5jb25zdCBGT0FTcGVha2VyRGF0YSA9IFt7XG4gIG5hbWU6ICdFMzVfQTEzNScsXG4gIHVybDogJ0UzNV9BMTM1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgMC4yMTY0OTUsIDAuMjE2NTMsIC0wLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFMzVfQS0xMzUnLFxuICB1cmw6ICdFMzVfQS0xMzUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAtMC4yMTY0OTUsIDAuMjE2NTMsIC0wLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFLTM1X0ExMzUnLFxuICB1cmw6ICdFLTM1X0ExMzUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAwLjIxNjQ5NSwgLTAuMjE2NTMsIC0wLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFLTM1X0EtMTM1JyxcbiAgdXJsOiAnRS0zNV9BLTEzNS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIC0wLjIxNjQ5NSwgLTAuMjE2NTMsIC0wLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFMzVfQTQ1JyxcbiAgdXJsOiAnRTM1X0E0NS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIDAuMjE2NDk1LCAwLjIxNjUzLCAwLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFMzVfQS00NScsXG4gIHVybDogJ0UzNV9BLTQ1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgLTAuMjE2NDk1LCAwLjIxNjUzLCAwLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFLTM1X0E0NScsXG4gIHVybDogJ0UtMzVfQTQ1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgMC4yMTY0OTUsIC0wLjIxNjUzLCAwLjIxNjQ5NV0sXG59LCB7XG4gIG5hbWU6ICdFLTM1X0EtNDUnLFxuICB1cmw6ICdFLTM1X0EtNDUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAtMC4yMTY0OTUsIC0wLjIxNjUzLCAwLjIxNjQ5NV0sXG59XTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVNwZWFrZXJEYXRhO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIEZPQVJlbmRlcmVyLiBUaGlzIGlzIHVzZXItZmFjaW5nIEFQSSBmb3IgdGhlIGZpcnN0LW9yZGVyXG4gKiBhbWJpc29uaWMgZGVjb2RlciBhbmQgdGhlIG9wdGltaXplZCBiaW5hdXJhbCByZW5kZXJlci5cbiAqL1xuXG5cblxuY29uc3QgQnVmZmVyTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBGT0FDb252b2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29uc3QgRk9BSHJpckJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuY29uc3QgRk9BUm90YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5jb25zdCBGT0FSb3V0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ30gUmVuZGVyaW5nTW9kZVxuICovXG5cbi8qKlxuICogUmVuZGVyaW5nIG1vZGUgRU5VTS5cbiAqIEBlbnVtIHtSZW5kZXJpbmdNb2RlfVxuICovXG5jb25zdCBSZW5kZXJpbmdNb2RlID0ge1xuICAvKiogQHR5cGUge3N0cmluZ30gVXNlIGFtYmlzb25pYyByZW5kZXJpbmcuICovXG4gIEFNQklTT05JQzogJ2FtYmlzb25pYycsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBCeXBhc3MuIE5vIGFtYmlzb25pYyByZW5kZXJpbmcuICovXG4gIEJZUEFTUzogJ2J5cGFzcycsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBEaXNhYmxlIGF1ZGlvIG91dHB1dC4gKi9cbiAgT0ZGOiAnb2ZmJyxcbn07XG5cblxuLyoqXG4gKiBPbW5pdG9uZSBGT0EgcmVuZGVyZXIgY2xhc3MuIFVzZXMgdGhlIG9wdGltaXplZCBjb252b2x1dGlvbiB0ZWNobmlxdWUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmNoYW5uZWxNYXBdIC0gQ3VzdG9tIGNoYW5uZWwgcm91dGluZyBtYXAuIFVzZWZ1bCBmb3JcbiAqIGhhbmRsaW5nIHRoZSBpbmNvbnNpc3RlbmN5IGluIGJyb3dzZXIncyBtdWx0aWNoYW5uZWwgYXVkaW8gZGVjb2RpbmcuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmhyaXJQYXRoTGlzdF0gLSBBIGxpc3Qgb2YgcGF0aHMgdG8gSFJJUiBmaWxlcy4gSXRcbiAqIG92ZXJyaWRlcyB0aGUgaW50ZXJuYWwgSFJJUiBsaXN0IGlmIGdpdmVuLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBbY29uZmlnLnJlbmRlcmluZ01vZGU9J2FtYmlzb25pYyddIC0gUmVuZGVyaW5nIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIEZPQVJlbmRlcmVyKGNvbnRleHQsIGNvbmZpZykge1xuICB0aGlzLl9jb250ZXh0ID0gVXRpbHMuaXNBdWRpb0NvbnRleHQoY29udGV4dCkgP1xuICAgICAgY29udGV4dCA6XG4gICAgICBVdGlscy50aHJvdygnRk9BUmVuZGVyZXI6IEludmFsaWQgQmFzZUF1ZGlvQ29udGV4dC4nKTtcblxuICB0aGlzLl9jb25maWcgPSB7XG4gICAgY2hhbm5lbE1hcDogRk9BUm91dGVyLkNoYW5uZWxNYXAuREVGQVVMVCxcbiAgICByZW5kZXJpbmdNb2RlOiBSZW5kZXJpbmdNb2RlLkFNQklTT05JQyxcbiAgfTtcblxuICBpZiAoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5jaGFubmVsTWFwKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuY2hhbm5lbE1hcCkgJiYgY29uZmlnLmNoYW5uZWxNYXAubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwID0gY29uZmlnLmNoYW5uZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlscy50aHJvdyhcbiAgICAgICAgICAgICdGT0FSZW5kZXJlcjogSW52YWxpZCBjaGFubmVsIG1hcC4gKGdvdCAnICsgY29uZmlnLmNoYW5uZWxNYXBcbiAgICAgICAgICAgICsgJyknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmhyaXJQYXRoTGlzdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmhyaXJQYXRoTGlzdCkgJiZcbiAgICAgICAgICBjb25maWcuaHJpclBhdGhMaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb25maWcucGF0aExpc3QgPSBjb25maWcuaHJpclBhdGhMaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMudGhyb3coXG4gICAgICAgICAgICAnRk9BUmVuZGVyZXI6IEludmFsaWQgSFJJUiBVUkxzLiBJdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggJyArXG4gICAgICAgICAgICAnMiBVUkxzIHRvIEhSSVIgZmlsZXMuIChnb3QgJyArIGNvbmZpZy5ocmlyUGF0aExpc3QgKyAnKScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maWcucmVuZGVyaW5nTW9kZSkge1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoUmVuZGVyaW5nTW9kZSkuaW5jbHVkZXMoY29uZmlnLnJlbmRlcmluZ01vZGUpKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlID0gY29uZmlnLnJlbmRlcmluZ01vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlscy5sb2coXG4gICAgICAgICAgICAnRk9BUmVuZGVyZXI6IEludmFsaWQgcmVuZGVyaW5nIG1vZGUgb3JkZXIuIChnb3QnICtcbiAgICAgICAgICAgIGNvbmZpZy5yZW5kZXJpbmdNb2RlICsgJykgRmFsbGJhY2tzIHRvIHRoZSBtb2RlIFwiYW1iaXNvbmljXCIuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYnVpbGRBdWRpb0dyYXBoKCk7XG5cbiAgdGhpcy5fdGVtcE1hdHJpeDQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgdGhpcy5faXNSZW5kZXJlclJlYWR5ID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGludGVybmFsIGF1ZGlvIGdyYXBoLlxuICogQHByaXZhdGVcbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLl9idWlsZEF1ZGlvR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9ieXBhc3MgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fZm9hUm91dGVyID0gbmV3IEZPQVJvdXRlcih0aGlzLl9jb250ZXh0LCB0aGlzLl9jb25maWcuY2hhbm5lbE1hcCk7XG4gIHRoaXMuX2ZvYVJvdGF0b3IgPSBuZXcgRk9BUm90YXRvcih0aGlzLl9jb250ZXh0KTtcbiAgdGhpcy5fZm9hQ29udm9sdmVyID0gbmV3IEZPQUNvbnZvbHZlcih0aGlzLl9jb250ZXh0KTtcbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2ZvYVJvdXRlci5pbnB1dCk7XG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9ieXBhc3MpO1xuICB0aGlzLl9mb2FSb3V0ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5fZm9hUm90YXRvci5pbnB1dCk7XG4gIHRoaXMuX2ZvYVJvdGF0b3Iub3V0cHV0LmNvbm5lY3QodGhpcy5fZm9hQ29udm9sdmVyLmlucHV0KTtcbiAgdGhpcy5fZm9hQ29udm9sdmVyLm91dHB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblxuICB0aGlzLmlucHV0LmNoYW5uZWxDb3VudCA9IDQ7XG4gIHRoaXMuaW5wdXQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG4gIHRoaXMuaW5wdXQuY2hhbm5lbEludGVycHJldGF0aW9uID0gJ2Rpc2NyZXRlJztcbn07XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBjYWxsYmFjayBoYW5kbGVyIGZvciB8aW5pdGlhbGl6ZXwgbWV0aG9kLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmUgLSBSZXNvbHV0aW9uIGhhbmRsZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWplY3QgLSBSZWplY3Rpb24gaGFuZGxlci5cbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLl9pbml0aWFsaXplQ2FsbGJhY2sgPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgY29uc3QgYnVmZmVyTGlzdCA9IHRoaXMuX2NvbmZpZy5wYXRoTGlzdFxuICAgICAgPyBuZXcgQnVmZmVyTGlzdCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb25maWcucGF0aExpc3QsIHtkYXRhVHlwZTogJ3VybCd9KVxuICAgICAgOiBuZXcgQnVmZmVyTGlzdCh0aGlzLl9jb250ZXh0LCBGT0FIcmlyQmFzZTY0KTtcbiAgYnVmZmVyTGlzdC5sb2FkKCkudGhlbihcbiAgICAgIGZ1bmN0aW9uKGhyaXJCdWZmZXJMaXN0KSB7XG4gICAgICAgIHRoaXMuX2ZvYUNvbnZvbHZlci5zZXRIUklSQnVmZmVyTGlzdChocmlyQnVmZmVyTGlzdCk7XG4gICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nTW9kZSh0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSk7XG4gICAgICAgIHRoaXMuX2lzUmVuZGVyZXJSZWFkeSA9IHRydWU7XG4gICAgICAgIFV0aWxzLmxvZygnRk9BUmVuZGVyZXI6IEhSSVJzIGxvYWRlZCBzdWNjZXNzZnVsbHkuIFJlYWR5LicpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0ZPQVJlbmRlcmVyOiBIUklSIGxvYWRpbmcvZGVjb2RpbmcgZmFpbGVkLic7XG4gICAgICAgIFV0aWxzLnRocm93KGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJlamVjdChlcnJvck1lc3NhZ2UpO1xuICAgICAgfSk7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIGxvYWRzIHRoZSByZXNvdXJjZSBmb3IgdGhlIHJlbmRlcmVyLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgVXRpbHMubG9nKFxuICAgICAgJ0ZPQVJlbmRlcmVyOiBJbml0aWFsaXppbmcuLi4gKG1vZGU6ICcgKyB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSArXG4gICAgICAnKScpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSh0aGlzLl9pbml0aWFsaXplQ2FsbGJhY2suYmluZCh0aGlzKSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBVdGlscy50aHJvdygnRk9BUmVuZGVyZXI6IEluaXRpYWxpemF0aW9uIGZhaWxlZC4gKCcgKyBlcnJvciArICcpJyk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgY2hhbm5lbCBtYXAuXG4gKiBAcGFyYW0ge051bWJlcltdfSBjaGFubmVsTWFwIC0gQ3VzdG9tIGNoYW5uZWwgcm91dGluZyBmb3IgRk9BIHN0cmVhbS5cbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLnNldENoYW5uZWxNYXAgPSBmdW5jdGlvbihjaGFubmVsTWFwKSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoYW5uZWxNYXAudG9TdHJpbmcoKSAhPT0gdGhpcy5fY29uZmlnLmNoYW5uZWxNYXAudG9TdHJpbmcoKSkge1xuICAgIFV0aWxzLmxvZyhcbiAgICAgICAgJ1JlbWFwcGluZyBjaGFubmVscyAoWycgKyB0aGlzLl9jb25maWcuY2hhbm5lbE1hcC50b1N0cmluZygpICtcbiAgICAgICAgJ10gLT4gWycgKyBjaGFubmVsTWFwLnRvU3RyaW5nKCkgKyAnXSkuJyk7XG4gICAgdGhpcy5fY29uZmlnLmNoYW5uZWxNYXAgPSBjaGFubmVsTWFwLnNsaWNlKCk7XG4gICAgdGhpcy5fZm9hUm91dGVyLnNldENoYW5uZWxNYXAodGhpcy5fY29uZmlnLmNoYW5uZWxNYXApO1xuICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggM3gzIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4MyAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4Mykge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2ZvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXgzKHJvdGF0aW9uTWF0cml4Myk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggNHg0IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4NCAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4NCkge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2ZvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXg0KHJvdGF0aW9uTWF0cml4NCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSByb3RhdGlvbiBtYXRyaXggZnJvbSBhIFRocmVlLmpzIGNhbWVyYSBvYmplY3QuIERlcHJlYXRlZCBpbiBWMSwgYW5kXG4gKiB0aGlzIGV4aXN0cyBvbmx5IGZvciB0aGUgYmFja3dhcmQgY29tcGF0aWJsaXR5LiBJbnN0ZWFkLCB1c2VcbiAqIHxzZXRSb3RhdGF0aW9uTWF0cml4NCgpfCB3aXRoIFRocmVlLmpzIHxjYW1lcmEud29ybGRNYXRyaXguZWxlbWVudHN8LlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYW1lcmFNYXRyaXggLSBNYXRyaXg0IGZyb20gVGhyZWUuanMgfGNhbWVyYS5tYXRyaXh8LlxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0Um90YXRpb25NYXRyaXhGcm9tQ2FtZXJhID0gZnVuY3Rpb24oY2FtZXJhTWF0cml4KSB7XG4gIGlmICghdGhpcy5faXNSZW5kZXJlclJlYWR5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRXh0cmFjdCB0aGUgaW5uZXIgYXJyYXkgZWxlbWVudHMgYW5kIGludmVyc2UuIChUaGUgYWN0dWFsIHZpZXcgcm90YXRpb24gaXNcbiAgLy8gdGhlIG9wcG9zaXRlIG9mIHRoZSBjYW1lcmEgbW92ZW1lbnQuKVxuICBVdGlscy5pbnZlcnRNYXRyaXg0KHRoaXMuX3RlbXBNYXRyaXg0LCBjYW1lcmFNYXRyaXguZWxlbWVudHMpO1xuICB0aGlzLl9mb2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4NCh0aGlzLl90ZW1wTWF0cml4NCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSByZW5kZXJpbmcgbW9kZS5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gbW9kZSAtIFJlbmRlcmluZyBtb2RlLlxuICogIC0gJ2FtYmlzb25pYyc6IGFjdGl2YXRlcyB0aGUgYW1iaXNvbmljIGRlY29kaW5nL2JpbmF1cmwgcmVuZGVyaW5nLlxuICogIC0gJ2J5cGFzcyc6IGJ5cGFzc2VzIHRoZSBpbnB1dCBzdHJlYW0gZGlyZWN0bHkgdG8gdGhlIG91dHB1dC4gTm8gYW1iaXNvbmljXG4gKiAgICBkZWNvZGluZyBvciBlbmNvZGluZy5cbiAqICAtICdvZmYnOiBhbGwgdGhlIHByb2Nlc3Npbmcgb2ZmIHNhdmluZyB0aGUgQ1BVIHBvd2VyLlxuICovXG5GT0FSZW5kZXJlci5wcm90b3R5cGUuc2V0UmVuZGVyaW5nTW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgaWYgKG1vZGUgPT09IHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLkFNQklTT05JQzpcbiAgICAgIHRoaXMuX2ZvYUNvbnZvbHZlci5lbmFibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuQllQQVNTOlxuICAgICAgdGhpcy5fZm9hQ29udm9sdmVyLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5jb25uZWN0KHRoaXMub3V0cHV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5PRkY6XG4gICAgICB0aGlzLl9mb2FDb252b2x2ZXIuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBVdGlscy5sb2coXG4gICAgICAgICAgJ0ZPQVJlbmRlcmVyOiBSZW5kZXJpbmcgbW9kZSBcIicgKyBtb2RlICsgJ1wiIGlzIG5vdCAnICtcbiAgICAgICAgICAnc3VwcG9ydGVkLicpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICBVdGlscy5sb2coJ0ZPQVJlbmRlcmVyOiBSZW5kZXJpbmcgbW9kZSBjaGFuZ2VkLiAoJyArIG1vZGUgKyAnKScpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVJlbmRlcmVyO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuY29uc3QgT21uaXRvbmVGT0FIcmlyQmFzZTY0ID0gW1xuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRCsvd0lBOXY4UUFQdi9Dd0QrL3djQS92OE1BUC8vQVFENy93RUFDQUFFQVBqLyt2OFlBQkFBN3Yvbi8vdi85UC9NLzhELy9mMzQvUjM4RXZ6eEFmRUJ0QTJsRFRjQkpRRko5VDcxRlAwRC9jRDF0ZlZvL1d2OXVQVE85UFBtT3VmYy9VLythZ0wzQWlzYy9SeHVHS0VaQnYzai9pWU16UTJnQXpzRVFRVUFCaVFGckFTekE1Y0IyUW15Q3kwQXRnUjRBZVlHdGZnQUEyajVPUUhQK3NjQXJQc01CSmdFZ2dJRUJ0ejYrUVZxL3BqL2FQZzhCUFAzZ1FFaStqRUFvZjBmQTF2OSsvN1MrOElCanZ3ZC94RDRJQURML1BmOXp2cysvbDMrd2dCNy8rTCs3ZnpGQURIOWtmNkErbjMrRFA2Ky9UUDl4UDY4L3BuK3cvMjYvaTM5WWdBMC91NzkwUHQ5L2tEKzd2MXMvV2IrOGY0Qy8xUCtwZi94L2NUKzYvM3AvWHo5ZmY1Ri8wZjlHLzRyLzZ2LzRQNUwvc0wrZmY3Yy9waitPdjdYL1VUKzlQNUcvb3orNnY2QS8yRCs5LzZQLzhyL2JQN20vaWorQy8vZS90ai9HZjRlLzl2K0Z3RFAvbHovc1A3Ri8ySCtydi9HL3M3L0hmN3kvNFArTkFEOS9rMEFLLzZ3L3pQL2hBQ2gvc1gvZ2Y0NEFPUCtkZ0NtL2lVQWsvNXFBT0QrUHdDKy9qRUFXUDRDQUFyL2JRQncvdnYvemY1aUFDRC9PZ0NTL3VEL0N2OW9BQWIvQ2dESy9rd0EvLzV0QUNIL1RnQ2cvaDRBSFA5YUFCUC9KQURQL2hFQVl2OWdBQWovM2Y4bS95c0FZdjhnQUNYLzgvOGsveXNBWHY4YkFCSC8vdjhqL3lnQWEvOHFBQUQvOWY5Zy8xWUFXZjhKQUNIL0FnQjIvejRBWFAvdy96My9GZ0IyL3lrQVgvLzkvei8vRXdDVi96VUFTLy9uLzFUL0dBQ0sveDRBVHYvMC80UC9RUUI0Ly92L1dQLzIvM1gvSEFCOC8vUC9WLy8zLzJmL0FRQmgvOXYvVGYveC81UC9Jd0NJL3dNQWYvOGhBS1AvSkFDWi94VUFpdjhuQUsvL0hnQ3IveU1BbS84dUFNei9PQUNpL3lRQXFmODdBTVQvTXdDWS95VUF0UDlGQU1IL0tnQ3UveWNBeVA4NUFNdi9Jd0N6L3hvQTFmOHFBTW4vRmdDOC94UUE0LzhuQU1YL0N3REoveFFBNGY4WkFNSC9CZ0RPL3hRQTRmOFdBTVAvQndEVS94UUE0UDhRQU1IL0FRRGIveFFBM1A4SkFNUC9BZ0RoL3hJQTJ2OEVBTWovQWdEay93MEExZi8rLzh2L0F3RG0vd3dBMHYvKy85SC9CZ0RsL3drQXp2LzgvOVQvQndEay93Y0F6di84LzlyL0NRRGkvd1FBemYvOC85Ly9DQURmLy8vLzBQLzkvK0wvQndEZC8vNy8wLy8vLytUL0JnRGIvL3ovMWY4QUFPZi9CUURaLy92LzJ2OENBT2IvQXdEWS8vdi8zdjhFQU9iL0FnRFkvLzMvNGY4RkFPWC9BUURaLy83LzVQOEdBT1AvQUFEYi93QUE1LzhHQU9ILy8vL2Qvd0lBNS84RkFPRC8vLy9mL3dNQTZQOEZBT0QvLy8vaC93UUE2UDhFQU43Ly8vL2gvd1VBNHY4REFOdi9BUURkL3dRQTNQOENBTm4vQWdEYi93TUEyLzhDQU52L0FnRGQvd0lBM3Y4Q0FPSC9BUURqL3dFQVwiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBQUFBQUFBL2Y4Q0FQLy9BUUQvL3dFQS8vOEJBUDMvQUFBQ0FQNy8rZjhBQUFJQS9QOEZBQVFBOC84QUFCb0ErZi9WL3dRQUhRRE8veG9BUVFCTy9vY0EwUHgxL3VjSFcvNFVDbThITE82a0FqdjgvZkNSRGRBQVlmUGlCSWdGWHZlVUNNMEdCdmg2L256N3JmMEovUWNRU1JWZEJnb0JTZ0ZSNjJyOU5QOG0rTG9FQXZyaUJWQUFpQVBtQUJFR01mMmwrU3dCanZhNi9HNEEvLzhQL0NZRE1nWG0vUjBDS0FFNi9mY0JCd0F0QU5EK2tRQTBBNVVEaHdGcy84SUI4ZnlkQUVQL0EvOHYvZTcvbVA4ai8yWUJJd0UzQXYwQVl2K3VBT0Q4bGdBZy93d0FJZi9ML24wQWUvL09BSk1CM1AvWEFGLy9Yd0NNLzA4QUIvOE5BRWYvcmY0akFUMy9sZ0FKQVA0QUhnRHBBTzhBVWY5TC8wNy9RZjhLQU9EL3gvK0QvM3NBVFFDREFNb0EwZjc5LytML0VRRHQvN0VBcXYrUy83SUF1di9vL3dnQWMvL1gvL0gvU3dDbS8rMy9ZZi9CL3lvQUFBREkvN1gvQXdCZy81RUFUZ0NYL3hZQS9QK3EvMDBBVkFDWS82di9CQUREL3p3QUxRQ04vOHovS1FEdS95Z0FFZ0NaLzZmL1ZRREMvL1QvS1FDcy83UC9VZ0FmQU83L05nQzgvNTcvYXdBWkFQUC8rUC9WLzh6L2JRQkJBTC8vRGdEMC8rVC9UQUJCQU16L0N3QXhBUHovU1FCcUFMbi9CZ0FMQVB6L0VBQTdBSXovMy84aUFBVUEvLzhrQUxmL3kvOVZBQlFBK3Y4MUFPai8wUDljQUI0QStmOFdBT3IvdnY4M0FCZ0F3LzhKQU9qLzRmOG5BQ0lBc2YveS93NEEzdjhnQUNRQXhQL24veWNBN1A4V0FDMEF5Zi9VL3ljQTl2LzcveVVBMFAvUC96VUFCQURjL3hVQTVQL0ovemNBQ3dEUy94VUE5UC9tL3pBQUNRRFgvKzMvOXYvMi95UUFDZ0RaLytQL0F3QUtBQllBLy8vYi85ai9FUUFMQUJrQURnRDYvKzcvR3dENC93NEE4UC93Ly9qL0VnQUVBQVVBOWYvMS93UUFHZ0Q0L3dBQTUvLy8vd0FBR1FEMS8vLy83ZjhGQUFVQUZRRHYvd0FBNnY4TEFBY0FGUURzL3dFQTlQOFNBQVlBQ3dEci8vNy9BUUFTQUFZQUJRRHYvd0lBQXdBV0FBSUFBZ0R2L3dBQUJnQVRBQUVBL2YvdS93UUFCZ0FRQVByLytQL3ovd1VBQ1FBTEFQai85Ly80L3dnQUJ3QUtBUFQvK2YvNS93NEFCd0FJQVBULysvLzkvdzRBQXdBREFQSC8vZi8vL3c4QS8vOEJBUFAvLy84QkFBMEEvZi8rLy9YL0FnQUNBQTBBKy8vOC8vYi9CQUFEQUFvQStmLzcvL24vQmdBREFBY0ErUC83Ly92L0J3QUJBQVFBK1AvOC8vMy9DUUFCQUFJQTkvLzkvLy8vQ1FELy8vLy8rUC8vL3dBQUNBRDkvLzcvK2Y4QUFBQUFCd0Q4Ly8zLyt2OENBQUFBQmdENy8vei8vUDhFQUFBQUJBRDYvLzMvL1A4RkFQLy9BZ0Q2Ly83Ly92OEZBUDcvQVFENy8vLy8vLzhHQVA3L0FBRDcvd0VBLy84RUFQMy9BQUQ5L3dFQS92OERBUDMvQUFEOS93SUEvdjhDQVAzL0FRRDkvd0lBL3Y4Q0FQNy9BUUQrL3dFQVwiLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBPbW5pdG9uZUZPQUhyaXJCYXNlNjQ7XG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgSE9BUmVuZGVyZXIuIFRoaXMgaXMgdXNlci1mYWNpbmcgQVBJIGZvciB0aGUgaGlnaGVyLW9yZGVyXG4gKiBhbWJpc29uaWMgZGVjb2RlciBhbmQgdGhlIG9wdGltaXplZCBiaW5hdXJhbCByZW5kZXJlci5cbiAqL1xuXG5cblxuY29uc3QgQnVmZmVyTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBIT0FDb252b2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuY29uc3QgSE9BUm90YXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5jb25zdCBUT0FIcmlyQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5jb25zdCBTT0FIcmlyQmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBSZW5kZXJpbmdNb2RlXG4gKi9cblxuLyoqXG4gKiBSZW5kZXJpbmcgbW9kZSBFTlVNLlxuICogQGVudW0ge1JlbmRlcmluZ01vZGV9XG4gKi9cbmNvbnN0IFJlbmRlcmluZ01vZGUgPSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBVc2UgYW1iaXNvbmljIHJlbmRlcmluZy4gKi9cbiAgQU1CSVNPTklDOiAnYW1iaXNvbmljJyxcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IEJ5cGFzcy4gTm8gYW1iaXNvbmljIHJlbmRlcmluZy4gKi9cbiAgQllQQVNTOiAnYnlwYXNzJyxcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IERpc2FibGUgYXVkaW8gb3V0cHV0LiAqL1xuICBPRkY6ICdvZmYnLFxufTtcblxuXG4vLyBDdXJyZW50bHkgU09BIGFuZCBUT0EgYXJlIG9ubHkgc3VwcG9ydGVkLlxuY29uc3QgU3VwcG9ydGVkQW1iaXNvbmljT3JkZXIgPSBbMiwgM107XG5cblxuLyoqXG4gKiBPbW5pdG9uZSBIT0EgcmVuZGVyZXIgY2xhc3MuIFVzZXMgdGhlIG9wdGltaXplZCBjb252b2x1dGlvbiB0ZWNobmlxdWUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5hbWJpc29uaWNPcmRlcj0zXSAtIEFtYmlzb25pYyBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuaHJpclBhdGhMaXN0XSAtIEEgbGlzdCBvZiBwYXRocyB0byBIUklSIGZpbGVzLiBJdFxuICogb3ZlcnJpZGVzIHRoZSBpbnRlcm5hbCBIUklSIGxpc3QgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IFtjb25maWcucmVuZGVyaW5nTW9kZT0nYW1iaXNvbmljJ10gLSBSZW5kZXJpbmcgbW9kZS5cbiAqL1xuZnVuY3Rpb24gSE9BUmVuZGVyZXIoY29udGV4dCwgY29uZmlnKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBVdGlscy5pc0F1ZGlvQ29udGV4dChjb250ZXh0KSA/XG4gICAgICBjb250ZXh0IDpcbiAgICAgIFV0aWxzLnRocm93KCdIT0FSZW5kZXJlcjogSW52YWxpZCBCYXNlQXVkaW9Db250ZXh0LicpO1xuXG4gIHRoaXMuX2NvbmZpZyA9IHtcbiAgICBhbWJpc29uaWNPcmRlcjogMyxcbiAgICByZW5kZXJpbmdNb2RlOiBSZW5kZXJpbmdNb2RlLkFNQklTT05JQyxcbiAgfTtcblxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5hbWJpc29uaWNPcmRlcikge1xuICAgIGlmIChTdXBwb3J0ZWRBbWJpc29uaWNPcmRlci5pbmNsdWRlcyhjb25maWcuYW1iaXNvbmljT3JkZXIpKSB7XG4gICAgICB0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIgPSBjb25maWcuYW1iaXNvbmljT3JkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLmxvZyhcbiAgICAgICAgICAnSE9BUmVuZGVyZXI6IEludmFsaWQgYW1iaXNvbmljIG9yZGVyLiAoZ290ICcgK1xuICAgICAgICAgIGNvbmZpZy5hbWJpc29uaWNPcmRlciArICcpIEZhbGxiYWNrcyB0byAzcmQtb3JkZXIgYW1iaXNvbmljLicpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NvbmZpZy5udW1iZXJPZkNoYW5uZWxzID1cbiAgICAgICh0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIgKyAxKSAqICh0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIgKyAxKTtcbiAgdGhpcy5fY29uZmlnLm51bWJlck9mU3RlcmVvQ2hhbm5lbHMgPVxuICAgICAgTWF0aC5jZWlsKHRoaXMuX2NvbmZpZy5udW1iZXJPZkNoYW5uZWxzIC8gMik7XG5cbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuaHJpclBhdGhMaXN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmhyaXJQYXRoTGlzdCkgJiZcbiAgICAgICAgY29uZmlnLmhyaXJQYXRoTGlzdC5sZW5ndGggPT09IHRoaXMuX2NvbmZpZy5udW1iZXJPZlN0ZXJlb0NoYW5uZWxzKSB7XG4gICAgICB0aGlzLl9jb25maWcucGF0aExpc3QgPSBjb25maWcuaHJpclBhdGhMaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy50aHJvdyhcbiAgICAgICAgICAnSE9BUmVuZGVyZXI6IEludmFsaWQgSFJJUiBVUkxzLiBJdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggJyArXG4gICAgICAgICAgdGhpcy5fY29uZmlnLm51bWJlck9mU3RlcmVvQ2hhbm5lbHMgKyAnIFVSTHMgdG8gSFJJUiBmaWxlcy4nICtcbiAgICAgICAgICAnIChnb3QgJyArIGNvbmZpZy5ocmlyUGF0aExpc3QgKyAnKScpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcgJiYgY29uZmlnLnJlbmRlcmluZ01vZGUpIHtcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhSZW5kZXJpbmdNb2RlKS5pbmNsdWRlcyhjb25maWcucmVuZGVyaW5nTW9kZSkpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlID0gY29uZmlnLnJlbmRlcmluZ01vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLmxvZyhcbiAgICAgICAgICAnSE9BUmVuZGVyZXI6IEludmFsaWQgcmVuZGVyaW5nIG1vZGUuIChnb3QgJyArXG4gICAgICAgICAgY29uZmlnLnJlbmRlcmluZ01vZGUgKyAnKSBGYWxsYmFja3MgdG8gXCJhbWJpc29uaWNcIi4nKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9idWlsZEF1ZGlvR3JhcGgoKTtcblxuICB0aGlzLl9pc1JlbmRlcmVyUmVhZHkgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgaW50ZXJuYWwgYXVkaW8gZ3JhcGguXG4gKiBAcHJpdmF0ZVxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuX2J1aWxkQXVkaW9HcmFwaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlucHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2J5cGFzcyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9ob2FSb3RhdG9yID0gbmV3IEhPQVJvdGF0b3IodGhpcy5fY29udGV4dCwgdGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyKTtcbiAgdGhpcy5faG9hQ29udm9sdmVyID1cbiAgICAgIG5ldyBIT0FDb252b2x2ZXIodGhpcy5fY29udGV4dCwgdGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyKTtcbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2hvYVJvdGF0b3IuaW5wdXQpO1xuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fYnlwYXNzKTtcbiAgdGhpcy5faG9hUm90YXRvci5vdXRwdXQuY29ubmVjdCh0aGlzLl9ob2FDb252b2x2ZXIuaW5wdXQpO1xuICB0aGlzLl9ob2FDb252b2x2ZXIub3V0cHV0LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXG4gIHRoaXMuaW5wdXQuY2hhbm5lbENvdW50ID0gdGhpcy5fY29uZmlnLm51bWJlck9mQ2hhbm5lbHM7XG4gIHRoaXMuaW5wdXQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG4gIHRoaXMuaW5wdXQuY2hhbm5lbEludGVycHJldGF0aW9uID0gJ2Rpc2NyZXRlJztcbn07XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBjYWxsYmFjayBoYW5kbGVyIGZvciB8aW5pdGlhbGl6ZXwgbWV0aG9kLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmUgLSBSZXNvbHV0aW9uIGhhbmRsZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWplY3QgLSBSZWplY3Rpb24gaGFuZGxlci5cbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLl9pbml0aWFsaXplQ2FsbGJhY2sgPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgbGV0IGJ1ZmZlckxpc3Q7XG4gIGlmICh0aGlzLl9jb25maWcucGF0aExpc3QpIHtcbiAgICBidWZmZXJMaXN0ID1cbiAgICAgICAgbmV3IEJ1ZmZlckxpc3QodGhpcy5fY29udGV4dCwgdGhpcy5fY29uZmlnLnBhdGhMaXN0LCB7ZGF0YVR5cGU6ICd1cmwnfSk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyTGlzdCA9IHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlciA9PT0gMlxuICAgICAgICA/IG5ldyBCdWZmZXJMaXN0KHRoaXMuX2NvbnRleHQsIFNPQUhyaXJCYXNlNjQpXG4gICAgICAgIDogbmV3IEJ1ZmZlckxpc3QodGhpcy5fY29udGV4dCwgVE9BSHJpckJhc2U2NCk7XG4gIH1cblxuICBidWZmZXJMaXN0LmxvYWQoKS50aGVuKFxuICAgICAgZnVuY3Rpb24oaHJpckJ1ZmZlckxpc3QpIHtcbiAgICAgICAgdGhpcy5faG9hQ29udm9sdmVyLnNldEhSSVJCdWZmZXJMaXN0KGhyaXJCdWZmZXJMaXN0KTtcbiAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdNb2RlKHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlKTtcbiAgICAgICAgdGhpcy5faXNSZW5kZXJlclJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgVXRpbHMubG9nKCdIT0FSZW5kZXJlcjogSFJJUnMgbG9hZGVkIHN1Y2Nlc3NmdWxseS4gUmVhZHkuJyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnSE9BUmVuZGVyZXI6IEhSSVIgbG9hZGluZy9kZWNvZGluZyBmYWlsZWQuJztcbiAgICAgICAgVXRpbHMudGhyb3coZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgcmVqZWN0KGVycm9yTWVzc2FnZSk7XG4gICAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbmQgbG9hZHMgdGhlIHJlc291cmNlIGZvciB0aGUgcmVuZGVyZXIuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5IT0FSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICBVdGlscy5sb2coXG4gICAgICAnSE9BUmVuZGVyZXI6IEluaXRpYWxpemluZy4uLiAobW9kZTogJyArIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlICtcbiAgICAgICcsIGFtYmlzb25pYyBvcmRlcjogJyArIHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlciArICcpJyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKHRoaXMuX2luaXRpYWxpemVDYWxsYmFjay5iaW5kKHRoaXMpLCBmdW5jdGlvbihlcnJvcikge1xuICAgIFV0aWxzLnRocm93KCdIT0FSZW5kZXJlcjogSW5pdGlhbGl6YXRpb24gZmFpbGVkLiAoJyArIGVycm9yICsgJyknKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggM3gzIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4MyAtIEEgM3gzIHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4Mykge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2hvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXgzKHJvdGF0aW9uTWF0cml4Myk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcm90YXRpb24gbWF0cml4IHdpdGggNHg0IG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IHJvdGF0aW9uTWF0cml4NCAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4NCkge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2hvYVJvdGF0b3Iuc2V0Um90YXRpb25NYXRyaXg0KHJvdGF0aW9uTWF0cml4NCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBkZWNvZGluZyBtb2RlLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBtb2RlIC0gRGVjb2RpbmcgbW9kZS5cbiAqICAtICdhbWJpc29uaWMnOiBhY3RpdmF0ZXMgdGhlIGFtYmlzb25pYyBkZWNvZGluZy9iaW5hdXJsIHJlbmRlcmluZy5cbiAqICAtICdieXBhc3MnOiBieXBhc3NlcyB0aGUgaW5wdXQgc3RyZWFtIGRpcmVjdGx5IHRvIHRoZSBvdXRwdXQuIE5vIGFtYmlzb25pY1xuICogICAgZGVjb2Rpbmcgb3IgZW5jb2RpbmcuXG4gKiAgLSAnb2ZmJzogYWxsIHRoZSBwcm9jZXNzaW5nIG9mZiBzYXZpbmcgdGhlIENQVSBwb3dlci5cbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJlbmRlcmluZ01vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIGlmIChtb2RlID09PSB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5BTUJJU09OSUM6XG4gICAgICB0aGlzLl9ob2FDb252b2x2ZXIuZW5hYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLkJZUEFTUzpcbiAgICAgIHRoaXMuX2hvYUNvbnZvbHZlci5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuT0ZGOlxuICAgICAgdGhpcy5faG9hQ29udm9sdmVyLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICdIT0FSZW5kZXJlcjogUmVuZGVyaW5nIG1vZGUgXCInICsgbW9kZSArICdcIiBpcyBub3QgJyArXG4gICAgICAgICAgJ3N1cHBvcnRlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgVXRpbHMubG9nKCdIT0FSZW5kZXJlcjogUmVuZGVyaW5nIG1vZGUgY2hhbmdlZC4gKCcgKyBtb2RlICsgJyknKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBIT0FSZW5kZXJlcjtcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmNvbnN0IE9tbml0b25lVE9BSHJpckJhc2U2NCA9IFtcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQrL3dRQTgvOFlBUDMvQ2dBQ0FBQUEvLzhDQUFZQTgvOEFBUEgvQ2dEdi85Ny9lLyt5LzlQK1VRRHdBSFVCRXdWNy9wUDhQL3kwOWJzRHdBZk5CR1lJRmYvWSs3MzYrZlA4OTBIdjhBR2NDM1QvdndZeStTNzBBQUlDQTNBRDRBYWdCdzBSNHczWkVBY044UlZZQVY4UThQMnora0VDSHdkSy9qSUcwUU5LQVlVRWxmOElDbGo3QmdqWCsvZjhqL2wzLzVmLzZma0sreHo4RlAwdi9uai9NZi9uL0ZjQlBmdkgvMUgzK2dCUC9IZjhjZmlDQVIvNTRRQmgrVVFBY3ZrekFXTDhUUDEzK2lEL1YvNzMrd3Y5S3YrWS9odit4UHo3L1VMODMvL2Evei85QVA2Ui81TCtqZjI2L1AzK3JQMjYvdEQ4blA3Qi9QditXUDFWL3NQOWd2OTEvM1A5eFAzSi9udi9HUDVTL3NiK0lQOHYvOWovZHY3VS9wcis2dit1L1ozL3N2NWNBT3I5US84My8rbi96UDV4LzU3KzIvL2svbndBL3YwMS8vTCtTQUNCL3NEL0ZmODFBSlQrVGdEcC9vY0FtLzVkQUZUK01nRCsvcE1BVy83by95SC94UURBL2trQTlQNkxBTDMrcEFDMC9pUUF6LzVVQUxEK1V3QXQvM1VBaGY0VUFBLy9wd0MrL2pvQXovNWFBQXYvZndEWS9pTUFJZit1QVBQK1pBQWMvMFFBeS80eEFCNy9UZ0RzL2dvQURQOHdBRUwvTndEby91Yi9VZjlCQUMzLyt2OUYveTRBUlA5SEFGUC9FUUEzL3hNQVRQODFBRzMvSFFBdS93Z0FhUDlGQUNiLzlmOUIveTBBVVA4ckFFRC9Dd0JWL3o0QVcvOFRBR0gvQlFCSy94c0FmdjhlQUZuL0FnQjMvendBZmY4UkFHai8vditFL3lBQWIvLzAvM24vRndCei94Y0FpdjhQQUhuL0ZRQ0oveGdBZy8veC8zai9FUUNhL3ljQWZmL3cvNDcvSHdDSS8vWC9pdi83LzQzL0pRQ00vK24va1A4QUFKYi9KQUNqLy83L29QOFpBTUwvU3dDby93NEF0djh0QU1iL1BBQ3IveGNBd1A5SEFNUC9PQURGL3k0QTBmOUlBTkwvTndDLy96RUEwZjlMQU1iL01BQzgveTRBM2Y5R0FNSC9GUURRL3lZQTIvOHNBTVQvQXdEWC94a0EzdjhTQU0zLzl2L2MvdzhBNGY4TEFNai84Zi9oL3hRQTJQOENBTW4vOC8vai94UUEwdi83LzlILy9QL2kveEVBMHYvMS85TC8vZi9qL3cwQTBmL3gvOWYvL3Yvay93Z0F6Ly91Lzl6L0F3RGcvd01BMFAvdi85Ly9CUURmLy8vLzB2L3kvK0QvQ0FEYy8vMy8wdi8yLytML0NnRGEvL3IvMXYvNS8rVC9DZ0RZLy9qLzJmLzkvK1QvQ0FEWS8vZi8zUDhBQU9UL0J3RFkvL2YvNFA4RUFPUC9CQURaLy9qLzR2OEdBT0wvQXdEYS8vci81ZjhJQU9IL0FRRGMvLzMvNXY4SkFPRC8vdi9mLy8vLzV2OElBT0QvL3YvaC93SUE1LzhIQU9ELy9mL2ovd01BNS84R0FPRC8vZi9sL3dZQTV2OEVBT0QvL3YvbS93WUE1ZjhDQU9MLy8vL24vd1lBNVA4QkFPSC9BQURsL3dVQTRmLy8vK0gvQVFEay93TUE0Zi8vLytUL0FRRG0vd0VBNS8vLy8rci9BQUR0L3dBQTcvLy8vL1AvQUFEMS8vLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy92Ly8vd0FBQUFBQUFBQUFBUUFBQUFBQS8vLzkvd0FBQkFEKy8vbi9BZ0FKQUFBQSt2LysvL2YvREFBZEFQdi8rditsLzhMK2pmLzQvdmdBZHdWUEFRQUNMUUJvK1FqL0V2N28vTjMvVmdDYkEwOEJ4ZitMK3luOUovMkhDVThGbWdCdkRlMzBSdjVoL0xUMDlnaTVDeGtBNWdPaTgvMzBrd0VNKzRZSk1mMm5CbWtKSkFRUUJMb0Z0dnZ2K200QTdQRjYvUjBCaWYzcUF1ZjhXQVJBQWY0R3lBQkcvQklBd3ZyNEFjdjhVLy9jL3lJQzhBRW4vQjhEYWYyQ0FnTUJBZjNNQU4zOHZnTEsvVVQvUXdDeUFQWUNsUHl2QVcvK3BRQW9BU0QrelArUi9JWUMxZjdDL25FQlFQOTZBWmIrMVFBSUFNLy95UUU3L3RrQVovN1RBWEwvdy84K0FJc0F0d0I3LzI0QTR2OWEvejRBN3Y0aUFEYi9kd0NqLzIzL2tnQk9BTlVBSXY4bEFLRUF4UDlnQUs3L0J3Q1AvNWtBNy85di8wd0F6djlEQUdULzMvOXZBSHYvNlArcS94VUE3UDhYQU8vL3V2L2cvMlVBRWdDVi93RUFUQURNLys3LysvL2ovK0QvOXYvaS8vai9JZ0QrL3hvQXhmLzYvejRBNS8rOC85RC9Rd0RxLyszL09RRFQvelVBSWdBL0FQUC9QZ0FqQVBEL0J3QUdBQ0FBREFDMy8vYi9IQUEzQU4vL1JnRE4vdzhBSUFBQ0FOLy9HUUJEQUNFQUl3QStBQ29BSlFBZUFQei9LZ0FZQVByL0RnQUVBQllBSWdBY0FNVC83ZjhPQU9MLzVQLzIvL0wvOVA4R0FQVC83di84Lys3LzZ2L3QvL3ovQWdBVUFPTC8vUDhWQUFNQTQvOElBUGIvK1A4TUFBb0E1djhOQUFzQTl2Ly8vd0VBQUFEOS8vbi85LzhKQUFZQTd2LzYvd01BK2Y4R0FBRUE3Zi83L3hnQUNBRDQvdzhBLy8vMy93MEErZjhCQUFJQS9QLzUveElBLy8vOS8vci83di8rL3hZQUNRRC8vL0gvQ3dEei93RUFEZ0FIQVBQL0ZBRG4vKzMvQVFENS8vZi9BZ0Q3L3dFQUJ3QU1BQUVBRFFEOC8vbi84ZjhPQVBYL0JBRCsvL1gvK3Y4V0FBUUErZjhDQUFFQTcvOFFBQUVBL1A4REFBVUE5ZjhLQUF3QTl2OERBQVVBK2Y4T0FBb0E5Zi83L3cwQSt2OEVBQWdBOFAvNi93b0ErLy84L3drQStQLzMvd29BKy8vOC93Y0E5Ly8xL3dvQUF3RDUvd2NBL1AvMy93MEFBd0QzL3dFQUJBRDIvd2tBQmdEMy93RUFCUUQzL3dVQUJRRDMvL3YvQndEMy93TUFCUUQzLy9yL0NRRDcvLy8vQlFENi8vbi9DUUQ5Ly8zL0JBRDkvL2ovQndBQUFQdi9Bd0QvLy9qL0J3QUJBUG4vQVFBQkFQbi9CUUFDQVBuLy8vOERBUHIvQXdBREFQci8vdjhFQVB2L0FRQURBUHYvL1A4RkFQMy8vLzhEQVB6LysvOEZBUDcvL2Y4Q0FQNy8rLzhFQVAvLy9QOEJBUC8vKy84REFBRUErLzhBQUFFQSsvOENBQUlBKy8vLy93SUEvZjhBQUFJQS9QLysvd0lBL2Y4QUFBSUEvZi85L3dNQS8vLy8vd0VBLy8vKy93SUEvLy8vL3dBQUFBRCsvd0FBQUFELy8vLy9BQUQvL3dBQS8vOEFBUC8vQUFELy93QUFcIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy8vLysvLy8vLy84QUFQLy8vLzhBQVAvL0FBQUFBUHovL2Y4SUFBTUE5Ly8vL3c0QUFRRDYvd3dBOC8vKy95OEFmdi8wLzJIL1VQNWdBYkgrMlFHMUIyY0FWQUloL2wzMkZQeU0vbkFDUFFEVi8rVUVvL1E2QVF3Q3Uvb0xEOWtGOFFKQS9VeitXZjJLQ09jQyt3VUtCc0w1YVFCUTk3cndPUGlQQXZuNUNBbDhBSEVEa1FQY0FBOEJuL2xJQWR6N0hRRjEreHo5Y0FNNC85NEU0Z0RLQXVuK2NnUFlBWXI5SmdKci9iZitpdnh6L01vQmd2NVVBOEVCU2dBUUFKNy9VZ0VrL2NRQjdmNjMvc0QvdmY0WEFoVC9CUUZDQURZQW5RR0kvOUVCdHYzaEFMRC92UCtjLzNIL1RnSU4vMXNCcGY4eUFQMy80ZjhxQUJyKzFmOE9BSjMvZHdBR0FERUJudjlKQVB6L0lRQndBSUgvamdBUy80d0FzQUNUQU9uL0RRRENBTG4vWlFDU0FBSUFBd0QxLzkvL2p2OWFBRFFBL3Y5RUFCMEFmZ0E4QUFRQUNnQjlBUHIvSUFBUkFQVC81djl4QUNBQUJBQUhBR1VBdC84OUFDNEFDZ0FqQU1QLyt2LzkveFlBN2YvMS8rRC83UDg3QUMwQXV2OFJBQWNBOS84RkFDOEEyLy95L3hJQUV3QWFBRFFBSkFEcC96b0FBZ0FmQUJJQTJmL2UvelVBK1AvNi93NEE5Ly9BL3pjQTQvL1AvL1QvNWYvUi8vLy9Fd0RiL3c0QTgvOEJBQmtBTkFEaC94RUErZi8wL3dJQUhBRGMvL2ovR3dEMS8vZi9HQURzLyt2L0VBQUFBUHovRWdEMy8rci9GZ0FNQUFrQUdBRDkvK3ovSVFBUUFQSC9HUUQzLy96L0NnQWZBT1gvQWdEOC8vSC9CQUFUQU92Lyt2Ly8vd0lBQkFBZEFPai9CUUFQQUFjQUFRQVRBT3ovOC84SkFBa0E2ZjhWQU92LytmOFFBQlVBL3Y4T0FPMy8rUDhLQUJVQTlmOEZBUHYvNS84VEFBMEE3ZjhYQUFrQUFRQUpBQllBNC84V0FBY0FDZ0FOQUJFQTd2OEVBUDcvQUFEKy93TUE5Ly83L3hBQUFRRDgvd1FBK2YvNy93TUFCZ0RxL3dBQSt2LzMvd1lBQ1FEMS8vMy9CQUQ5L3dnQURnRHcvL3IvQWdENi93RUFDQUR2Ly9qL0JRRC8vL1gvQndEdS8vai9BZ0FDQVBQL0JBRDIvL24vQkFBR0FQYi9CQUQ4Ly8zL0JRQUpBUEwvQXdEKy8vMy9CQUFJQVBQLy9mOERBUHovQUFBR0FQUC8rLzhDQVA3Ly9mOEZBUFgvK2Y4REFBQUEvUDhFQVBmLyt2OEdBQU1BKy84RUFQdi8rLzhHQUFRQSt2OENBUC8vL1A4RUFBVUErZjhBQVAvLy9mOENBQVVBK1AvLy93RUEvdjhCQUFVQStmLysvd0lBQUFELy93VUErdi85L3dNQUFRRDkvd1FBKy8vOS93TUFBZ0Q4L3dNQS9QLzkvd01BQXdENy93RUEvdi8rL3dJQUF3RDYvd0VBLy8vKy93QUFCQUQ2L3dBQUFRRC8vd0FBQXdENy8vLy9BUUFBQVAvL0F3RDgvLzcvQWdBQkFQMy9BZ0Q5Ly83L0FRQUJBUDMvQVFEKy8vNy9BQUFDQVB6L0FBRCsvLy8vLy84QkFQMy9BQUQvL3dBQS8vOEJBUDcvQUFELy93QUEvdjhBQVA3L0FBRC8vd0FBLy84QUFQLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy9QLzkvLzMvLy8vLy93QUFBQUFBQUFJQUFnQUNBUC8vQ0FBRUFFRUEvLytjQUFVQWIvOEhBQUg5K1A5ZUFSa0FvZ1FVQUpuOEJ3Q2QvZ1gvK1FRTkFLb0M5Z0ZkQXRiL2IvdmQvOTM2VFAvNkFzRC9uZnFuL3VuMVcvMGRBOElFc1FMdkFKdjJiUDcyK1dNQWtQOGRBY1grblFPMkFJcjZiUC9FQUJYK05nSy9CZGoySVF2MkFFNEVVQWlEL3hRQW53SW0vQjBCL3dHTkFvSDdzUWFQL2I4Q2lRYWtBcUQrUi85eEE0NzdLUUwvLzZyNzV2L08vcGNDZ1FDdEFpTUNCUUFrQU5BQVJ3SGYvLzM5aGdCbC9rVUFKZ0V0QVVFQVRnQS9BZ29BU0FESy96VUFKdjI5L3ZMK2wvOWMvMGNBVXdCQkFFOEE2UUU1Lzg3L1d2OU5BT2YrNXY3UC81UC80LzlCQUtZQVF3REQvellCNXYrci96WUFUd0FwLzF2L1dRQUVBQjBBaHdBMEFBMEFJQUEzQUFFQXp2L3UvKy8vNXY5bS96d0FJQURRLzhUL1NBQmlBTmIvU3dBYkFGZi9NUURYLzdML2hQOFRBUHIvQWdBTUFBc0FId0FaQUkzL1ZnREMvOXYvNS8veC82UC9Bd0JsQU12L3lmODJBQjRBK1A5V0FQai9Od0RpLzFFQTB2OUpBTmovSndBY0FBRUFEQUJZQU5qLzRmOE1BRXdBbVA4MkFOLy8zUDhVQURZQTcvLzYvd0lBQ0FEVS95Z0F5djgyQU43Lzl2LzIveWdBeHYvOS8rMy81Ly9uL3pVQTYvL2cveTRBRGdENS93c0FCd0R2L3hJQUR3QUdBQ29BSlFEMy96SUErLzhGQUJzQUZnRE8vekFBSEFBSUFCUUFMQURwL3hjQUNBQUFBUEgvR0FEcy93a0FDUUFGQUFnQUZRRHAvd0lBSEFEMS8vUC9FUUR3LyszL0dBRDkvK2YvSEFEOC8vVC9EQUFRQVBIL0h3RDQvL3IvRHdBUEFPai9FUUFDQU9uL0RBQVhBT1gvQkFBT0FOSC85LzhNQU8vLzlmOExBTlQvOWY4RUFPLy82ZjhOQU5iLytQOEtBT3ovNXY4TUFPRC83ZjhVQU8vLzcvLysvLzcvOXY4WUFQai85Zi96L3dzQSt2OFNBUEQvK3YveC94WUErZjhTQVBiLzkvLzMveEVBQlFBQ0FQbi85Ly95L3hRQUNRRC8vL2IvL3YvNy94SUFDUUQ5Ly9IL0FBRDcveEVBQWdENS8vUC9Bd0Q5L3c4QUFnRDMvL0QvQkFELy93VUEvdi8wLy9EL0JnQURBQU1BL1AvMi8vZi9Cd0FHQVA3LysvLzIvL2ovQ0FBRkFQdi8rZi81Ly92L0J3QUhBUG4vOS8vNy8vNy9CUUFGQVBmLzkvLysvd0VBQkFBQ0FQZi8rUDhCQUFJQUFnQUFBUGovOS84Q0FBTUFBQUQrLy9uLytmOEVBQVFBL3YvOC8vci8rLzhFQUFNQS9QLzcvL3ovL1A4RUFBSUEvUC81Ly83Ly92OERBQUVBKy8vNS8vLy8vLzhDQUFBQSsvLzUvd0VBQUFBQkFQLy8rLy82L3dJQUFRRC8vLzMvL1AvNy93TUFBUUQvLy8zLy9mLzkvd0lBQVFEOS8vMy8vdi85L3dNQUFRRDkvL3ovQUFELy93RUFBQUQ5Ly96L0FBQUFBQUFBLy8vOS8vMy9BQUQvL3dBQS92Ly8vLzcvQUFELy93QUEvLy8vLy8vL0FBRC8vd0FBLy84QUFQLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQrLy8vLytmLy8vL3YvL3YvLy93QUEvLy8vL3dVQUFRQUlBQUlBQndBQ0FIa0FUQUFPQWFNQUFmOUMvOVg2UXZ3aEFyQUF0Z2hBQlczN252L3krMHdBV1FOY0FFOEpSd1NPQzZBRUplOFA4Uy96clBXYUJJLytMUUEvKzBMK1AvNEs4QWdBYi84dUNoNzhCUXRDNjE0R2FRV2ZBaW41VWZ6TjhUZitHUWl6QVo0TUNRTWJHSjRCb1JTN0F2Y0h5UUFSQTZuOVp3SFovejREdndBWkFsQUI2Z2JOQVM0R0ZBREZBVEw3RS8ySytqMzdDL3hwL1NEOVV2MFZBT3NEcy8vV0FkMytidjdGL2Y3OW1QMlgvS0grRndDMC8xbitWZ0ZjQVRBQkhRR2FBRVQrbmY4WS9ob0FvdnBxQVhqOUNRS1cvbHNDbC80UkFwaitiQUhrL1JjQWx2NEJBRy8rRGdEaS8vMy9Hd0FPQUVJQXEvK3kvM3ovOHY4Ky83VC9UdjgvLzI3L21nRFovMXNBK1ArY0FBQUEvUC9pL3lNQWkvODVBTVAvS2dETS85TUE5UCtRQUJvQTRRQWlBQ3dBQ3dCZEFQNy9UUURiL3kwQXlmK1NBQTBBWndEZy80d0ErLzgvQUFNQWdRRHAvdzBBREFBUUFBb0FOZ0FnQUE0QUtBQklBQjRBNHYvMy8rZi8rdi9jLytuL0VBRG4vd2dBRkFBcUFPei9Jd0RjLzkvLzNmOFhBTkQvMnYvYS93MEE1djhCQU5iLzlQL20vd0FBOFA4WkFOMy9Sd0FHQUVzQUJnQi9BUDcvTkFBU0FFZ0FCQUEzQVAzL0tnRDkvMXNBOFA4bEFPci9GZ0QxL3hBQTQvOGtBT3YvQXdENC94RUE1ZjhOQVBULyt2LzMveDhBN2Y4UEFQai9Jd0Q1L3lBQTkvOFpBQUVBR2dENC94b0E5ZjhIQUFNQUNBRDAveGdBK1A4QUFQci9JUURwL3c0QTh2OEhBUFgvSWdEMS93WUErUDhHQVBYL0dnRDMvd29BQlFBU0FBY0FHUUR3Lyt2LzlQOGJBUDMvSEFEcy8rZi83LzhMQVByLy92LzAvL1QvQWdEMi93c0E2UC8vLytQL0NBRFkvLzcvNXYvMy93UUEvdjhMQVBEL0dnRDEveU1BL1A4UUFPdi9MQUR3L3lRQStQOFhBTzcvTVFEOS95RUFBUUFjQVBEL0lnRDkveE1BKy84T0FPLy9GUUFCQUFvQSsvOFBBUFAvRlFBQkFBUUE5LzhQQVBYL0NBQURBQUVBK1A4TkFQdi9DQUFHQUFVQTkvOEpBUC8vQUFBRkFQei8rZjhIQUFRQS9mOEZBUDMvL1A4RkFBWUErUDhEQVA3LysvOEFBQWNBOS84QkFQLy8vZi8vL3dnQTkvLysvd0FBL3YvOC93VUE5Ly84L3dJQS8vLzcvd1VBK3YvNy93SUFBQUQ2L3dNQS9QLzYvd0VBQVFENi93RUEvdi83L3dJQUFnRDYvLy8vQUFENy93RUFBZ0Q3Ly83L0FRRDgvd0FBQXdEOC8vMy9Bd0Q5L3dBQUFnRDkvL3ovQXdELy8vLy9BZ0QrLy96L0F3QUFBUDcvQVFELy8vMy9BZ0FCQVAzL0FBQUFBUDMvQWdBQ0FQei8vLzhCQVAzL0FRQUNBUDMvL3Y4QkFQNy9BQUFCQVAzLy92OENBUDcvLy84QkFQNy8vZjhDQVAvLy8vOEFBQUFBL3Y4Q0FBQUFBQUFBQUFBQS92OEJBQUFBQUFELy93QUEvLzhBQVAvL0FBRC8vd0FBLy84QUFQLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUFBQVAvL0FBRC8vd0FBLy84QUFBQUEvLy8vL3dBQUFRRCsvLy8vQUFBR0FQMy9PQUFCQUlJQUF3QnYvL2YvRS8wUUFLMEFEUUN6QS83LzhQNHUvMGNCRFFDSkE2QUJiUURnL3c3L3ovOW8rVm4vU1BuTC8xLy9FZisyK2pyOVJmWmdBNVFGWndJTERGaitQQWIyL25FRktnS2svUjBEbHY2Yi9GVURzUDZZQW9qOVNnQVQvaUwvdEFQd0F2OEEwUDZ6QXI3L2R3QW5BZjM5dVAyMi9za0Eydi8vLzJZQ29QNFVBVXNBWmdGMkFKSCs0UDcwL3J6OStmK1UvWHYvOHY3Q0FjYitUQUNTL2t3QXYvK3gvdFg5b1A3MS9vTC8xZjhuQUVVQVp3R3RBQWdBSWdDL0FENEJhUDhHQUdIL2RRREYvNjRBcmY4bkFha0FoQUg5LytrQVFRRDNBRmIvcS84cC95SUFSLzhGQVBEL1pBQS9BSVlBM3Y4dEFEUUFEUUJwLzNmL0N3QUJBUDMvV2Y4T0FOai9Xd0RIL3hvQWUvOERBS3ovenY5Ni96OEEzZi9KLzVYL0lBRDUvL2ovcS8vYy8rLy9SQURxLy9EL3Z2OHBBRFVBRlFESS95OEFDQUFiQU5iL093RDMvKzMvOWYvZS93Y0FJQUFlQU1ILzgvOHhBQzBBRUFEVy8rMy9IQUFEQVB2LzhQOERBT0wvT3dEMy94Y0FDUUFIQU0vLzVmOFhBQWNBei8vVC85RC9IZ0Q5Ly8vL3lmL2UvL3YvQWdELy85SC82Ly8vLy9ILysvOGhBQUlBOS8vNy93MEFGZ0FRQVBMLzJ2LzgveHNBR1FBQkFOei85UDhZQUFRQS92L3kvd01BNXY4WUFBa0FBQUFBQUFNQTcvOEtBQmdBRHdEcy8vai9Cd0FUQUJzQThQLzEvL3ovQkFBTUFBQUE5UC9zL3hBQS92OEdBQWtBL3YvcC93TUFDd0FMQVA3LzlQL3Avd2NBRFFBRkFQYi83Ly80L3cwQUNBRDgvL2IvL3YvMS93TUFDd0QxLy9ULzhQLzgvd0FBQ1FEei8rZi81UDhHQUFrQUJRRDUvL0QvK3Y4RkFBMEFBd0QvLy9UL0FnQUNBQkFBL3Y4Q0FQRC8rLzhGQUFvQTlmLzMvL2YvL3Y4R0FQNy85di90Ly96LytmOEFBUGovK3YvMy93RUErdjhIQVByLy9QLzUvd1FBLy84REFQci8rUC8zL3dZQS8vLysvL1gvKy8vNS93UUEvZi83Ly9YLysvLzQvd01BL2YvOC8vai8vdi85L3dZQS8vLzgvL2YvQWdBQUFBVUEvZi82Ly9uL0F3QUNBQUlBL2YvNy8vei9Bd0FDQUFBQS9mLzYvLzMvQWdBREFQNy8vZi83L3dBQUF3QUZBUHovLy8vOC93TUFBZ0FFQVB2Ly92Lysvd01BQWdBREFQdi8vdi8vL3dNQUFRQUJBUHYvL2Y4QUFBSUFBQUQvLy92Ly9mOEJBQUlBLy8vKy8vei8vdjhDQUFJQS92LzkvLzMvLy84Q0FBRUEvdi85Ly83L0FBQUNBQUFBL3YvOS8vLy9BQUFCQUFBQS9mLzkvd0FBQVFBQkFQLy8vZi8rL3dFQUFRQUFBUC8vL3YvKy93RUFBUUQvLy83Ly92Ly8vd0VBQVFELy8vNy8vdi8vL3dFQUFBRCsvLzcvLy84QUFBQUFBQUQrLy83Ly8vOEFBQUFBLy8vKy8vNy8vLzhBQUFBQS8vLy8vLy8vQUFBQUFQLy8vLy8vLy8vLy8vOEFBUC8vLy8vLy8vLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUFBQUFBQUFBQUJBQUFBQUFELy8vLy8vLy8vLy8vLy92Ly8vLzMvLy8vLy8vLy8rLy84Ly8vL0FRRDkvL3ovOWY4QkFBSUErZjhkQUNnQVdRQnhBSlgvcXYrWS91ejlhUDlrLzdVRFVRUUJBaVFBNFBnaS9Ba0IwZ0thQnNELytmeHAvdno5Q1FTcC9JLyt5d0RPK3ZNRDBmeksvUEFCY2dCZUJmb0J2Lyt1QXVIOVNmNWdBeTM5YXdNbUJXVUJ1UDlmQTkvOWZnRGovMi8rRUFDYUFDY0NTdjlaLzJqL3J2N2hBQTBBV2Y1NS83TDg0UDdFL1NJQVQvNjdBTXYvdGYrRkFBNy8xdis3L2d2L0lQK0Uvc1FBK1A1YUFYei90UDlYQUZYL3RQOG8vNHIvai8vZS95UUFNdjltQUpUL3JnQ3IvOVgvRXdDYi8vSC85ZjdGLzZEL0VBQW9BSzMvL3YrZS96c0FoLytCLzdyL2lmL0MvMnIvNFAvei82Ly9Id0N5LzBJQTcvOVpBTFQveS84MEFDZ0E5di9KLzkvL0RnQTVBRFVBTFFBUkFESUFDd0FmQU9mL05nQXJBQ01BQ1FCQkFFY0FHQUFqQUM0QVdRQlVBSGNBQUFBZkFDRUFJQUFjQVBqL0NBRGsveVFBN3Y4OUFFRUFGd0Q1L3hZQTZmOGFBT1gvQUFERi96UUFEd0FVQU9UL0JRRHIveVVBNlA4WEFPZi9IQURSLzBBQThQOG5BQWdBQ1FEdC95Y0FLQUFIQVBIL0lRRHoveHNBQ0FEbi8vbi9EZ0FEQUE0QThQLy8vOHovR2dETi95TUEvZjhRQU5qL013QUNBQzBBQ3dBT0FPMy9KZ0FaQUFVQUNnQUFBQTRBSWdBYUFBa0FEd0FDQUFBQUhRQVRBQVVBQlFBQ0FBZ0FDd0FqQU8vLy8vOEFBQThBQlFBUEFQTC8vZjhHQUFzQUJnQUdBUEQvOHY4R0FQei9DQUQ2Ly9ILzZ2OFBBQWdBQmdENC8vMy85djhhQUFnQUJ3RDEvLzcvL3Y4UUFBb0FDQUQvL3dVQTl2OFFBQW9BQkFBRkFBZ0FBZ0FKQUFvQUF3RC8vdzBBQWdELy93Y0EvdjhEQUFvQUJRQUZBQlVBQkFBS0FBWUFCd0FIQUE4QUNnQUdBQXdBRHdBTUFBa0FFQUFKQUFnQUR3QU1BQWdBRGdBSkFBVUFDUUFQQUFVQUN3QUhBQUVBQmdBSUFBRUFCQUFHQVAvL0FnQUpBQUFBQWdBRUFQNy8vLzhJQUFJQS8vOEdBQUVBQVFBSkFBSUEvdjhFQUFNQS8vOEpBQUVBL3Y4REFBTUEvdjhIQUFNQS9mOEJBQVVBL3Y4RkFBTUEvdjhCQUFjQS8vOERBQU1BL3Y4QkFBWUEvLzhDQUFNQS8vLy8vd2NBQUFBQUFBTUFBQUQvL3dZQUFRRCsvd01BQVFELy93VUFBUUQrL3dJQUFnRC8vd1FBQWdEKy93RUFBd0QvL3dNQUF3RCsvd0VBQXdELy93SUFBd0QvL3dFQUJBQUFBQUVBQkFELy93QUFCQUFCQUFBQUF3QUFBQUFBQkFBQkFQLy9Bd0FCQUFBQUF3QUNBUC8vQWdBQ0FBQUFBd0FDQVAvL0FnQUNBQUFBQWdBQ0FBQUFBUUFEQUFBQUFRQUNBQUFBQVFBREFBQUFBUUFDQUFBQUFBQUNBQUVBQUFBQ0FBRUFBQUFDQUFFQUFBQUJBQUVBQUFBQkFBRUFBQUFCQUFFQUFBQUJBQUVBQUFBQkFBRUFBQUFCQUFFQUFBQUFBQUFBQUFBQUFBQUFcIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUFBQVAvL0FBRC8vd0FBLy84QUFBQUEvLzhBQVAvL0FBQUNBQUFBK2Y4QkFBWUEvLy80L3dJQS8vOEFBQThBL3YvVi93RUFFd0E5QUFFQlJ3QTJBRjcva2ZvZy8zZ0J3djk5Q0RZQlUvcXRBVVgvQVA3T0Fma0FYL285QjM4RlNmd2FBdVQxNC82MEJBcjhDUUFJL3RmeUlRVHpBWFArZWdkVUJCd0JvZjdUQk1UOGJBV2kvNUVFV3dCUkFBQUt5ZnhFLzhiODh2cDZBQ1ArUEFGNC9xRDhNUU5NL3lnQ0ovMlhBUEQ5a1A1Z0FWVC9pUDlJL2xFQjRQOHFBRDBCRkFHYS8rNy9EZ0IyQU9QOThnRm0vdS8rVnY1L0FHOEFTUDlnQU0vL3F2OXcvL29BY3YrMi9qSUJIZ0E3LzZEL29BQUdBS0gvbEFEVC93QUFnZ0M4QUFZQWtQOXlBRWNBa2Y4QkFPRC9SQUFyL3pVQU53RHQveFFBSlFBa0FNVC96d0EvQU9IL3h2OXpBR3NBTlFCVEFJY0FMQUF2QUNJQVRBQ3kveE1BREFEZy94Y0FXQUJ2QUpMLzdmOVZBUGIvRWdEdC93Y0E0ZjhrQVBQLzVQK2gvd2dBQ1FEeS8vci9MZ0FRQU1uLzgvOUNBT1gvNXYvUy85Ly8zUDhwQUJZQXVQL3MvdzhBRmdEdC8rMy83di93LzlqLzUvOEdBT2YvMlAvMi8vUC8vdjhrQUJNQXVmL20veG9BREFEWi8rci8zUDhLQUFVQUt3RGUvd3NBM1A4VkFBQUFEZ0FmQUIwQUNBQU1BRjRBR2dBaEFQTC9Nd0R6LzBrQUJBQUtBUFgvTHdBYkFBa0E5di9zLyszLzgvOENBQkFBQUFEbS8vbi9CUUFMQUFVQUFRRGovL24vSlFBVkFQWC85di8rL3dJQUVRQUJBUFAvOFAvMS93QUFCZ0Q2LyszLzcvL28vL2ovREFEOC8rYi84UDhJQUFrQUJnRDQvL0QvOFA4VUFBb0FBd0Q0L3dBQStmOE9BQWNBQUFBRkFQWC85djhUQUFrQTh2OEVBUGIvOS84ZEFBMEE3LzhDQVBuLytmOFNBQVFBOC84Q0FPZi8rdjhEQUFnQTlQLy8vL0gvL1A4SUFBVUE4Ly8wL3dJQUFRQUdBQWdBOS8vNy93QUErLzhFQVAvLytQLysvLy8vQWdBQ0FBc0E4di8rL3dJQUJRRDcvd2dBOXYvNy93TUFCQUQ1L3dBQS9QLzMvd0VBQVFENy8vNy8vUC8xL3dRQS8vLzMvL3IvLy8vMy93TUFBd0QxLy9yL0F3RDYvLy8vQWdENC8vbi9Bd0Q4Ly83L0FnRDQvL24vQXdEKy8vMy9BUUQ0Ly9uL0JRRC8vL24vQUFENi8vai9CQUFCQVBqL0FBRDkvL3YvQXdBREFQai8vdi8rLy96L0F3QUVBUGovL3Y4QkFQNy9BUUFEQVBqLy9mOENBUC8vLy84RUFQci8vUDhEQUFBQS92OENBUHYvL1A4REFBRUEvZjhCQVAzLy9mOERBQUlBL1A4QUFQNy8vZjhEQUFJQS9QLy8vd0FBL2Y4QkFBSUErLy8rL3dFQS8vOEFBQUVBKy8vKy93RUEvLy8vL3dFQS9QLysvd0VBLy8vKy93QUEvZi85L3dFQUFBRDkvd0FBL2YvKy93RUFBUUQ4Ly8vLy92Lysvd0FBQVFEOC8vLy8vLy8vLy8vL0FRRDkvLy8vQUFELy8vLy9BQUQrLy8vL0FBQUFBUC8vQUFELy8vLy8vLzhBQVAvL0FBRC8vd0FBLy84QUFQLy9cIixcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gT21uaXRvbmVUT0FIcmlyQmFzZTY0O1xuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuY29uc3QgT21uaXRvbmVTT0FIcmlyQmFzZTY0ID0gW1xuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRCsvd1FBOC84WkFQci9EQUQrL3dNQS92OEtBQVFBL2Y4REFBTUFCQURzLy96Lzh2L3ovOGYvUi85MC9vYisvL3pBQVdzREF3WTNES245Ly90dTkzRHZrd0k2QW40Q3V3SjAvQkg3VlB1eDkyWDBHdTdOL0VYOW1nZnFDa2tJaVJNZ0JkNE5RUUdML2MwRy94QnhBS0VMWkFUVUEvc0lIUlN4K2ZrQ3lBVW1CTkVKSUFSbEFkSHoyQWpOQUNjSXNBVzRBbEVDc3Z0Si9QLzdLL3RmKytuOGFQNFcrZzBGWEFFbEFNbjhuUUhuL3NUK1p2N04rOVgyeHZ6TS9PMytFdnBxQkJEN1NRTGQrdmIvc1Bsdy9KRDcyLzNuK1JyK0wvd1Mvdno2VVFHZy9OZitBdjVMLzVYOUd2Mi8vU1ArbWYzai9sZit2LzJCL1pILzVQMDUvaUw5TVA5Ri91ZjlVUDR2L3F2OW12N28vWG4rd1Ayay84TCt1UDVKL3REK0R2L1kvYkwrbVA3Mi9uMytwUCs3L2hBQSsvNXpBR0grWi8rdS9nOEF6djJ5LzZMKy8vOW8vaUlBRFA4VkFDei9Dd0NOL3BiLzF2NHlBRlArd2YrNC9qc0FjZjVWQVAzK2JBRGEvbk1BNmY0c0FPVCtJUUJkL3Y3Lzd2NmFBSUwrUUFEZS9uRUEwUDR5QUt6K0NRQ28vbW9BdWY1eEFONyttQUM4L2pjQU5mOWVBUFgrSUFBMS8xa0FBUDloQU16K1BRRDUvbTBBMi80Z0FQcitVUURoL2pRQUV2OUJBUEgrRkFCTi96a0FTdjlEQURQL0JBQmUvMUlBR2Y4b0FFMy9SUUF3L3pJQVFmOG1BRG4vR2dCRS94SUFSLzhoQUQ3L0JBQnkvekVBS1AvMC8wNy9Hd0JYL3o0QVJmOG1BRnIvUVFCVi96VUFWUDhlQUZ6L0pBQnQvMEVBVVA4TUFIei9LZ0JyL3ljQVl2OEVBSDMvTUFCbC94OEFndjhiQUlqL0dnQnYvL3ovZmY4QUFKWC9JQUJ1LytUL2p2L3IvNHovOS85bi83Ny9wUDhKQUpEL0VRQ0ovL3IvcS84V0FKLy9HUUNVL3hZQXR2OHFBS3IvUFFDVy95c0F3ZjgrQUxiL09nQzMveWdBei84dUFNNy9PZ0RIL3lnQXovOGtBTXovT2dDLy94c0ExZjhxQU1uL0x3RE4veGNBMWY4b0FNdi9KUURSL3hNQXpmOGJBTS8vSGdEVS93VUEydjhaQU5ML0V3RFcvd0VBMWY4WkFNei9Cd0RYL3dJQTB2OFNBTlQvQlFEVy93TUEwLzhQQU5UL0FBRFkvd0lBMWY4TUFOWC8rZi9hL3dVQTB2OElBTmYvKy8vWS93VUEwLzhEQU5yLytmL1kvd1FBMXY4QkFOci8rZi9aL3dVQTEvLzgvOXovK3YvWS93WUEyZi84LzkzLy92L1kvd1VBMnYvOS85My8vLy9aL3dVQTNQLzgvOTcvQWdEYS93TUEzdi84Lzk3L0F3RGIvd0lBMy8vOS85Ny9CQURkL3dFQTRmLy8vOS8vQlFEZi93QUE0djhBQU4vL0JRRGYvd0FBNC84Q0FOLy9CQURoL3dBQTQvOERBT0QvQkFEaS8vLy80LzhEQU9IL0F3RGsvd0FBNVA4RkFPTC9BZ0RsL3dFQTVQOEZBT0wvQVFEbC93RUE0LzhFQU9ML0FRRGovd0lBNFA4REFOLy9BQURnL3dJQTN2OENBT0QvQUFEaC93RUE0djhBQU9QL0FBRG0vd0FBNlA4QUFPei9BQUR1L3dBQVwiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vL2YvKy8vNy8vLzhBQVAvLy8vOEJBQUVBL2Y4QUFBRUFBUUFGQUFVQTkvLzYveDBBMmYvOS94TUEzUCtqQUUvL29mOUhBS1AvL2dDai83Ny9aL3ZpLzI4RDkveXdESkFKSXZyNkFzWDBYZWM0QmhjR3pmMjNEWlA3eWZaNkMxLy9ud0JEQklIeVlnb2IvVGYzc1E0MUFOb0tSQS9BK0U3eWZmQWE5Z0Q1RVFVQkRNd015Z2lxQUhNQXFQcWhBR1VCMi9nRSthNzhILys0QVBUNkR3SVVBQTBITndNaEJmTDhFLzkwQTVuN2RQOWNBTElDK3Y1Qy9xMEFPdjlrQW9nQkh2MDEvKzMvcUFRRC91YjhULzR2QU9VQTVQNktBVHYreXdFWUFlVCtLUDZpLzNnQ0ZQNmgvaHIvK1A4M0FDTC9WQURuLzhVQVJRSkkvNE1BdS84cUFsait3ZjRpQVBiL0xnRkovOFFBVUFCQUFJNEFCZitrLzNYL1lnRksvaWovai85SEFEb0FpLytXQUEwQlZ3Qy9BQ0wvTEFDZS8vY0FSdjlpL3hnQVVnQTBBQ2ovRmdCZ0FJai81UDlNLzd6L3p2OC9BS3ovZ3Y4c0FFUUE2LytJL3lZQWF3REwvN1QveGY4cUFPdi9GUUN1LzVuL0VnQXlBTzMvaS85TEFFNEErLy9SLy9QL0ZnRGUvOHovdS84REFESUFMQUFaQUxML1RBQThBQndBby8vMS94d0EvUC9ML3owQTZQOGpBTjcvN3YrYS96QUF3Zi83LzMvL0tRQXVBQ3dBOXY4UkFHWUFJd0JOQURnQUtnQVNBRjBBRGdBTkFDRUFNUURILy9IL0xRQUNBQjBBeS8vLy94MEFQQUFCQUFRQTJ2OGlBQWNBRWdERS8rdi9GUUQrLytQL0RBRDEvOTcvNnYvNC8vWC9Fd0Q0Lys3LzVQOGNBQTBBQ1FESC8vNy9DUUFYQUFFQS9QLzUvL2ovQ3dBV0FBRUFCUUQ5Ly9uL0FRQVdBQjBBN3Yvay93QUFDUUFtQVAvLzkvOEFBUG4vOC84YUFPLy82LzhmQU92LzV2OGhBUC8vNS84UEFPZi9BQUFHQVBuLzZ2OEpBQVlBQmdBQkFPdi8xLy8xLy9MLytQOERBQmNBNmYvOC93TUFDZ0Q3L3hBQTN2LzIvL3ovREFEdS8vei81di81L3dFQS9QLzYvLzcvN3YveC93UUFCZ0Q1L3dBQTh2L3cvd2tBRVFEMi8vai8rdjhFQUFjQUVBRDMvL3YvK3Y4Q0FBQUFDUUQzLy92Ly92Lzkvd1VBREFEMi8vWC9BZ0FIQUFBQUJ3RDIvL1QvQmdBS0FQNy9BUUQ0Ly9yL0JBQUlBUG4vQUFEMy8vZi9CUUFIQVB2Ly92LzcvL24vQlFBSkFQai8rdi85Ly83L0FnQUdBUGovK2Y4QkFBRUFBZ0FGQVBuLyt2OEJBQUlBQUFBRUFQbi8rZjhDQUFRQS92OEJBUHIvK3Y4Q0FBUUEvUC8vLy92Ly9QOENBQVFBKy8vKy8vMy8vZjhDQUFVQSt2LzkvLy8vLy84QUFBUUErdi84Ly8vL0FBRC8vd0lBKy8vOC93QUFBUUQrL3dFQSsvLzgvd0FBQWdEOS8vLy8vUC85L3dFQUFnRDgvLzcvL2YvOS93QUFBZ0Q4Ly8zLy92LysvLy8vQVFEOC8vei8vLy8vLy8vL0FBRDgvLzMvLy84QUFQNy9BQUQ5Ly83Ly8vOEFBUDcvLy8vKy8vLy8vLzhBQVA3Ly8vLysvLy8vLy8vLy8vLy8vLy8vLy8vL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vL3Y4QUFQLy8vLy8vL3dBQUFBQUFBUDcvQVFBQkFBQUFCd0QvLy9YL0JRQWpBUEwvQ1FEYi85RC9HQUFiLzdzQVl3Q1cvejBCY1AvWC83VC8yUURXK3dIOHlBTkNDQ1VKNVFUKytVWG1oUHdoQTc4RnVBeEgrcDc4aWZ1ZEJsQUc5dm11L2xBSzJmZGxCLy8vY2Zqb0NhMEU3QWtuOVliL3p2YmErQWtBSFB5d0JHRUJGd1VOQUw4QVhBQUdBMjBERnZtUi9reitGLzA2QWcvK0d3SGwvNUVFS2dKZC9xMEFQL3ltLzluNkVmeFkvMkgrL1FGdEFDNEM2UUJEQWFNQ28vMjAvKzMvM2YvcC9mTDlydjlWLzZjQmhRSHVBWDRBY3dKWUFhSC9JUC9QL2dzQXBQMExBZTcvc1FCdUFJMEFBZ0dEQUU0QnpBQ2UvNVgvL3Yrdi8rZitaZitnQU92LzVRQmhBT0lBcEFBTkFTWUF1UCtoLzhiL0hRQnIvOS8vYkFDV0FHRUFGQUI1QUQwQVdRRFUvK0QvWWYvcC8vRC9zLytSLzRRQU1RQnZBQkVBa1FCZkFCUUFKZ0RXL3d3QTgvOFhBTHovdmY4ekFGQUFLd0QxL3pFQVB3REoveDBBNy84TEFPWC9Gd0RSLy9IL0VRQWRBTy8vNlA4UUFGRUEyZjhXQUJFQU1nRHkveElBK2Yvcy94QUFMZ0R2Ly8vL0hRQXZBUFQvK2Y4aUFBWUFFZ0FGQUJvQUdnRC8vdzBBK2YvMC94c0FIZ0R4LzlmL0dBQUNBUEgvOGY4SkFQZi9Hd0FMQUJFQTcvOGNBUFQvQ2dEMi8vai9CUUQ4LyszL09nQWdBQVlBOWY4UEFONy9EZ0Q5LzlyLzEvLzMvKzMvOS8vMS8vYi84Ly81Ly9mL0FnQUpBT2YvK3Y4T0FBTUFDd0Q5Lys3LzVmOGVBQUVBOS8vcS8vNy84UDhXQVA3LysvLzQvd0lBK2Y4VEFBSUE5Zi81L3djQStQOGlBQWdBOXYvbi94b0EvLzhnQUFVQUJ3RGovd0FBOXY4QkFBVUFGUURuL3dNQTd2OFFBQkFBRVFEbS93d0E4ZjhhQUFBQUJ3RHUvd2NBQ2dBU0FBRUE3Ly93Ly9mL0JnQVJBQWtBNlAvMy93Y0FEZ0FLQUFZQTRmLzQvd1lBRGdBQUFQci84UC85L3hRQUNnQUhBUG4vNy8vOS94RUFBZ0QrLy9MLzh2LzgveFVBQXdEdy8vSC85ZjhDQUFzQS92L3EvL0wvK2Y4RkFBWUEvUC9yLy9qLy8vOEdBQWtBKy8vby8vai9BUUFJQVAvLyt2L28vL3YvQ0FBSUFQdi8rUC93L3dFQUNRQUhBUGovK2YvMC93SUFDd0FGQVBiLytmLzQvd1FBQ3dBQ0FQUC8rZi8rL3dZQUNBRC8vL0wvKy84QkFBWUFCUUQ5Ly9QLy9QOEZBQVVBQWdENy8vVC8vZjhIQUFRQS8vLzcvL2YvLy84SUFBTUEvUC82Ly9yL0FRQUlBQUVBK3YvNi8vMy9BZ0FIQUFBQStmLzcvd0FBQXdBRkFQNy8rUC84L3dJQUFnQUNBUDMvK2YvOS93TUFBd0FBQVB6Lyt2Lysvd1FBQWdEKy8vei8rLzhBQUFRQUFRRDgvL3ovL2Y4QkFBUUFBQUQ3Ly8zLy8vOEJBQU1BLy8vNy8vMy9BQUFDQUFFQS92LzcvLzcvQVFBQkFBQUEvdi85Ly8vL0FRQUFBUC8vL3YvKy8vLy9BQUQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1wiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRC8vLy8vLy8vKy8vLy8vLzhBQUFBQS92Lysvd0FBQVFEOC8vMy9DUUFKQVAzLyt2OFBBQWNBcEFCbEFCa0Jrd0NPL2kvL2xmcWEvSFFBY2YvM0Jka0N6d0pjQkNNQzB3TU4vOS85d2dJN0FhRUNZZnhWL1RmODN2aG4veHJ0OE93eC84bjdjZ0hBQlliNDNRY1pEaDRXdWdOckE3UDc0Z0h1Lzl6L3p2MHQvYWNDaVFIWS9pdjRxUU9sL3lzQ0UvMC8vWFQ5U2Y0Ty8vajl4ZnVwQW4zOTRnSE8rcnNDWEFGSUF4UUM5d0lYQmdjRDJBUXVBbmIvOWdKaC82d0FWZnhFQUk0QnZmN29BRnYvYkFMc0FNUUJlLzg4L2pvQVQvNGRBSDM5L3Y5TEFYbi9nd0RJLy9RQmRBQmNBQTBBN2Y0bEFNbi8vLys5L3R2L2lBQnAvMTMvcFAvZEFMdi93LzhNQUh2Ly9mK3kvNi8vLy83VS81QUFaUCtaLzhyL25RRFIvNXIvRHdEci94QUE0ditzLzN6LytQOXVBT3YvdC84MkFHY0FIZ0NiL3lRQUZRQkdBTTcvQ2dEMy94b0FlZ0FhQU96L0NnQkhBQThBZHY4L0FBQUFCUUMyL3hJQUFBQTdBQlFBS2dDai96NEFBUUFYQUp6L0pBQURBQWNBOGYvMS8yQUFBUUFsQVBEL05nRHgvMXdBN3YvNC93TUFaQUR2Ly8zL0hRQWtBRm9BOFA5RkFQdi9GZ0JJQVBmL1dRQUhBRVVBQ1FEMC94SUFRd0R1L3dNQXdQOVZBTG4vWHdDdy95RUE1ZjhzQVBqL0ZnREQvMVlBeXY4ckFPWC9IUURvLy9qL0lRQVFBQ0FBSHdEOS95UUFIUUJBQUJnQUJRQWlBQVVBS0FEMy93a0FDd0FLQUFNQUJ3QUpBUGIvK2Y4R0FPci9KUUFIQUJNQTZQOFRBQTRBR2dELy93b0E4LzhaQVAvL0dBRHUvdzBBOXY4U0FBTUFCd0Q0L3dRQTVQOFhBQVFBQ2dEcS93VUErLzhWQUFjQUNBRHMveElBQUFBVEFQSC8rdi8xLy9ULzdmLy8vK3ovK3YveS8rLy85LzhLQUFjQUNnQUpBUFQvQkFBS0FBQUFCZ0FJQVBMLzl2OEtBQU1BQkFBQ0FQci85djhPQUFJQStQL3gvL3YvK2Y4TUFQYi8rUC93L3dRQTlmOE1BUG4vLy8vNy93b0EvdjhQQUFFQUFnRDEveEFBQVFBUEFQLy9Bd0QvL3hRQUJ3QUxBQUFBQmdBREFCQUFBZ0FIQUFBQUNBQUJBQThBQlFBRkFBTUFCd0FFQUE0QUJ3QURBQUVBQ1FBRkFBb0FBd0QvL3dBQUNRQURBQVVBQVFELy8vLy9DQUFCQUFNQUFBRC8vLy8vQndBQ0FBRUFBQUQvLy8vL0J3QUNBUDcvLy84QkFBQUFCZ0FCQVA3Ly8vOENBQUFBQkFBQUFQNy8vLzhEQUFBQUF3QUFBUDMvLy84REFBQUFBUUFBQVAzLy92OEVBQUFBQUFEKy8vLy8vLzhFQVAvLy8vLysvd0FBL3Y4RUFQLy8vLy8rL3dFQS92OEVBUC8vL3YvKy93SUEvLzhEQVAvLy92Lysvd0lBLy84QkFQLy8vdi8rL3dNQS8vOEJBUC8vLy8vKy93TUEvLzhBQVAvL0FBRCsvd1FBLy84QUFQNy9BUUQvL3dJQS8vLy8vLy8vQVFELy93SUEvLy8vLy8vL0FRQUFBQUVBQUFBQUFQLy9BUUQvL3dFQUFBQUFBUC8vQVFBQUFBRUFBQUFBQUFBQVwiLFxuXCJVa2xHUmlRRUFBQlhRVlpGWm0xMElCQUFBQUFCQUFJQWdMc0FBQUR1QWdBRUFCQUFaR0YwWVFBRUFBRCsvd0FBK3Y4QUFQei9BQUQvL3dBQS9mOEFBQUVBQUFEKy93QUFDUUFBQUFRQUFBQVpBQUFBdGdBQUFGc0JBQUJXL2dBQUgvb0FBR2NCQUFCb0J3QUFsQUFBQU8zL0FBQVJBUUFBK3dJQUFFb0VBQUNlL2dBQWl2NEFBTEQwQUFESjh3QUFrUVFBQUYzNEFBQmk4UUFBUFFBQUFBSDJBQUQxOUFBQURBTUFBSndHQUFDVEVBQUEwQXdBQUprSEFBQ09Cd0FBdVFFQUFOY0RBQUM2QWdBQUh3VUFBSEVGQUFCMEF3QUFiZ0VBQUR6K0FBRFlBUUFBR0FBQUFKd0NBQURnQUFBQS8vMEFBTW4rQUFBVC9BQUF3UDhBQU9uOUFBQUpBQUFBZXdFQUFPbitBQUNOL3dBQU92MEFBTzMrQUFETi9nQUFjUDhBQUNqL0FBQ3EvZ0FBK2Y0QUFNTDlBQUNhL3dBQS9mNEFBTjcvQUFCby93QUE2LzRBQUUvL0FBQUMvd0FBRVFBQUFIWC9BQUIwQUFBQTVmOEFBRXdBQUFCM0FBQUE1LzhBQU1JQUFBQkNBQUFBemdBQUFFOEFBQUIzQUFBQUtBQUFBRE1BQUFDcUFBQUFMd0FBQUs0QUFBQVNBQUFBVmdBQUFDZ0FBQUF0QUFBQVRBQUFBUDMvQUFBN0FBQUEyLzhBQUNRQUFBRHcvd0FBTFFBQUFERUFBQUFsQUFBQWJBQUFBRE1BQUFCVUFBQUFFQUFBQUNnQUFBRDEvd0FBOXY4QUFQci9BQUR1L3dBQUxnQUFBQklBQUFCVUFBQUFSQUFBQUdVQUFBQkdBQUFBT0FBQUFHQUFBQUF1QUFBQVJRQUFBQ0VBQUFBZkFBQUFBQUFBQUFrQUFBQVFBQUFBQXdBQUFCSUFBQURzL3dBQUVBQUFBQVlBQUFBU0FBQUFJZ0FBQUJFQUFBQURBQUFBQkFBQUFBOEFBQUQ0L3dBQUhRQUFBQXNBQUFBSUFBQUFEZ0FBQVAvL0FBQWNBQUFBRHdBQUFBWUFBQUFTQUFBQUZ3QUFBQU1BQUFBWUFBQUFFZ0FBQVByL0FBQVFBQUFBRFFBQUFBb0FBQUQzL3dBQUJnQUFBUGIvQUFEZi93QUEvdjhBQVBML0FBRDYvd0FBRkFBQUFBUUFBQUFFQUFBQUd3QUFBQUVBQUFBTUFBQUFJQUFBQUFJQUFBQWRBQUFBR0FBQUFBSUFBQUFjQUFBQUVnQUFBQWNBQUFBZUFBQUFEd0FBQUFRQUFBQWVBQUFBQkFBQUFBWUFBQUFaQUFBQUFRQUFBQTRBQUFBVEFBQUEvdjhBQUFvQUFBQU9BQUFBKy84QUFBc0FBQUFKQUFBQStmOEFBQXNBQUFBQkFBQUErZjhBQUFvQUFBRDkvd0FBK3Y4QUFBY0FBQUQ1L3dBQSt2OEFBQVVBQUFEMy93QUEvZjhBQUFRQUFBRDIvd0FBQUFBQUFBRUFBQUQzL3dBQUFnQUFBQUFBQUFENC93QUFBd0FBQVA3L0FBRDYvd0FBQkFBQUFQMy9BQUQ4L3dBQUJBQUFBUHYvQUFEKy93QUFBd0FBQVB2L0FBRC8vd0FBQVFBQUFQdi9BQUFBQUFBQUFBQUFBUHYvQUFBQ0FBQUEvLzhBQVB6L0FBQUNBQUFBL3Y4QUFQMy9BQUFDQUFBQS9mOEFBUDcvQUFBQkFBQUEvZjhBQVAvL0FBQUJBQUFBL2Y4QUFBQUFBQUFBQUFBQS92OEFBQUVBQUFBQUFBQUEvLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBPbW5pdG9uZVNPQUhyaXJCYXNlNjQ7XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIENyb3NzLWJyb3dzZXIgc3VwcG9ydCBwb2x5ZmlsbCBmb3IgT21uaXRvbmUgbGlicmFyeS5cbiAqL1xuXG5cblxuXG4vKipcbiAqIERldGVjdHMgYnJvd3NlciB0eXBlIGFuZCB2ZXJzaW9uLlxuICogQHJldHVybiB7c3RyaW5nW119IC0gQW4gYXJyYXkgY29udGFpbnMgdGhlIGRldGVjdGVkIGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvbi5cbiAqL1xuZXhwb3J0cy5nZXRCcm93c2VySW5mbyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGxldCBNID0gdWEubWF0Y2goXG4gICAgICAvKG9wZXJhfGNocm9tZXxzYWZhcml8ZmlyZWZveHxtc2llfHRyaWRlbnQoPz1cXC8pKVxcLz9cXHMqKFtcXGRcXC5dKykvaSkgfHxcbiAgICAgIFtdO1xuICBsZXQgdGVtO1xuXG4gIGlmICgvdHJpZGVudC9pLnRlc3QoTVsxXSkpIHtcbiAgICB0ZW0gPSAvXFxicnZbIDpdKyhcXGQrKS9nLmV4ZWModWEpIHx8IFtdO1xuICAgIHJldHVybiB7bmFtZTogJ0lFJywgdmVyc2lvbjogKHRlbVsxXSB8fCAnJyl9O1xuICB9XG5cbiAgaWYgKE1bMV0gPT09ICdDaHJvbWUnKSB7XG4gICAgdGVtID0gdWEubWF0Y2goL1xcYk9QUnxFZGdlXFwvKFxcZCspLyk7XG4gICAgaWYgKHRlbSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4ge25hbWU6ICdPcGVyYScsIHZlcnNpb246IHRlbVsxXX07XG4gICAgfVxuICB9XG5cbiAgTSA9IE1bMl0gPyBbTVsxXSwgTVsyXV0gOiBbbmF2aWdhdG9yLmFwcE5hbWUsIG5hdmlnYXRvci5hcHBWZXJzaW9uLCAnLT8nXTtcbiAgaWYgKCh0ZW0gPSB1YS5tYXRjaCgvdmVyc2lvblxcLyhbXFxkLl0rKS9pKSkgIT0gbnVsbCkge1xuICAgIE0uc3BsaWNlKDEsIDEsIHRlbVsxXSk7XG4gIH1cblxuICBsZXQgcGxhdGZvcm0gPSB1YS5tYXRjaCgvYW5kcm9pZHxpcGFkfGlwaG9uZS9pKTtcbiAgaWYgKCFwbGF0Zm9ybSkge1xuICAgIHBsYXRmb3JtID0gdWEubWF0Y2goL2Nyb3N8bGludXh8bWFjIG9zIHh8d2luZG93cy9pKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogTVswXSxcbiAgICB2ZXJzaW9uOiBNWzFdLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybSA/IHBsYXRmb3JtWzBdIDogJ3Vua25vd24nLFxuICB9O1xufTtcblxuXG4vKipcbiAqIFBhdGNoZXMgQXVkaW9Db250ZXh0IGlmIHRoZSBwcmVmaXhlZCBBUEkgaXMgZm91bmQuXG4gKi9cbmV4cG9ydHMucGF0Y2hTYWZhcmkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgJiYgd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQpIHtcbiAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcbiAgICB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0O1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSB2ZXJzaW9uLlxuICovXG5cblxuXG5cbi8qKlxuICogT21uaXRvbmUgbGlicmFyeSB2ZXJzaW9uXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICcxLjAuNic7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBSZXNvbmFuY2VBdWRpbyB2ZXJzaW9uLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLyoqXG4gKiBSZXNvbmFuY2VBdWRpbyBsaWJyYXJ5IHZlcnNpb25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gJzAuMC40JztcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiLCJpbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuRGVmYXVsdE9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHR9XG5cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9XG5cblx0c2V0IHkoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHooKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9XG5cblx0c2V0IHooIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IG9yZGVyKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG5cdH1cblxuXHRzZXQgb3JkZXIoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fb3JkZXIgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG5cdH1cblxuXHRjb3B5KCBldWxlciApIHtcblxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcblx0XHR0aGlzLl95ID0gZXVsZXIuX3k7XG5cdFx0dGhpcy5feiA9IGV1bGVyLl96O1xuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0Y29uc3QgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcblx0XHRjb25zdCBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdO1xuXHRcdGNvbnN0IG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0b3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0X21hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XG5cblx0fVxuXG5cdHNldEZyb21WZWN0b3IzKCB2LCBvcmRlciApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0cmVvcmRlciggbmV3T3JkZXIgKSB7XG5cblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cblx0XHRfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBfcXVhdGVybmlvbiwgbmV3T3JkZXIgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCBldWxlciApIHtcblxuXHRcdHJldHVybiAoIGV1bGVyLl94ID09PSB0aGlzLl94ICkgJiYgKCBldWxlci5feSA9PT0gdGhpcy5feSApICYmICggZXVsZXIuX3ogPT09IHRoaXMuX3ogKSAmJiAoIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuXHRcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0dG9WZWN0b3IzKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRcdHJldHVybiBvcHRpb25hbFJlc3VsdC5zZXQoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuZXcgVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRfb25DaGFuZ2UoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZUNhbGxiYWNrKCkge31cblxufVxuXG5FdWxlci5wcm90b3R5cGUuaXNFdWxlciA9IHRydWU7XG5cbkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsImNvbnN0IF9sdXQgPSBbXTtcblxuZm9yICggbGV0IGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xuXG5cdF9sdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApO1xuXG59XG5cbmxldCBfc2VlZCA9IDEyMzQ1Njc7XG5cblxuY29uc3QgREVHMlJBRCA9IE1hdGguUEkgLyAxODA7XG5jb25zdCBSQUQyREVHID0gMTgwIC8gTWF0aC5QSTtcblxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cblx0Y29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IHV1aWQgPSBfbHV0WyBkMCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQxICYgMHhmZiBdICsgX2x1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIF9sdXRbIGQxID4+IDI0ICYgMHhmZiBdICsgJy0nICtcblx0XHRcdF9sdXRbIGQyICYgMHgzZiB8IDB4ODAgXSArIF9sdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQyID4+IDI0ICYgMHhmZiBdICtcblx0XHRcdF9sdXRbIGQzICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMjQgJiAweGZmIF07XG5cblx0Ly8gLnRvVXBwZXJDYXNlKCkgaGVyZSBmbGF0dGVucyBjb25jYXRlbmF0ZWQgc3RyaW5ncyB0byBzYXZlIGhlYXAgbWVtb3J5IHNwYWNlLlxuXHRyZXR1cm4gdXVpZC50b1VwcGVyQ2FzZSgpO1xuXG59XG5cbmZ1bmN0aW9uIGNsYW1wKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cblx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcblxufVxuXG4vLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cbmZ1bmN0aW9uIGV1Y2xpZGVhbk1vZHVsbyggbiwgbSApIHtcblxuXHRyZXR1cm4gKCAoIG4gJSBtICkgKyBtICkgJSBtO1xuXG59XG5cbi8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cbmZ1bmN0aW9uIG1hcExpbmVhciggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XG5cblx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvdHV0b3JpYWxzL3Byb2dyYW1taW5nL2dlbmVyYWwtYW5kLWdhbWVwbGF5LXByb2dyYW1taW5nL2ludmVyc2UtbGVycC1hLXN1cGVyLXVzZWZ1bC15ZXQtb2Z0ZW4tb3Zlcmxvb2tlZC1mdW5jdGlvbi1yNTIzMC9cbmZ1bmN0aW9uIGludmVyc2VMZXJwKCB4LCB5LCB2YWx1ZSApIHtcblxuXHRpZiAoIHggIT09IHkgKSB7XG5cblx0XHRyZXR1cm4gKCB2YWx1ZSAtIHggKSAvICggeSAtIHggKTtcblxuXHRcdCB9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIDA7XG5cblx0XHQgfVxuXG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uXG5mdW5jdGlvbiBsZXJwKCB4LCB5LCB0ICkge1xuXG5cdHJldHVybiAoIDEgLSB0ICkgKiB4ICsgdCAqIHk7XG5cbn1cblxuLy8gaHR0cDovL3d3dy5yb3J5ZHJpc2NvbGwuY29tLzIwMTYvMDMvMDcvZnJhbWUtcmF0ZS1pbmRlcGVuZGVudC1kYW1waW5nLXVzaW5nLWxlcnAvXG5mdW5jdGlvbiBkYW1wKCB4LCB5LCBsYW1iZGEsIGR0ICkge1xuXG5cdHJldHVybiBsZXJwKCB4LCB5LCAxIC0gTWF0aC5leHAoIC0gbGFtYmRhICogZHQgKSApO1xuXG59XG5cbi8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci92Y3Nqbnl6N3g0XG5mdW5jdGlvbiBwaW5ncG9uZyggeCwgbGVuZ3RoID0gMSApIHtcblxuXHRyZXR1cm4gbGVuZ3RoIC0gTWF0aC5hYnMoIGV1Y2xpZGVhbk1vZHVsbyggeCwgbGVuZ3RoICogMiApIC0gbGVuZ3RoICk7XG5cbn1cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXG5mdW5jdGlvbiBzbW9vdGhzdGVwKCB4LCBtaW4sIG1heCApIHtcblxuXHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG5cdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cbn1cblxuZnVuY3Rpb24gc21vb3RoZXJzdGVwKCB4LCBtaW4sIG1heCApIHtcblxuXHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG5cdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG5cdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cbn1cblxuLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEludCggbG93LCBoaWdoICkge1xuXG5cdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cbn1cblxuLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcbmZ1bmN0aW9uIHJhbmRGbG9hdCggbG93LCBoaWdoICkge1xuXG5cdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cbn1cblxuLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0U3ByZWFkKCByYW5nZSApIHtcblxuXHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxufVxuXG4vLyBEZXRlcm1pbmlzdGljIHBzZXVkby1yYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIFsgMCwgMSBdXG5mdW5jdGlvbiBzZWVkZWRSYW5kb20oIHMgKSB7XG5cblx0aWYgKCBzICE9PSB1bmRlZmluZWQgKSBfc2VlZCA9IHMgJSAyMTQ3NDgzNjQ3O1xuXG5cdC8vIFBhcmstTWlsbGVyIGFsZ29yaXRobVxuXG5cdF9zZWVkID0gX3NlZWQgKiAxNjgwNyAlIDIxNDc0ODM2NDc7XG5cblx0cmV0dXJuICggX3NlZWQgLSAxICkgLyAyMTQ3NDgzNjQ2O1xuXG59XG5cbmZ1bmN0aW9uIGRlZ1RvUmFkKCBkZWdyZWVzICkge1xuXG5cdHJldHVybiBkZWdyZWVzICogREVHMlJBRDtcblxufVxuXG5mdW5jdGlvbiByYWRUb0RlZyggcmFkaWFucyApIHtcblxuXHRyZXR1cm4gcmFkaWFucyAqIFJBRDJERUc7XG5cbn1cblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKCB2YWx1ZSApIHtcblxuXHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxufVxuXG5mdW5jdGlvbiBjZWlsUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmNlaWwoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG59XG5cbmZ1bmN0aW9uIGZsb29yUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmZsb29yKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCBxLCBhLCBiLCBjLCBvcmRlciApIHtcblxuXHQvLyBJbnRyaW5zaWMgUHJvcGVyIEV1bGVyIEFuZ2xlcyAtIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcl9hbmdsZXNcblxuXHQvLyByb3RhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGF4ZXMgaW4gdGhlIG9yZGVyIHNwZWNpZmllZCBieSAnb3JkZXInXG5cdC8vIHJvdGF0aW9uIGJ5IGFuZ2xlICdhJyBpcyBhcHBsaWVkIGZpcnN0LCB0aGVuIGJ5IGFuZ2xlICdiJywgdGhlbiBieSBhbmdsZSAnYydcblx0Ly8gYW5nbGVzIGFyZSBpbiByYWRpYW5zXG5cblx0Y29uc3QgY29zID0gTWF0aC5jb3M7XG5cdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdGNvbnN0IGMyID0gY29zKCBiIC8gMiApO1xuXHRjb25zdCBzMiA9IHNpbiggYiAvIDIgKTtcblxuXHRjb25zdCBjMTMgPSBjb3MoICggYSArIGMgKSAvIDIgKTtcblx0Y29uc3QgczEzID0gc2luKCAoIGEgKyBjICkgLyAyICk7XG5cblx0Y29uc3QgYzFfMyA9IGNvcyggKCBhIC0gYyApIC8gMiApO1xuXHRjb25zdCBzMV8zID0gc2luKCAoIGEgLSBjICkgLyAyICk7XG5cblx0Y29uc3QgYzNfMSA9IGNvcyggKCBjIC0gYSApIC8gMiApO1xuXHRjb25zdCBzM18xID0gc2luKCAoIGMgLSBhICkgLyAyICk7XG5cblx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRjYXNlICdYWVgnOlxuXHRcdFx0cS5zZXQoIGMyICogczEzLCBzMiAqIGMxXzMsIHMyICogczFfMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWVpZJzpcblx0XHRcdHEuc2V0KCBzMiAqIHMxXzMsIGMyICogczEzLCBzMiAqIGMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1pYWic6XG5cdFx0XHRxLnNldCggczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogczEzLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdYWlgnOlxuXHRcdFx0cS5zZXQoIGMyICogczEzLCBzMiAqIHMzXzEsIHMyICogYzNfMSwgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWVhZJzpcblx0XHRcdHEuc2V0KCBzMiAqIGMzXzEsIGMyICogczEzLCBzMiAqIHMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1pZWic6XG5cdFx0XHRxLnNldCggczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogczEzLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdH1cblxufVxuXG5cblxuXG5leHBvcnQge1xuXHRERUcyUkFELFxuXHRSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQsXG5cdGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG8sXG5cdG1hcExpbmVhcixcblx0aW52ZXJzZUxlcnAsXG5cdGxlcnAsXG5cdGRhbXAsXG5cdHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXAsXG5cdHJhbmRJbnQsXG5cdHJhbmRGbG9hdCxcblx0cmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb20sXG5cdGRlZ1RvUmFkLFxuXHRyYWRUb0RlZyxcblx0aXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3byxcblx0Zmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxufTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBNYXRyaXg0IHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHNldCggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XG5cdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG5cdFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xuXHRcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fVxuXG5cdGNvcHkoIG0gKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTsgdGVbIDMgXSA9IG1lWyAzIF07XG5cdFx0dGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdOyB0ZVsgNiBdID0gbWVbIDYgXTsgdGVbIDcgXSA9IG1lWyA3IF07XG5cdFx0dGVbIDggXSA9IG1lWyA4IF07IHRlWyA5IF0gPSBtZVsgOSBdOyB0ZVsgMTAgXSA9IG1lWyAxMCBdOyB0ZVsgMTEgXSA9IG1lWyAxMSBdO1xuXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07IHRlWyAxMyBdID0gbWVbIDEzIF07IHRlWyAxNCBdID0gbWVbIDE0IF07IHRlWyAxNSBdID0gbWVbIDE1IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weVBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xuXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG5cdFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgMyBdLCBtZVsgNiBdLCAwLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDQgXSwgbWVbIDcgXSwgMCxcblx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF0sIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcblx0XHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VCYXNpcyggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcblx0XHRcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXG5cdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXh0cmFjdFJvdGF0aW9uKCBtICkge1xuXG5cdFx0Ly8gdGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCByZWZsZWN0aW9uIG1hdHJpY2VzXG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc2NhbGVZID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc2NhbGVaID0gMSAvIF92MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMSBdID0gbWVbIDEgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xuXHRcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xuXHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XG5cdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyKCBldWxlciApIHtcblxuXHRcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcblx0XHRjb25zdCBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xuXHRcdGNvbnN0IGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcblx0XHRcdHRlWyA4IF0gPSBkO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWYgKyBiZSAqIGQ7XG5cdFx0XHR0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogYztcblxuXHRcdFx0dGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlICsgZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuXHRcdFx0dGVbIDggXSA9IGEgKiBkO1xuXG5cdFx0XHR0ZVsgMSBdID0gYSAqIGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XG5cdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcblx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcblx0XHRcdHRlWyA2IF0gPSBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xuXHRcdFx0dGVbIDggXSA9IGFlICogZCArIGJmO1xuXG5cdFx0XHR0ZVsgMSBdID0gYyAqIGY7XG5cdFx0XHR0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG5cdFx0XHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYiAqIGM7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XG5cblx0XHRcdHRlWyAxIF0gPSBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGU7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGQgKiBlO1xuXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuXHRcdFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuXHRcdFx0Y29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gZjtcblx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm90dG9tIHJvd1xuXHRcdHRlWyAzIF0gPSAwO1xuXHRcdHRlWyA3IF0gPSAwO1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdC8vIGxhc3QgY29sdW1uXG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29tcG9zZSggX3plcm8sIHEsIF9vbmUgKTtcblxuXHR9XG5cblx0bG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRfei5zdWJWZWN0b3JzKCBleWUsIHRhcmdldCApO1xuXG5cdFx0aWYgKCBfei5sZW5ndGhTcSgpID09PSAwICkge1xuXG5cdFx0XHQvLyBleWUgYW5kIHRhcmdldCBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb25cblxuXHRcdFx0X3oueiA9IDE7XG5cblx0XHR9XG5cblx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0aWYgKCBfeC5sZW5ndGhTcSgpID09PSAwICkge1xuXG5cdFx0XHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdXAueiApID09PSAxICkge1xuXG5cdFx0XHRcdF96LnggKz0gMC4wMDAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdF96LnogKz0gMC4wMDAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdFx0X3guY3Jvc3NWZWN0b3JzKCB1cCwgX3ogKTtcblxuXHRcdH1cblxuXHRcdF94Lm5vcm1hbGl6ZSgpO1xuXHRcdF95LmNyb3NzVmVjdG9ycyggX3osIF94ICk7XG5cblx0XHR0ZVsgMCBdID0gX3gueDsgdGVbIDQgXSA9IF95Lng7IHRlWyA4IF0gPSBfei54O1xuXHRcdHRlWyAxIF0gPSBfeC55OyB0ZVsgNSBdID0gX3kueTsgdGVbIDkgXSA9IF96Lnk7XG5cdFx0dGVbIDIgXSA9IF94Lno7IHRlWyA2IF0gPSBfeS56OyB0ZVsgMTAgXSA9IF96Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIG0sIG4gKSB7XG5cblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XG5cdFx0Y29uc3QgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG5cdFx0Y29uc3QgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdGNvbnN0IGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcblxuXHRcdGNvbnN0IGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdGNvbnN0IGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcblx0XHRjb25zdCBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cblx0XHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuXHRcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG5cdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0Mztcblx0XHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuXHRcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG5cdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0Mjtcblx0XHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuXHRcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG5cdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcblx0XHR0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuXHRcdHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG5cdFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcblx0XHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuXHRcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcblx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuXHRcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xuXHRcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG5cdFx0Y29uc3QgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0Y29uc3QgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuXHRcdGNvbnN0IG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuXHRcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0bjQxICogKFxuXHRcdFx0XHQrIG4xNCAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjE0ICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjEyICogbjIzICogbjM0XG5cdFx0XHQpICtcblx0XHRcdG40MiAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjMgKiBuMzRcblx0XHRcdFx0IC0gbjExICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgLSBuMTMgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjEzICogbjI0ICogbjMxXG5cdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDMgKiAoXG5cdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xMSAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTQgKiBuMjEgKiBuMzJcblx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xNCAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTIgKiBuMjQgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQ0ICogKFxuXHRcdFx0XHQtIG4xMyAqIG4yMiAqIG4zMVxuXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcblx0XHRcdFx0ICsgbjExICogbjIyICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjIzICogbjMxXG5cdFx0XHQpXG5cblx0XHQpO1xuXG5cdH1cblxuXHR0cmFuc3Bvc2UoKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0bGV0IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRQb3NpdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRlWyAxMiBdID0geC54O1xuXHRcdFx0dGVbIDEzIF0gPSB4Lnk7XG5cdFx0XHR0ZVsgMTQgXSA9IHguejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRlWyAxMiBdID0geDtcblx0XHRcdHRlWyAxMyBdID0geTtcblx0XHRcdHRlWyAxNCBdID0gejtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHMsXG5cblx0XHRcdG4xMSA9IHRlWyAwIF0sIG4yMSA9IHRlWyAxIF0sIG4zMSA9IHRlWyAyIF0sIG40MSA9IHRlWyAzIF0sXG5cdFx0XHRuMTIgPSB0ZVsgNCBdLCBuMjIgPSB0ZVsgNSBdLCBuMzIgPSB0ZVsgNiBdLCBuNDIgPSB0ZVsgNyBdLFxuXHRcdFx0bjEzID0gdGVbIDggXSwgbjIzID0gdGVbIDkgXSwgbjMzID0gdGVbIDEwIF0sIG40MyA9IHRlWyAxMSBdLFxuXHRcdFx0bjE0ID0gdGVbIDEyIF0sIG4yNCA9IHRlWyAxMyBdLCBuMzQgPSB0ZVsgMTQgXSwgbjQ0ID0gdGVbIDE1IF0sXG5cblx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcblx0XHRcdHQxMyA9IG4xMyAqIG4yNCAqIG40MiAtIG4xNCAqIG4yMyAqIG40MiArIG4xNCAqIG4yMiAqIG40MyAtIG4xMiAqIG4yNCAqIG40MyAtIG4xMyAqIG4yMiAqIG40NCArIG4xMiAqIG4yMyAqIG40NCxcblx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblxuXHRcdGNvbnN0IGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMyArIG40MSAqIHQxNDtcblxuXHRcdGlmICggZGV0ID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG5cdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcblx0XHR0ZVsgMSBdID0gKCBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMiBdID0gKCBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuXHRcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XG5cdFx0dGVbIDUgXSA9ICggbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xuXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcblx0XHR0ZVsgMTMgXSA9ICggbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDE0IF0gPSAoIG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggdiApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG5cdFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcblx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuXHRcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuXHRcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE1heFNjYWxlT25BeGlzKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3Qgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG5cdFx0Y29uc3Qgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG5cdFx0Y29uc3Qgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9XG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHQwLCAxLCAwLCB5LFxuXHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uWCggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgYywgLSBzLCAwLFxuXHRcdFx0MCwgcywgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uWSggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQgYywgMCwgcywgMCxcblx0XHRcdCAwLCAxLCAwLCAwLFxuXHRcdFx0LSBzLCAwLCBjLCAwLFxuXHRcdFx0IDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uWiggdGhldGEgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsIDAsXG5cdFx0XHRzLCBjLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcblx0XHRjb25zdCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG5cdFx0Y29uc3QgdCA9IDEgLSBjO1xuXHRcdGNvbnN0IHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XG5cdFx0Y29uc3QgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXG5cdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG5cdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VTY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLCAwLFxuXHRcdFx0MCwgeSwgMCwgMCxcblx0XHRcdDAsIDAsIHosIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VTaGVhciggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCB5LCB6LCAwLFxuXHRcdFx0eCwgMSwgeiwgMCxcblx0XHRcdHgsIHksIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBxdWF0ZXJuaW9uLl94LCB5ID0gcXVhdGVybmlvbi5feSwgeiA9IHF1YXRlcm5pb24uX3osIHcgPSBxdWF0ZXJuaW9uLl93O1xuXHRcdGNvbnN0IHgyID0geCArIHgsXHR5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xuXHRcdGNvbnN0IHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG5cdFx0Y29uc3QgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6Mjtcblx0XHRjb25zdCB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xuXG5cdFx0Y29uc3Qgc3ggPSBzY2FsZS54LCBzeSA9IHNjYWxlLnksIHN6ID0gc2NhbGUuejtcblxuXHRcdHRlWyAwIF0gPSAoIDEgLSAoIHl5ICsgenogKSApICogc3g7XG5cdFx0dGVbIDEgXSA9ICggeHkgKyB3eiApICogc3g7XG5cdFx0dGVbIDIgXSA9ICggeHogLSB3eSApICogc3g7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gKCB4eSAtIHd6ICkgKiBzeTtcblx0XHR0ZVsgNSBdID0gKCAxIC0gKCB4eCArIHp6ICkgKSAqIHN5O1xuXHRcdHRlWyA2IF0gPSAoIHl6ICsgd3ggKSAqIHN5O1xuXHRcdHRlWyA3IF0gPSAwO1xuXG5cdFx0dGVbIDggXSA9ICggeHogKyB3eSApICogc3o7XG5cdFx0dGVbIDkgXSA9ICggeXogLSB3eCApICogc3o7XG5cdFx0dGVbIDEwIF0gPSAoIDEgLSAoIHh4ICsgeXkgKSApICogc3o7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSBwb3NpdGlvbi54O1xuXHRcdHRlWyAxMyBdID0gcG9zaXRpb24ueTtcblx0XHR0ZVsgMTQgXSA9IHBvc2l0aW9uLno7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0bGV0IHN4ID0gX3YxLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gX3YxLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gX3YxLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuXHRcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cdFx0Y29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXHRcdGlmICggZGV0IDwgMCApIHN4ID0gLSBzeDtcblxuXHRcdHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcblx0XHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XG5cdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcblx0XHRfbTEuY29weSggdGhpcyApO1xuXG5cdFx0Y29uc3QgaW52U1ggPSAxIC8gc3g7XG5cdFx0Y29uc3QgaW52U1kgPSAxIC8gc3k7XG5cdFx0Y29uc3QgaW52U1ogPSAxIC8gc3o7XG5cblx0XHRfbTEuZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRfbTEuZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcblx0XHRfbTEuZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcblxuXHRcdF9tMS5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdF9tMS5lbGVtZW50c1sgNSBdICo9IGludlNZO1xuXHRcdF9tMS5lbGVtZW50c1sgNiBdICo9IGludlNZO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0X20xLmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XG5cdFx0X20xLmVsZW1lbnRzWyAxMCBdICo9IGludlNaO1xuXG5cdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tMSApO1xuXG5cdFx0c2NhbGUueCA9IHN4O1xuXHRcdHNjYWxlLnkgPSBzeTtcblx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRcdGlmICggZmFyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlUGVyc3BlY3RpdmUoKSBoYXMgYmVlbiByZWRlZmluZWQgYW5kIGhhcyBhIG5ldyBzaWduYXR1cmUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG5cdFx0Y29uc3QgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdGNvbnN0IGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0geTtcdHRlWyA5IF0gPSBiO1x0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7XHR0ZVsgMTQgXSA9IGQ7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHcgPSAxLjAgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdGNvbnN0IGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdGNvbnN0IHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuXHRcdGNvbnN0IHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcblx0XHRjb25zdCB5ID0gKCB0b3AgKyBib3R0b20gKSAqIGg7XG5cdFx0Y29uc3QgeiA9ICggZmFyICsgbmVhciApICogcDtcblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IDA7XHR0ZVsgMTIgXSA9IC0geDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSAyICogaDtcdHRlWyA5IF0gPSAwO1x0dGVbIDEzIF0gPSAtIHk7XG5cdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IDA7XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDkgXSA9IHRlWyA5IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cbn1cblxuTWF0cml4NC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gdHJ1ZTtcblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3plcm8gPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAwLCAwLCAwICk7XG5jb25zdCBfb25lID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuY29uc3QgX3ggPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF96ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5leHBvcnQgeyBNYXRyaXg0IH07XG4iLCJpbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMuanMnO1xuXG5jbGFzcyBRdWF0ZXJuaW9uIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCwgdyA9IDEgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHR9XG5cblx0c3RhdGljIHNsZXJwKCBxYSwgcWIsIHFtLCB0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogU3RhdGljIC5zbGVycCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBxbS5zbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gcW0uc2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICk7XG5cblx0fVxuXG5cdHN0YXRpYyBzbGVycEZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG5cdFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxuXG5cdFx0bGV0IHgwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDAgXSxcblx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcblx0XHRcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcblx0XHRcdHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcblxuXHRcdGNvbnN0IHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcblx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcblx0XHRcdHoxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDIgXSxcblx0XHRcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGlmICggdCA9PT0gMCApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAwIF0gPSB4MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHoxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xuXG5cdFx0XHRsZXQgcyA9IDEgLSB0O1xuXHRcdFx0Y29uc3QgY29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcblx0XHRcdFx0c3FyU2luID0gMSAtIGNvcyAqIGNvcztcblxuXHRcdFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcblx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcblx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG5cdFx0XHRcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xuXHRcdFx0XHR0ID0gTWF0aC5zaW4oIHQgKiBsZW4gKSAvIHNpbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0RGlyID0gdCAqIGRpcjtcblxuXHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xuXHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcblx0XHRcdGlmICggcyA9PT0gMSAtIHQgKSB7XG5cblx0XHRcdFx0Y29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcblxuXHRcdFx0XHR4MCAqPSBmO1xuXHRcdFx0XHR5MCAqPSBmO1xuXHRcdFx0XHR6MCAqPSBmO1xuXHRcdFx0XHR3MCAqPSBmO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRkc3RbIGRzdE9mZnNldCBdID0geDA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cblx0fVxuXG5cdHN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdCggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEgKSB7XG5cblx0XHRjb25zdCB4MCA9IHNyYzBbIHNyY09mZnNldDAgXTtcblx0XHRjb25zdCB5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF07XG5cdFx0Y29uc3QgejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdO1xuXHRcdGNvbnN0IHcwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDMgXTtcblxuXHRcdGNvbnN0IHgxID0gc3JjMVsgc3JjT2Zmc2V0MSBdO1xuXHRcdGNvbnN0IHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXTtcblx0XHRjb25zdCB6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF07XG5cdFx0Y29uc3QgdzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwICogdzEgKyB3MCAqIHgxICsgeTAgKiB6MSAtIHowICogeTE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MCAqIHcxICsgdzAgKiB5MSArIHowICogeDEgLSB4MCAqIHoxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejAgKiB3MSArIHcwICogejEgKyB4MCAqIHkxIC0geTAgKiB4MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwICogdzEgLSB4MCAqIHgxIC0geTAgKiB5MSAtIHowICogejE7XG5cblx0XHRyZXR1cm4gZHN0O1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgdygpIHtcblxuXHRcdHJldHVybiB0aGlzLl93O1xuXG5cdH1cblxuXHRzZXQgdyggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl93ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl93ID0gdztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdH1cblxuXHRjb3B5KCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tRXVsZXIoIGV1bGVyLCB1cGRhdGUgKSB7XG5cblx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHggPSBldWxlci5feCwgeSA9IGV1bGVyLl95LCB6ID0gZXVsZXIuX3osIG9yZGVyID0gZXVsZXIuX29yZGVyO1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuXHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG5cdFx0Y29uc3QgY29zID0gTWF0aC5jb3M7XG5cdFx0Y29uc3Qgc2luID0gTWF0aC5zaW47XG5cblx0XHRjb25zdCBjMSA9IGNvcyggeCAvIDIgKTtcblx0XHRjb25zdCBjMiA9IGNvcyggeSAvIDIgKTtcblx0XHRjb25zdCBjMyA9IGNvcyggeiAvIDIgKTtcblxuXHRcdGNvbnN0IHMxID0gc2luKCB4IC8gMiApO1xuXHRcdGNvbnN0IHMyID0gc2luKCB5IC8gMiApO1xuXHRcdGNvbnN0IHMzID0gc2luKCB6IC8gMiApO1xuXG5cdFx0c3dpdGNoICggb3JkZXIgKSB7XG5cblx0XHRcdGNhc2UgJ1hZWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWFonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWlhZJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pZWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdZWlgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWFpZJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cblx0XHRjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcblx0XHR0aGlzLl96ID0gYXhpcy56ICogcztcblx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApIHtcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG5cdFx0XHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRjb25zdCBzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tVW5pdFZlY3RvcnMoIHZGcm9tLCB2VG8gKSB7XG5cblx0XHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuXHRcdGxldCByID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRpZiAoIHIgPCBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0Ly8gdkZyb20gYW5kIHZUbyBwb2ludCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zXG5cblx0XHRcdHIgPSAwO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAtIHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3kgPSB2RnJvbS54O1xuXHRcdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3kgPSAtIHZGcm9tLno7XG5cdFx0XHRcdHRoaXMuX3ogPSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7IC8vIGlubGluZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgb24gVmVjdG9yM1xuXG5cdFx0XHR0aGlzLl94ID0gdkZyb20ueSAqIHZUby56IC0gdkZyb20ueiAqIHZUby55O1xuXHRcdFx0dGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcblx0XHRcdHRoaXMuX3ogPSB2RnJvbS54ICogdlRvLnkgLSB2RnJvbS55ICogdlRvLng7XG5cdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhbmdsZVRvKCBxICkge1xuXG5cdFx0cmV0dXJuIDIgKiBNYXRoLmFjb3MoIE1hdGguYWJzKCBNYXRoVXRpbHMuY2xhbXAoIHRoaXMuZG90KCBxICksIC0gMSwgMSApICkgKTtcblxuXHR9XG5cblx0cm90YXRlVG93YXJkcyggcSwgc3RlcCApIHtcblxuXHRcdGNvbnN0IGFuZ2xlID0gdGhpcy5hbmdsZVRvKCBxICk7XG5cblx0XHRpZiAoIGFuZ2xlID09PSAwICkgcmV0dXJuIHRoaXM7XG5cblx0XHRjb25zdCB0ID0gTWF0aC5taW4oIDEsIHN0ZXAgLyBhbmdsZSApO1xuXG5cdFx0dGhpcy5zbGVycCggcSwgdCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGlkZW50aXR5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwLCAxICk7XG5cblx0fVxuXG5cdGludmVydCgpIHtcblxuXHRcdC8vIHF1YXRlcm5pb24gaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKTtcblxuXHR9XG5cblx0Y29uanVnYXRlKCkge1xuXG5cdFx0dGhpcy5feCAqPSAtIDE7XG5cdFx0dGhpcy5feSAqPSAtIDE7XG5cdFx0dGhpcy5feiAqPSAtIDE7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG5cdH1cblxuXHRsZW5ndGhTcSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0bGV0IGwgPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0aWYgKCBsID09PSAwICkge1xuXG5cdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHR0aGlzLl93ID0gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGwgPSAxIC8gbDtcblxuXHRcdFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuXHRcdFx0dGhpcy5feiA9IHRoaXMuX3ogKiBsO1xuXHRcdFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBxLCBwICkge1xuXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSB7XG5cblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cblxuXHRcdGNvbnN0IHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0Y29uc3QgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuXHRcdHRoaXMuX3ggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcblx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuXHRcdHRoaXMuX3cgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnAoIHFiLCB0ICkge1xuXG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuXHRcdGxldCBjb3NIYWxmVGhldGEgPSB3ICogcWIuX3cgKyB4ICogcWIuX3ggKyB5ICogcWIuX3kgKyB6ICogcWIuX3o7XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuXHRcdFx0dGhpcy5feCA9IC0gcWIuX3g7XG5cdFx0XHR0aGlzLl95ID0gLSBxYi5feTtcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcblxuXHRcdFx0dGhpcy5fdyA9IHc7XG5cdFx0XHR0aGlzLl94ID0geDtcblx0XHRcdHRoaXMuX3kgPSB5O1xuXHRcdFx0dGhpcy5feiA9IHo7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xuXG5cdFx0aWYgKCBzcXJTaW5IYWxmVGhldGEgPD0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAxIC0gdDtcblx0XHRcdHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuXHRcdFx0dGhpcy5feCA9IHMgKiB4ICsgdCAqIHRoaXMuX3g7XG5cdFx0XHR0aGlzLl95ID0gcyAqIHkgKyB0ICogdGhpcy5feTtcblx0XHRcdHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZSgpO1xuXHRcdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggc3FyU2luSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcblx0XHRjb25zdCByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG5cdFx0XHRyYXRpb0IgPSBNYXRoLnNpbiggdCAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhO1xuXG5cdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcblx0XHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzbGVycFF1YXRlcm5pb25zKCBxYSwgcWIsIHQgKSB7XG5cblx0XHR0aGlzLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cblx0fVxuXG5cdGVxdWFscyggcXVhdGVybmlvbiApIHtcblxuXHRcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLl94ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy5feSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMuX3ogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblx0XHR0aGlzLl93ID0gYXR0cmlidXRlLmdldFcoIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cbn1cblxuUXVhdGVybmlvbi5wcm90b3R5cGUuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcbmltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuXG5jbGFzcyBWZWN0b3IzIHtcblxuXHRjb25zdHJ1Y3RvciggeCA9IDAsIHkgPSAwLCB6ID0gMCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHogKSB7XG5cblx0XHRpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSB0aGlzLno7IC8vIHNwcml0ZS5zY2FsZS5zZXQoeCx5KVxuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdHRoaXMueiA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRZKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRaKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRDb21wb25lbnQoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldENvbXBvbmVudCggaW5kZXggKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cdFx0dGhpcy56ID0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZCggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54IC09IHM7XG5cdFx0dGhpcy55IC09IHM7XG5cdFx0dGhpcy56IC09IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3ViVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAtIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG5cdFx0dGhpcy56ID0gYS56IC0gYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCB2LCB3ICkge1xuXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggKj0gdi54O1xuXHRcdHRoaXMueSAqPSB2Lnk7XG5cdFx0dGhpcy56ICo9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlFdWxlciggZXVsZXIgKSB7XG5cblx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcblxuXHR9XG5cblx0YXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBfcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU5vcm1hbE1hdHJpeCggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4MyggbSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XG5cblx0XHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xuXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlRdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBxeCA9IHEueCwgcXkgPSBxLnksIHF6ID0gcS56LCBxdyA9IHEudztcblxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cblx0XHRjb25zdCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcblx0XHRjb25zdCBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHRjb25zdCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcblx0XHRjb25zdCBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdCggY2FtZXJhICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdH1cblxuXHR1bnByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICkuYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHR9XG5cblx0dHJhbnNmb3JtRGlyZWN0aW9uKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRkaXZpZGUoIHYgKSB7XG5cblx0XHR0aGlzLnggLz0gdi54O1xuXHRcdHRoaXMueSAvPSB2Lnk7XG5cdFx0dGhpcy56IC89IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdG1pbiggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1heCggdiApIHtcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wKCBtaW4sIG1heCApIHtcblxuXHRcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy56ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcExlbmd0aCggbWluLCBtYXggKSB7XG5cblx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XG5cblx0fVxuXG5cdGZsb29yKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VpbCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuXG5cdH1cblxuXHQvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuXHR9XG5cblx0bWFuaGF0dGFuTGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuXHR9XG5cblx0bm9ybWFsaXplKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcblxuXHR9XG5cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGVycFZlY3RvcnMoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggPSB2MS54ICsgKCB2Mi54IC0gdjEueCApICogYWxwaGE7XG5cdFx0dGhpcy55ID0gdjEueSArICggdjIueSAtIHYxLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiA9IHYxLnogKyAoIHYyLnogLSB2MS56ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjcm9zcyggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB0aGlzLCB2ICk7XG5cblx0fVxuXG5cdGNyb3NzVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG5cdFx0Y29uc3QgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcblxuXHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3RPblZlY3RvciggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gdi5sZW5ndGhTcSgpO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCApO1xuXG5cdFx0Y29uc3Qgc2NhbGFyID0gdi5kb3QoIHRoaXMgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggdiApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcblxuXHR9XG5cblx0cHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xuXG5cdFx0X3ZlY3Rvci5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yICk7XG5cblx0fVxuXG5cdHJlZmxlY3QoIG5vcm1hbCApIHtcblxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3Rvci5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIE1hdGguUEkgLyAyO1xuXG5cdFx0Y29uc3QgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gZGVub21pbmF0b3I7XG5cblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvU3F1YXJlZCggdiApIHtcblxuXHRcdGNvbnN0IGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueSwgZHogPSB0aGlzLnogLSB2Lno7XG5cblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG5cdH1cblxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKSArIE1hdGguYWJzKCB0aGlzLnogLSB2LnogKTtcblxuXHR9XG5cblx0c2V0RnJvbVNwaGVyaWNhbCggcyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMoIHMucmFkaXVzLCBzLnBoaSwgcy50aGV0YSApO1xuXG5cdH1cblxuXHRzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XG5cblx0XHRjb25zdCBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcGhpICkgKiByYWRpdXM7XG5cblx0XHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNvcyggcGhpICkgKiByYWRpdXM7XG5cdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUN5bGluZHJpY2FsKCBjICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCBjLnJhZGl1cywgYy50aGV0YSwgYy55ICk7XG5cblx0fVxuXG5cdHNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggcmFkaXVzLCB0aGV0YSwgeSApIHtcblxuXHRcdHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICkge1xuXG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAxMiBdO1xuXHRcdHRoaXMueSA9IGVbIDEzIF07XG5cdFx0dGhpcy56ID0gZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4U2NhbGUoIG0gKSB7XG5cblx0XHRjb25zdCBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuXHRcdHRoaXMueCA9IHN4O1xuXHRcdHRoaXMueSA9IHN5O1xuXHRcdHRoaXMueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhDb2x1bW4oIG0sIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDQgKTtcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeDNDb2x1bW4oIG0sIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDMgKTtcblxuXHR9XG5cblx0ZXF1YWxzKCB2ICkge1xuXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyYW5kb20oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy56ID0gTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5WZWN0b3IzLnByb3RvdHlwZS5pc1ZlY3RvcjMgPSB0cnVlO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmV4cG9ydCB7IFZlY3RvcjMgfTtcbiIsImltcG9ydCB7IGRldGVjdCB9IGZyb20gXCJkZXRlY3QtYnJvd3NlclwiO1xuaW1wb3J0IHsgaXNJb3MgfSBmcm9tIFwiLi9pc0lvc1wiO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICBjb25zdCBicm93c2VyID0gZGV0ZWN0KCk7XG4gIGNvbnNvbGUubG9nKGJyb3dzZXIpO1xuICBjb25zb2xlLmxvZyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgLy9pT1Mgd2Ugd2lsbCByZWRpcmVjdCB0byBub24gYXIgdmVyc2lvbiBhbnl3YXlcbiAgaWYgKGlzSW9zKSByZXR1cm47XG4gIGlmIChicm93c2VyLm9zICE9PSBcIkFuZHJvaWQgT1NcIiAmJiBicm93c2VyLm9zICE9PSBcImFuZHJvaWRcIikgcmV0dXJuO1xuICBpZiAoYnJvd3Nlci5uYW1lICE9PSBcImNocm9tZVwiICYmIGJyb3dzZXIubmFtZSAhPT0gXCJjaHJvbWl1bS13ZWJ2aWV3XCIpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Vycm9yLW92ZXJsYXlcIikuaW5uZXJIVE1MID0gYFxuICAgIDxkaXY+VGhpcyBzaXRlIG9ubHkgc3VwcG9ydHMgdGhlIDxhIGhyZWY9J2h0dHBzOi8vcGxheS5nb29nbGUuY29tL3N0b3JlL2FwcHMvZGV0YWlscz9pZD1jb20uYW5kcm9pZC5jaHJvbWUnPkNocm9tZSB3ZWIgYnJvd3NlciBvbiBBbmRyb2lkLjwvYT48L2Rpdj47XG4gICAgYDtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Vycm9yLW92ZXJsYXlcIikuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICB9XG59KTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICBcIiNlcnJvci1vdmVybGF5XCIsXG4gICkuaW5uZXJIVE1MID0gYDxkaXY+T29wcyEgQW4gZXJyb3I8YnI+PGJyPlBsZWFzZSByZWZyZXNoIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uPGJyPjxicj48c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMC41ZW1cIj4ke2V2ZW50Lm1lc3NhZ2V9PC9zcGFuPjwvZGl2PmA7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZXJyb3Itb3ZlcmxheVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gIGNvbnN0IGlkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWlkXCIpO1xuICBpZiAoaWQpIHtcbiAgICBmZXRjaChcImh0dHBzOi8vc3BhdGlhbHN0YXRzLmx1Y2FzLWxldmluLmNvbS9cIiArIGlkICsgXCIvZXJyb3IvXCIgKyBlbmNvZGVVUkkoZXZlbnQubWVzc2FnZS5zdWJzdHIoMCwgMTAwKSkpLmNhdGNoKCk7XG4gIH1cbn0pO1xuIiwiZXhwb3J0IGNvbnN0IGlzSW9zID1cbiAgW1wiaVBhZCBTaW11bGF0b3JcIiwgXCJpUGhvbmUgU2ltdWxhdG9yXCIsIFwiaVBvZCBTaW11bGF0b3JcIiwgXCJpUGFkXCIsIFwiaVBob25lXCIsIFwiaVBvZFwiXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pIHx8XG4gIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTWFjXCIpICYmIFwib250b3VjaGVuZFwiIGluIGRvY3VtZW50KTtcbiIsImV4cG9ydCBpbnRlcmZhY2UgTG9hZE1lZGlhU3RhdGUge1xuICBsb2FkZWQ/OiBib29sZWFuO1xuICBudW1Mb2FkZWQ/OiBudW1iZXI7XG4gIG51bUl0ZW1zPzogbnVtYmVyO1xuICBidWZmZXJTb3VyY2VzPzogQXVkaW9CdWZmZXJTb3VyY2VOb2RlW107XG4gIHJlcXVlc3RzPzogWE1MSHR0cFJlcXVlc3RbXTtcbiAgcHJvZ3Jlc3M/OiBudW1iZXJbXTtcbn1cblxuaW50ZXJmYWNlIExvYWRNZWRpYVBhcmFtcyB7XG4gIGVsOiBIVE1MRWxlbWVudDtcbiAgYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gIG9uU3VjY2VzcyhiYXJjb2RlRGF0YTogc3RyaW5nLCBidWZmZXJTb3VyY2VzOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGVbXSk6IHZvaWQ7XG4gIG9uUHJvZ3Jlc3MocGVyY2VudDogbnVtYmVyKTogdm9pZDtcbiAgYmFyY29kZURhdGE6IHN0cmluZztcbiAgbG9hZGluZ0JhcmNvZGVDb250YWluZXI6IHsgbG9hZGluZ0JhcmNvZGU6IG51bWJlciB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZE1lZGlhKHN0YXRlOiBMb2FkTWVkaWFTdGF0ZSwgcGFyYW1zOiBMb2FkTWVkaWFQYXJhbXMpOiB2b2lkIHtcbiAgc3RhdGUubG9hZGVkID0gZmFsc2U7XG4gIHN0YXRlLm51bUxvYWRlZCA9IDA7XG4gIHN0YXRlLm51bUl0ZW1zID0gcGFyYW1zLmVsLmNoaWxkcmVuLmxlbmd0aDtcbiAgc3RhdGUuYnVmZmVyU291cmNlcyA9IFtdO1xuICBjb25zb2xlLmxvZyhwYXJhbXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xuICBzdGF0ZS5yZXF1ZXN0cyA9IFtdO1xuXG4gIGNvbnNvbGUubG9nKGBMb2FkaW5nICR7c3RhdGUubnVtSXRlbXN9IGF1ZGlvIGVsZW1lbnRzYCk7XG5cbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHBhcmFtcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcbiAgc3RhdGUucHJvZ3Jlc3MgPSBBcnJheShwYXJhbXMuZWwuY2hpbGRyZW4ubGVuZ3RoKS5maWxsKDApO1xuICBBcnJheS5mcm9tKHBhcmFtcy5lbC5jaGlsZHJlbikuZm9yRWFjaCgoYW5jaG9yRWwsIGluZGV4KSA9PiB7XG4gICAgaWYgKGFuY2hvckVsLnRhZ05hbWUgIT09IFwiQVwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGxvYWRlciBzaG91bGQgb25seSBoYXZlIDxhPiBjaGlsZHJlblwiKTtcbiAgICB9XG4gICAgY29uc3Qgb3JpZ2luYWxVcmw6IHN0cmluZyA9IGFuY2hvckVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgY29uc3QgdXJsID1cbiAgICAgIHNhbXBsZVJhdGUgPT09IDQ4MDAwXG4gICAgICAgID8gb3JpZ2luYWxVcmwuc2xpY2UoMCwgLTMpICsgXCI0OC5cIiArIG9yaWdpbmFsVXJsLnNsaWNlKC0zKVxuICAgICAgICA6IHNhbXBsZVJhdGUgPT09IDQ0MTAwXG4gICAgICAgID8gb3JpZ2luYWxVcmwuc2xpY2UoMCwgLTMpICsgXCI0NC5cIiArIG9yaWdpbmFsVXJsLnNsaWNlKC0zKVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKCF1cmwpIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBzYW1wbGUgcmF0ZSAke3NhbXBsZVJhdGV9YCk7XG5cbiAgICBzdGF0ZS5idWZmZXJTb3VyY2VzLnB1c2gocGFyYW1zLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKSk7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHN0YXRlLnJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgY2hpbGRQcm9ncmVzcy5iaW5kKHRoaXMsIHN0YXRlLCBwYXJhbXMsIGluZGV4KSk7XG4gICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjaGlsZExvYWRTdWNjZXNzLmJpbmQodGhpcywgc3RhdGUsIHBhcmFtcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBjaGlsZEVycm9yLmJpbmQodGhpcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjaGlsZEFib3J0LmJpbmQodGhpcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICByZXF1ZXN0LnNlbmQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkUHJvZ3Jlc3Moc3RhdGU6IExvYWRNZWRpYVN0YXRlLCBwYXJhbXM6IExvYWRNZWRpYVBhcmFtcywgaW5kZXg6IG51bWJlciwgZXZlbnQ6IFByb2dyZXNzRXZlbnQpIHtcbiAgY29uc3QgcGVyY2VudCA9IGV2ZW50LnRvdGFsID8gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWwgOiAwO1xuICBzdGF0ZS5wcm9ncmVzc1tpbmRleF0gPSBwZXJjZW50O1xuICBjb25zdCB0b3RhbFBlcmNlbnQgPSBzdGF0ZS5wcm9ncmVzcy5yZWR1Y2UoKHByZXY6IG51bWJlciwgY3VyOiBudW1iZXIpID0+IHByZXYgKyBjdXIpIC8gc3RhdGUucHJvZ3Jlc3MubGVuZ3RoO1xuICBwYXJhbXMub25Qcm9ncmVzcyh0b3RhbFBlcmNlbnQpO1xufVxuXG5mdW5jdGlvbiBjaGlsZExvYWRTdWNjZXNzKHN0YXRlOiBMb2FkTWVkaWFTdGF0ZSwgcGFyYW1zOiBMb2FkTWVkaWFQYXJhbXMsIGluZGV4OiBudW1iZXIpIHtcbiAgY29uc29sZS5sb2coYExvYWRlZCAke2luZGV4fWApO1xuICBjb25zdCBkYXRhID0gc3RhdGUucmVxdWVzdHNbaW5kZXhdPy5yZXNwb25zZTtcbiAgLy9ndWFyZCBhZ2FpbnN0IHJhY2UgY29uZGl0aW9uc1xuICBpZiAoIWRhdGEpIHJldHVybjtcbiAgLy9zYWZhcmkgZG9lc24ndCBzdXBwb3J0IHByb21pc2UgYmFzZWQgZGVjb2RlXG4gIHBhcmFtcy5hdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKFxuICAgIGRhdGEsXG4gICAgKGJ1ZmZlcjogQXVkaW9CdWZmZXIpID0+IHtcbiAgICAgIGlmICghc3RhdGUuYnVmZmVyU291cmNlc1tpbmRleF0pIHN0YXRlLmJ1ZmZlclNvdXJjZXNbaW5kZXhdID0gcGFyYW1zLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIHN0YXRlLmJ1ZmZlclNvdXJjZXNbaW5kZXhdLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgICAgc3RhdGUubnVtTG9hZGVkICs9IDE7XG4gICAgICBpZiAoc3RhdGUubnVtTG9hZGVkID49IHN0YXRlLm51bUl0ZW1zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIGFsbCBpdGVtc1wiKTtcbiAgICAgICAgc3RhdGUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcGFyYW1zLm9uU3VjY2VzcyhwYXJhbXMuYmFyY29kZURhdGEsIHN0YXRlLmJ1ZmZlclNvdXJjZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgKCkgPT4ge1xuICAgICAgY2hpbGRFcnJvcihpbmRleCk7XG4gICAgfSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2hpbGRFcnJvcihpbmRleDogbnVtYmVyLCBldmVudD86IFByb2dyZXNzRXZlbnQpIHtcbiAgdGhyb3cgRXJyb3IoYENvdWxkbid0IGxvYWQgcGllY2UgJHtpbmRleH0uYCk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkQWJvcnQoaW5kZXg6IG51bWJlcikge1xuICBjb25zb2xlLmxvZyhgQWJvcnRpbmcgbG9hZCBpdGVtICR7aW5kZXh9YCk7XG59XG4iLCJpbXBvcnQgeyBSZXNvbmFuY2VBdWRpbyB9IGZyb20gXCJyZXNvbmFuY2UtYXVkaW9cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRSZXNvbmFuY2UoYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQpOiBSZXNvbmFuY2VBdWRpbyB7XG4gIGNvbnNvbGUubG9nKFwiTG9hZGluZyByZXNvbmFuY2VcIik7XG4gIGNvbnN0IGFtYmlzb25pY09yZGVyID0gMTtcbiAgY29uc3QgcmVzb25hbmNlQXVkaW9TY2VuZSA9IG5ldyBSZXNvbmFuY2VBdWRpbyhhdWRpb0NvbnRleHQsIHsgYW1iaXNvbmljT3JkZXIgfSk7XG4gIHJlc29uYW5jZUF1ZGlvU2NlbmUuc2V0Um9vbVByb3BlcnRpZXMoXG4gICAgeyB3aWR0aDogNiwgaGVpZ2h0OiA1LCBkZXB0aDogNiB9LFxuICAgIHtcbiAgICAgIGJhY2s6IFwid29vZC1wYW5lbFwiLFxuICAgICAgbGVmdDogXCJicmljay1iYXJlXCIsXG4gICAgICByaWdodDogXCJicmljay1iYXJlXCIsXG4gICAgICBmcm9udDogXCJ3b29kLXBhbmVsXCIsXG4gICAgICBkb3duOiBcInBseXdvb2QtcGFuZWxcIixcbiAgICAgIHVwOiBcImFjb3VzdGljLWNlaWxpbmctdGlsZXNcIixcbiAgICB9LFxuICApO1xuICByZXNvbmFuY2VBdWRpb1NjZW5lLm91dHB1dC5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gIHJldHVybiByZXNvbmFuY2VBdWRpb1NjZW5lO1xufVxuIiwiaW1wb3J0IHsgRXVsZXIgfSBmcm9tIFwidGhyZWUvc3JjL21hdGgvRXVsZXJcIjtcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwidGhyZWUvc3JjL21hdGgvVmVjdG9yM1wiO1xuaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gXCJ0aHJlZS9zcmMvbWF0aC9RdWF0ZXJuaW9uXCI7XG5pbXBvcnQgeyBSZXNvbmFuY2VBdWRpbywgU291cmNlIH0gZnJvbSBcInJlc29uYW5jZS1hdWRpb1wiO1xuaW1wb3J0ICogYXMgTnVuanVja3MgZnJvbSBcIm51bmp1Y2tzXCI7XG5pbXBvcnQgXCIuL2dsb2JhbFwiO1xuaW1wb3J0IHsgbG9hZFJlc29uYW5jZSB9IGZyb20gXCIuL2xvYWRSZXNvbmFuY2VcIjtcbmltcG9ydCB7IGxvYWRNZWRpYSwgTG9hZE1lZGlhU3RhdGUgfSBmcm9tIFwiLi9sb2FkTWVkaWFcIjtcblxuY29uc3QgaW5kZXggPSBOdW1iZXIucGFyc2VJbnQod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC8/KFxcZCspXFwuaHRtbC8pWzFdKTtcblxuTnVuanVja3MuY29uZmlndXJlKFwidGVtcGxhdGVzXCIsIHsgYXV0b2VzY2FwZTogdHJ1ZSB9KTtcbmRvY3VtZW50LndyaXRlKE51bmp1Y2tzLnJlbmRlcihgbG9hZGVyLSR7aW5kZXh9Lm5qa2ApKTtcbmRvY3VtZW50LndyaXRlKE51bmp1Y2tzLnJlbmRlcihgc2NlbmUtJHtpbmRleH0ubmprYCkpO1xuXG5jb25zdCBsb2FkTWVkaWFTdGF0ZTogTG9hZE1lZGlhU3RhdGUgPSB7fTtcbmxldCByZXNvbmFuY2VBdWRpb1NjZW5lOiBSZXNvbmFuY2VBdWRpbyB8IHVuZGVmaW5lZDtcbmxldCBhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dCB8IHVuZGVmaW5lZDtcbmxldCBvcmllbnRhdGlvblBlcm1pc3Npb246IFBlcm1pc3Npb25TdGF0ZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuY29uc3QgZGVndG9yYWQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbmNvbnN0IHlBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5jb25zdCB6QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuY29uc3QgdXBBeGlzID0gbmV3IFZlY3RvcjMoMCwgLTEsIDApO1xuY29uc3QgZm9yd2FyZEF4aXMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKTtcbmxldCBpbml0aWFsRGlyZWN0aW9uOiB1bmRlZmluZWQgfCBWZWN0b3IzID0gdW5kZWZpbmVkO1xuY29uc3QgcTAgPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBhbHBoYU9mZnNldCA9IDA7XG5jb25zdCBmb3J3YXJkID0gbmV3IFZlY3RvcjMoMCwgMCwgLTEpO1xuY29uc3QgdXAgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbmNvbnN0IGV1bGVyT3JpZ2luID0gbmV3IEV1bGVyKE1hdGguUEkgLyAyLCAwLCAwLCBcIllaWFwiKTtcblxuY29uc3QgZnJlZXplQ2hlY2tib3hFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJlZXplLWNoZWNrYm94XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbmludGVyZmFjZSBBbmltYXRpb25UaW1lbGluZUl0ZW0ge1xuICBhbmltYXRpb246IEVudGl0eUFuaW1hdGlvbjtcbiAgZW50aXR5OiBBdWRpb0VudGl0eTtcbiAgb2Zmc2V0OiBudW1iZXI7XG4gIHN0YXJ0VGltZTogbnVtYmVyO1xuICBmaW5pc2hUaW1lOiBudW1iZXI7XG59XG5pbnRlcmZhY2UgQW5pbWF0aW9uVGltZWxpbmVHcm91cCB7XG4gIGl0ZW1zOiBBbmltYXRpb25UaW1lbGluZUl0ZW1bXTtcbiAgb2Zmc2V0OiBudW1iZXI7XG4gIGZpbmlzaFRpbWU6IG51bWJlcjtcbn1cbmNvbnN0IGFuaW1hdGlvblRpbWVsaW5lOiAoQW5pbWF0aW9uVGltZWxpbmVJdGVtIHwgQW5pbWF0aW9uVGltZWxpbmVHcm91cClbXSA9IFtdO1xubGV0IHRpbWVsaW5lTG9vcDogbnVsbCB8IGJvb2xlYW4gPSBudWxsO1xubGV0IGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPSAtMTtcbmxldCBhbmltYXRpb25TdGFydFRpbWUgPSAwO1xuXG5pbnRlcmZhY2UgRW50aXR5QW5pbWF0aW9uIHtcbiAgZHVyOiBudW1iZXI7XG4gIGZyb206IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdG86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZGVsYXk/OiBudW1iZXI7XG4gIGVhc2luZzogXCJsaW5lYXJcIjtcbn1cblxuaW50ZXJmYWNlIEF1ZGlvRW50aXR5IHtcbiAgZWw6IEVsZW1lbnQ7XG4gIHBvc2l0aW9uOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGluZGV4OiBudW1iZXI7XG4gIGJ1ZmZlclNvdXJjZTogQXVkaW9CdWZmZXJTb3VyY2VOb2RlO1xuICByZXNvbmFuY2VTb3VyY2U6IFNvdXJjZTtcbiAgYW5pbWF0aW9uczogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPjtcbn1cbmNvbnN0IGVudGl0aWVzOiBBdWRpb0VudGl0eVtdID0gW107XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gIGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcihcIiNwbGF5LW92ZXJsYXlcIikuY2xhc3NMaXN0LnJlbW92ZShcImZhZGUtb3V0XCIpO1xuICBhdWRpb0NvbnRleHQgPSBuZXcgd2luZG93LkF1ZGlvQ29udGV4dCgpO1xuICByZXNvbmFuY2VBdWRpb1NjZW5lID0gbG9hZFJlc29uYW5jZShhdWRpb0NvbnRleHQpO1xuICBjb25zdCBsb2FkZXJFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbbG9hZGVyXVwiKTtcbiAgbG9hZE1lZGlhKGxvYWRNZWRpYVN0YXRlLCB7XG4gICAgZWw6IGxvYWRlckVsLFxuICAgIGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0LFxuICAgIG9uU3VjY2VzczogbWVkaWFMb2FkZWQsXG4gICAgb25Qcm9ncmVzczogKHBlcmNlbnQpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRpbmdCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3BsYXktYnV0dG9uXCIpO1xuICAgICAgaWYgKGxvYWRpbmdCdXR0b24pIGxvYWRpbmdCdXR0b24uaW5uZXJUZXh0ID0gYExvYWRpbmcgJHtNYXRoLnJvdW5kKHBlcmNlbnQgKiA5OCl9JS4uLmA7XG4gICAgfSxcbiAgICBiYXJjb2RlRGF0YTogaW5kZXgudG9TdHJpbmcoKSxcbiAgICBsb2FkaW5nQmFyY29kZUNvbnRhaW5lcjogeyBsb2FkaW5nQmFyY29kZTogaW5kZXggfSxcbiAgfSk7XG5cbiAgbG9hZEVudGl0aWVzKCk7XG59KTtcblxuZnVuY3Rpb24gbG9hZEVudGl0aWVzKCkge1xuICBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbcmVzb25hbmNlLXNvdXJjZV1cIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KGUuZ2V0QXR0cmlidXRlKFwicmVzb25hbmNlLXNvdXJjZVwiKSk7XG4gICAgY29uc3QgcG9zaXRpb24gPSBlXG4gICAgICAuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIilcbiAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgIC5tYXAoKGkpID0+IE51bWJlci5wYXJzZUZsb2F0KGkpKSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgY29uc3QgYnVmZmVyU291cmNlID0gbG9hZE1lZGlhU3RhdGUuYnVmZmVyU291cmNlcz8uW2luZGV4XTtcbiAgICBjb25zdCByZXNvbmFuY2VTb3VyY2UgPSByZXNvbmFuY2VBdWRpb1NjZW5lLmNyZWF0ZVNvdXJjZSgpO1xuICAgIGJ1ZmZlclNvdXJjZS5jb25uZWN0KHJlc29uYW5jZVNvdXJjZS5pbnB1dCk7XG4gICAgcmVzb25hbmNlU291cmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uWzBdLCAtcG9zaXRpb25bMl0sIHBvc2l0aW9uWzFdKTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBleHRyYWN0QW5pbWF0aW9ucyhlKTtcbiAgICBjb25zdCBtaXhpbkFuaW1hdGlvbnMgPSBlLmhhc0F0dHJpYnV0ZShcIm1peGluXCIpXG4gICAgICA/IGV4dHJhY3RBbmltYXRpb25zKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUuZ2V0QXR0cmlidXRlKFwibWl4aW5cIikpKVxuICAgICAgOiB7fTtcblxuICAgIGNvbnN0IGVudGl0eSA9IHtcbiAgICAgIGVsOiBlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBpbmRleCxcbiAgICAgIGJ1ZmZlclNvdXJjZSxcbiAgICAgIHJlc29uYW5jZVNvdXJjZSxcbiAgICAgIGFuaW1hdGlvbnM6IHsgLi4ubWl4aW5BbmltYXRpb25zLCAuLi5hbmltYXRpb25zIH0sXG4gICAgfTtcbiAgICBlbnRpdGllcy5wdXNoKGVudGl0eSk7XG4gIH0pO1xuXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLWVudGl0eVwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgYXR0ciA9IEFycmF5LmZyb20oZS5hdHRyaWJ1dGVzKS5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUuc3RhcnRzV2l0aChcImFuaW1hdGlvbi10aW1lbGluZVwiKSk7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIGlmICh0aW1lbGluZUxvb3AgIT09IG51bGwpIHRocm93IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSBlbnRpdHkgd2l0aCBhbmltYXRpb24tdGltZWxpbmUgYXR0cmlidXRlXCIpO1xuICAgICAgaWYgKGF0dHIudmFsdWUubWF0Y2goL2xvb3A6XFxzP3RydWUvKSkgdGltZWxpbmVMb29wID0gdHJ1ZTtcbiAgICAgIGVsc2UgdGltZWxpbmVMb29wID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgY29uc29sZS5sb2coYGxvb3A6ICR7dGltZWxpbmVMb29wfWApO1xuXG4gIGNvbnN0IHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYS10aW1lbGluZVwiKTtcbiAgaWYgKCF0KSB0aHJvdyBFcnJvcihcIk5vIGFuaW1hdGlvbiB0aW1lbGluZSBmb3VuZFwiKTtcbiAgbGV0IHRpbWUgPSAwO1xuICBBcnJheS5mcm9tKHQuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09IFwiQS1USU1FTElORS1BTklNQVRJT05cIikge1xuICAgICAgY29uc3QgbmFtZSA9IGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICBjb25zdCBvZmZzZXQgPSBOdW1iZXIucGFyc2VJbnQoY2hpbGQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hpbGQuZ2V0QXR0cmlidXRlKFwic2VsZWN0XCIpO1xuICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXMuZmluZCgoZSkgPT4gZS5lbCA9PT0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpKTtcbiAgICAgIGlmICghZW50aXR5KSB0aHJvdyBFcnJvcihgQ291bGRuJ3QgZmluZCBlbnRpdHkgJHt0YXJnZXR9YCk7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBlbnRpdHkuYW5pbWF0aW9uc1tuYW1lXTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUgKyAoYW5pbWF0aW9uLmRlbGF5ID8/IDApICsgb2Zmc2V0O1xuICAgICAgY29uc3QgZmluaXNoVGltZSA9IHN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXI7XG4gICAgICBhbmltYXRpb25UaW1lbGluZS5wdXNoKHtcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBlbnRpdHksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBmaW5pc2hUaW1lLFxuICAgICAgfSk7XG4gICAgICB0aW1lID0gZmluaXNoVGltZTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnRhZ05hbWUgPT09IFwiQS1USU1FTElORS1HUk9VUFwiKSB7XG4gICAgICBjb25zdCBncm91cE9mZnNldCA9IE51bWJlci5wYXJzZUludChjaGlsZC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICBjb25zdCBncm91cDogQW5pbWF0aW9uVGltZWxpbmVHcm91cCA9IHsgaXRlbXM6IFtdLCBvZmZzZXQ6IGdyb3VwT2Zmc2V0LCBmaW5pc2hUaW1lOiAwIH07XG4gICAgICBBcnJheS5mcm9tKGNoaWxkLmNoaWxkcmVuKS5mb3JFYWNoKChncmFuZGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChncmFuZGNoaWxkLnRhZ05hbWUgPT09IFwiQS1USU1FTElORS1BTklNQVRJT05cIikge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBncmFuZGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTnVtYmVyLnBhcnNlSW50KGdyYW5kY2hpbGQuZ2V0QXR0cmlidXRlKFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdyYW5kY2hpbGQuZ2V0QXR0cmlidXRlKFwic2VsZWN0XCIpO1xuICAgICAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzLmZpbmQoKGUpID0+IGUuZWwgPT09IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KSk7XG4gICAgICAgICAgaWYgKCFlbnRpdHkpIHRocm93IEVycm9yKGBDb3VsZG4ndCBmaW5kIGVudGl0eSAke3RhcmdldH1gKTtcbiAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSBlbnRpdHkuYW5pbWF0aW9uc1tuYW1lXTtcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lICsgKGFuaW1hdGlvbi5kZWxheSA/PyAwKSArIGdyb3VwT2Zmc2V0ICsgb2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IGZpbmlzaFRpbWUgPSBzdGFydFRpbWUgKyBhbmltYXRpb24uZHVyO1xuICAgICAgICAgIGdyb3VwLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZW50aXR5LFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgZmluaXNoVGltZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBncm91cC5maW5pc2hUaW1lID0gTWF0aC5tYXgoZ3JvdXAuZmluaXNoVGltZSwgZmluaXNoVGltZSk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgdGltZWxpbmUgdGFnICR7Z3JhbmRjaGlsZC50YWdOYW1lfWApO1xuICAgICAgfSk7XG4gICAgICBhbmltYXRpb25UaW1lbGluZS5wdXNoKGdyb3VwKTtcbiAgICAgIHRpbWUgPSBncm91cC5maW5pc2hUaW1lO1xuICAgIH0gZWxzZSB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgdGltZWxpbmUgdGFnICR7Y2hpbGQudGFnTmFtZX1gKTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKGFuaW1hdGlvblRpbWVsaW5lKTtcbn1cblxuZnVuY3Rpb24gbWVkaWFMb2FkZWQoKSB7XG4gIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcjxIVE1MQnV0dG9uRWxlbWVudD4oXCIjcGxheS1idXR0b25cIik7XG4gIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICBidXR0b24uaW5uZXJUZXh0ID0gXCJQbGF5XCI7XG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyAxO1xuICAgIGFuaW1hdGlvblN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiBlbnRpdHkuYnVmZmVyU291cmNlLnN0YXJ0KHN0YXJ0VGltZSkpO1xuICAgIHdpbmRvdy5zZXRJbnRlcnZhbChtYWluTG9vcCwgNTApO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVcIikuaW5uZXJUZXh0ID0gXCJZb3UgYXJlIGxpc3RlbmluZyB0byB0aGUgc3BhdGlhbCBleHBlcmllbmNlLlwiO1xuICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICBpZiAod2luZG93LkRldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgRGV2aWNlT3JpZW50YXRpb25FdmVudC5yZXF1ZXN0UGVybWlzc2lvbiAmJlxuICAgICAgICBvcmllbnRhdGlvblBlcm1pc3Npb24gIT09IFwiZGVuaWVkXCIgJiZcbiAgICAgICAgb3JpZW50YXRpb25QZXJtaXNzaW9uICE9PSBcImdyYW50ZWRcIlxuICAgICAgKSB7XG4gICAgICAgIG9yaWVudGF0aW9uUGVybWlzc2lvbiA9IGF3YWl0IERldmljZU9yaWVudGF0aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uUGVybWlzc2lvbiA9PT0gXCJkZW5pZWRcIikge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgICBtZXNzYWdlLmlubmVyVGV4dCA9IFwiWW91IGRpZCBub3QgZ2l2ZSBwZXJtaXNzaW9uIHRvIHVzZSBkZXZpY2UgbW90aW9uLiBZb3VyIHZpZXdwb2ludCB3aWxsIHJlbWFpbiBzdGF0aWMuXCI7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRocm90dGxlKHVwZGF0ZUxpc3RlbmVyLCA1MCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1haW5Mb29wKCkge1xuICB1cGRhdGVFbnRpdGllcygpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFbnRpdGllcygpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgaWYgKCFhbmltYXRpb25UaW1lbGluZVswXSkgcmV0dXJuO1xuICAvL2luY3JlbWVudCB0aGUgdGltZWxpbmUgaWYgbmVjZXNzYXJ5XG4gIHdoaWxlIChub3cgPiAoYW5pbWF0aW9uVGltZWxpbmU/LlthbmltYXRpb25UaW1lbGluZUluZGV4XT8uZmluaXNoVGltZSA/PyAwKSArIGFuaW1hdGlvblN0YXJ0VGltZSkge1xuICAgIGlmIChcbiAgICAgIC8vd2FpdGluZyBmb3Igb2Zmc2V0IG9ubHkgYXBwbGllcyB0byB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbiwgYW5kIHRpbWVsaW5lIGdyb3Vwc1xuICAgICAgLy9zaW5jZSBzdGFydFRpbWUgZmFjdG9ycyBpdCBpbiBsYXRlclxuICAgICAgKChhbmltYXRpb25UaW1lbGluZVthbmltYXRpb25UaW1lbGluZUluZGV4ICsgMV0gJiYgXCJpdGVtc1wiIGluIGFuaW1hdGlvblRpbWVsaW5lW2FuaW1hdGlvblRpbWVsaW5lSW5kZXggKyAxXSkgfHxcbiAgICAgICAgYW5pbWF0aW9uVGltZWxpbmVJbmRleCA8IDApICYmXG4gICAgICBub3cgPD1cbiAgICAgICAgKGFuaW1hdGlvblRpbWVsaW5lPy5bYW5pbWF0aW9uVGltZWxpbmVJbmRleF0/LmZpbmlzaFRpbWUgPz8gMCkgK1xuICAgICAgICAgIGFuaW1hdGlvblN0YXJ0VGltZSArXG4gICAgICAgICAgKGFuaW1hdGlvblRpbWVsaW5lPy5bYW5pbWF0aW9uVGltZWxpbmVJbmRleCArIDFdPy5vZmZzZXQgPz8gMClcbiAgICApIHtcbiAgICAgIC8vZG9uJ3QgZ28gdG8gbmV4dCBhbmltYXRpb24gaWYgbm93IGlzbid0IGJpZ2dlciB0aGFuIHRoZSBvZmZzZXQgeWV0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdGlvblRpbWVsaW5lSW5kZXgrKztcbiAgICBpZiAoYW5pbWF0aW9uVGltZWxpbmVJbmRleCA+PSBhbmltYXRpb25UaW1lbGluZS5sZW5ndGgpIHtcbiAgICAgIGlmICghdGltZWxpbmVMb29wKSByZXR1cm47XG4gICAgICBhbmltYXRpb25TdGFydFRpbWUgPSBhbmltYXRpb25TdGFydFRpbWUgKyBhbmltYXRpb25UaW1lbGluZVthbmltYXRpb25UaW1lbGluZUluZGV4IC0gMV0uZmluaXNoVGltZTtcbiAgICAgIGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPSAwO1xuICAgIH1cbiAgfVxuICAvL2luZGV4IGlzIGxlc3MgdGhhbiB6ZXJvIGF0IHRoZSBzdGFydCBiZWNhdXNlIHRoZSBhdWRpbyBwbGF5cyBhZnRlciAxIHNlY1xuICBpZiAoYW5pbWF0aW9uVGltZWxpbmVJbmRleCA8IDApIHJldHVybjtcblxuICAvL3BsYWNlIGl0ZW1zXG4gIGNvbnN0IGEgPSBhbmltYXRpb25UaW1lbGluZVthbmltYXRpb25UaW1lbGluZUluZGV4XTtcbiAgLy9pcyBhcnJheVxuICBpZiAoXCJpdGVtc1wiIGluIGEpIHtcbiAgICBhLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgPD0gaXRlbS5zdGFydFRpbWUpIHJldHVybjtcbiAgICAgIGludGVycG9sYXRlKFxuICAgICAgICBpdGVtLmVudGl0eS5yZXNvbmFuY2VTb3VyY2UsXG4gICAgICAgIE1hdGgubWF4KDAsIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgLSBpdGVtLnN0YXJ0VGltZSkgLyAoaXRlbS5maW5pc2hUaW1lIC0gaXRlbS5zdGFydFRpbWUpKSxcbiAgICAgICAgaXRlbS5hbmltYXRpb24uZnJvbSxcbiAgICAgICAgaXRlbS5hbmltYXRpb24udG8sXG4gICAgICApO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgPD0gYS5zdGFydFRpbWUpIHJldHVybjtcbiAgICAvL3NpbmdsZSBpdGVtLCBub3QgYXJyYXlcbiAgICBpbnRlcnBvbGF0ZShcbiAgICAgIGEuZW50aXR5LnJlc29uYW5jZVNvdXJjZSxcbiAgICAgIE1hdGgubWF4KDAsIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgLSBhLnN0YXJ0VGltZSkgLyAoYS5maW5pc2hUaW1lIC0gYS5zdGFydFRpbWUpKSxcbiAgICAgIGEuYW5pbWF0aW9uLmZyb20sXG4gICAgICBhLmFuaW1hdGlvbi50byxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVyKGU6IERldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgaWYgKGZyZWV6ZUNoZWNrYm94RWwuY2hlY2tlZCkgcmV0dXJuO1xuICBjb25zdCBhbHBoYSA9IGUuYWxwaGEgPyBlLmFscGhhICogZGVndG9yYWQgKyBhbHBoYU9mZnNldCA6IDA7IC8vIFpcbiAgY29uc3QgYmV0YSA9IGUuYmV0YSA/IGUuYmV0YSAqIGRlZ3RvcmFkIDogMDsgLy8gWCdcbiAgY29uc3QgZ2FtbWEgPSBlLmdhbW1hID8gZS5nYW1tYSAqIGRlZ3RvcmFkIDogMDsgLy8gWScnXG4gIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyT3JpZ2luKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh6QXhpcywgYWxwaGEpO1xuICBxdWF0ZXJuaW9uLm11bHRpcGx5KHEwKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh4QXhpcywgYmV0YSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuICBxMC5zZXRGcm9tQXhpc0FuZ2xlKHlBeGlzLCBnYW1tYSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuXG4gIHVwLmNvcHkodXBBeGlzKS5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gIGZvcndhcmQuY29weShmb3J3YXJkQXhpcykuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuXG4gIGlmICghaW5pdGlhbERpcmVjdGlvbikge1xuICAgIGluaXRpYWxEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpLnByb2plY3RPblBsYW5lKHVwQXhpcykubm9ybWFsaXplKCk7XG4gICAgY29uc3QgYW5nbGUgPSBpbml0aWFsRGlyZWN0aW9uLmFuZ2xlVG8oZm9yd2FyZEF4aXMpO1xuICAgIGV1bGVyT3JpZ2luLnkgPSBhbmdsZTtcbiAgfVxuICAvKmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWdcIikuaW5uZXJIVE1MID0gYCR7Zm9yd2FyZC54LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC55LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC56LnRvRml4ZWQoXG4gICAgMixcbiAgKX08YnI+JHt1cC54LnRvRml4ZWQoMil9ICR7dXAueS50b0ZpeGVkKDIpfSAke3VwLnoudG9GaXhlZCgyKX08YnI+XG4gICR7YWxwaGEudG9GaXhlZCgyKX0gJHtiZXRhLnRvRml4ZWQoMil9ICR7Z2FtbWEudG9GaXhlZCgyKX08YnI+XG4gICR7ZXVsZXJPcmlnaW4ueC50b0ZpeGVkKDIpfSAke2V1bGVyT3JpZ2luLnkudG9GaXhlZCgyKX0gJHtldWxlck9yaWdpbi56LnRvRml4ZWQoMil9YDsqL1xuXG4gIC8vQHRzLWV4cGVjdC1lcnJvciAtIGJhZCB0eXBpbmdcbiAgcmVzb25hbmNlQXVkaW9TY2VuZS5zZXRMaXN0ZW5lck9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjazogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93biwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgcHJldiA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKG5vdyAtIHByZXYgPCBkZWxheSkgcmV0dXJuO1xuICAgIHByZXYgPSBub3c7XG4gICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QW5pbWF0aW9ucyhlbGVtZW50OiBFbGVtZW50KTogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBlbGVtZW50LmF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKFwiYW5pbWF0aW9uX19cIikgfHwgYXR0ci5uYW1lID09PSBcImFuaW1hdGlvblwiKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0ci5uYW1lLnN0YXJ0c1dpdGgoXCJhbmltYXRpb25fX1wiKSA/IGF0dHIubmFtZS5zcGxpdChcIl9fXCIpWzFdIDogYXR0ci5uYW1lO1xuICAgICAgcmVzdWx0W25hbWVdID0gcGFyc2VBbmltYXRpb24oYXR0ci52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uKGE6IHN0cmluZykge1xuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgY29uc3QgZGF0YSA9IGEuc3BsaXQoXCI7XCIpLm1hcCgoZSkgPT5cbiAgICBlXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoXCI6XCIpXG4gICAgICAubWFwKChlMikgPT4gZTIudHJpbSgpKSxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFbaV0ubGVuZ3RoIDwgMikgY29udGludWU7XG4gICAgaWYgKGRhdGFbaV1bMF0gPT09IFwiZGVsYXlcIikgdGhyb3cgRXJyb3IoXCJEb24ndCB1c2UgZGVsYXksIHVzZSB0aW1lbGluZSBvZmZzZXRcIik7XG4gICAgaWYgKGRhdGFbaV1bMF0gPT09IFwiZnJvbVwiIHx8IGRhdGFbaV1bMF0gPT09IFwidG9cIikge1xuICAgICAgcmVzdWx0W2RhdGFbaV1bMF1dID0gZGF0YVtpXVsxXS5zcGxpdChcIiBcIikubWFwKChuKSA9PiBOdW1iZXIucGFyc2VGbG9hdChuKSk7XG4gICAgfSBlbHNlIGlmIChkYXRhW2ldWzBdID09PSBcImR1clwiKSB7XG4gICAgICByZXN1bHRbZGF0YVtpXVswXV0gPSBOdW1iZXIucGFyc2VJbnQoZGF0YVtpXVsxXSk7XG4gICAgfSBlbHNlIGlmIChkYXRhW2ldWzFdID09PSBcInRydWVcIikge1xuICAgICAgcmVzdWx0W2RhdGFbaV1bMF1dID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGFbaV1bMV0gPT09IFwiZmFsc2VcIikge1xuICAgICAgcmVzdWx0W2RhdGFbaV1bMF1dID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtkYXRhW2ldWzBdXSA9IGRhdGFbaV1bMV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQgYXMgRW50aXR5QW5pbWF0aW9uO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShcbiAgcmVzb25hbmNlU291cmNlOiBTb3VyY2UsXG4gIHQ6IG51bWJlcixcbiAgZnJvbTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICB0bzogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBlYXNpbmc6IEVudGl0eUFuaW1hdGlvbltcImVhc2luZ1wiXSA9IFwibGluZWFyXCIsXG4pIHtcbiAgc3dpdGNoIChlYXNpbmcpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICByZXNvbmFuY2VTb3VyY2Uuc2V0UG9zaXRpb24oXG4gICAgICAgIGZyb21bMF0gKyB0ICogKHRvWzBdIC0gZnJvbVswXSksXG4gICAgICAgIGZyb21bMV0gKyB0ICogKHRvWzFdIC0gZnJvbVsxXSksXG4gICAgICAgIGZyb21bMl0gKyB0ICogKHRvWzJdIC0gZnJvbVsyXSksXG4gICAgICApO1xuICAgICAgLy8gcmVzb25hbmNlU291cmNlLnNldFBvc2l0aW9uKFxuICAgICAgLy8gICBmcm9tWzBdICsgdCAqICh0b1swXSAtIGZyb21bMF0pLFxuICAgICAgLy8gICAtKGZyb21bMl0gKyB0ICogKHRvWzJdIC0gZnJvbVsyXSkpLFxuICAgICAgLy8gICBmcm9tWzFdICsgdCAqICh0b1sxXSAtIGZyb21bMV0pLFxuICAgICAgLy8gKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihgVW5oYW5kbGVkIGVhc2luZyAke2Vhc2luZ31gKTtcbiAgfVxufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZVxuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3AudHNcIik7XG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdleHBvcnRzJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4iXSwic291cmNlUm9vdCI6IiJ9