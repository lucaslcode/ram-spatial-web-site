/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/detect-browser/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/detect-browser/es/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserInfo": function() { return /* binding */ BrowserInfo; },
/* harmony export */   "NodeInfo": function() { return /* binding */ NodeInfo; },
/* harmony export */   "SearchBotDeviceInfo": function() { return /* binding */ SearchBotDeviceInfo; },
/* harmony export */   "BotInfo": function() { return /* binding */ BotInfo; },
/* harmony export */   "ReactNativeInfo": function() { return /* binding */ ReactNativeInfo; },
/* harmony export */   "detect": function() { return /* binding */ detect; },
/* harmony export */   "browserName": function() { return /* binding */ browserName; },
/* harmony export */   "parseUserAgent": function() { return /* binding */ parseUserAgent; },
/* harmony export */   "detectOS": function() { return /* binding */ detectOS; },
/* harmony export */   "getNodeVersion": function() { return /* binding */ getNodeVersion; }
/* harmony export */ });
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var BrowserInfo = /** @class */ (function () {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}());

var NodeInfo = /** @class */ (function () {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = process.platform;
    }
    return NodeInfo;
}());

var SearchBotDeviceInfo = /** @class */ (function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}());

var BotInfo = /** @class */ (function () {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}());

var ReactNativeInfo = /** @class */ (function () {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}());

// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    ['aol', /AOLShield\/([0-9\._]+)/],
    ['edge', /Edge\/([0-9\._]+)/],
    ['edge-ios', /EdgiOS\/([0-9\._]+)/],
    ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
    ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
    ['samsung', /SamsungBrowser\/([0-9\.]+)/],
    ['silk', /\bSilk\/([0-9._-]+)\b/],
    ['miui', /MiuiBrowser\/([0-9\.]+)$/],
    ['beaker', /BeakerBrowser\/([0-9\.]+)/],
    ['edge-chromium', /EdgA?\/([0-9\.]+)/],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/,
    ],
    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
    ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
    ['fxios', /FxiOS\/([0-9\.]+)/],
    ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
    ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
    ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
    ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ['ie', /MSIE\s(7\.0)/],
    ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ['android', /Android\s([0-9\.]+)/],
    ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ['safari', /Version\/([0-9\._]+).*Safari/],
    ['facebook', /FBAV\/([0-9\.]+)/],
    ['instagram', /Instagram\s([0-9\.]+)/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
    ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ['searchbot', SEARCHBOX_UA_REGEX],
];
var operatingSystemRules = [
    ['iOS', /iP(hone|od|ad)/],
    ['Android OS', /Android/],
    ['BlackBerry OS', /BlackBerry|BB10/],
    ['Windows Mobile', /IEMobile/],
    ['Amazon OS', /Kindle/],
    ['Windows 3.11', /Win16/],
    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
    ['Windows 98', /(Windows 98)|(Win98)/],
    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
    ['Windows Server 2003', /(Windows NT 5.2)/],
    ['Windows Vista', /(Windows NT 6.0)/],
    ['Windows 7', /(Windows NT 6.1)/],
    ['Windows 8', /(Windows NT 6.2)/],
    ['Windows 8.1', /(Windows NT 6.3)/],
    ['Windows 10', /(Windows NT 10.0)/],
    ['Windows ME', /Windows ME/],
    ['Open BSD', /OpenBSD/],
    ['Sun OS', /SunOS/],
    ['Chrome OS', /CrOS/],
    ['Linux', /(Linux)|(X11)/],
    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
    ['QNX', /QNX/],
    ['BeOS', /BeOS/],
    ['OS/2', /OS\/2/],
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' &&
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return (ua !== '' &&
        userAgentRules.reduce(function (matched, _a) {
            var browser = _a[0], regex = _a[1];
            if (matched) {
                return matched;
            }
            var uaMatch = regex.exec(ua);
            return !!uaMatch && [browser, uaMatch];
        }, false));
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
        }
    }
    else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
        output.push('0');
    }
    return output;
}


/***/ }),

/***/ "./node_modules/nunjucks/browser/nunjucks.js":
/*!***************************************************!*\
  !*** ./node_modules/nunjucks/browser/nunjucks.js ***!
  \***************************************************/
/***/ (function(module) {

/*! Browser bundle of nunjucks 3.2.3  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_617__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_617__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_617__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_617__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_617__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_617__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_617__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_617__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_617__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_617__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_617__(__nested_webpack_require_617__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ArrayProto = Array.prototype;
var ObjProto = Object.prototype;
var escapeMap = {
  '&': '&amp;',
  '"': '&quot;',
  '\'': '&#39;',
  '<': '&lt;',
  '>': '&gt;'
};
var escapeRegex = /[&"'<>]/g;
var exports = module.exports = {};

function hasOwnProp(obj, k) {
  return ObjProto.hasOwnProperty.call(obj, k);
}

exports.hasOwnProp = hasOwnProp;

function lookupEscape(ch) {
  return escapeMap[ch];
}

function _prettifyError(path, withInternals, err) {
  if (!err.Update) {
    // not one of ours, cast it
    err = new exports.TemplateError(err);
  }

  err.Update(path); // Unless they marked the dev flag, show them a trace from here

  if (!withInternals) {
    var old = err;
    err = new Error(old.message);
    err.name = old.name;
  }

  return err;
}

exports._prettifyError = _prettifyError;

function TemplateError(message, lineno, colno) {
  var err;
  var cause;

  if (message instanceof Error) {
    cause = message;
    message = cause.name + ": " + cause.message;
  }

  if (Object.setPrototypeOf) {
    err = new Error(message);
    Object.setPrototypeOf(err, TemplateError.prototype);
  } else {
    err = this;
    Object.defineProperty(err, 'message', {
      enumerable: false,
      writable: true,
      value: message
    });
  }

  Object.defineProperty(err, 'name', {
    value: 'Template render error'
  });

  if (Error.captureStackTrace) {
    Error.captureStackTrace(err, this.constructor);
  }

  var getStack;

  if (cause) {
    var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

    getStack = stackDescriptor && (stackDescriptor.get || function () {
      return stackDescriptor.value;
    });

    if (!getStack) {
      getStack = function getStack() {
        return cause.stack;
      };
    }
  } else {
    var stack = new Error(message).stack;

    getStack = function getStack() {
      return stack;
    };
  }

  Object.defineProperty(err, 'stack', {
    get: function get() {
      return getStack.call(err);
    }
  });
  Object.defineProperty(err, 'cause', {
    value: cause
  });
  err.lineno = lineno;
  err.colno = colno;
  err.firstUpdate = true;

  err.Update = function Update(path) {
    var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
    // where error occurred

    if (this.firstUpdate) {
      if (this.lineno && this.colno) {
        msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
      } else if (this.lineno) {
        msg += " [Line " + this.lineno + "]";
      }
    }

    msg += '\n ';

    if (this.firstUpdate) {
      msg += ' ';
    }

    this.message = msg + (this.message || '');
    this.firstUpdate = false;
    return this;
  };

  return err;
}

if (Object.setPrototypeOf) {
  Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
} else {
  TemplateError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: TemplateError
    }
  });
}

exports.TemplateError = TemplateError;

function escape(val) {
  return val.replace(escapeRegex, lookupEscape);
}

exports.escape = escape;

function isFunction(obj) {
  return ObjProto.toString.call(obj) === '[object Function]';
}

exports.isFunction = isFunction;

function isArray(obj) {
  return ObjProto.toString.call(obj) === '[object Array]';
}

exports.isArray = isArray;

function isString(obj) {
  return ObjProto.toString.call(obj) === '[object String]';
}

exports.isString = isString;

function isObject(obj) {
  return ObjProto.toString.call(obj) === '[object Object]';
}

exports.isObject = isObject;
/**
 * @param {string|number} attr
 * @returns {(string|number)[]}
 * @private
 */

function _prepareAttributeParts(attr) {
  if (!attr) {
    return [];
  }

  if (typeof attr === 'string') {
    return attr.split('.');
  }

  return [attr];
}
/**
 * @param {string}   attribute      Attribute value. Dots allowed.
 * @returns {function(Object): *}
 */


function getAttrGetter(attribute) {
  var parts = _prepareAttributeParts(attribute);

  return function attrGetter(item) {
    var _item = item;

    for (var i = 0; i < parts.length; i++) {
      var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
      // that something goes wrong. Just roll out to undefined in that case.

      if (hasOwnProp(_item, part)) {
        _item = _item[part];
      } else {
        return undefined;
      }
    }

    return _item;
  };
}

exports.getAttrGetter = getAttrGetter;

function groupBy(obj, val, throwOnUndefined) {
  var result = {};
  var iterator = isFunction(val) ? val : getAttrGetter(val);

  for (var i = 0; i < obj.length; i++) {
    var value = obj[i];
    var key = iterator(value, i);

    if (key === undefined && throwOnUndefined === true) {
      throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
    }

    (result[key] || (result[key] = [])).push(value);
  }

  return result;
}

exports.groupBy = groupBy;

function toArray(obj) {
  return Array.prototype.slice.call(obj);
}

exports.toArray = toArray;

function without(array) {
  var result = [];

  if (!array) {
    return result;
  }

  var length = array.length;
  var contains = toArray(arguments).slice(1);
  var index = -1;

  while (++index < length) {
    if (indexOf(contains, array[index]) === -1) {
      result.push(array[index]);
    }
  }

  return result;
}

exports.without = without;

function repeat(char_, n) {
  var str = '';

  for (var i = 0; i < n; i++) {
    str += char_;
  }

  return str;
}

exports.repeat = repeat;

function each(obj, func, context) {
  if (obj == null) {
    return;
  }

  if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
    obj.forEach(func, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, l = obj.length; i < l; i++) {
      func.call(context, obj[i], i, obj);
    }
  }
}

exports.each = each;

function map(obj, func) {
  var results = [];

  if (obj == null) {
    return results;
  }

  if (ArrayProto.map && obj.map === ArrayProto.map) {
    return obj.map(func);
  }

  for (var i = 0; i < obj.length; i++) {
    results[results.length] = func(obj[i], i);
  }

  if (obj.length === +obj.length) {
    results.length = obj.length;
  }

  return results;
}

exports.map = map;

function asyncIter(arr, iter, cb) {
  var i = -1;

  function next() {
    i++;

    if (i < arr.length) {
      iter(arr[i], i, next, cb);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncIter = asyncIter;

function asyncFor(obj, iter, cb) {
  var keys = keys_(obj || {});
  var len = keys.length;
  var i = -1;

  function next() {
    i++;
    var k = keys[i];

    if (i < len) {
      iter(k, obj[k], i, len, next);
    } else {
      cb();
    }
  }

  next();
}

exports.asyncFor = asyncFor;

function indexOf(arr, searchElement, fromIndex) {
  return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
}

exports.indexOf = indexOf;

function keys_(obj) {
  /* eslint-disable no-restricted-syntax */
  var arr = [];

  for (var k in obj) {
    if (hasOwnProp(obj, k)) {
      arr.push(k);
    }
  }

  return arr;
}

exports.keys = keys_;

function _entries(obj) {
  return keys_(obj).map(function (k) {
    return [k, obj[k]];
  });
}

exports._entries = _entries;

function _values(obj) {
  return keys_(obj).map(function (k) {
    return obj[k];
  });
}

exports._values = _values;

function extend(obj1, obj2) {
  obj1 = obj1 || {};
  keys_(obj2).forEach(function (k) {
    obj1[k] = obj2[k];
  });
  return obj1;
}

exports._assign = exports.extend = extend;

function inOperator(key, val) {
  if (isArray(val) || isString(val)) {
    return val.indexOf(key) !== -1;
  } else if (isObject(val)) {
    return key in val;
  }

  throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
}

exports.inOperator = inOperator;

/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_10865__) {

"use strict";
 // A simple class system, more documentation to come

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var EventEmitter = __nested_webpack_require_10865__(16);

var lib = __nested_webpack_require_10865__(0);

function parentWrap(parent, prop) {
  if (typeof parent !== 'function' || typeof prop !== 'function') {
    return prop;
  }

  return function wrap() {
    // Save the current parent method
    var tmp = this.parent; // Set parent to the previous method, call, and restore

    this.parent = parent;
    var res = prop.apply(this, arguments);
    this.parent = tmp;
    return res;
  };
}

function extendClass(cls, name, props) {
  props = props || {};
  lib.keys(props).forEach(function (k) {
    props[k] = parentWrap(cls.prototype[k], props[k]);
  });

  var subclass = /*#__PURE__*/function (_cls) {
    _inheritsLoose(subclass, _cls);

    function subclass() {
      return _cls.apply(this, arguments) || this;
    }

    _createClass(subclass, [{
      key: "typename",
      get: function get() {
        return name;
      }
    }]);

    return subclass;
  }(cls);

  lib._assign(subclass.prototype, props);

  return subclass;
}

var Obj = /*#__PURE__*/function () {
  function Obj() {
    // Unfortunately necessary for backwards compatibility
    this.init.apply(this, arguments);
  }

  var _proto = Obj.prototype;

  _proto.init = function init() {};

  Obj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(Obj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return Obj;
}();

var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(EmitterObj, _EventEmitter);

  function EmitterObj() {
    var _this2;

    var _this;

    _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

    (_this2 = _this).init.apply(_this2, arguments);

    return _this;
  }

  var _proto2 = EmitterObj.prototype;

  _proto2.init = function init() {};

  EmitterObj.extend = function extend(name, props) {
    if (typeof name === 'object') {
      props = name;
      name = 'anonymous';
    }

    return extendClass(this, name, props);
  };

  _createClass(EmitterObj, [{
    key: "typename",
    get: function get() {
      return this.constructor.name;
    }
  }]);

  return EmitterObj;
}(EventEmitter);

module.exports = {
  Obj: Obj,
  EmitterObj: EmitterObj
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_14315__) {

"use strict";


var lib = __nested_webpack_require_14315__(0);

var arrayFrom = Array.from;
var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
// we know how to access variables. Block tags can introduce special
// variables, for example.

var Frame = /*#__PURE__*/function () {
  function Frame(parent, isolateWrites) {
    this.variables = Object.create(null);
    this.parent = parent;
    this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
    // this frame to its parent (though reads may).

    this.isolateWrites = isolateWrites;
  }

  var _proto = Frame.prototype;

  _proto.set = function set(name, val, resolveUp) {
    // Allow variables with dots by automatically creating the
    // nested structure
    var parts = name.split('.');
    var obj = this.variables;
    var frame = this;

    if (resolveUp) {
      if (frame = this.resolve(parts[0], true)) {
        frame.set(name, val);
        return;
      }
    }

    for (var i = 0; i < parts.length - 1; i++) {
      var id = parts[i];

      if (!obj[id]) {
        obj[id] = {};
      }

      obj = obj[id];
    }

    obj[parts[parts.length - 1]] = val;
  };

  _proto.get = function get(name) {
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return null;
  };

  _proto.lookup = function lookup(name) {
    var p = this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return val;
    }

    return p && p.lookup(name);
  };

  _proto.resolve = function resolve(name, forWrite) {
    var p = forWrite && this.isolateWrites ? undefined : this.parent;
    var val = this.variables[name];

    if (val !== undefined) {
      return this;
    }

    return p && p.resolve(name);
  };

  _proto.push = function push(isolateWrites) {
    return new Frame(this, isolateWrites);
  };

  _proto.pop = function pop() {
    return this.parent;
  };

  return Frame;
}();

function makeMacro(argNames, kwargNames, func) {
  return function macro() {
    for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      macroArgs[_key] = arguments[_key];
    }

    var argCount = numArgs(macroArgs);
    var args;
    var kwargs = getKeywordArgs(macroArgs);

    if (argCount > argNames.length) {
      args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
      // keyword arguments (essentially default values)

      macroArgs.slice(args.length, argCount).forEach(function (val, i) {
        if (i < kwargNames.length) {
          kwargs[kwargNames[i]] = val;
        }
      });
      args.push(kwargs);
    } else if (argCount < argNames.length) {
      args = macroArgs.slice(0, argCount);

      for (var i = argCount; i < argNames.length; i++) {
        var arg = argNames[i]; // Keyword arguments that should be passed as
        // positional arguments, i.e. the caller explicitly
        // used the name of a positional arg

        args.push(kwargs[arg]);
        delete kwargs[arg];
      }

      args.push(kwargs);
    } else {
      args = macroArgs;
    }

    return func.apply(this, args);
  };
}

function makeKeywordArgs(obj) {
  obj.__keywords = true;
  return obj;
}

function isKeywordArgs(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
}

function getKeywordArgs(args) {
  var len = args.length;

  if (len) {
    var lastArg = args[len - 1];

    if (isKeywordArgs(lastArg)) {
      return lastArg;
    }
  }

  return {};
}

function numArgs(args) {
  var len = args.length;

  if (len === 0) {
    return 0;
  }

  var lastArg = args[len - 1];

  if (isKeywordArgs(lastArg)) {
    return len - 1;
  } else {
    return len;
  }
} // A SafeString object indicates that the string should not be
// autoescaped. This happens magically because autoescaping only
// occurs on primitive string objects.


function SafeString(val) {
  if (typeof val !== 'string') {
    return val;
  }

  this.val = val;
  this.length = val.length;
}

SafeString.prototype = Object.create(String.prototype, {
  length: {
    writable: true,
    configurable: true,
    value: 0
  }
});

SafeString.prototype.valueOf = function valueOf() {
  return this.val;
};

SafeString.prototype.toString = function toString() {
  return this.val;
};

function copySafeness(dest, target) {
  if (dest instanceof SafeString) {
    return new SafeString(target);
  }

  return target.toString();
}

function markSafe(val) {
  var type = typeof val;

  if (type === 'string') {
    return new SafeString(val);
  } else if (type !== 'function') {
    return val;
  } else {
    return function wrapSafe(args) {
      var ret = val.apply(this, arguments);

      if (typeof ret === 'string') {
        return new SafeString(ret);
      }

      return ret;
    };
  }
}

function suppressValue(val, autoescape) {
  val = val !== undefined && val !== null ? val : '';

  if (autoescape && !(val instanceof SafeString)) {
    val = lib.escape(val.toString());
  }

  return val;
}

function ensureDefined(val, lineno, colno) {
  if (val === null || val === undefined) {
    throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
  }

  return val;
}

function memberLookup(obj, val) {
  if (obj === undefined || obj === null) {
    return undefined;
  }

  if (typeof obj[val] === 'function') {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return obj[val].apply(obj, args);
    };
  }

  return obj[val];
}

function callWrap(obj, name, context, args) {
  if (!obj) {
    throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
  } else if (typeof obj !== 'function') {
    throw new Error('Unable to call `' + name + '`, which is not a function');
  }

  return obj.apply(context, args);
}

function contextOrFrameLookup(context, frame, name) {
  var val = frame.lookup(name);
  return val !== undefined ? val : context.lookup(name);
}

function handleError(error, lineno, colno) {
  if (error.lineno) {
    return error;
  } else {
    return new lib.TemplateError(error, lineno, colno);
  }
}

function asyncEach(arr, dimen, iter, cb) {
  if (lib.isArray(arr)) {
    var len = arr.length;
    lib.asyncIter(arr, function iterCallback(item, i, next) {
      switch (dimen) {
        case 1:
          iter(item, i, len, next);
          break;

        case 2:
          iter(item[0], item[1], i, len, next);
          break;

        case 3:
          iter(item[0], item[1], item[2], i, len, next);
          break;

        default:
          item.push(i, len, next);
          iter.apply(this, item);
      }
    }, cb);
  } else {
    lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
      iter(key, val, i, len, next);
    }, cb);
  }
}

function asyncAll(arr, dimen, func, cb) {
  var finished = 0;
  var len;
  var outputArr;

  function done(i, output) {
    finished++;
    outputArr[i] = output;

    if (finished === len) {
      cb(null, outputArr.join(''));
    }
  }

  if (lib.isArray(arr)) {
    len = arr.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var i = 0; i < arr.length; i++) {
        var item = arr[i];

        switch (dimen) {
          case 1:
            func(item, i, len, done);
            break;

          case 2:
            func(item[0], item[1], i, len, done);
            break;

          case 3:
            func(item[0], item[1], item[2], i, len, done);
            break;

          default:
            item.push(i, len, done);
            func.apply(this, item);
        }
      }
    }
  } else {
    var keys = lib.keys(arr || {});
    len = keys.length;
    outputArr = new Array(len);

    if (len === 0) {
      cb(null, '');
    } else {
      for (var _i = 0; _i < keys.length; _i++) {
        var k = keys[_i];
        func(k, arr[k], _i, len, done);
      }
    }
  }
}

function fromIterator(arr) {
  if (typeof arr !== 'object' || arr === null || lib.isArray(arr)) {
    return arr;
  } else if (supportsIterators && Symbol.iterator in arr) {
    return arrayFrom(arr);
  } else {
    return arr;
  }
}

module.exports = {
  Frame: Frame,
  makeMacro: makeMacro,
  makeKeywordArgs: makeKeywordArgs,
  numArgs: numArgs,
  suppressValue: suppressValue,
  ensureDefined: ensureDefined,
  memberLookup: memberLookup,
  contextOrFrameLookup: contextOrFrameLookup,
  callWrap: callWrap,
  handleError: handleError,
  isArray: lib.isArray,
  keys: lib.keys,
  SafeString: SafeString,
  copySafeness: copySafeness,
  markSafe: markSafe,
  asyncEach: asyncEach,
  asyncAll: asyncAll,
  inOperator: lib.inOperator,
  fromIterator: fromIterator
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __nested_webpack_require_23363__) {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = __nested_webpack_require_23363__(1),
    Obj = _require.Obj;

function traverseAndCheck(obj, type, results) {
  if (obj instanceof type) {
    results.push(obj);
  }

  if (obj instanceof Node) {
    obj.findAll(type, results);
  }
}

var Node = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Node, _Obj);

  function Node() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Node.prototype;

  _proto.init = function init(lineno, colno) {
    var _arguments = arguments,
        _this = this;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.lineno = lineno;
    this.colno = colno;
    this.fields.forEach(function (field, i) {
      // The first two args are line/col numbers, so offset by 2
      var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
      // testing easier to normalize values.

      if (val === undefined) {
        val = null;
      }

      _this[field] = val;
    });
  };

  _proto.findAll = function findAll(type, results) {
    var _this2 = this;

    results = results || [];

    if (this instanceof NodeList) {
      this.children.forEach(function (child) {
        return traverseAndCheck(child, type, results);
      });
    } else {
      this.fields.forEach(function (field) {
        return traverseAndCheck(_this2[field], type, results);
      });
    }

    return results;
  };

  _proto.iterFields = function iterFields(func) {
    var _this3 = this;

    this.fields.forEach(function (field) {
      func(_this3[field], field);
    });
  };

  return Node;
}(Obj); // Abstract nodes


var Value = /*#__PURE__*/function (_Node) {
  _inheritsLoose(Value, _Node);

  function Value() {
    return _Node.apply(this, arguments) || this;
  }

  _createClass(Value, [{
    key: "typename",
    get: function get() {
      return 'Value';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['value'];
    }
  }]);

  return Value;
}(Node); // Concrete nodes


var NodeList = /*#__PURE__*/function (_Node2) {
  _inheritsLoose(NodeList, _Node2);

  function NodeList() {
    return _Node2.apply(this, arguments) || this;
  }

  var _proto2 = NodeList.prototype;

  _proto2.init = function init(lineno, colno, nodes) {
    _Node2.prototype.init.call(this, lineno, colno, nodes || []);
  };

  _proto2.addChild = function addChild(node) {
    this.children.push(node);
  };

  _createClass(NodeList, [{
    key: "typename",
    get: function get() {
      return 'NodeList';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['children'];
    }
  }]);

  return NodeList;
}(Node);

var Root = NodeList.extend('Root');
var Literal = Value.extend('Literal');
var Symbol = Value.extend('Symbol');
var Group = NodeList.extend('Group');
var ArrayNode = NodeList.extend('Array');
var Pair = Node.extend('Pair', {
  fields: ['key', 'value']
});
var Dict = NodeList.extend('Dict');
var LookupVal = Node.extend('LookupVal', {
  fields: ['target', 'val']
});
var If = Node.extend('If', {
  fields: ['cond', 'body', 'else_']
});
var IfAsync = If.extend('IfAsync');
var InlineIf = Node.extend('InlineIf', {
  fields: ['cond', 'body', 'else_']
});
var For = Node.extend('For', {
  fields: ['arr', 'name', 'body', 'else_']
});
var AsyncEach = For.extend('AsyncEach');
var AsyncAll = For.extend('AsyncAll');
var Macro = Node.extend('Macro', {
  fields: ['name', 'args', 'body']
});
var Caller = Macro.extend('Caller');
var Import = Node.extend('Import', {
  fields: ['template', 'target', 'withContext']
});

var FromImport = /*#__PURE__*/function (_Node3) {
  _inheritsLoose(FromImport, _Node3);

  function FromImport() {
    return _Node3.apply(this, arguments) || this;
  }

  var _proto3 = FromImport.prototype;

  _proto3.init = function init(lineno, colno, template, names, withContext) {
    _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
  };

  _createClass(FromImport, [{
    key: "typename",
    get: function get() {
      return 'FromImport';
    }
  }, {
    key: "fields",
    get: function get() {
      return ['template', 'names', 'withContext'];
    }
  }]);

  return FromImport;
}(Node);

var FunCall = Node.extend('FunCall', {
  fields: ['name', 'args']
});
var Filter = FunCall.extend('Filter');
var FilterAsync = Filter.extend('FilterAsync', {
  fields: ['name', 'args', 'symbol']
});
var KeywordArgs = Dict.extend('KeywordArgs');
var Block = Node.extend('Block', {
  fields: ['name', 'body']
});
var Super = Node.extend('Super', {
  fields: ['blockName', 'symbol']
});
var TemplateRef = Node.extend('TemplateRef', {
  fields: ['template']
});
var Extends = TemplateRef.extend('Extends');
var Include = Node.extend('Include', {
  fields: ['template', 'ignoreMissing']
});
var Set = Node.extend('Set', {
  fields: ['targets', 'value']
});
var Switch = Node.extend('Switch', {
  fields: ['expr', 'cases', 'default']
});
var Case = Node.extend('Case', {
  fields: ['cond', 'body']
});
var Output = NodeList.extend('Output');
var Capture = Node.extend('Capture', {
  fields: ['body']
});
var TemplateData = Literal.extend('TemplateData');
var UnaryOp = Node.extend('UnaryOp', {
  fields: ['target']
});
var BinOp = Node.extend('BinOp', {
  fields: ['left', 'right']
});
var In = BinOp.extend('In');
var Is = BinOp.extend('Is');
var Or = BinOp.extend('Or');
var And = BinOp.extend('And');
var Not = UnaryOp.extend('Not');
var Add = BinOp.extend('Add');
var Concat = BinOp.extend('Concat');
var Sub = BinOp.extend('Sub');
var Mul = BinOp.extend('Mul');
var Div = BinOp.extend('Div');
var FloorDiv = BinOp.extend('FloorDiv');
var Mod = BinOp.extend('Mod');
var Pow = BinOp.extend('Pow');
var Neg = UnaryOp.extend('Neg');
var Pos = UnaryOp.extend('Pos');
var Compare = Node.extend('Compare', {
  fields: ['expr', 'ops']
});
var CompareOperand = Node.extend('CompareOperand', {
  fields: ['expr', 'type']
});
var CallExtension = Node.extend('CallExtension', {
  init: function init(ext, prop, args, contentArgs) {
    this.parent();
    this.extName = ext.__name || ext;
    this.prop = prop;
    this.args = args || new NodeList();
    this.contentArgs = contentArgs || [];
    this.autoescape = ext.autoescape;
  },
  fields: ['extName', 'prop', 'args', 'contentArgs']
});
var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

function print(str, indent, inline) {
  var lines = str.split('\n');
  lines.forEach(function (line, i) {
    if (line && (inline && i > 0 || !inline)) {
      process.stdout.write(' '.repeat(indent));
    }

    var nl = i === lines.length - 1 ? '' : '\n';
    process.stdout.write("" + line + nl);
  });
} // Print the AST in a nicely formatted tree format for debuggin


function printNodes(node, indent) {
  indent = indent || 0;
  print(node.typename + ': ', indent);

  if (node instanceof NodeList) {
    print('\n');
    node.children.forEach(function (n) {
      printNodes(n, indent + 2);
    });
  } else if (node instanceof CallExtension) {
    print(node.extName + "." + node.prop + "\n");

    if (node.args) {
      printNodes(node.args, indent + 2);
    }

    if (node.contentArgs) {
      node.contentArgs.forEach(function (n) {
        printNodes(n, indent + 2);
      });
    }
  } else {
    var nodes = [];
    var props = null;
    node.iterFields(function (val, fieldName) {
      if (val instanceof Node) {
        nodes.push([fieldName, val]);
      } else {
        props = props || {};
        props[fieldName] = val;
      }
    });

    if (props) {
      print(JSON.stringify(props, null, 2) + '\n', null, true);
    } else {
      print('\n');
    }

    nodes.forEach(function (_ref) {
      var fieldName = _ref[0],
          n = _ref[1];
      print("[" + fieldName + "] =>", indent + 2);
      printNodes(n, indent + 4);
    });
  }
}

module.exports = {
  Node: Node,
  Root: Root,
  NodeList: NodeList,
  Value: Value,
  Literal: Literal,
  Symbol: Symbol,
  Group: Group,
  Array: ArrayNode,
  Pair: Pair,
  Dict: Dict,
  Output: Output,
  Capture: Capture,
  TemplateData: TemplateData,
  If: If,
  IfAsync: IfAsync,
  InlineIf: InlineIf,
  For: For,
  AsyncEach: AsyncEach,
  AsyncAll: AsyncAll,
  Macro: Macro,
  Caller: Caller,
  Import: Import,
  FromImport: FromImport,
  FunCall: FunCall,
  Filter: Filter,
  FilterAsync: FilterAsync,
  KeywordArgs: KeywordArgs,
  Block: Block,
  Super: Super,
  Extends: Extends,
  Include: Include,
  Set: Set,
  Switch: Switch,
  Case: Case,
  LookupVal: LookupVal,
  BinOp: BinOp,
  In: In,
  Is: Is,
  Or: Or,
  And: And,
  Not: Not,
  Add: Add,
  Concat: Concat,
  Sub: Sub,
  Mul: Mul,
  Div: Div,
  FloorDiv: FloorDiv,
  Mod: Mod,
  Pow: Pow,
  Neg: Neg,
  Pos: Pos,
  Compare: Compare,
  CompareOperand: CompareOperand,
  CallExtension: CallExtension,
  CallExtensionAsync: CallExtensionAsync,
  printNodes: printNodes
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {



/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_33427__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var parser = __nested_webpack_require_33427__(8);

var transformer = __nested_webpack_require_33427__(17);

var nodes = __nested_webpack_require_33427__(3);

var _require = __nested_webpack_require_33427__(0),
    TemplateError = _require.TemplateError;

var _require2 = __nested_webpack_require_33427__(2),
    Frame = _require2.Frame;

var _require3 = __nested_webpack_require_33427__(1),
    Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
// through


var compareOps = {
  '==': '==',
  '===': '===',
  '!=': '!=',
  '!==': '!==',
  '<': '<',
  '>': '>',
  '<=': '<=',
  '>=': '>='
};

var Compiler = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Compiler, _Obj);

  function Compiler() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Compiler.prototype;

  _proto.init = function init(templateName, throwOnUndefined) {
    this.templateName = templateName;
    this.codebuf = [];
    this.lastId = 0;
    this.buffer = null;
    this.bufferStack = [];
    this._scopeClosers = '';
    this.inBlock = false;
    this.throwOnUndefined = throwOnUndefined;
  };

  _proto.fail = function fail(msg, lineno, colno) {
    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    throw new TemplateError(msg, lineno, colno);
  };

  _proto._pushBuffer = function _pushBuffer() {
    var id = this._tmpid();

    this.bufferStack.push(this.buffer);
    this.buffer = id;

    this._emit("var " + this.buffer + " = \"\";");

    return id;
  };

  _proto._popBuffer = function _popBuffer() {
    this.buffer = this.bufferStack.pop();
  };

  _proto._emit = function _emit(code) {
    this.codebuf.push(code);
  };

  _proto._emitLine = function _emitLine(code) {
    this._emit(code + '\n');
  };

  _proto._emitLines = function _emitLines() {
    var _this = this;

    for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
      lines[_key] = arguments[_key];
    }

    lines.forEach(function (line) {
      return _this._emitLine(line);
    });
  };

  _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
    this.buffer = 'output';
    this._scopeClosers = '';

    this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

    this._emitLine("var lineno = " + node.lineno + ";");

    this._emitLine("var colno = " + node.colno + ";");

    this._emitLine("var " + this.buffer + " = \"\";");

    this._emitLine('try {');
  };

  _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
    if (!noReturn) {
      this._emitLine('cb(null, ' + this.buffer + ');');
    }

    this._closeScopeLevels();

    this._emitLine('} catch (e) {');

    this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

    this._emitLine('}');

    this._emitLine('}');

    this.buffer = null;
  };

  _proto._addScopeLevel = function _addScopeLevel() {
    this._scopeClosers += '})';
  };

  _proto._closeScopeLevels = function _closeScopeLevels() {
    this._emitLine(this._scopeClosers + ';');

    this._scopeClosers = '';
  };

  _proto._withScopedSyntax = function _withScopedSyntax(func) {
    var _scopeClosers = this._scopeClosers;
    this._scopeClosers = '';
    func.call(this);

    this._closeScopeLevels();

    this._scopeClosers = _scopeClosers;
  };

  _proto._makeCallback = function _makeCallback(res) {
    var err = this._tmpid();

    return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
  };

  _proto._tmpid = function _tmpid() {
    this.lastId++;
    return 't_' + this.lastId;
  };

  _proto._templateName = function _templateName() {
    return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
  };

  _proto._compileChildren = function _compileChildren(node, frame) {
    var _this2 = this;

    node.children.forEach(function (child) {
      _this2.compile(child, frame);
    });
  };

  _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
    var _this3 = this;

    if (startChar) {
      this._emit(startChar);
    }

    node.children.forEach(function (child, i) {
      if (i > 0) {
        _this3._emit(',');
      }

      _this3.compile(child, frame);
    });

    if (endChar) {
      this._emit(endChar);
    }
  };

  _proto._compileExpression = function _compileExpression(node, frame) {
    // TODO: I'm not really sure if this type check is worth it or
    // not.
    this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
    this.compile(node, frame);
  };

  _proto.assertType = function assertType(node) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      types[_key2 - 1] = arguments[_key2];
    }

    if (!types.some(function (t) {
      return node instanceof t;
    })) {
      this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
    var _this4 = this;

    var args = node.args;
    var contentArgs = node.contentArgs;
    var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

    if (!async) {
      this._emit(this.buffer + " += runtime.suppressValue(");
    }

    this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

    this._emit('context');

    if (args || contentArgs) {
      this._emit(',');
    }

    if (args) {
      if (!(args instanceof nodes.NodeList)) {
        this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
      }

      args.children.forEach(function (arg, i) {
        // Tag arguments are passed normally to the call. Note
        // that keyword arguments are turned into a single js
        // object as the last argument, if they exist.
        _this4._compileExpression(arg, frame);

        if (i !== args.children.length - 1 || contentArgs.length) {
          _this4._emit(',');
        }
      });
    }

    if (contentArgs.length) {
      contentArgs.forEach(function (arg, i) {
        if (i > 0) {
          _this4._emit(',');
        }

        if (arg) {
          _this4._emitLine('function(cb) {');

          _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

          var id = _this4._pushBuffer();

          _this4._withScopedSyntax(function () {
            _this4.compile(arg, frame);

            _this4._emitLine("cb(null, " + id + ");");
          });

          _this4._popBuffer();

          _this4._emitLine("return " + id + ";");

          _this4._emitLine('}');
        } else {
          _this4._emit('null');
        }
      });
    }

    if (async) {
      var res = this._tmpid();

      this._emitLine(', ' + this._makeCallback(res));

      this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

      this._addScopeLevel();
    } else {
      this._emit(')');

      this._emit(", " + autoescape + " && env.opts.autoescape);\n");
    }
  };

  _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
    this.compileCallExtension(node, frame, true);
  };

  _proto.compileNodeList = function compileNodeList(node, frame) {
    this._compileChildren(node, frame);
  };

  _proto.compileLiteral = function compileLiteral(node) {
    if (typeof node.value === 'string') {
      var val = node.value.replace(/\\/g, '\\\\');
      val = val.replace(/"/g, '\\"');
      val = val.replace(/\n/g, '\\n');
      val = val.replace(/\r/g, '\\r');
      val = val.replace(/\t/g, '\\t');
      val = val.replace(/\u2028/g, "\\u2028");

      this._emit("\"" + val + "\"");
    } else if (node.value === null) {
      this._emit('null');
    } else {
      this._emit(node.value.toString());
    }
  };

  _proto.compileSymbol = function compileSymbol(node, frame) {
    var name = node.value;
    var v = frame.lookup(name);

    if (v) {
      this._emit(v);
    } else {
      this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
    }
  };

  _proto.compileGroup = function compileGroup(node, frame) {
    this._compileAggregate(node, frame, '(', ')');
  };

  _proto.compileArray = function compileArray(node, frame) {
    this._compileAggregate(node, frame, '[', ']');
  };

  _proto.compileDict = function compileDict(node, frame) {
    this._compileAggregate(node, frame, '{', '}');
  };

  _proto.compilePair = function compilePair(node, frame) {
    var key = node.key;
    var val = node.value;

    if (key instanceof nodes.Symbol) {
      key = new nodes.Literal(key.lineno, key.colno, key.value);
    } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
      this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
    }

    this.compile(key, frame);

    this._emit(': ');

    this._compileExpression(val, frame);
  };

  _proto.compileInlineIf = function compileInlineIf(node, frame) {
    this._emit('(');

    this.compile(node.cond, frame);

    this._emit('?');

    this.compile(node.body, frame);

    this._emit(':');

    if (node.else_ !== null) {
      this.compile(node.else_, frame);
    } else {
      this._emit('""');
    }

    this._emit(')');
  };

  _proto.compileIn = function compileIn(node, frame) {
    this._emit('runtime.inOperator(');

    this.compile(node.left, frame);

    this._emit(',');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileIs = function compileIs(node, frame) {
    // first, we need to try to get the name of the test function, if it's a
    // callable (i.e., has args) and not a symbol.
    var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
    : node.right.value;

    this._emit('env.getTest("' + right + '").call(context, ');

    this.compile(node.left, frame); // compile the arguments for the callable if they exist

    if (node.right.args) {
      this._emit(',');

      this.compile(node.right.args, frame);
    }

    this._emit(') === true');
  };

  _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
    this.compile(node.left, frame);

    this._emit(str);

    this.compile(node.right, frame);
  } // ensure concatenation instead of addition
  // by adding empty string in between
  ;

  _proto.compileOr = function compileOr(node, frame) {
    return this._binOpEmitter(node, frame, ' || ');
  };

  _proto.compileAnd = function compileAnd(node, frame) {
    return this._binOpEmitter(node, frame, ' && ');
  };

  _proto.compileAdd = function compileAdd(node, frame) {
    return this._binOpEmitter(node, frame, ' + ');
  };

  _proto.compileConcat = function compileConcat(node, frame) {
    return this._binOpEmitter(node, frame, ' + "" + ');
  };

  _proto.compileSub = function compileSub(node, frame) {
    return this._binOpEmitter(node, frame, ' - ');
  };

  _proto.compileMul = function compileMul(node, frame) {
    return this._binOpEmitter(node, frame, ' * ');
  };

  _proto.compileDiv = function compileDiv(node, frame) {
    return this._binOpEmitter(node, frame, ' / ');
  };

  _proto.compileMod = function compileMod(node, frame) {
    return this._binOpEmitter(node, frame, ' % ');
  };

  _proto.compileNot = function compileNot(node, frame) {
    this._emit('!');

    this.compile(node.target, frame);
  };

  _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
    this._emit('Math.floor(');

    this.compile(node.left, frame);

    this._emit(' / ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compilePow = function compilePow(node, frame) {
    this._emit('Math.pow(');

    this.compile(node.left, frame);

    this._emit(', ');

    this.compile(node.right, frame);

    this._emit(')');
  };

  _proto.compileNeg = function compileNeg(node, frame) {
    this._emit('-');

    this.compile(node.target, frame);
  };

  _proto.compilePos = function compilePos(node, frame) {
    this._emit('+');

    this.compile(node.target, frame);
  };

  _proto.compileCompare = function compileCompare(node, frame) {
    var _this5 = this;

    this.compile(node.expr, frame);
    node.ops.forEach(function (op) {
      _this5._emit(" " + compareOps[op.type] + " ");

      _this5.compile(op.expr, frame);
    });
  };

  _proto.compileLookupVal = function compileLookupVal(node, frame) {
    this._emit('runtime.memberLookup((');

    this._compileExpression(node.target, frame);

    this._emit('),');

    this._compileExpression(node.val, frame);

    this._emit(')');
  };

  _proto._getNodeName = function _getNodeName(node) {
    switch (node.typename) {
      case 'Symbol':
        return node.value;

      case 'FunCall':
        return 'the return value of (' + this._getNodeName(node.name) + ')';

      case 'LookupVal':
        return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

      case 'Literal':
        return node.value.toString();

      default:
        return '--expression--';
    }
  };

  _proto.compileFunCall = function compileFunCall(node, frame) {
    // Keep track of line/col info at runtime by settings
    // variables within an expression. An expression in javascript
    // like (x, y, z) returns the last value, and x and y can be
    // anything
    this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

    this._emit('runtime.callWrap('); // Compile it as normal.


    this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
    // if the lookup fails.


    this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

    this._compileAggregate(node.args, frame, '[', '])');

    this._emit(')');
  };

  _proto.compileFilter = function compileFilter(node, frame) {
    var name = node.name;
    this.assertType(name, nodes.Symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emit(')');
  };

  _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
    var name = node.name;
    var symbol = node.symbol.value;
    this.assertType(name, nodes.Symbol);
    frame.set(symbol, symbol);

    this._emit('env.getFilter("' + name.value + '").call(context, ');

    this._compileAggregate(node.args, frame);

    this._emitLine(', ' + this._makeCallback(symbol));

    this._addScopeLevel();
  };

  _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
    this._emit('runtime.makeKeywordArgs(');

    this.compileDict(node, frame);

    this._emit(')');
  };

  _proto.compileSet = function compileSet(node, frame) {
    var _this6 = this;

    var ids = []; // Lookup the variable names for each identifier and create
    // new ones if necessary

    node.targets.forEach(function (target) {
      var name = target.value;
      var id = frame.lookup(name);

      if (id === null || id === undefined) {
        id = _this6._tmpid(); // Note: This relies on js allowing scope across
        // blocks, in case this is created inside an `if`

        _this6._emitLine('var ' + id + ';');
      }

      ids.push(id);
    });

    if (node.value) {
      this._emit(ids.join(' = ') + ' = ');

      this._compileExpression(node.value, frame);

      this._emitLine(';');
    } else {
      this._emit(ids.join(' = ') + ' = ');

      this.compile(node.body, frame);

      this._emitLine(';');
    }

    node.targets.forEach(function (target, i) {
      var id = ids[i];
      var name = target.value; // We are running this for every var, but it's very
      // uncommon to assign to multiple vars anyway

      _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

      _this6._emitLine('if(frame.topLevel) {');

      _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

      _this6._emitLine('}');

      if (name.charAt(0) !== '_') {
        _this6._emitLine('if(frame.topLevel) {');

        _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

        _this6._emitLine('}');
      }
    });
  };

  _proto.compileSwitch = function compileSwitch(node, frame) {
    var _this7 = this;

    this._emit('switch (');

    this.compile(node.expr, frame);

    this._emit(') {');

    node.cases.forEach(function (c, i) {
      _this7._emit('case ');

      _this7.compile(c.cond, frame);

      _this7._emit(': ');

      _this7.compile(c.body, frame); // preserve fall-throughs


      if (c.body.children.length) {
        _this7._emitLine('break;');
      }
    });

    if (node.default) {
      this._emit('default:');

      this.compile(node.default, frame);
    }

    this._emit('}');
  };

  _proto.compileIf = function compileIf(node, frame, async) {
    var _this8 = this;

    this._emit('if(');

    this._compileExpression(node.cond, frame);

    this._emitLine(') {');

    this._withScopedSyntax(function () {
      _this8.compile(node.body, frame);

      if (async) {
        _this8._emit('cb()');
      }
    });

    if (node.else_) {
      this._emitLine('}\nelse {');

      this._withScopedSyntax(function () {
        _this8.compile(node.else_, frame);

        if (async) {
          _this8._emit('cb()');
        }
      });
    } else if (async) {
      this._emitLine('}\nelse {');

      this._emit('cb()');
    }

    this._emitLine('}');
  };

  _proto.compileIfAsync = function compileIfAsync(node, frame) {
    this._emit('(function(cb) {');

    this.compileIf(node, frame, true);

    this._emit('})(' + this._makeCallback());

    this._addScopeLevel();
  };

  _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
    var _this9 = this;

    var bindings = [{
      name: 'index',
      val: i + " + 1"
    }, {
      name: 'index0',
      val: i
    }, {
      name: 'revindex',
      val: len + " - " + i
    }, {
      name: 'revindex0',
      val: len + " - " + i + " - 1"
    }, {
      name: 'first',
      val: i + " === 0"
    }, {
      name: 'last',
      val: i + " === " + len + " - 1"
    }, {
      name: 'length',
      val: len
    }];
    bindings.forEach(function (b) {
      _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
    });
  };

  _proto.compileFor = function compileFor(node, frame) {
    var _this10 = this;

    // Some of this code is ugly, but it keeps the generated code
    // as fast as possible. ForAsync also shares some of this, but
    // not much.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit("var " + arr + " = ");

    this._compileExpression(node.arr, frame);

    this._emitLine(';');

    this._emit("if(" + arr + ") {");

    this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
    // appropriately


    if (node.name instanceof nodes.Array) {
      this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
      // body of the loop is duplicated for each condition, but
      // we are optimizing for speed over size.


      this._emitLine("if(runtime.isArray(" + arr + ")) {");

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


      node.name.children.forEach(function (child, u) {
        var tid = _this10._tmpid();

        _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

        _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

        frame.set(node.name.children[u].value, tid);
      });

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('} else {'); // Iterate over the key/values of an object


      var _node$name$children = node.name.children,
          key = _node$name$children[0],
          val = _node$name$children[1];

      var k = this._tmpid();

      var v = this._tmpid();

      frame.set(key.value, k);
      frame.set(val.value, v);

      this._emitLine(i + " = -1;");

      this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

      this._emitLine("for(var " + k + " in " + arr + ") {");

      this._emitLine(i + "++;");

      this._emitLine("var " + v + " = " + arr + "[" + k + "];");

      this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

      this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');

      this._emitLine('}');
    } else {
      // Generate a typical array iteration
      var _v = this._tmpid();

      frame.set(node.name.value, _v);

      this._emitLine("var " + len + " = " + arr + ".length;");

      this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

      this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

      this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

      this._emitLoopBindings(node, arr, i, len);

      this._withScopedSyntax(function () {
        _this10.compile(node.body, frame);
      });

      this._emitLine('}');
    }

    this._emitLine('}');

    if (node.else_) {
      this._emitLine('if (!' + len + ') {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
    var _this11 = this;

    // This shares some code with the For tag, but not enough to
    // worry about. This iterates across an object asynchronously,
    // but not in parallel.
    var i = this._tmpid();

    var len = this._tmpid();

    var arr = this._tmpid();

    var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
    frame = frame.push();

    this._emitLine('frame = frame.push();');

    this._emit('var ' + arr + ' = runtime.fromIterator(');

    this._compileExpression(node.arr, frame);

    this._emitLine(');');

    if (node.name instanceof nodes.Array) {
      var arrayLen = node.name.children.length;

      this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

      node.name.children.forEach(function (name) {
        _this11._emit(name.value + ",");
      });

      this._emit(i + ',' + len + ',next) {');

      node.name.children.forEach(function (name) {
        var id = name.value;
        frame.set(id, id);

        _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
      });
    } else {
      var id = node.name.value;

      this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

      this._emitLine('frame.set("' + id + '", ' + id + ');');

      frame.set(id, id);
    }

    this._emitLoopBindings(node, arr, i, len);

    this._withScopedSyntax(function () {
      var buf;

      if (parallel) {
        buf = _this11._pushBuffer();
      }

      _this11.compile(node.body, frame);

      _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

      if (parallel) {
        _this11._popBuffer();
      }
    });

    var output = this._tmpid();

    this._emitLine('}, ' + this._makeCallback(output));

    this._addScopeLevel();

    if (parallel) {
      this._emitLine(this.buffer + ' += ' + output + ';');
    }

    if (node.else_) {
      this._emitLine('if (!' + arr + '.length) {');

      this.compile(node.else_, frame);

      this._emitLine('}');
    }

    this._emitLine('frame = frame.pop();');
  };

  _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
    this._compileAsyncLoop(node, frame);
  };

  _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
    this._compileAsyncLoop(node, frame, true);
  };

  _proto._compileMacro = function _compileMacro(node, frame) {
    var _this12 = this;

    var args = [];
    var kwargs = null;

    var funcId = 'macro_' + this._tmpid();

    var keepFrame = frame !== undefined; // Type check the definition of the args

    node.args.children.forEach(function (arg, i) {
      if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
        kwargs = arg;
      } else {
        _this12.assertType(arg, nodes.Symbol);

        args.push(arg);
      }
    });
    var realNames = [].concat(args.map(function (n) {
      return "l_" + n.value;
    }), ['kwargs']); // Quoted argument names

    var argNames = args.map(function (n) {
      return "\"" + n.value + "\"";
    });
    var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
      return "\"" + n.key.value + "\"";
    }); // We pass a function to makeMacro which destructures the
    // arguments so support setting positional args with keywords
    // args and passing keyword args as positional args
    // (essentially default values). See runtime.js.

    var currFrame;

    if (keepFrame) {
      currFrame = frame.push(true);
    } else {
      currFrame = new Frame();
    }

    this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
    // random names because the function
    // will create a new run-time scope for us


    args.forEach(function (arg) {
      _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

      currFrame.set(arg.value, "l_" + arg.value);
    }); // Expose the keyword arguments

    if (kwargs) {
      kwargs.children.forEach(function (pair) {
        var name = pair.key.value;

        _this12._emit("frame.set(\"" + name + "\", ");

        _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

        _this12._emit(" ? kwargs[\"" + name + "\"] : ");

        _this12._compileExpression(pair.value, currFrame);

        _this12._emit(');');
      });
    }

    var bufferId = this._pushBuffer();

    this._withScopedSyntax(function () {
      _this12.compile(node.body, currFrame);
    });

    this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

    this._emitLine("return new runtime.SafeString(" + bufferId + ");");

    this._emitLine('});');

    this._popBuffer();

    return funcId;
  };

  _proto.compileMacro = function compileMacro(node, frame) {
    var funcId = this._compileMacro(node); // Expose the macro to the templates


    var name = node.name.value;
    frame.set(name, funcId);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
    } else {
      if (node.name.value.charAt(0) !== '_') {
        this._emitLine("context.addExport(\"" + name + "\");");
      }

      this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
    }
  };

  _proto.compileCaller = function compileCaller(node, frame) {
    // basically an anonymous "macro expression"
    this._emit('(function (){');

    var funcId = this._compileMacro(node, frame);

    this._emit("return " + funcId + ";})()");
  };

  _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
    var parentTemplateId = this._tmpid();

    var parentName = this._templateName();

    var cb = this._makeCallback(parentTemplateId);

    var eagerCompileArg = eagerCompile ? 'true' : 'false';
    var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

    this._emit('env.getTemplate(');

    this._compileExpression(node.template, frame);

    this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

    return parentTemplateId;
  };

  _proto.compileImport = function compileImport(node, frame) {
    var target = node.target.value;

    var id = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

    this._addScopeLevel();

    frame.set(target, id);

    if (frame.parent) {
      this._emitLine("frame.set(\"" + target + "\", " + id + ");");
    } else {
      this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
    }
  };

  _proto.compileFromImport = function compileFromImport(node, frame) {
    var _this13 = this;

    var importedId = this._compileGetTemplate(node, frame, false, false);

    this._addScopeLevel();

    this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

    this._addScopeLevel();

    node.names.children.forEach(function (nameNode) {
      var name;
      var alias;

      var id = _this13._tmpid();

      if (nameNode instanceof nodes.Pair) {
        name = nameNode.key.value;
        alias = nameNode.value.value;
      } else {
        name = nameNode.value;
        alias = name;
      }

      _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

      _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

      _this13._emitLine('} else {');

      _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

      _this13._emitLine('}');

      frame.set(alias, id);

      if (frame.parent) {
        _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
      } else {
        _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
      }
    });
  };

  _proto.compileBlock = function compileBlock(node) {
    var id = this._tmpid(); // If we are executing outside a block (creating a top-level
    // block), we really don't want to execute its code because it
    // will execute twice: once when the child template runs and
    // again when the parent template runs. Note that blocks
    // within blocks will *always* execute immediately *and*
    // wherever else they are invoked (like used in a parent
    // template). This may have behavioral differences from jinja
    // because blocks can have side effects, but it seems like a
    // waste of performance to always execute huge top-level
    // blocks twice


    if (!this.inBlock) {
      this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
    }

    this._emit("context.getBlock(\"" + node.name.value + "\")");

    if (!this.inBlock) {
      this._emit(')');
    }

    this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

    this._emitLine(this.buffer + " += " + id + ";");

    this._addScopeLevel();
  };

  _proto.compileSuper = function compileSuper(node, frame) {
    var name = node.blockName.value;
    var id = node.symbol.value;

    var cb = this._makeCallback(id);

    this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

    this._emitLine(id + " = runtime.markSafe(" + id + ");");

    this._addScopeLevel();

    frame.set(id, id);
  };

  _proto.compileExtends = function compileExtends(node, frame) {
    var k = this._tmpid();

    var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
    // `if`, so if this happens we need to capture the parent
    // template in the top-level scope


    this._emitLine("parentTemplate = " + parentTemplateId);

    this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

    this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

    this._emitLine('}');

    this._addScopeLevel();
  };

  _proto.compileInclude = function compileInclude(node, frame) {
    this._emitLine('var tasks = [];');

    this._emitLine('tasks.push(');

    this._emitLine('function(callback) {');

    var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

    this._emitLine("callback(null," + id + ");});");

    this._emitLine('});');

    var id2 = this._tmpid();

    this._emitLine('tasks.push(');

    this._emitLine('function(template, callback){');

    this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

    this._emitLine('callback(null,' + id2 + ');});');

    this._emitLine('});');

    this._emitLine('tasks.push(');

    this._emitLine('function(result, callback){');

    this._emitLine(this.buffer + " += result;");

    this._emitLine('callback(null);');

    this._emitLine('});');

    this._emitLine('env.waterfall(tasks, function(){');

    this._addScopeLevel();
  };

  _proto.compileTemplateData = function compileTemplateData(node, frame) {
    this.compileLiteral(node, frame);
  };

  _proto.compileCapture = function compileCapture(node, frame) {
    var _this14 = this;

    // we need to temporarily override the current buffer id as 'output'
    // so the set block writes to the capture output instead of the buffer
    var buffer = this.buffer;
    this.buffer = 'output';

    this._emitLine('(function() {');

    this._emitLine('var output = "";');

    this._withScopedSyntax(function () {
      _this14.compile(node.body, frame);
    });

    this._emitLine('return output;');

    this._emitLine('})()'); // and of course, revert back to the old buffer id


    this.buffer = buffer;
  };

  _proto.compileOutput = function compileOutput(node, frame) {
    var _this15 = this;

    var children = node.children;
    children.forEach(function (child) {
      // TemplateData is a special case because it is never
      // autoescaped, so simply output it for optimization
      if (child instanceof nodes.TemplateData) {
        if (child.value) {
          _this15._emit(_this15.buffer + " += ");

          _this15.compileLiteral(child, frame);

          _this15._emitLine(';');
        }
      } else {
        _this15._emit(_this15.buffer + " += runtime.suppressValue(");

        if (_this15.throwOnUndefined) {
          _this15._emit('runtime.ensureDefined(');
        }

        _this15.compile(child, frame);

        if (_this15.throwOnUndefined) {
          _this15._emit("," + node.lineno + "," + node.colno + ")");
        }

        _this15._emit(', env.opts.autoescape);\n');
      }
    });
  };

  _proto.compileRoot = function compileRoot(node, frame) {
    var _this16 = this;

    if (frame) {
      this.fail('compileRoot: root node can\'t have frame');
    }

    frame = new Frame();

    this._emitFuncBegin(node, 'root');

    this._emitLine('var parentTemplate = null;');

    this._compileChildren(node, frame);

    this._emitLine('if(parentTemplate) {');

    this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

    this._emitLine('} else {');

    this._emitLine("cb(null, " + this.buffer + ");");

    this._emitLine('}');

    this._emitFuncEnd(true);

    this.inBlock = true;
    var blockNames = [];
    var blocks = node.findAll(nodes.Block);
    blocks.forEach(function (block, i) {
      var name = block.name.value;

      if (blockNames.indexOf(name) !== -1) {
        throw new Error("Block \"" + name + "\" defined more than once.");
      }

      blockNames.push(name);

      _this16._emitFuncBegin(block, "b_" + name);

      var tmpFrame = new Frame();

      _this16._emitLine('var frame = frame.push(true);');

      _this16.compile(block.body, tmpFrame);

      _this16._emitFuncEnd();
    });

    this._emitLine('return {');

    blocks.forEach(function (block, i) {
      var blockName = "b_" + block.name.value;

      _this16._emitLine(blockName + ": " + blockName + ",");
    });

    this._emitLine('root: root\n};');
  };

  _proto.compile = function compile(node, frame) {
    var _compile = this['compile' + node.typename];

    if (_compile) {
      _compile.call(this, node, frame);
    } else {
      this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
    }
  };

  _proto.getCode = function getCode() {
    return this.codebuf.join('');
  };

  return Compiler;
}(Obj);

module.exports = {
  compile: function compile(src, asyncFilters, extensions, name, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

    var preprocessors = (extensions || []).map(function (ext) {
      return ext.preprocess;
    }).filter(function (f) {
      return !!f;
    });
    var processedSrc = preprocessors.reduce(function (s, processor) {
      return processor(s);
    }, src);
    c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
    return c.getCode();
  },
  Compiler: Compiler
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_71591__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var path = __nested_webpack_require_71591__(4);

var _require = __nested_webpack_require_71591__(1),
    EmitterObj = _require.EmitterObj;

module.exports = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Loader, _EmitterObj);

  function Loader() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Loader.prototype;

  _proto.resolve = function resolve(from, to) {
    return path.resolve(path.dirname(from), to);
  };

  _proto.isRelative = function isRelative(filename) {
    return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
  };

  return Loader;
}(EmitterObj);

/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_72640__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var asap = __nested_webpack_require_72640__(12);

var _waterfall = __nested_webpack_require_72640__(15);

var lib = __nested_webpack_require_72640__(0);

var compiler = __nested_webpack_require_72640__(5);

var filters = __nested_webpack_require_72640__(18);

var _require = __nested_webpack_require_72640__(10),
    FileSystemLoader = _require.FileSystemLoader,
    WebLoader = _require.WebLoader,
    PrecompiledLoader = _require.PrecompiledLoader;

var tests = __nested_webpack_require_72640__(20);

var globals = __nested_webpack_require_72640__(21);

var _require2 = __nested_webpack_require_72640__(1),
    Obj = _require2.Obj,
    EmitterObj = _require2.EmitterObj;

var globalRuntime = __nested_webpack_require_72640__(2);

var handleError = globalRuntime.handleError,
    Frame = globalRuntime.Frame;

var expressApp = __nested_webpack_require_72640__(22); // If the user is using the async API, *always* call it
// asynchronously even if the template was synchronous.


function callbackAsap(cb, err, res) {
  asap(function () {
    cb(err, res);
  });
}
/**
 * A no-op template, for use with {% include ignore missing %}
 */


var noopTmplSrc = {
  type: 'code',
  obj: {
    root: function root(env, context, frame, runtime, cb) {
      try {
        cb(null, '');
      } catch (e) {
        cb(handleError(e, null, null));
      }
    }
  }
};

var Environment = /*#__PURE__*/function (_EmitterObj) {
  _inheritsLoose(Environment, _EmitterObj);

  function Environment() {
    return _EmitterObj.apply(this, arguments) || this;
  }

  var _proto = Environment.prototype;

  _proto.init = function init(loaders, opts) {
    var _this = this;

    // The dev flag determines the trace that'll be shown on errors.
    // If set to true, returns the full trace from the error point,
    // otherwise will return trace starting from Template.render
    // (the full trace from within nunjucks may confuse developers using
    //  the library)
    // defaults to false
    opts = this.opts = opts || {};
    this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
    // every string variable will be escaped by default.
    // If false, strings can be manually escaped using the `escape` filter.
    // defaults to true

    this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
    // to output a null or undefined value

    this.opts.throwOnUndefined = !!opts.throwOnUndefined;
    this.opts.trimBlocks = !!opts.trimBlocks;
    this.opts.lstripBlocks = !!opts.lstripBlocks;
    this.loaders = [];

    if (!loaders) {
      // The filesystem loader is only available server-side
      if (FileSystemLoader) {
        this.loaders = [new FileSystemLoader('views')];
      } else if (WebLoader) {
        this.loaders = [new WebLoader('/views')];
      }
    } else {
      this.loaders = lib.isArray(loaders) ? loaders : [loaders];
    } // It's easy to use precompiled templates: just include them
    // before you configure nunjucks and this will automatically
    // pick it up and use it


    if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
      this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
    }

    this._initLoaders();

    this.globals = globals();
    this.filters = {};
    this.tests = {};
    this.asyncFilters = [];
    this.extensions = {};
    this.extensionsList = [];

    lib._entries(filters).forEach(function (_ref) {
      var name = _ref[0],
          filter = _ref[1];
      return _this.addFilter(name, filter);
    });

    lib._entries(tests).forEach(function (_ref2) {
      var name = _ref2[0],
          test = _ref2[1];
      return _this.addTest(name, test);
    });
  };

  _proto._initLoaders = function _initLoaders() {
    var _this2 = this;

    this.loaders.forEach(function (loader) {
      // Caching and cache busting
      loader.cache = {};

      if (typeof loader.on === 'function') {
        loader.on('update', function (name, fullname) {
          loader.cache[name] = null;

          _this2.emit('update', name, fullname, loader);
        });
        loader.on('load', function (name, source) {
          _this2.emit('load', name, source, loader);
        });
      }
    });
  };

  _proto.invalidateCache = function invalidateCache() {
    this.loaders.forEach(function (loader) {
      loader.cache = {};
    });
  };

  _proto.addExtension = function addExtension(name, extension) {
    extension.__name = name;
    this.extensions[name] = extension;
    this.extensionsList.push(extension);
    return this;
  };

  _proto.removeExtension = function removeExtension(name) {
    var extension = this.getExtension(name);

    if (!extension) {
      return;
    }

    this.extensionsList = lib.without(this.extensionsList, extension);
    delete this.extensions[name];
  };

  _proto.getExtension = function getExtension(name) {
    return this.extensions[name];
  };

  _proto.hasExtension = function hasExtension(name) {
    return !!this.extensions[name];
  };

  _proto.addGlobal = function addGlobal(name, value) {
    this.globals[name] = value;
    return this;
  };

  _proto.getGlobal = function getGlobal(name) {
    if (typeof this.globals[name] === 'undefined') {
      throw new Error('global not found: ' + name);
    }

    return this.globals[name];
  };

  _proto.addFilter = function addFilter(name, func, async) {
    var wrapped = func;

    if (async) {
      this.asyncFilters.push(name);
    }

    this.filters[name] = wrapped;
    return this;
  };

  _proto.getFilter = function getFilter(name) {
    if (!this.filters[name]) {
      throw new Error('filter not found: ' + name);
    }

    return this.filters[name];
  };

  _proto.addTest = function addTest(name, func) {
    this.tests[name] = func;
    return this;
  };

  _proto.getTest = function getTest(name) {
    if (!this.tests[name]) {
      throw new Error('test not found: ' + name);
    }

    return this.tests[name];
  };

  _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
    var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
    return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
  };

  _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
    var _this3 = this;

    var that = this;
    var tmpl = null;

    if (name && name.raw) {
      // this fixes autoescape for templates referenced in symbols
      name = name.raw;
    }

    if (lib.isFunction(parentName)) {
      cb = parentName;
      parentName = null;
      eagerCompile = eagerCompile || false;
    }

    if (lib.isFunction(eagerCompile)) {
      cb = eagerCompile;
      eagerCompile = false;
    }

    if (name instanceof Template) {
      tmpl = name;
    } else if (typeof name !== 'string') {
      throw new Error('template names must be a string: ' + name);
    } else {
      for (var i = 0; i < this.loaders.length; i++) {
        var loader = this.loaders[i];
        tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

        if (tmpl) {
          break;
        }
      }
    }

    if (tmpl) {
      if (eagerCompile) {
        tmpl.compile();
      }

      if (cb) {
        cb(null, tmpl);
        return undefined;
      } else {
        return tmpl;
      }
    }

    var syncResult;

    var createTemplate = function createTemplate(err, info) {
      if (!info && !err && !ignoreMissing) {
        err = new Error('template not found: ' + name);
      }

      if (err) {
        if (cb) {
          cb(err);
          return;
        } else {
          throw err;
        }
      }

      var newTmpl;

      if (!info) {
        newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
      } else {
        newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

        if (!info.noCache) {
          info.loader.cache[name] = newTmpl;
        }
      }

      if (cb) {
        cb(null, newTmpl);
      } else {
        syncResult = newTmpl;
      }
    };

    lib.asyncIter(this.loaders, function (loader, i, next, done) {
      function handle(err, src) {
        if (err) {
          done(err);
        } else if (src) {
          src.loader = loader;
          done(null, src);
        } else {
          next();
        }
      } // Resolve name relative to parentName


      name = that.resolveTemplate(loader, parentName, name);

      if (loader.async) {
        loader.getSource(name, handle);
      } else {
        handle(null, loader.getSource(name));
      }
    }, createTemplate);
    return syncResult;
  };

  _proto.express = function express(app) {
    return expressApp(this, app);
  };

  _proto.render = function render(name, ctx, cb) {
    if (lib.isFunction(ctx)) {
      cb = ctx;
      ctx = null;
    } // We support a synchronous API to make it easier to migrate
    // existing code to async. This works because if you don't do
    // anything async work, the whole thing is actually run
    // synchronously.


    var syncResult = null;
    this.getTemplate(name, function (err, tmpl) {
      if (err && cb) {
        callbackAsap(cb, err);
      } else if (err) {
        throw err;
      } else {
        syncResult = tmpl.render(ctx, cb);
      }
    });
    return syncResult;
  };

  _proto.renderString = function renderString(src, ctx, opts, cb) {
    if (lib.isFunction(opts)) {
      cb = opts;
      opts = {};
    }

    opts = opts || {};
    var tmpl = new Template(src, this, opts.path);
    return tmpl.render(ctx, cb);
  };

  _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
    return _waterfall(tasks, callback, forceAsync);
  };

  return Environment;
}(EmitterObj);

var Context = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Context, _Obj);

  function Context() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto2 = Context.prototype;

  _proto2.init = function init(ctx, blocks, env) {
    var _this4 = this;

    // Has to be tied to an environment so we can tap into its globals.
    this.env = env || new Environment(); // Make a duplicate of ctx

    this.ctx = lib.extend({}, ctx);
    this.blocks = {};
    this.exported = [];
    lib.keys(blocks).forEach(function (name) {
      _this4.addBlock(name, blocks[name]);
    });
  };

  _proto2.lookup = function lookup(name) {
    // This is one of the most called functions, so optimize for
    // the typical case where the name isn't in the globals
    if (name in this.env.globals && !(name in this.ctx)) {
      return this.env.globals[name];
    } else {
      return this.ctx[name];
    }
  };

  _proto2.setVariable = function setVariable(name, val) {
    this.ctx[name] = val;
  };

  _proto2.getVariables = function getVariables() {
    return this.ctx;
  };

  _proto2.addBlock = function addBlock(name, block) {
    this.blocks[name] = this.blocks[name] || [];
    this.blocks[name].push(block);
    return this;
  };

  _proto2.getBlock = function getBlock(name) {
    if (!this.blocks[name]) {
      throw new Error('unknown block "' + name + '"');
    }

    return this.blocks[name][0];
  };

  _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
    var idx = lib.indexOf(this.blocks[name] || [], block);
    var blk = this.blocks[name][idx + 1];
    var context = this;

    if (idx === -1 || !blk) {
      throw new Error('no super block available for "' + name + '"');
    }

    blk(env, context, frame, runtime, cb);
  };

  _proto2.addExport = function addExport(name) {
    this.exported.push(name);
  };

  _proto2.getExported = function getExported() {
    var _this5 = this;

    var exported = {};
    this.exported.forEach(function (name) {
      exported[name] = _this5.ctx[name];
    });
    return exported;
  };

  return Context;
}(Obj);

var Template = /*#__PURE__*/function (_Obj2) {
  _inheritsLoose(Template, _Obj2);

  function Template() {
    return _Obj2.apply(this, arguments) || this;
  }

  var _proto3 = Template.prototype;

  _proto3.init = function init(src, env, path, eagerCompile) {
    this.env = env || new Environment();

    if (lib.isObject(src)) {
      switch (src.type) {
        case 'code':
          this.tmplProps = src.obj;
          break;

        case 'string':
          this.tmplStr = src.obj;
          break;

        default:
          throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
      }
    } else if (lib.isString(src)) {
      this.tmplStr = src;
    } else {
      throw new Error('src must be a string or an object describing the source');
    }

    this.path = path;

    if (eagerCompile) {
      try {
        this._compile();
      } catch (err) {
        throw lib._prettifyError(this.path, this.env.opts.dev, err);
      }
    } else {
      this.compiled = false;
    }
  };

  _proto3.render = function render(ctx, parentFrame, cb) {
    var _this6 = this;

    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    } else if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // If there is a parent frame, we are being called from internal
    // code of another template, and the internal system
    // depends on the sync/async nature of the parent template
    // to be inherited, so force an async callback


    var forceAsync = !parentFrame; // Catch compile errors for async rendering

    try {
      this.compile();
    } catch (e) {
      var err = lib._prettifyError(this.path, this.env.opts.dev, e);

      if (cb) {
        return callbackAsap(cb, err);
      } else {
        throw err;
      }
    }

    var context = new Context(ctx || {}, this.blocks, this.env);
    var frame = parentFrame ? parentFrame.push(true) : new Frame();
    frame.topLevel = true;
    var syncResult = null;
    var didError = false;
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
      // TODO: this is actually a bug in the compiled template (because waterfall
      // tasks are both not passing errors up the chain of callbacks AND are not
      // causing a return from the top-most render function). But fixing that
      // will require a more substantial change to the compiler.
      if (didError && cb && typeof res !== 'undefined') {
        // prevent multiple calls to cb
        return;
      }

      if (err) {
        err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
        didError = true;
      }

      if (cb) {
        if (forceAsync) {
          callbackAsap(cb, err, res);
        } else {
          cb(err, res);
        }
      } else {
        if (err) {
          throw err;
        }

        syncResult = res;
      }
    });
    return syncResult;
  };

  _proto3.getExported = function getExported(ctx, parentFrame, cb) {
    // eslint-disable-line consistent-return
    if (typeof ctx === 'function') {
      cb = ctx;
      ctx = {};
    }

    if (typeof parentFrame === 'function') {
      cb = parentFrame;
      parentFrame = null;
    } // Catch compile errors for async rendering


    try {
      this.compile();
    } catch (e) {
      if (cb) {
        return cb(e);
      } else {
        throw e;
      }
    }

    var frame = parentFrame ? parentFrame.push() : new Frame();
    frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

    var context = new Context(ctx || {}, this.blocks, this.env);
    this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
      if (err) {
        cb(err, null);
      } else {
        cb(null, context.getExported());
      }
    });
  };

  _proto3.compile = function compile() {
    if (!this.compiled) {
      this._compile();
    }
  };

  _proto3._compile = function _compile() {
    var props;

    if (this.tmplProps) {
      props = this.tmplProps;
    } else {
      var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
      var func = new Function(source); // eslint-disable-line no-new-func

      props = func();
    }

    this.blocks = this._getBlocks(props);
    this.rootRenderFunc = props.root;
    this.compiled = true;
  };

  _proto3._getBlocks = function _getBlocks(props) {
    var blocks = {};
    lib.keys(props).forEach(function (k) {
      if (k.slice(0, 2) === 'b_') {
        blocks[k.slice(2)] = props[k];
      }
    });
    return blocks;
  };

  return Template;
}(Obj);

module.exports = {
  Environment: Environment,
  Template: Template
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_89670__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var lexer = __nested_webpack_require_89670__(9);

var nodes = __nested_webpack_require_89670__(3);

var Obj = __nested_webpack_require_89670__(1).Obj;

var lib = __nested_webpack_require_89670__(0);

var Parser = /*#__PURE__*/function (_Obj) {
  _inheritsLoose(Parser, _Obj);

  function Parser() {
    return _Obj.apply(this, arguments) || this;
  }

  var _proto = Parser.prototype;

  _proto.init = function init(tokens) {
    this.tokens = tokens;
    this.peeked = null;
    this.breakOnBlocks = null;
    this.dropLeadingWhitespace = false;
    this.extensions = [];
  };

  _proto.nextToken = function nextToken(withWhitespace) {
    var tok;

    if (this.peeked) {
      if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
        this.peeked = null;
      } else {
        tok = this.peeked;
        this.peeked = null;
        return tok;
      }
    }

    tok = this.tokens.nextToken();

    if (!withWhitespace) {
      while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
        tok = this.tokens.nextToken();
      }
    }

    return tok;
  };

  _proto.peekToken = function peekToken() {
    this.peeked = this.peeked || this.nextToken();
    return this.peeked;
  };

  _proto.pushToken = function pushToken(tok) {
    if (this.peeked) {
      throw new Error('pushToken: can only push one token on between reads');
    }

    this.peeked = tok;
  };

  _proto.error = function error(msg, lineno, colno) {
    if (lineno === undefined || colno === undefined) {
      var tok = this.peekToken() || {};
      lineno = tok.lineno;
      colno = tok.colno;
    }

    if (lineno !== undefined) {
      lineno += 1;
    }

    if (colno !== undefined) {
      colno += 1;
    }

    return new lib.TemplateError(msg, lineno, colno);
  };

  _proto.fail = function fail(msg, lineno, colno) {
    throw this.error(msg, lineno, colno);
  };

  _proto.skip = function skip(type) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.expect = function expect(type) {
    var tok = this.nextToken();

    if (tok.type !== type) {
      this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
    }

    return tok;
  };

  _proto.skipValue = function skipValue(type, val) {
    var tok = this.nextToken();

    if (!tok || tok.type !== type || tok.value !== val) {
      this.pushToken(tok);
      return false;
    }

    return true;
  };

  _proto.skipSymbol = function skipSymbol(val) {
    return this.skipValue(lexer.TOKEN_SYMBOL, val);
  };

  _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
    var tok;

    if (!name) {
      tok = this.peekToken();

      if (!tok) {
        this.fail('unexpected end of file');
      }

      if (tok.type !== lexer.TOKEN_SYMBOL) {
        this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
      }

      name = this.nextToken().value;
    }

    tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
      if (tok.value.charAt(0) === '-') {
        this.dropLeadingWhitespace = true;
      }
    } else {
      this.fail('expected block end in ' + name + ' statement');
    }

    return tok;
  };

  _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
    var tok = this.nextToken();

    if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
      this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
    } else {
      this.pushToken(tok);
      this.fail('expected variable end');
    }
  };

  _proto.parseFor = function parseFor() {
    var forTok = this.peekToken();
    var node;
    var endBlock;

    if (this.skipSymbol('for')) {
      node = new nodes.For(forTok.lineno, forTok.colno);
      endBlock = 'endfor';
    } else if (this.skipSymbol('asyncEach')) {
      node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
      endBlock = 'endeach';
    } else if (this.skipSymbol('asyncAll')) {
      node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
      endBlock = 'endall';
    } else {
      this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
    }

    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseFor: variable name expected for loop');
    }

    var type = this.peekToken().type;

    if (type === lexer.TOKEN_COMMA) {
      // key/value iteration
      var key = node.name;
      node.name = new nodes.Array(key.lineno, key.colno);
      node.name.addChild(key);

      while (this.skip(lexer.TOKEN_COMMA)) {
        var prim = this.parsePrimary();
        node.name.addChild(prim);
      }
    }

    if (!this.skipSymbol('in')) {
      this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
    }

    node.arr = this.parseExpression();
    this.advanceAfterBlockEnd(forTok.value);
    node.body = this.parseUntilBlocks(endBlock, 'else');

    if (this.skipSymbol('else')) {
      this.advanceAfterBlockEnd('else');
      node.else_ = this.parseUntilBlocks(endBlock);
    }

    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseMacro = function parseMacro() {
    var macroTok = this.peekToken();

    if (!this.skipSymbol('macro')) {
      this.fail('expected macro');
    }

    var name = this.parsePrimary(true);
    var args = this.parseSignature();
    var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
    this.advanceAfterBlockEnd(macroTok.value);
    node.body = this.parseUntilBlocks('endmacro');
    this.advanceAfterBlockEnd();
    return node;
  };

  _proto.parseCall = function parseCall() {
    // a call block is parsed as a normal FunCall, but with an added
    // 'caller' kwarg which is a Caller node.
    var callTok = this.peekToken();

    if (!this.skipSymbol('call')) {
      this.fail('expected call');
    }

    var callerArgs = this.parseSignature(true) || new nodes.NodeList();
    var macroCall = this.parsePrimary();
    this.advanceAfterBlockEnd(callTok.value);
    var body = this.parseUntilBlocks('endcall');
    this.advanceAfterBlockEnd();
    var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
    var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

    var args = macroCall.args.children;

    if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
      args.push(new nodes.KeywordArgs());
    }

    var kwargs = args[args.length - 1];
    kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
    return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
  };

  _proto.parseWithContext = function parseWithContext() {
    var tok = this.peekToken();
    var withContext = null;

    if (this.skipSymbol('with')) {
      withContext = true;
    } else if (this.skipSymbol('without')) {
      withContext = false;
    }

    if (withContext !== null) {
      if (!this.skipSymbol('context')) {
        this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
      }
    }

    return withContext;
  };

  _proto.parseImport = function parseImport() {
    var importTok = this.peekToken();

    if (!this.skipSymbol('import')) {
      this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('as')) {
      this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
    }

    var target = this.parseExpression();
    var withContext = this.parseWithContext();
    var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
    this.advanceAfterBlockEnd(importTok.value);
    return node;
  };

  _proto.parseFrom = function parseFrom() {
    var fromTok = this.peekToken();

    if (!this.skipSymbol('from')) {
      this.fail('parseFrom: expected from');
    }

    var template = this.parseExpression();

    if (!this.skipSymbol('import')) {
      this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
    }

    var names = new nodes.NodeList();
    var withContext;

    while (1) {
      // eslint-disable-line no-constant-condition
      var nextTok = this.peekToken();

      if (nextTok.type === lexer.TOKEN_BLOCK_END) {
        if (!names.children.length) {
          this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
        } // Since we are manually advancing past the block end,
        // need to keep track of whitespace control (normally
        // this is done in `advanceAfterBlockEnd`


        if (nextTok.value.charAt(0) === '-') {
          this.dropLeadingWhitespace = true;
        }

        this.nextToken();
        break;
      }

      if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
      }

      var name = this.parsePrimary();

      if (name.value.charAt(0) === '_') {
        this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
      }

      if (this.skipSymbol('as')) {
        var alias = this.parsePrimary();
        names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
      } else {
        names.addChild(name);
      }

      withContext = this.parseWithContext();
    }

    return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
  };

  _proto.parseBlock = function parseBlock() {
    var tag = this.peekToken();

    if (!this.skipSymbol('block')) {
      this.fail('parseBlock: expected block', tag.lineno, tag.colno);
    }

    var node = new nodes.Block(tag.lineno, tag.colno);
    node.name = this.parsePrimary();

    if (!(node.name instanceof nodes.Symbol)) {
      this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
    }

    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('endblock');
    this.skipSymbol('endblock');
    this.skipSymbol(node.name.value);
    var tok = this.peekToken();

    if (!tok) {
      this.fail('parseBlock: expected endblock, got end of file');
    }

    this.advanceAfterBlockEnd(tok.value);
    return node;
  };

  _proto.parseExtends = function parseExtends() {
    var tagName = 'extends';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseTemplateRef: expected ' + tagName);
    }

    var node = new nodes.Extends(tag.lineno, tag.colno);
    node.template = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseInclude = function parseInclude() {
    var tagName = 'include';
    var tag = this.peekToken();

    if (!this.skipSymbol(tagName)) {
      this.fail('parseInclude: expected ' + tagName);
    }

    var node = new nodes.Include(tag.lineno, tag.colno);
    node.template = this.parseExpression();

    if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
      node.ignoreMissing = true;
    }

    this.advanceAfterBlockEnd(tag.value);
    return node;
  };

  _proto.parseIf = function parseIf() {
    var tag = this.peekToken();
    var node;

    if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
      node = new nodes.If(tag.lineno, tag.colno);
    } else if (this.skipSymbol('ifAsync')) {
      node = new nodes.IfAsync(tag.lineno, tag.colno);
    } else {
      this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
    }

    node.cond = this.parseExpression();
    this.advanceAfterBlockEnd(tag.value);
    node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
    var tok = this.peekToken();

    switch (tok && tok.value) {
      case 'elseif':
      case 'elif':
        node.else_ = this.parseIf();
        break;

      case 'else':
        this.advanceAfterBlockEnd();
        node.else_ = this.parseUntilBlocks('endif');
        this.advanceAfterBlockEnd();
        break;

      case 'endif':
        node.else_ = null;
        this.advanceAfterBlockEnd();
        break;

      default:
        this.fail('parseIf: expected elif, else, or endif, got end of file');
    }

    return node;
  };

  _proto.parseSet = function parseSet() {
    var tag = this.peekToken();

    if (!this.skipSymbol('set')) {
      this.fail('parseSet: expected set', tag.lineno, tag.colno);
    }

    var node = new nodes.Set(tag.lineno, tag.colno, []);
    var target;

    while (target = this.parsePrimary()) {
      node.targets.push(target);

      if (!this.skip(lexer.TOKEN_COMMA)) {
        break;
      }
    }

    if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
      if (!this.skip(lexer.TOKEN_BLOCK_END)) {
        this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
      } else {
        node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
        node.value = null;
        this.advanceAfterBlockEnd();
      }
    } else {
      node.value = this.parseExpression();
      this.advanceAfterBlockEnd(tag.value);
    }

    return node;
  };

  _proto.parseSwitch = function parseSwitch() {
    /*
     * Store the tag names in variables in case someone ever wants to
     * customize this.
     */
    var switchStart = 'switch';
    var switchEnd = 'endswitch';
    var caseStart = 'case';
    var caseDefault = 'default'; // Get the switch tag.

    var tag = this.peekToken(); // fail early if we get some unexpected tag.

    if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
      this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
    } // parse the switch expression


    var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

    this.advanceAfterBlockEnd(switchStart);
    this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

    var tok = this.peekToken(); // create new variables for our cases and default case.

    var cases = [];
    var defaultCase; // while we're dealing with new cases nodes...

    do {
      // skip the start symbol and get the case expression
      this.skipSymbol(caseStart);
      var cond = this.parseExpression();
      this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

      var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
      cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

      tok = this.peekToken();
    } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


    switch (tok.value) {
      case caseDefault:
        this.advanceAfterBlockEnd();
        defaultCase = this.parseUntilBlocks(switchEnd);
        this.advanceAfterBlockEnd();
        break;

      case switchEnd:
        this.advanceAfterBlockEnd();
        break;

      default:
        // otherwise bail because EOF
        this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
    } // and return the switch node.


    return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
  };

  _proto.parseStatement = function parseStatement() {
    var tok = this.peekToken();
    var node;

    if (tok.type !== lexer.TOKEN_SYMBOL) {
      this.fail('tag name expected', tok.lineno, tok.colno);
    }

    if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
      return null;
    }

    switch (tok.value) {
      case 'raw':
        return this.parseRaw();

      case 'verbatim':
        return this.parseRaw('verbatim');

      case 'if':
      case 'ifAsync':
        return this.parseIf();

      case 'for':
      case 'asyncEach':
      case 'asyncAll':
        return this.parseFor();

      case 'block':
        return this.parseBlock();

      case 'extends':
        return this.parseExtends();

      case 'include':
        return this.parseInclude();

      case 'set':
        return this.parseSet();

      case 'macro':
        return this.parseMacro();

      case 'call':
        return this.parseCall();

      case 'import':
        return this.parseImport();

      case 'from':
        return this.parseFrom();

      case 'filter':
        return this.parseFilterStatement();

      case 'switch':
        return this.parseSwitch();

      default:
        if (this.extensions.length) {
          for (var i = 0; i < this.extensions.length; i++) {
            var ext = this.extensions[i];

            if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
              return ext.parse(this, nodes, lexer);
            }
          }
        }

        this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
    }

    return node;
  };

  _proto.parseRaw = function parseRaw(tagName) {
    tagName = tagName || 'raw';
    var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

    var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
    var rawLevel = 1;
    var str = '';
    var matches = null; // Skip opening raw token
    // Keep this token to track line and column numbers

    var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
    // or when we've found the matching "endraw" block

    while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
      var all = matches[0];
      var pre = matches[1];
      var blockName = matches[2]; // Adjust rawlevel

      if (blockName === tagName) {
        rawLevel += 1;
      } else if (blockName === endTagName) {
        rawLevel -= 1;
      } // Add to str


      if (rawLevel === 0) {
        // We want to exclude the last "endraw"
        str += pre; // Move tokenizer to beginning of endraw block

        this.tokens.backN(all.length - pre.length);
      } else {
        str += all;
      }
    }

    return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
  };

  _proto.parsePostfix = function parsePostfix(node) {
    var lookup;
    var tok = this.peekToken();

    while (tok) {
      if (tok.type === lexer.TOKEN_LEFT_PAREN) {
        // Function call
        node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
      } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
        // Reference
        lookup = this.parseAggregate();

        if (lookup.children.length > 1) {
          this.fail('invalid index');
        }

        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
      } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
        // Reference
        this.nextToken();
        var val = this.nextToken();

        if (val.type !== lexer.TOKEN_SYMBOL) {
          this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
        } // Make a literal string because it's not a variable
        // reference


        lookup = new nodes.Literal(val.lineno, val.colno, val.value);
        node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
      } else {
        break;
      }

      tok = this.peekToken();
    }

    return node;
  };

  _proto.parseExpression = function parseExpression() {
    var node = this.parseInlineIf();
    return node;
  };

  _proto.parseInlineIf = function parseInlineIf() {
    var node = this.parseOr();

    if (this.skipSymbol('if')) {
      var condNode = this.parseOr();
      var bodyNode = node;
      node = new nodes.InlineIf(node.lineno, node.colno);
      node.body = bodyNode;
      node.cond = condNode;

      if (this.skipSymbol('else')) {
        node.else_ = this.parseOr();
      } else {
        node.else_ = null;
      }
    }

    return node;
  };

  _proto.parseOr = function parseOr() {
    var node = this.parseAnd();

    while (this.skipSymbol('or')) {
      var node2 = this.parseAnd();
      node = new nodes.Or(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAnd = function parseAnd() {
    var node = this.parseNot();

    while (this.skipSymbol('and')) {
      var node2 = this.parseNot();
      node = new nodes.And(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseNot = function parseNot() {
    var tok = this.peekToken();

    if (this.skipSymbol('not')) {
      return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
    }

    return this.parseIn();
  };

  _proto.parseIn = function parseIn() {
    var node = this.parseIs();

    while (1) {
      // eslint-disable-line no-constant-condition
      // check if the next token is 'not'
      var tok = this.nextToken();

      if (!tok) {
        break;
      }

      var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

      if (!invert) {
        this.pushToken(tok);
      }

      if (this.skipSymbol('in')) {
        var node2 = this.parseIs();
        node = new nodes.In(node.lineno, node.colno, node, node2);

        if (invert) {
          node = new nodes.Not(node.lineno, node.colno, node);
        }
      } else {
        // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
        if (invert) {
          this.pushToken(tok);
        }

        break;
      }
    }

    return node;
  } // I put this right after "in" in the operator precedence stack. That can
  // obviously be changed to be closer to Jinja.
  ;

  _proto.parseIs = function parseIs() {
    var node = this.parseCompare(); // look for an is

    if (this.skipSymbol('is')) {
      // look for a not
      var not = this.skipSymbol('not'); // get the next node

      var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

      node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

      if (not) {
        node = new nodes.Not(node.lineno, node.colno, node);
      }
    } // return the node.


    return node;
  };

  _proto.parseCompare = function parseCompare() {
    var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
    var expr = this.parseConcat();
    var ops = [];

    while (1) {
      // eslint-disable-line no-constant-condition
      var tok = this.nextToken();

      if (!tok) {
        break;
      } else if (compareOps.indexOf(tok.value) !== -1) {
        ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
      } else {
        this.pushToken(tok);
        break;
      }
    }

    if (ops.length) {
      return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
    } else {
      return expr;
    }
  } // finds the '~' for string concatenation
  ;

  _proto.parseConcat = function parseConcat() {
    var node = this.parseAdd();

    while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
      var node2 = this.parseAdd();
      node = new nodes.Concat(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseAdd = function parseAdd() {
    var node = this.parseSub();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      var node2 = this.parseSub();
      node = new nodes.Add(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseSub = function parseSub() {
    var node = this.parseMul();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      var node2 = this.parseMul();
      node = new nodes.Sub(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMul = function parseMul() {
    var node = this.parseDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
      var node2 = this.parseDiv();
      node = new nodes.Mul(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseDiv = function parseDiv() {
    var node = this.parseFloorDiv();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
      var node2 = this.parseFloorDiv();
      node = new nodes.Div(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseFloorDiv = function parseFloorDiv() {
    var node = this.parseMod();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
      var node2 = this.parseMod();
      node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseMod = function parseMod() {
    var node = this.parsePow();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
      var node2 = this.parsePow();
      node = new nodes.Mod(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parsePow = function parsePow() {
    var node = this.parseUnary();

    while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
      var node2 = this.parseUnary();
      node = new nodes.Pow(node.lineno, node.colno, node, node2);
    }

    return node;
  };

  _proto.parseUnary = function parseUnary(noFilters) {
    var tok = this.peekToken();
    var node;

    if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
      node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
    } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
      node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
    } else {
      node = this.parsePrimary();
    }

    if (!noFilters) {
      node = this.parseFilter(node);
    }

    return node;
  };

  _proto.parsePrimary = function parsePrimary(noPostfix) {
    var tok = this.nextToken();
    var val;
    var node = null;

    if (!tok) {
      this.fail('expected expression, got end of file');
    } else if (tok.type === lexer.TOKEN_STRING) {
      val = tok.value;
    } else if (tok.type === lexer.TOKEN_INT) {
      val = parseInt(tok.value, 10);
    } else if (tok.type === lexer.TOKEN_FLOAT) {
      val = parseFloat(tok.value);
    } else if (tok.type === lexer.TOKEN_BOOLEAN) {
      if (tok.value === 'true') {
        val = true;
      } else if (tok.value === 'false') {
        val = false;
      } else {
        this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
      }
    } else if (tok.type === lexer.TOKEN_NONE) {
      val = null;
    } else if (tok.type === lexer.TOKEN_REGEX) {
      val = new RegExp(tok.value.body, tok.value.flags);
    }

    if (val !== undefined) {
      node = new nodes.Literal(tok.lineno, tok.colno, val);
    } else if (tok.type === lexer.TOKEN_SYMBOL) {
      node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
    } else {
      // See if it's an aggregate type, we need to push the
      // current delimiter token back on
      this.pushToken(tok);
      node = this.parseAggregate();
    }

    if (!noPostfix) {
      node = this.parsePostfix(node);
    }

    if (node) {
      return node;
    } else {
      throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
    }
  };

  _proto.parseFilterName = function parseFilterName() {
    var tok = this.expect(lexer.TOKEN_SYMBOL);
    var name = tok.value;

    while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
      name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
    }

    return new nodes.Symbol(tok.lineno, tok.colno, name);
  };

  _proto.parseFilterArgs = function parseFilterArgs(node) {
    if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
      // Get a FunCall node and add the parameters to the
      // filter
      var call = this.parsePostfix(node);
      return call.args.children;
    }

    return [];
  };

  _proto.parseFilter = function parseFilter(node) {
    while (this.skip(lexer.TOKEN_PIPE)) {
      var name = this.parseFilterName();
      node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
    }

    return node;
  };

  _proto.parseFilterStatement = function parseFilterStatement() {
    var filterTok = this.peekToken();

    if (!this.skipSymbol('filter')) {
      this.fail('parseFilterStatement: expected filter');
    }

    var name = this.parseFilterName();
    var args = this.parseFilterArgs(name);
    this.advanceAfterBlockEnd(filterTok.value);
    var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
    this.advanceAfterBlockEnd();
    var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
    return new nodes.Output(name.lineno, name.colno, [node]);
  };

  _proto.parseAggregate = function parseAggregate() {
    var tok = this.nextToken();
    var node;

    switch (tok.type) {
      case lexer.TOKEN_LEFT_PAREN:
        node = new nodes.Group(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_BRACKET:
        node = new nodes.Array(tok.lineno, tok.colno);
        break;

      case lexer.TOKEN_LEFT_CURLY:
        node = new nodes.Dict(tok.lineno, tok.colno);
        break;

      default:
        return null;
    }

    while (1) {
      // eslint-disable-line no-constant-condition
      var type = this.peekToken().type;

      if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
        this.nextToken();
        break;
      }

      if (node.children.length > 0) {
        if (!this.skip(lexer.TOKEN_COMMA)) {
          this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
        }
      }

      if (node instanceof nodes.Dict) {
        // TODO: check for errors
        var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
        // colon

        if (!this.skip(lexer.TOKEN_COLON)) {
          this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
        } // TODO: check for errors


        var value = this.parseExpression();
        node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
      } else {
        // TODO: check for errors
        var expr = this.parseExpression();
        node.addChild(expr);
      }
    }

    return node;
  };

  _proto.parseSignature = function parseSignature(tolerant, noParens) {
    var tok = this.peekToken();

    if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
      if (tolerant) {
        return null;
      } else {
        this.fail('expected arguments', tok.lineno, tok.colno);
      }
    }

    if (tok.type === lexer.TOKEN_LEFT_PAREN) {
      tok = this.nextToken();
    }

    var args = new nodes.NodeList(tok.lineno, tok.colno);
    var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
    var checkComma = false;

    while (1) {
      // eslint-disable-line no-constant-condition
      tok = this.peekToken();

      if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
        this.nextToken();
        break;
      } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
        break;
      }

      if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
        this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
      } else {
        var arg = this.parseExpression();

        if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
          kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
        } else {
          args.addChild(arg);
        }
      }

      checkComma = true;
    }

    if (kwargs.children.length) {
      args.addChild(kwargs);
    }

    return args;
  };

  _proto.parseUntilBlocks = function parseUntilBlocks() {
    var prev = this.breakOnBlocks;

    for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
      blockNames[_key] = arguments[_key];
    }

    this.breakOnBlocks = blockNames;
    var ret = this.parse();
    this.breakOnBlocks = prev;
    return ret;
  };

  _proto.parseNodes = function parseNodes() {
    var tok;
    var buf = [];

    while (tok = this.nextToken()) {
      if (tok.type === lexer.TOKEN_DATA) {
        var data = tok.value;
        var nextToken = this.peekToken();
        var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
        // leading whitespace of the data. This is marked with
        // the `dropLeadingWhitespace` variable.

        if (this.dropLeadingWhitespace) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/^\s*/, '');
          this.dropLeadingWhitespace = false;
        } // Same for the succeeding block start token


        if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
          // TODO: this could be optimized (don't use regex)
          data = data.replace(/\s*$/, '');
        }

        buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
      } else if (tok.type === lexer.TOKEN_BLOCK_START) {
        this.dropLeadingWhitespace = false;
        var n = this.parseStatement();

        if (!n) {
          break;
        }

        buf.push(n);
      } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
        var e = this.parseExpression();
        this.dropLeadingWhitespace = false;
        this.advanceAfterVariableEnd();
        buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
      } else if (tok.type === lexer.TOKEN_COMMENT) {
        this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
      } else {
        // Ignore comments, otherwise this should be an error
        this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
      }
    }

    return buf;
  };

  _proto.parse = function parse() {
    return new nodes.NodeList(0, 0, this.parseNodes());
  };

  _proto.parseAsRoot = function parseAsRoot() {
    return new nodes.Root(0, 0, this.parseNodes());
  };

  return Parser;
}(Obj); // var util = require('util');
// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
// var t;
// while((t = l.nextToken())) {
//     console.log(util.inspect(t));
// }
// var p = new Parser(lexer.lex('hello {% filter title %}' +
//                              'Hello madam how are you' +
//                              '{% endfilter %}'));
// var n = p.parseAsRoot();
// nodes.printNodes(n);


module.exports = {
  parse: function parse(src, extensions, opts) {
    var p = new Parser(lexer.lex(src, opts));

    if (extensions !== undefined) {
      p.extensions = extensions;
    }

    return p.parseAsRoot();
  },
  Parser: Parser
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_125313__) {

"use strict";


var lib = __nested_webpack_require_125313__(0);

var whitespaceChars = " \n\t\r\xA0";
var delimChars = '()[]{}%*-+~/#,:|.<>=!';
var intChars = '0123456789';
var BLOCK_START = '{%';
var BLOCK_END = '%}';
var VARIABLE_START = '{{';
var VARIABLE_END = '}}';
var COMMENT_START = '{#';
var COMMENT_END = '#}';
var TOKEN_STRING = 'string';
var TOKEN_WHITESPACE = 'whitespace';
var TOKEN_DATA = 'data';
var TOKEN_BLOCK_START = 'block-start';
var TOKEN_BLOCK_END = 'block-end';
var TOKEN_VARIABLE_START = 'variable-start';
var TOKEN_VARIABLE_END = 'variable-end';
var TOKEN_COMMENT = 'comment';
var TOKEN_LEFT_PAREN = 'left-paren';
var TOKEN_RIGHT_PAREN = 'right-paren';
var TOKEN_LEFT_BRACKET = 'left-bracket';
var TOKEN_RIGHT_BRACKET = 'right-bracket';
var TOKEN_LEFT_CURLY = 'left-curly';
var TOKEN_RIGHT_CURLY = 'right-curly';
var TOKEN_OPERATOR = 'operator';
var TOKEN_COMMA = 'comma';
var TOKEN_COLON = 'colon';
var TOKEN_TILDE = 'tilde';
var TOKEN_PIPE = 'pipe';
var TOKEN_INT = 'int';
var TOKEN_FLOAT = 'float';
var TOKEN_BOOLEAN = 'boolean';
var TOKEN_NONE = 'none';
var TOKEN_SYMBOL = 'symbol';
var TOKEN_SPECIAL = 'special';
var TOKEN_REGEX = 'regex';

function token(type, value, lineno, colno) {
  return {
    type: type,
    value: value,
    lineno: lineno,
    colno: colno
  };
}

var Tokenizer = /*#__PURE__*/function () {
  function Tokenizer(str, opts) {
    this.str = str;
    this.index = 0;
    this.len = str.length;
    this.lineno = 0;
    this.colno = 0;
    this.in_code = false;
    opts = opts || {};
    var tags = opts.tags || {};
    this.tags = {
      BLOCK_START: tags.blockStart || BLOCK_START,
      BLOCK_END: tags.blockEnd || BLOCK_END,
      VARIABLE_START: tags.variableStart || VARIABLE_START,
      VARIABLE_END: tags.variableEnd || VARIABLE_END,
      COMMENT_START: tags.commentStart || COMMENT_START,
      COMMENT_END: tags.commentEnd || COMMENT_END
    };
    this.trimBlocks = !!opts.trimBlocks;
    this.lstripBlocks = !!opts.lstripBlocks;
  }

  var _proto = Tokenizer.prototype;

  _proto.nextToken = function nextToken() {
    var lineno = this.lineno;
    var colno = this.colno;
    var tok;

    if (this.in_code) {
      // Otherwise, if we are in a block parse it as code
      var cur = this.current();

      if (this.isFinished()) {
        // We have nothing else to parse
        return null;
      } else if (cur === '"' || cur === '\'') {
        // We've hit a string
        return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
      } else if (tok = this._extract(whitespaceChars)) {
        // We hit some whitespace
        return token(TOKEN_WHITESPACE, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
        // Special check for the block end tag
        //
        // It is a requirement that start and end tags are composed of
        // delimiter characters (%{}[] etc), and our code always
        // breaks on delimiters so we can assume the token parsing
        // doesn't consume these elsewhere
        this.in_code = false;

        if (this.trimBlocks) {
          cur = this.current();

          if (cur === '\n') {
            // Skip newline
            this.forward();
          } else if (cur === '\r') {
            // Skip CRLF newline
            this.forward();
            cur = this.current();

            if (cur === '\n') {
              this.forward();
            } else {
              // Was not a CRLF, so go back
              this.back();
            }
          }
        }

        return token(TOKEN_BLOCK_END, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
        // Special check for variable end tag (see above)
        this.in_code = false;
        return token(TOKEN_VARIABLE_END, tok, lineno, colno);
      } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
        // Skip past 'r/'.
        this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

        var regexBody = '';

        while (!this.isFinished()) {
          if (this.current() === '/' && this.previous() !== '\\') {
            this.forward();
            break;
          } else {
            regexBody += this.current();
            this.forward();
          }
        } // Check for flags.
        // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


        var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
        var regexFlags = '';

        while (!this.isFinished()) {
          var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

          if (isCurrentAFlag) {
            regexFlags += this.current();
            this.forward();
          } else {
            break;
          }
        }

        return token(TOKEN_REGEX, {
          body: regexBody,
          flags: regexFlags
        }, lineno, colno);
      } else if (delimChars.indexOf(cur) !== -1) {
        // We've hit a delimiter (a special char like a bracket)
        this.forward();
        var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
        var curComplex = cur + this.current();
        var type;

        if (lib.indexOf(complexOps, curComplex) !== -1) {
          this.forward();
          cur = curComplex; // See if this is a strict equality/inequality comparator

          if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
            cur = curComplex + this.current();
            this.forward();
          }
        }

        switch (cur) {
          case '(':
            type = TOKEN_LEFT_PAREN;
            break;

          case ')':
            type = TOKEN_RIGHT_PAREN;
            break;

          case '[':
            type = TOKEN_LEFT_BRACKET;
            break;

          case ']':
            type = TOKEN_RIGHT_BRACKET;
            break;

          case '{':
            type = TOKEN_LEFT_CURLY;
            break;

          case '}':
            type = TOKEN_RIGHT_CURLY;
            break;

          case ',':
            type = TOKEN_COMMA;
            break;

          case ':':
            type = TOKEN_COLON;
            break;

          case '~':
            type = TOKEN_TILDE;
            break;

          case '|':
            type = TOKEN_PIPE;
            break;

          default:
            type = TOKEN_OPERATOR;
        }

        return token(type, cur, lineno, colno);
      } else {
        // We are not at whitespace or a delimiter, so extract the
        // text and parse it
        tok = this._extractUntil(whitespaceChars + delimChars);

        if (tok.match(/^[-+]?[0-9]+$/)) {
          if (this.current() === '.') {
            this.forward();

            var dec = this._extract(intChars);

            return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
          } else {
            return token(TOKEN_INT, tok, lineno, colno);
          }
        } else if (tok.match(/^(true|false)$/)) {
          return token(TOKEN_BOOLEAN, tok, lineno, colno);
        } else if (tok === 'none') {
          return token(TOKEN_NONE, tok, lineno, colno);
          /*
           * Added to make the test `null is null` evaluate truthily.
           * Otherwise, Nunjucks will look up null in the context and
           * return `undefined`, which is not what we want. This *may* have
           * consequences is someone is using null in their templates as a
           * variable.
           */
        } else if (tok === 'null') {
          return token(TOKEN_NONE, tok, lineno, colno);
        } else if (tok) {
          return token(TOKEN_SYMBOL, tok, lineno, colno);
        } else {
          throw new Error('Unexpected value while parsing: ' + tok);
        }
      }
    } else {
      // Parse out the template text, breaking on tag
      // delimiters because we need to look for block/variable start
      // tags (don't use the full delimChars for optimization)
      var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

      if (this.isFinished()) {
        return null;
      } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
        this.in_code = true;
        return token(TOKEN_BLOCK_START, tok, lineno, colno);
      } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
        this.in_code = true;
        return token(TOKEN_VARIABLE_START, tok, lineno, colno);
      } else {
        tok = '';
        var data;
        var inComment = false;

        if (this._matches(this.tags.COMMENT_START)) {
          inComment = true;
          tok = this._extractString(this.tags.COMMENT_START);
        } // Continually consume text, breaking on the tag delimiter
        // characters and checking to see if it's a start tag.
        //
        // We could hit the end of the template in the middle of
        // our looping, so check for the null return value from
        // _extractUntil


        while ((data = this._extractUntil(beginChars)) !== null) {
          tok += data;

          if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
            if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
              var lastLine = tok.slice(-this.colno);

              if (/^\s+$/.test(lastLine)) {
                // Remove block leading whitespace from beginning of the string
                tok = tok.slice(0, -this.colno);

                if (!tok.length) {
                  // All data removed, collapse to avoid unnecessary nodes
                  // by returning next token (block start)
                  return this.nextToken();
                }
              }
            } // If it is a start tag, stop looping


            break;
          } else if (this._matches(this.tags.COMMENT_END)) {
            if (!inComment) {
              throw new Error('unexpected end of comment');
            }

            tok += this._extractString(this.tags.COMMENT_END);
            break;
          } else {
            // It does not match any tag, so add the character and
            // carry on
            tok += this.current();
            this.forward();
          }
        }

        if (data === null && inComment) {
          throw new Error('expected end of comment, got end of file');
        }

        return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
      }
    }
  };

  _proto._parseString = function _parseString(delimiter) {
    this.forward();
    var str = '';

    while (!this.isFinished() && this.current() !== delimiter) {
      var cur = this.current();

      if (cur === '\\') {
        this.forward();

        switch (this.current()) {
          case 'n':
            str += '\n';
            break;

          case 't':
            str += '\t';
            break;

          case 'r':
            str += '\r';
            break;

          default:
            str += this.current();
        }

        this.forward();
      } else {
        str += cur;
        this.forward();
      }
    }

    this.forward();
    return str;
  };

  _proto._matches = function _matches(str) {
    if (this.index + str.length > this.len) {
      return null;
    }

    var m = this.str.slice(this.index, this.index + str.length);
    return m === str;
  };

  _proto._extractString = function _extractString(str) {
    if (this._matches(str)) {
      this.forwardN(str.length);
      return str;
    }

    return null;
  };

  _proto._extractUntil = function _extractUntil(charString) {
    // Extract all non-matching chars, with the default matching set
    // to everything
    return this._extractMatching(true, charString || '');
  };

  _proto._extract = function _extract(charString) {
    // Extract all matching chars (no default, so charString must be
    // explicit)
    return this._extractMatching(false, charString);
  };

  _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
    // Pull out characters until a breaking char is hit.
    // If breakOnMatch is false, a non-matching char stops it.
    // If breakOnMatch is true, a matching char stops it.
    if (this.isFinished()) {
      return null;
    }

    var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

    if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
      var t = this.current();
      this.forward(); // And pull out all the chars one at a time until we hit a
      // breaking char

      var idx = charString.indexOf(this.current());

      while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
        t += this.current();
        this.forward();
        idx = charString.indexOf(this.current());
      }

      return t;
    }

    return '';
  };

  _proto._extractRegex = function _extractRegex(regex) {
    var matches = this.currentStr().match(regex);

    if (!matches) {
      return null;
    } // Move forward whatever was matched


    this.forwardN(matches[0].length);
    return matches;
  };

  _proto.isFinished = function isFinished() {
    return this.index >= this.len;
  };

  _proto.forwardN = function forwardN(n) {
    for (var i = 0; i < n; i++) {
      this.forward();
    }
  };

  _proto.forward = function forward() {
    this.index++;

    if (this.previous() === '\n') {
      this.lineno++;
      this.colno = 0;
    } else {
      this.colno++;
    }
  };

  _proto.backN = function backN(n) {
    for (var i = 0; i < n; i++) {
      this.back();
    }
  };

  _proto.back = function back() {
    this.index--;

    if (this.current() === '\n') {
      this.lineno--;
      var idx = this.src.lastIndexOf('\n', this.index - 1);

      if (idx === -1) {
        this.colno = this.index;
      } else {
        this.colno = this.index - idx;
      }
    } else {
      this.colno--;
    }
  } // current returns current character
  ;

  _proto.current = function current() {
    if (!this.isFinished()) {
      return this.str.charAt(this.index);
    }

    return '';
  } // currentStr returns what's left of the unparsed string
  ;

  _proto.currentStr = function currentStr() {
    if (!this.isFinished()) {
      return this.str.substr(this.index);
    }

    return '';
  };

  _proto.previous = function previous() {
    return this.str.charAt(this.index - 1);
  };

  return Tokenizer;
}();

module.exports = {
  lex: function lex(src, opts) {
    return new Tokenizer(src, opts);
  },
  TOKEN_STRING: TOKEN_STRING,
  TOKEN_WHITESPACE: TOKEN_WHITESPACE,
  TOKEN_DATA: TOKEN_DATA,
  TOKEN_BLOCK_START: TOKEN_BLOCK_START,
  TOKEN_BLOCK_END: TOKEN_BLOCK_END,
  TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
  TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
  TOKEN_COMMENT: TOKEN_COMMENT,
  TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
  TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
  TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
  TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
  TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
  TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
  TOKEN_OPERATOR: TOKEN_OPERATOR,
  TOKEN_COMMA: TOKEN_COMMA,
  TOKEN_COLON: TOKEN_COLON,
  TOKEN_TILDE: TOKEN_TILDE,
  TOKEN_PIPE: TOKEN_PIPE,
  TOKEN_INT: TOKEN_INT,
  TOKEN_FLOAT: TOKEN_FLOAT,
  TOKEN_BOOLEAN: TOKEN_BOOLEAN,
  TOKEN_NONE: TOKEN_NONE,
  TOKEN_SYMBOL: TOKEN_SYMBOL,
  TOKEN_SPECIAL: TOKEN_SPECIAL,
  TOKEN_REGEX: TOKEN_REGEX
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_141230__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __nested_webpack_require_141230__(6);

var _require = __nested_webpack_require_141230__(19),
    PrecompiledLoader = _require.PrecompiledLoader;

var WebLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(WebLoader, _Loader);

  function WebLoader(baseURL, opts) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.baseURL = baseURL || '.';
    opts = opts || {}; // By default, the cache is turned off because there's no way
    // to "watch" templates over HTTP, so they are re-downloaded
    // and compiled each time. (Remember, PRECOMPILE YOUR
    // TEMPLATES in production!)

    _this.useCache = !!opts.useCache; // We default `async` to false so that the simple synchronous
    // API can be used when you aren't doing anything async in
    // your templates (which is most of the time). This performs a
    // sync ajax request, but that's ok because it should *only*
    // happen in development. PRECOMPILE YOUR TEMPLATES.

    _this.async = !!opts.async;
    return _this;
  }

  var _proto = WebLoader.prototype;

  _proto.resolve = function resolve(from, to) {
    throw new Error('relative templates not support in the browser yet');
  };

  _proto.getSource = function getSource(name, cb) {
    var _this2 = this;

    var useCache = this.useCache;
    var result;
    this.fetch(this.baseURL + '/' + name, function (err, src) {
      if (err) {
        if (cb) {
          cb(err.content);
        } else if (err.status === 404) {
          result = null;
        } else {
          throw err.content;
        }
      } else {
        result = {
          src: src,
          path: name,
          noCache: !useCache
        };

        _this2.emit('load', name, result);

        if (cb) {
          cb(null, result);
        }
      }
    }); // if this WebLoader isn't running asynchronously, the
    // fetch above would actually run sync and we'll have a
    // result here

    return result;
  };

  _proto.fetch = function fetch(url, cb) {
    // Only in the browser please
    if (typeof window === 'undefined') {
      throw new Error('WebLoader can only by used in a browser');
    }

    var ajax = new XMLHttpRequest();
    var loading = true;

    ajax.onreadystatechange = function () {
      if (ajax.readyState === 4 && loading) {
        loading = false;

        if (ajax.status === 0 || ajax.status === 200) {
          cb(null, ajax.responseText);
        } else {
          cb({
            status: ajax.status,
            content: ajax.responseText
          });
        }
      }
    };

    url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' + new Date().getTime();
    ajax.open('GET', url, this.async);
    ajax.send();
  };

  return WebLoader;
}(Loader);

module.exports = {
  WebLoader: WebLoader,
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_144485__) {

"use strict";


var lib = __nested_webpack_require_144485__(0);

var _require = __nested_webpack_require_144485__(7),
    Environment = _require.Environment,
    Template = _require.Template;

var Loader = __nested_webpack_require_144485__(6);

var loaders = __nested_webpack_require_144485__(10);

var precompile = __nested_webpack_require_144485__(23);

var compiler = __nested_webpack_require_144485__(5);

var parser = __nested_webpack_require_144485__(8);

var lexer = __nested_webpack_require_144485__(9);

var runtime = __nested_webpack_require_144485__(2);

var nodes = __nested_webpack_require_144485__(3);

var installJinjaCompat = __nested_webpack_require_144485__(25); // A single instance of an environment, since this is so commonly used


var e;

function configure(templatesPath, opts) {
  opts = opts || {};

  if (lib.isObject(templatesPath)) {
    opts = templatesPath;
    templatesPath = null;
  }

  var TemplateLoader;

  if (loaders.FileSystemLoader) {
    TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
      watch: opts.watch,
      noCache: opts.noCache
    });
  } else if (loaders.WebLoader) {
    TemplateLoader = new loaders.WebLoader(templatesPath, {
      useCache: opts.web && opts.web.useCache,
      async: opts.web && opts.web.async
    });
  }

  e = new Environment(TemplateLoader, opts);

  if (opts && opts.express) {
    e.express(opts.express);
  }

  return e;
}

module.exports = {
  Environment: Environment,
  Template: Template,
  Loader: Loader,
  FileSystemLoader: loaders.FileSystemLoader,
  NodeResolveLoader: loaders.NodeResolveLoader,
  PrecompiledLoader: loaders.PrecompiledLoader,
  WebLoader: loaders.WebLoader,
  compiler: compiler,
  parser: parser,
  lexer: lexer,
  runtime: runtime,
  lib: lib,
  nodes: nodes,
  installJinjaCompat: installJinjaCompat,
  configure: configure,
  reset: function reset() {
    e = undefined;
  },
  compile: function compile(src, env, path, eagerCompile) {
    if (!e) {
      configure();
    }

    return new Template(src, env, path, eagerCompile);
  },
  render: function render(name, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.render(name, ctx, cb);
  },
  renderString: function renderString(src, ctx, cb) {
    if (!e) {
      configure();
    }

    return e.renderString(src, ctx, cb);
  },
  precompile: precompile ? precompile.precompile : undefined,
  precompileString: precompile ? precompile.precompileString : undefined
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_146877__) {

"use strict";


// rawAsap provides everything we need except exception management.
var rawAsap = __nested_webpack_require_146877__(13);
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};


/***/ }),
/* 13 */
/***/ (function(module, exports, __nested_webpack_require_149147__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

/* WEBPACK VAR INJECTION */}.call(exports, __nested_webpack_require_149147__(14)))

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// MIT license (by Elan Shanker).
(function(globals) {
  'use strict';

  var executeSync = function(){
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'function'){
      args[0].apply(null, args.splice(1));
    }
  };

  var executeAsync = function(fn){
    if (typeof setImmediate === 'function') {
      setImmediate(fn);
    } else if (typeof process !== 'undefined' && process.nextTick) {
      process.nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  };

  var makeIterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  
  var _isArray = Array.isArray || function(maybeArray){
    return Object.prototype.toString.call(maybeArray) === '[object Array]';
  };

  var waterfall = function (tasks, callback, forceAsync) {
    var nextTick = forceAsync ? executeAsync : executeSync;
    callback = callback || function () {};
    if (!_isArray(tasks)) {
      var err = new Error('First argument to waterfall must be an array of functions');
      return callback(err);
    }
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {};
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(makeIterator(tasks))();
  };

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return waterfall;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
  } else {}
})(this);


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function eventListener() {
      if (errorListener !== undefined) {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };
    var errorListener;

    // Adding an error listener is not optional because
    // if an error is thrown on an event emitter we cannot
    // guarantee that the actual event we are waiting will
    // be fired. The result could be a silent way to create
    // memory or file descriptor leaks, which is something
    // we should avoid.
    if (name !== 'error') {
      errorListener = function errorListener(err) {
        emitter.removeListener(name, eventListener);
        reject(err);
      };

      emitter.once('error', errorListener);
    }

    emitter.once(name, eventListener);
  });
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_176372__) {

"use strict";


var nodes = __nested_webpack_require_176372__(3);

var lib = __nested_webpack_require_176372__(0);

var sym = 0;

function gensym() {
  return 'hole_' + sym++;
} // copy-on-write version of map


function mapCOW(arr, func) {
  var res = null;

  for (var i = 0; i < arr.length; i++) {
    var item = func(arr[i]);

    if (item !== arr[i]) {
      if (!res) {
        res = arr.slice();
      }

      res[i] = item;
    }
  }

  return res || arr;
}

function walk(ast, func, depthFirst) {
  if (!(ast instanceof nodes.Node)) {
    return ast;
  }

  if (!depthFirst) {
    var astT = func(ast);

    if (astT && astT !== ast) {
      return astT;
    }
  }

  if (ast instanceof nodes.NodeList) {
    var children = mapCOW(ast.children, function (node) {
      return walk(node, func, depthFirst);
    });

    if (children !== ast.children) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
    }
  } else if (ast instanceof nodes.CallExtension) {
    var args = walk(ast.args, func, depthFirst);
    var contentArgs = mapCOW(ast.contentArgs, function (node) {
      return walk(node, func, depthFirst);
    });

    if (args !== ast.args || contentArgs !== ast.contentArgs) {
      ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
    }
  } else {
    var props = ast.fields.map(function (field) {
      return ast[field];
    });
    var propsT = mapCOW(props, function (prop) {
      return walk(prop, func, depthFirst);
    });

    if (propsT !== props) {
      ast = new nodes[ast.typename](ast.lineno, ast.colno);
      propsT.forEach(function (prop, i) {
        ast[ast.fields[i]] = prop;
      });
    }
  }

  return depthFirst ? func(ast) || ast : ast;
}

function depthWalk(ast, func) {
  return walk(ast, func, true);
}

function _liftFilters(node, asyncFilters, prop) {
  var children = [];
  var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
    var symbol;

    if (descNode instanceof nodes.Block) {
      return descNode;
    } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
      symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
      children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
    }

    return symbol;
  });

  if (prop) {
    node[prop] = walked;
  } else {
    node = walked;
  }

  if (children.length) {
    children.push(node);
    return new nodes.NodeList(node.lineno, node.colno, children);
  } else {
    return node;
  }
}

function liftFilters(ast, asyncFilters) {
  return depthWalk(ast, function (node) {
    if (node instanceof nodes.Output) {
      return _liftFilters(node, asyncFilters);
    } else if (node instanceof nodes.Set) {
      return _liftFilters(node, asyncFilters, 'value');
    } else if (node instanceof nodes.For) {
      return _liftFilters(node, asyncFilters, 'arr');
    } else if (node instanceof nodes.If) {
      return _liftFilters(node, asyncFilters, 'cond');
    } else if (node instanceof nodes.CallExtension) {
      return _liftFilters(node, asyncFilters, 'args');
    } else {
      return undefined;
    }
  });
}

function liftSuper(ast) {
  return walk(ast, function (blockNode) {
    if (!(blockNode instanceof nodes.Block)) {
      return;
    }

    var hasSuper = false;
    var symbol = gensym();
    blockNode.body = walk(blockNode.body, function (node) {
      // eslint-disable-line consistent-return
      if (node instanceof nodes.FunCall && node.name.value === 'super') {
        hasSuper = true;
        return new nodes.Symbol(node.lineno, node.colno, symbol);
      }
    });

    if (hasSuper) {
      blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
    }
  });
}

function convertStatements(ast) {
  return depthWalk(ast, function (node) {
    if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
      return undefined;
    }

    var async = false;
    walk(node, function (child) {
      if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
        async = true; // Stop iterating by returning the node

        return child;
      }

      return undefined;
    });

    if (async) {
      if (node instanceof nodes.If) {
        return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
      } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
        return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
      }
    }

    return undefined;
  });
}

function cps(ast, asyncFilters) {
  return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
}

function transform(ast, asyncFilters) {
  return cps(ast, asyncFilters || []);
} // var parser = require('./parser');
// var src = 'hello {% foo %}{% endfoo %} end';
// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
// nodes.printNodes(ast);


module.exports = {
  transform: transform
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_181667__) {

"use strict";


var lib = __nested_webpack_require_181667__(0);

var r = __nested_webpack_require_181667__(2);

var exports = module.exports = {};

function normalize(value, defaultValue) {
  if (value === null || value === undefined || value === false) {
    return defaultValue;
  }

  return value;
}

exports.abs = Math.abs;

function isNaN(num) {
  return num !== num; // eslint-disable-line no-self-compare
}

function batch(arr, linecount, fillWith) {
  var i;
  var res = [];
  var tmp = [];

  for (i = 0; i < arr.length; i++) {
    if (i % linecount === 0 && tmp.length) {
      res.push(tmp);
      tmp = [];
    }

    tmp.push(arr[i]);
  }

  if (tmp.length) {
    if (fillWith) {
      for (i = tmp.length; i < linecount; i++) {
        tmp.push(fillWith);
      }
    }

    res.push(tmp);
  }

  return res;
}

exports.batch = batch;

function capitalize(str) {
  str = normalize(str, '');
  var ret = str.toLowerCase();
  return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
}

exports.capitalize = capitalize;

function center(str, width) {
  str = normalize(str, '');
  width = width || 80;

  if (str.length >= width) {
    return str;
  }

  var spaces = width - str.length;
  var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
  var post = lib.repeat(' ', spaces / 2);
  return r.copySafeness(str, pre + str + post);
}

exports.center = center;

function default_(val, def, bool) {
  if (bool) {
    return val || def;
  } else {
    return val !== undefined ? val : def;
  }
} // TODO: it is confusing to export something called 'default'


exports['default'] = default_; // eslint-disable-line dot-notation

function dictsort(val, caseSensitive, by) {
  if (!lib.isObject(val)) {
    throw new lib.TemplateError('dictsort filter: val must be an object');
  }

  var array = []; // deliberately include properties from the object's prototype

  for (var k in val) {
    // eslint-disable-line guard-for-in, no-restricted-syntax
    array.push([k, val[k]]);
  }

  var si;

  if (by === undefined || by === 'key') {
    si = 0;
  } else if (by === 'value') {
    si = 1;
  } else {
    throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
  }

  array.sort(function (t1, t2) {
    var a = t1[si];
    var b = t2[si];

    if (!caseSensitive) {
      if (lib.isString(a)) {
        a = a.toUpperCase();
      }

      if (lib.isString(b)) {
        b = b.toUpperCase();
      }
    }

    return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
  });
  return array;
}

exports.dictsort = dictsort;

function dump(obj, spaces) {
  return JSON.stringify(obj, null, spaces);
}

exports.dump = dump;

function escape(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.escape = escape;

function safe(str) {
  if (str instanceof r.SafeString) {
    return str;
  }

  str = str === null || str === undefined ? '' : str;
  return r.markSafe(str.toString());
}

exports.safe = safe;

function first(arr) {
  return arr[0];
}

exports.first = first;

function forceescape(str) {
  str = str === null || str === undefined ? '' : str;
  return r.markSafe(lib.escape(str.toString()));
}

exports.forceescape = forceescape;

function groupby(arr, attr) {
  return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
}

exports.groupby = groupby;

function indent(str, width, indentfirst) {
  str = normalize(str, '');

  if (str === '') {
    return '';
  }

  width = width || 4; // let res = '';

  var lines = str.split('\n');
  var sp = lib.repeat(' ', width);
  var res = lines.map(function (l, i) {
    return i === 0 && !indentfirst ? l : "" + sp + l;
  }).join('\n');
  return r.copySafeness(str, res);
}

exports.indent = indent;

function join(arr, del, attr) {
  del = del || '';

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return arr.join(del);
}

exports.join = join;

function last(arr) {
  return arr[arr.length - 1];
}

exports.last = last;

function lengthFilter(val) {
  var value = normalize(val, '');

  if (value !== undefined) {
    if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
      // ECMAScript 2015 Maps and Sets
      return value.size;
    }

    if (lib.isObject(value) && !(value instanceof r.SafeString)) {
      // Objects (besides SafeStrings), non-primative Arrays
      return lib.keys(value).length;
    }

    return value.length;
  }

  return 0;
}

exports.length = lengthFilter;

function list(val) {
  if (lib.isString(val)) {
    return val.split('');
  } else if (lib.isObject(val)) {
    return lib._entries(val || {}).map(function (_ref) {
      var key = _ref[0],
          value = _ref[1];
      return {
        key: key,
        value: value
      };
    });
  } else if (lib.isArray(val)) {
    return val;
  } else {
    throw new lib.TemplateError('list filter: type not iterable');
  }
}

exports.list = list;

function lower(str) {
  str = normalize(str, '');
  return str.toLowerCase();
}

exports.lower = lower;

function nl2br(str) {
  if (str === null || str === undefined) {
    return '';
  }

  return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
}

exports.nl2br = nl2br;

function random(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

exports.random = random;
/**
 * Construct select or reject filter
 *
 * @param {boolean} expectedTestResult
 * @returns {function(array, string, *): array}
 */

function getSelectOrReject(expectedTestResult) {
  function filter(arr, testName, secondArg) {
    if (testName === void 0) {
      testName = 'truthy';
    }

    var context = this;
    var test = context.env.getTest(testName);
    return lib.toArray(arr).filter(function examineTestResult(item) {
      return test.call(context, item, secondArg) === expectedTestResult;
    });
  }

  return filter;
}

exports.reject = getSelectOrReject(false);

function rejectattr(arr, attr) {
  return arr.filter(function (item) {
    return !item[attr];
  });
}

exports.rejectattr = rejectattr;
exports.select = getSelectOrReject(true);

function selectattr(arr, attr) {
  return arr.filter(function (item) {
    return !!item[attr];
  });
}

exports.selectattr = selectattr;

function replace(str, old, new_, maxCount) {
  var originalStr = str;

  if (old instanceof RegExp) {
    return str.replace(old, new_);
  }

  if (typeof maxCount === 'undefined') {
    maxCount = -1;
  }

  var res = ''; // Output
  // Cast Numbers in the search term to string

  if (typeof old === 'number') {
    old = '' + old;
  } else if (typeof old !== 'string') {
    // If it is something other than number or string,
    // return the original string
    return str;
  } // Cast numbers in the replacement to string


  if (typeof str === 'number') {
    str = '' + str;
  } // If by now, we don't have a string, throw it back


  if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
    return str;
  } // ShortCircuits


  if (old === '') {
    // Mimic the python behaviour: empty string is replaced
    // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
    res = new_ + str.split('').join(new_) + new_;
    return r.copySafeness(str, res);
  }

  var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
  // not contain the old value, return the string

  if (maxCount === 0 || nextIndex === -1) {
    return str;
  }

  var pos = 0;
  var count = 0; // # of replacements made

  while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
    // Grab the next chunk of src string and add it with the
    // replacement, to the result
    res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

    pos = nextIndex + old.length;
    count++; // See if there are any more replacements to be made

    nextIndex = str.indexOf(old, pos);
  } // We've either reached the end, or done the max # of
  // replacements, tack on any remaining string


  if (pos < str.length) {
    res += str.substring(pos);
  }

  return r.copySafeness(originalStr, res);
}

exports.replace = replace;

function reverse(val) {
  var arr;

  if (lib.isString(val)) {
    arr = list(val);
  } else {
    // Copy it
    arr = lib.map(val, function (v) {
      return v;
    });
  }

  arr.reverse();

  if (lib.isString(val)) {
    return r.copySafeness(val, arr.join(''));
  }

  return arr;
}

exports.reverse = reverse;

function round(val, precision, method) {
  precision = precision || 0;
  var factor = Math.pow(10, precision);
  var rounder;

  if (method === 'ceil') {
    rounder = Math.ceil;
  } else if (method === 'floor') {
    rounder = Math.floor;
  } else {
    rounder = Math.round;
  }

  return rounder(val * factor) / factor;
}

exports.round = round;

function slice(arr, slices, fillWith) {
  var sliceLength = Math.floor(arr.length / slices);
  var extra = arr.length % slices;
  var res = [];
  var offset = 0;

  for (var i = 0; i < slices; i++) {
    var start = offset + i * sliceLength;

    if (i < extra) {
      offset++;
    }

    var end = offset + (i + 1) * sliceLength;
    var currSlice = arr.slice(start, end);

    if (fillWith && i >= extra) {
      currSlice.push(fillWith);
    }

    res.push(currSlice);
  }

  return res;
}

exports.slice = slice;

function sum(arr, attr, start) {
  if (start === void 0) {
    start = 0;
  }

  if (attr) {
    arr = lib.map(arr, function (v) {
      return v[attr];
    });
  }

  return start + arr.reduce(function (a, b) {
    return a + b;
  }, 0);
}

exports.sum = sum;
exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function sortFilter(arr, reversed, caseSens, attr) {
  var _this = this;

  // Copy it
  var array = lib.map(arr, function (v) {
    return v;
  });
  var getAttribute = lib.getAttrGetter(attr);
  array.sort(function (a, b) {
    var x = attr ? getAttribute(a) : a;
    var y = attr ? getAttribute(b) : b;

    if (_this.env.opts.throwOnUndefined && attr && (x === undefined || y === undefined)) {
      throw new TypeError("sort: attribute \"" + attr + "\" resolved to undefined");
    }

    if (!caseSens && lib.isString(x) && lib.isString(y)) {
      x = x.toLowerCase();
      y = y.toLowerCase();
    }

    if (x < y) {
      return reversed ? 1 : -1;
    } else if (x > y) {
      return reversed ? -1 : 1;
    } else {
      return 0;
    }
  });
  return array;
});

function string(obj) {
  return r.copySafeness(obj, obj);
}

exports.string = string;

function striptags(input, preserveLinebreaks) {
  input = normalize(input, '');
  var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
  var trimmedInput = trim(input.replace(tags, ''));
  var res = '';

  if (preserveLinebreaks) {
    res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
    .replace(/ +/g, ' ') // squash adjacent spaces
    .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
    .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
  } else {
    res = trimmedInput.replace(/\s+/gi, ' ');
  }

  return r.copySafeness(input, res);
}

exports.striptags = striptags;

function title(str) {
  str = normalize(str, '');
  var words = str.split(' ').map(function (word) {
    return capitalize(word);
  });
  return r.copySafeness(str, words.join(' '));
}

exports.title = title;

function trim(str) {
  return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
}

exports.trim = trim;

function truncate(input, length, killwords, end) {
  var orig = input;
  input = normalize(input, '');
  length = length || 255;

  if (input.length <= length) {
    return input;
  }

  if (killwords) {
    input = input.substring(0, length);
  } else {
    var idx = input.lastIndexOf(' ', length);

    if (idx === -1) {
      idx = length;
    }

    input = input.substring(0, idx);
  }

  input += end !== undefined && end !== null ? end : '...';
  return r.copySafeness(orig, input);
}

exports.truncate = truncate;

function upper(str) {
  str = normalize(str, '');
  return str.toUpperCase();
}

exports.upper = upper;

function urlencode(obj) {
  var enc = encodeURIComponent;

  if (lib.isString(obj)) {
    return enc(obj);
  } else {
    var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
    return keyvals.map(function (_ref2) {
      var k = _ref2[0],
          v = _ref2[1];
      return enc(k) + "=" + enc(v);
    }).join('&');
  }
}

exports.urlencode = urlencode; // For the jinja regexp, see
// https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
var httpHttpsRe = /^https?:\/\/.*$/;
var wwwRe = /^www\./;
var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

function urlize(str, length, nofollow) {
  if (isNaN(length)) {
    length = Infinity;
  }

  var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
  var words = str.split(/(\s+)/).filter(function (word) {
    // If the word has no length, bail. This can happen for str with
    // trailing whitespace.
    return word && word.length;
  }).map(function (word) {
    var matches = word.match(puncRe);
    var possibleUrl = matches ? matches[1] : word;
    var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

    if (httpHttpsRe.test(possibleUrl)) {
      return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // url that starts with www.


    if (wwwRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    } // an email address of the form username@domain.tld


    if (emailRe.test(possibleUrl)) {
      return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
    } // url that ends in .com, .org or .net that is not an email address


    if (tldRe.test(possibleUrl)) {
      return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
    }

    return word;
  });
  return words.join('');
}

exports.urlize = urlize;

function wordcount(str) {
  str = normalize(str, '');
  var words = str ? str.match(/\w+/g) : null;
  return words ? words.length : null;
}

exports.wordcount = wordcount;

function float(val, def) {
  var res = parseFloat(val);
  return isNaN(res) ? def : res;
}

exports.float = float;
var intFilter = r.makeMacro(['value', 'default', 'base'], [], function doInt(value, defaultValue, base) {
  if (base === void 0) {
    base = 10;
  }

  var res = parseInt(value, base);
  return isNaN(res) ? defaultValue : res;
});
exports.int = intFilter; // Aliases

exports.d = exports.default;
exports.e = exports.escape;

/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_196726__) {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Loader = __nested_webpack_require_196726__(6);

var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
  _inheritsLoose(PrecompiledLoader, _Loader);

  function PrecompiledLoader(compiledTemplates) {
    var _this;

    _this = _Loader.call(this) || this;
    _this.precompiled = compiledTemplates || {};
    return _this;
  }

  var _proto = PrecompiledLoader.prototype;

  _proto.getSource = function getSource(name) {
    if (this.precompiled[name]) {
      return {
        src: {
          type: 'code',
          obj: this.precompiled[name]
        },
        path: name
      };
    }

    return null;
  };

  return PrecompiledLoader;
}(Loader);

module.exports = {
  PrecompiledLoader: PrecompiledLoader
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_197892__) {

"use strict";


var SafeString = __nested_webpack_require_197892__(2).SafeString;
/**
 * Returns `true` if the object is a function, otherwise `false`.
 * @param { any } value
 * @returns { boolean }
 */


function callable(value) {
  return typeof value === 'function';
}

exports.callable = callable;
/**
 * Returns `true` if the object is strictly not `undefined`.
 * @param { any } value
 * @returns { boolean }
 */

function defined(value) {
  return value !== undefined;
}

exports.defined = defined;
/**
 * Returns `true` if the operand (one) is divisble by the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function divisibleby(one, two) {
  return one % two === 0;
}

exports.divisibleby = divisibleby;
/**
 * Returns true if the string has been escaped (i.e., is a SafeString).
 * @param { any } value
 * @returns { boolean }
 */

function escaped(value) {
  return value instanceof SafeString;
}

exports.escaped = escaped;
/**
 * Returns `true` if the arguments are strictly equal.
 * @param { any } one
 * @param { any } two
 */

function equalto(one, two) {
  return one === two;
}

exports.equalto = equalto; // Aliases

exports.eq = exports.equalto;
exports.sameas = exports.equalto;
/**
 * Returns `true` if the value is evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function even(value) {
  return value % 2 === 0;
}

exports.even = even;
/**
 * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
 * undefined, NaN or null. I don't know if we should stick to the default JS
 * behavior or attempt to replicate what Python believes should be falsy (i.e.,
 * empty arrays, empty dicts, not 0...).
 * @param { any } value
 * @returns { boolean }
 */

function falsy(value) {
  return !value;
}

exports.falsy = falsy;
/**
 * Returns `true` if the operand (one) is greater or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ge(one, two) {
  return one >= two;
}

exports.ge = ge;
/**
 * Returns `true` if the operand (one) is greater than the test's argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function greaterthan(one, two) {
  return one > two;
}

exports.greaterthan = greaterthan; // alias

exports.gt = exports.greaterthan;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function le(one, two) {
  return one <= two;
}

exports.le = le;
/**
 * Returns `true` if the operand (one) is less than the test's passed argument
 * (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function lessthan(one, two) {
  return one < two;
}

exports.lessthan = lessthan; // alias

exports.lt = exports.lessthan;
/**
 * Returns `true` if the string is lowercased.
 * @param { string } value
 * @returns { boolean }
 */

function lower(value) {
  return value.toLowerCase() === value;
}

exports.lower = lower;
/**
 * Returns `true` if the operand (one) is less than or equal to the test's
 * argument (two).
 * @param { number } one
 * @param { number } two
 * @returns { boolean }
 */

function ne(one, two) {
  return one !== two;
}

exports.ne = ne;
/**
 * Returns true if the value is strictly equal to `null`.
 * @param { any }
 * @returns { boolean }
 */

function nullTest(value) {
  return value === null;
}

exports.null = nullTest;
/**
 * Returns true if value is a number.
 * @param { any }
 * @returns { boolean }
 */

function number(value) {
  return typeof value === 'number';
}

exports.number = number;
/**
 * Returns `true` if the value is *not* evenly divisible by 2.
 * @param { number } value
 * @returns { boolean }
 */

function odd(value) {
  return value % 2 === 1;
}

exports.odd = odd;
/**
 * Returns `true` if the value is a string, `false` if not.
 * @param { any } value
 * @returns { boolean }
 */

function string(value) {
  return typeof value === 'string';
}

exports.string = string;
/**
 * Returns `true` if the value is not in the list of things considered falsy:
 * '', null, undefined, 0, NaN and false.
 * @param { any } value
 * @returns { boolean }
 */

function truthy(value) {
  return !!value;
}

exports.truthy = truthy;
/**
 * Returns `true` if the value is undefined.
 * @param { any } value
 * @returns { boolean }
 */

function undefinedTest(value) {
  return value === undefined;
}

exports.undefined = undefinedTest;
/**
 * Returns `true` if the string is uppercased.
 * @param { string } value
 * @returns { boolean }
 */

function upper(value) {
  return value.toUpperCase() === value;
}

exports.upper = upper;
/**
 * If ES6 features are available, returns `true` if the value implements the
 * `Symbol.iterator` method. If not, it's a string or Array.
 *
 * Could potentially cause issues if a browser exists that has Set and Map but
 * not Symbol.
 *
 * @param { any } value
 * @returns { boolean }
 */

function iterable(value) {
  if (typeof Symbol !== 'undefined') {
    return !!value[Symbol.iterator];
  } else {
    return Array.isArray(value) || typeof value === 'string';
  }
}

exports.iterable = iterable;
/**
 * If ES6 features are available, returns `true` if the value is an object hash
 * or an ES6 Map. Otherwise just return if it's an object hash.
 * @param { any } value
 * @returns { boolean }
 */

function mapping(value) {
  // only maps and object hashes
  var bool = value !== null && value !== undefined && typeof value === 'object' && !Array.isArray(value);

  if (Set) {
    return bool && !(value instanceof Set);
  } else {
    return bool;
  }
}

exports.mapping = mapping;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _cycler(items) {
  var index = -1;
  return {
    current: null,
    reset: function reset() {
      index = -1;
      this.current = null;
    },
    next: function next() {
      index++;

      if (index >= items.length) {
        index = 0;
      }

      this.current = items[index];
      return this.current;
    }
  };
}

function _joiner(sep) {
  sep = sep || ',';
  var first = true;
  return function () {
    var val = first ? '' : sep;
    first = false;
    return val;
  };
} // Making this a function instead so it returns a new object
// each time it's called. That way, if something like an environment
// uses it, they will each have their own copy.


function globals() {
  return {
    range: function range(start, stop, step) {
      if (typeof stop === 'undefined') {
        stop = start;
        start = 0;
        step = 1;
      } else if (!step) {
        step = 1;
      }

      var arr = [];

      if (step > 0) {
        for (var i = start; i < stop; i += step) {
          arr.push(i);
        }
      } else {
        for (var _i = start; _i > stop; _i += step) {
          // eslint-disable-line for-direction
          arr.push(_i);
        }
      }

      return arr;
    },
    cycler: function cycler() {
      return _cycler(Array.prototype.slice.call(arguments));
    },
    joiner: function joiner(sep) {
      return _joiner(sep);
    }
  };
}

module.exports = globals;

/***/ }),
/* 22 */
/***/ (function(module, exports, __nested_webpack_require_205249__) {

var path = __nested_webpack_require_205249__(4);

module.exports = function express(env, app) {
  function NunjucksView(name, opts) {
    this.name = name;
    this.path = name;
    this.defaultEngine = opts.defaultEngine;
    this.ext = path.extname(name);

    if (!this.ext && !this.defaultEngine) {
      throw new Error('No default engine was specified and no extension was provided.');
    }

    if (!this.ext) {
      this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
    }
  }

  NunjucksView.prototype.render = function render(opts, cb) {
    env.render(this.name, opts, cb);
  };

  app.set('view', NunjucksView);
  app.set('nunjucksEnv', env);
  return env;
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_206024__) {

"use strict";


var fs = __nested_webpack_require_206024__(4);

var path = __nested_webpack_require_206024__(4);

var _require = __nested_webpack_require_206024__(0),
    _prettifyError = _require._prettifyError;

var compiler = __nested_webpack_require_206024__(5);

var _require2 = __nested_webpack_require_206024__(7),
    Environment = _require2.Environment;

var precompileGlobal = __nested_webpack_require_206024__(24);

function match(filename, patterns) {
  if (!Array.isArray(patterns)) {
    return false;
  }

  return patterns.some(function (pattern) {
    return filename.match(pattern);
  });
}

function precompileString(str, opts) {
  opts = opts || {};
  opts.isString = true;
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (!opts.name) {
    throw new Error('the "name" option is required when compiling a string');
  }

  return wrapper([_precompile(str, opts.name, env)], opts);
}

function precompile(input, opts) {
  // The following options are available:
  //
  // * name: name of the template (auto-generated when compiling a directory)
  // * isString: input is a string, not a file path
  // * asFunction: generate a callable function
  // * force: keep compiling on error
  // * env: the Environment to use (gets extensions and async filters from it)
  // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
  // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
  // * wrapper: function(templates, opts) {...}
  //       Customize the output format to store the compiled template.
  //       By default, templates are stored in a global variable used by the runtime.
  //       A custom loader will be necessary to load your custom wrapper.
  opts = opts || {};
  var env = opts.env || new Environment([]);
  var wrapper = opts.wrapper || precompileGlobal;

  if (opts.isString) {
    return precompileString(input, opts);
  }

  var pathStats = fs.existsSync(input) && fs.statSync(input);
  var precompiled = [];
  var templates = [];

  function addTemplates(dir) {
    fs.readdirSync(dir).forEach(function (file) {
      var filepath = path.join(dir, file);
      var subpath = filepath.substr(path.join(input, '/').length);
      var stat = fs.statSync(filepath);

      if (stat && stat.isDirectory()) {
        subpath += '/';

        if (!match(subpath, opts.exclude)) {
          addTemplates(filepath);
        }
      } else if (match(subpath, opts.include)) {
        templates.push(filepath);
      }
    });
  }

  if (pathStats.isFile()) {
    precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
  } else if (pathStats.isDirectory()) {
    addTemplates(input);

    for (var i = 0; i < templates.length; i++) {
      var name = templates[i].replace(path.join(input, '/'), '');

      try {
        precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
      } catch (e) {
        if (opts.force) {
          // Don't stop generating the output if we're
          // forcing compilation.
          console.error(e); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }
    }
  }

  return wrapper(precompiled, opts);
}

function _precompile(str, name, env) {
  env = env || new Environment([]);
  var asyncFilters = env.asyncFilters;
  var extensions = env.extensionsList;
  var template;
  name = name.replace(/\\/g, '/');

  try {
    template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
  } catch (err) {
    throw _prettifyError(name, false, err);
  }

  return {
    name: name,
    template: template
  };
}

module.exports = {
  precompile: precompile,
  precompileString: precompileString
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function precompileGlobal(templates, opts) {
  var out = '';
  opts = opts || {};

  for (var i = 0; i < templates.length; i++) {
    var name = JSON.stringify(templates[i].name);
    var template = templates[i].template;
    out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

    if (opts.asFunction) {
      out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
    }

    out += '})();\n';
  }

  return out;
}

module.exports = precompileGlobal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

function installCompat() {
  'use strict';
  /* eslint-disable camelcase */
  // This must be called like `nunjucks.installCompat` so that `this`
  // references the nunjucks instance

  var runtime = this.runtime;
  var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

  var Compiler = this.compiler.Compiler;
  var Parser = this.parser.Parser;
  var nodes = this.nodes;
  var lexer = this.lexer;
  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
  var orig_memberLookup = runtime.memberLookup;
  var orig_Compiler_assertType;
  var orig_Parser_parseAggregate;

  if (Compiler) {
    orig_Compiler_assertType = Compiler.prototype.assertType;
  }

  if (Parser) {
    orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
  }

  function uninstall() {
    runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
    runtime.memberLookup = orig_memberLookup;

    if (Compiler) {
      Compiler.prototype.assertType = orig_Compiler_assertType;
    }

    if (Parser) {
      Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
    }
  }

  runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
    var val = orig_contextOrFrameLookup.apply(this, arguments);

    if (val !== undefined) {
      return val;
    }

    switch (key) {
      case 'True':
        return true;

      case 'False':
        return false;

      case 'None':
        return null;

      default:
        return undefined;
    }
  };

  function getTokensState(tokens) {
    return {
      index: tokens.index,
      lineno: tokens.lineno,
      colno: tokens.colno
    };
  }

  if ( true && nodes && Compiler && Parser) {
    // i.e., not slim mode
    var Slice = nodes.Node.extend('Slice', {
      fields: ['start', 'stop', 'step'],
      init: function init(lineno, colno, start, stop, step) {
        start = start || new nodes.Literal(lineno, colno, null);
        stop = stop || new nodes.Literal(lineno, colno, null);
        step = step || new nodes.Literal(lineno, colno, 1);
        this.parent(lineno, colno, start, stop, step);
      }
    });

    Compiler.prototype.assertType = function assertType(node) {
      if (node instanceof Slice) {
        return;
      }

      orig_Compiler_assertType.apply(this, arguments);
    };

    Compiler.prototype.compileSlice = function compileSlice(node, frame) {
      this._emit('(');

      this._compileExpression(node.start, frame);

      this._emit('),(');

      this._compileExpression(node.stop, frame);

      this._emit('),(');

      this._compileExpression(node.step, frame);

      this._emit(')');
    };

    Parser.prototype.parseAggregate = function parseAggregate() {
      var _this = this;

      var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

      origState.colno--;
      origState.index--;

      try {
        return orig_Parser_parseAggregate.apply(this);
      } catch (e) {
        var errState = getTokensState(this.tokens);

        var rethrow = function rethrow() {
          lib._assign(_this.tokens, errState);

          return e;
        }; // Reset to state before original parseAggregate called


        lib._assign(this.tokens, origState);

        this.peeked = false;
        var tok = this.peekToken();

        if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
          throw rethrow();
        } else {
          this.nextToken();
        }

        var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
        // so re-raise the original exception.

        var isSlice = false;

        for (var i = 0; i <= node.fields.length; i++) {
          if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
            break;
          }

          if (i === node.fields.length) {
            if (isSlice) {
              this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
            } else {
              break;
            }
          }

          if (this.skip(lexer.TOKEN_COLON)) {
            isSlice = true;
          } else {
            var field = node.fields[i];
            node[field] = this.parseExpression();
            isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
          }
        }

        if (!isSlice) {
          throw rethrow();
        }

        return new nodes.Array(tok.lineno, tok.colno, [node]);
      }
    };
  }

  function sliceLookup(obj, start, stop, step) {
    obj = obj || [];

    if (start === null) {
      start = step < 0 ? obj.length - 1 : 0;
    }

    if (stop === null) {
      stop = step < 0 ? -1 : obj.length;
    } else if (stop < 0) {
      stop += obj.length;
    }

    if (start < 0) {
      start += obj.length;
    }

    var results = [];

    for (var i = start;; i += step) {
      if (i < 0 || i > obj.length) {
        break;
      }

      if (step > 0 && i >= stop) {
        break;
      }

      if (step < 0 && i <= stop) {
        break;
      }

      results.push(runtime.memberLookup(obj, i));
    }

    return results;
  }

  function hasOwnProp(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  var ARRAY_MEMBERS = {
    pop: function pop(index) {
      if (index === undefined) {
        return this.pop();
      }

      if (index >= this.length || index < 0) {
        throw new Error('KeyError');
      }

      return this.splice(index, 1);
    },
    append: function append(element) {
      return this.push(element);
    },
    remove: function remove(element) {
      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          return this.splice(i, 1);
        }
      }

      throw new Error('ValueError');
    },
    count: function count(element) {
      var count = 0;

      for (var i = 0; i < this.length; i++) {
        if (this[i] === element) {
          count++;
        }
      }

      return count;
    },
    index: function index(element) {
      var i;

      if ((i = this.indexOf(element)) === -1) {
        throw new Error('ValueError');
      }

      return i;
    },
    find: function find(element) {
      return this.indexOf(element);
    },
    insert: function insert(index, elem) {
      return this.splice(index, 0, elem);
    }
  };
  var OBJECT_MEMBERS = {
    items: function items() {
      return lib._entries(this);
    },
    values: function values() {
      return lib._values(this);
    },
    keys: function keys() {
      return lib.keys(this);
    },
    get: function get(key, def) {
      var output = this[key];

      if (output === undefined) {
        output = def;
      }

      return output;
    },
    has_key: function has_key(key) {
      return hasOwnProp(this, key);
    },
    pop: function pop(key, def) {
      var output = this[key];

      if (output === undefined && def !== undefined) {
        output = def;
      } else if (output === undefined) {
        throw new Error('KeyError');
      } else {
        delete this[key];
      }

      return output;
    },
    popitem: function popitem() {
      var keys = lib.keys(this);

      if (!keys.length) {
        throw new Error('KeyError');
      }

      var k = keys[0];
      var val = this[k];
      delete this[k];
      return [k, val];
    },
    setdefault: function setdefault(key, def) {
      if (def === void 0) {
        def = null;
      }

      if (!(key in this)) {
        this[key] = def;
      }

      return this[key];
    },
    update: function update(kwargs) {
      lib._assign(this, kwargs);

      return null; // Always returns None
    }
  };
  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

  runtime.memberLookup = function memberLookup(obj, val, autoescape) {
    if (arguments.length === 4) {
      return sliceLookup.apply(this, arguments);
    }

    obj = obj || {}; // If the object is an object, return any of the methods that Python would
    // otherwise provide.

    if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
      return ARRAY_MEMBERS[val].bind(obj);
    }

    if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
      return OBJECT_MEMBERS[val].bind(obj);
    }

    return orig_memberLookup.apply(this, arguments);
  };

  return uninstall;
}

module.exports = installCompat;

/***/ })
/******/ ]);
});
//# sourceMappingURL=nunjucks.js.map

/***/ }),

/***/ "./node_modules/resonance-audio/build/resonance-audio.js":
/*!***************************************************************!*\
  !*** ./node_modules/resonance-audio/build/resonance-audio.js ***!
  \***************************************************************/
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_536__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_536__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_536__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_536__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_536__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_536__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_536__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_536__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_536__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_536__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_536__(__nested_webpack_require_536__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library common utilities, mathematical constants,
 * and default values.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * @class Utils
 * @description A set of defaults, constants and utility functions.
 */
function Utils() {};


/**
 * Default input gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_GAIN = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field listener by.
 * @type {Number}
 */
Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Maximum outside-the-room distance to attenuate far-field sources by.
 * @type {Number}
 */
Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE = 1;


/**
 * Default distance from listener when setting angle.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_DISTANCE = 1;


/** @type {Float32Array} */
Utils.DEFAULT_POSITION = [0, 0, 0];


/** @type {Float32Array} */
Utils.DEFAULT_FORWARD = [0, 0, -1];


/** @type {Float32Array} */
Utils.DEFAULT_UP = [0, 1, 0];


/** @type {Float32Array} */
Utils.DEFAULT_RIGHT = [1, 0, 0];


/**
 * @type {Number}
 */
Utils.DEFAULT_SPEED_OF_SOUND = 343;


/** Rolloff models (e.g. 'logarithmic', 'linear', or 'none').
 * @type {Array}
 */
Utils.ATTENUATION_ROLLOFFS = ['logarithmic', 'linear', 'none'];


/** Default rolloff model ('logarithmic').
 * @type {string}
 */
Utils.DEFAULT_ATTENUATION_ROLLOFF = 'logarithmic';


/** @type {Number} */
Utils.DEFAULT_MIN_DISTANCE = 1;


/** @type {Number} */
Utils.DEFAULT_MAX_DISTANCE = 1000;


/**
 * The default alpha (i.e. microphone pattern).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_ALPHA = 0;


/**
 * The default pattern sharpness (i.e. pattern exponent).
 * @type {Number}
 */
Utils.DEFAULT_DIRECTIVITY_SHARPNESS = 1;


/**
 * Default azimuth (in degrees). Suitable range is 0 to 360.
 * @type {Number}
 */
Utils.DEFAULT_AZIMUTH = 0;


/**
 * Default elevation (in degres).
 * Suitable range is from -90 (below) to 90 (above).
 * @type {Number}
 */
Utils.DEFAULT_ELEVATION = 0;


/**
 * The default ambisonic order.
 * @type {Number}
 */
Utils.DEFAULT_AMBISONIC_ORDER = 1;


/**
 * The default source width.
 * @type {Number}
 */
Utils.DEFAULT_SOURCE_WIDTH = 0;


/**
 * The maximum delay (in seconds) of a single wall reflection.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MAX_DURATION = 0.5;


/**
 * The -12dB cutoff frequency (in Hertz) for the lowpass filter applied to
 * all reflections.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY = 6400; // Uses -12dB cutoff.


/**
 * The default reflection coefficients (where 0 = no reflection, 1 = perfect
 * reflection, -1 = mirrored reflection (180-degrees out of phase)).
 * @type {Object}
 */
Utils.DEFAULT_REFLECTION_COEFFICIENTS = {
  left: 0, right: 0, front: 0, back: 0, down: 0, up: 0,
};


/**
 * The minimum distance we consider the listener to be to any given wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MIN_DISTANCE = 1;


/**
 * Default room dimensions (in meters).
 * @type {Object}
 */
Utils.DEFAULT_ROOM_DIMENSIONS = {
  width: 0, height: 0, depth: 0,
};


/**
 * The multiplier to apply to distances from the listener to each wall.
 * @type {Number}
 */
Utils.DEFAULT_REFLECTION_MULTIPLIER = 1;


/** The default bandwidth (in octaves) of the center frequencies.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_BANDWIDTH = 1;


/** The default multiplier applied when computing tail lengths.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_DURATION_MULTIPLIER = 1;


/**
 * The late reflections pre-delay (in milliseconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_PREDELAY = 1.5;


/**
 * The length of the beginning of the impulse response to apply a
 * half-Hann window to.
 * @type {Number}
 */
Utils.DEFAULT_REVERB_TAIL_ONSET = 3.8;


/**
 * The default gain (linear).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_GAIN = 0.01;


/**
 * The maximum impulse response length (in seconds).
 * @type {Number}
 */
Utils.DEFAULT_REVERB_MAX_DURATION = 3;


/**
 * Center frequencies of the multiband late reflections.
 * Nine bands are computed by: 31.25 * 2^(0:8).
 * @type {Array}
 */
Utils.DEFAULT_REVERB_FREQUENCY_BANDS = [
  31.25, 62.5, 125, 250, 500, 1000, 2000, 4000, 8000,
];


/**
 * The number of frequency bands.
 */
Utils.NUMBER_REVERB_FREQUENCY_BANDS =
  Utils.DEFAULT_REVERB_FREQUENCY_BANDS.length;


/**
 * The default multiband RT60 durations (in seconds).
 * @type {Float32Array}
 */
Utils.DEFAULT_REVERB_DURATIONS =
  new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);


/**
 * Pre-defined frequency-dependent absorption coefficients for listed materials.
 * Currently supported materials are:
 * <ul>
 * <li>'transparent'</li>
 * <li>'acoustic-ceiling-tiles'</li>
 * <li>'brick-bare'</li>
 * <li>'brick-painted'</li>
 * <li>'concrete-block-coarse'</li>
 * <li>'concrete-block-painted'</li>
 * <li>'curtain-heavy'</li>
 * <li>'fiber-glass-insulation'</li>
 * <li>'glass-thin'</li>
 * <li>'glass-thick'</li>
 * <li>'grass'</li>
 * <li>'linoleum-on-concrete'</li>
 * <li>'marble'</li>
 * <li>'metal'</li>
 * <li>'parquet-on-concrete'</li>
 * <li>'plaster-smooth'</li>
 * <li>'plywood-panel'</li>
 * <li>'polished-concrete-or-tile'</li>
 * <li>'sheetrock'</li>
 * <li>'water-or-ice-surface'</li>
 * <li>'wood-ceiling'</li>
 * <li>'wood-panel'</li>
 * <li>'uniform'</li>
 * </ul>
 * @type {Object}
 */
Utils.ROOM_MATERIAL_COEFFICIENTS = {
  'transparent':
  [1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000],
  'acoustic-ceiling-tiles':
  [0.672, 0.675, 0.700, 0.660, 0.720, 0.920, 0.880, 0.750, 1.000],
  'brick-bare':
  [0.030, 0.030, 0.030, 0.030, 0.030, 0.040, 0.050, 0.070, 0.140],
  'brick-painted':
  [0.006, 0.007, 0.010, 0.010, 0.020, 0.020, 0.020, 0.030, 0.060],
  'concrete-block-coarse':
  [0.360, 0.360, 0.360, 0.440, 0.310, 0.290, 0.390, 0.250, 0.500],
  'concrete-block-painted':
  [0.092, 0.090, 0.100, 0.050, 0.060, 0.070, 0.090, 0.080, 0.160],
  'curtain-heavy':
  [0.073, 0.106, 0.140, 0.350, 0.550, 0.720, 0.700, 0.650, 1.000],
  'fiber-glass-insulation':
  [0.193, 0.220, 0.220, 0.820, 0.990, 0.990, 0.990, 0.990, 1.000],
  'glass-thin':
  [0.180, 0.169, 0.180, 0.060, 0.040, 0.030, 0.020, 0.020, 0.040],
  'glass-thick':
  [0.350, 0.350, 0.350, 0.250, 0.180, 0.120, 0.070, 0.040, 0.080],
  'grass':
  [0.050, 0.050, 0.150, 0.250, 0.400, 0.550, 0.600, 0.600, 0.600],
  'linoleum-on-concrete':
  [0.020, 0.020, 0.020, 0.030, 0.030, 0.030, 0.030, 0.020, 0.040],
  'marble':
  [0.010, 0.010, 0.010, 0.010, 0.010, 0.010, 0.020, 0.020, 0.040],
  'metal':
  [0.030, 0.035, 0.040, 0.040, 0.050, 0.050, 0.050, 0.070, 0.090],
  'parquet-on-concrete':
  [0.028, 0.030, 0.040, 0.040, 0.070, 0.060, 0.060, 0.070, 0.140],
  'plaster-rough':
  [0.017, 0.018, 0.020, 0.030, 0.040, 0.050, 0.040, 0.030, 0.060],
  'plaster-smooth':
  [0.011, 0.012, 0.013, 0.015, 0.020, 0.030, 0.040, 0.050, 0.100],
  'plywood-panel':
  [0.400, 0.340, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'polished-concrete-or-tile':
  [0.008, 0.008, 0.010, 0.010, 0.015, 0.020, 0.020, 0.020, 0.040],
  'sheet-rock':
  [0.290, 0.279, 0.290, 0.100, 0.050, 0.040, 0.070, 0.090, 0.180],
  'water-or-ice-surface':
  [0.006, 0.006, 0.008, 0.008, 0.013, 0.015, 0.020, 0.025, 0.050],
  'wood-ceiling':
  [0.150, 0.147, 0.150, 0.110, 0.100, 0.070, 0.060, 0.070, 0.140],
  'wood-panel':
  [0.280, 0.280, 0.280, 0.220, 0.170, 0.090, 0.100, 0.110, 0.220],
  'uniform':
  [0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500, 0.500],
};


/**
 * Default materials that use strings from
 * {@linkcode Utils.MATERIAL_COEFFICIENTS MATERIAL_COEFFICIENTS}
 * @type {Object}
 */
Utils.DEFAULT_ROOM_MATERIALS = {
  left: 'transparent', right: 'transparent', front: 'transparent',
  back: 'transparent', down: 'transparent', up: 'transparent',
};


/**
 * The number of bands to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.NUMBER_REFLECTION_AVERAGING_BANDS = 3;


/**
 * The starting band to average over when computing reflection coefficients.
 * @type {Number}
 */
Utils.ROOM_STARTING_AVERAGING_BAND = 4;


/**
 * The minimum threshold for room volume.
 * Room model is disabled if volume is below this value.
 * @type {Number} */
Utils.ROOM_MIN_VOLUME = 1e-4;


/**
 * Air absorption coefficients per frequency band.
 * @type {Float32Array}
 */
Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS =
  [0.0006, 0.0006, 0.0007, 0.0008, 0.0010, 0.0015, 0.0026, 0.0060, 0.0207];


/**
 * A scalar correction value to ensure Sabine and Eyring produce the same RT60
 * value at the cross-over threshold.
 * @type {Number}
 */
Utils.ROOM_EYRING_CORRECTION_COEFFICIENT = 1.38;


/**
 * @type {Number}
 * @private
 */
Utils.TWO_PI = 6.28318530717959;


/**
 * @type {Number}
 * @private
 */
Utils.TWENTY_FOUR_LOG10 = 55.2620422318571;


/**
 * @type {Number}
 * @private
 */
Utils.LOG1000 = 6.90775527898214;


/**
 * @type {Number}
 * @private
 */
Utils.LOG2_DIV2 = 0.346573590279973;


/**
 * @type {Number}
 * @private
 */
Utils.DEGREES_TO_RADIANS = 0.017453292519943;


/**
 * @type {Number}
 * @private
 */
Utils.RADIANS_TO_DEGREES = 57.295779513082323;


/**
 * @type {Number}
 * @private
 */
Utils.EPSILON_FLOAT = 1e-8;


/**
 * ResonanceAudio library logging function.
 * @type {Function}
 * @param {any} Message to be printed out.
 * @private
 */
Utils.log = function() {
  window.console.log.apply(window.console, [
    '%c[ResonanceAudio]%c '
      + Array.prototype.slice.call(arguments).join(' ') + ' %c(@'
      + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 700',
    'font-weight: 400',
    'color: #AAA',
  ]);
};


/**
 * Normalize a 3-d vector.
 * @param {Float32Array} v 3-element vector.
 * @return {Float32Array} 3-element vector.
 * @private
 */
Utils.normalizeVector = function(v) {
  let n = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  if (n > exports.EPSILON_FLOAT) {
    n = 1 / n;
    v[0] *= n;
    v[1] *= n;
    v[2] *= n;
  }
  return v;
};


/**
 * Cross-product between two 3-d vectors.
 * @param {Float32Array} a 3-element vector.
 * @param {Float32Array} b 3-element vector.
 * @return {Float32Array}
 * @private
 */
Utils.crossProduct = function(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0],
  ];
};

module.exports = Utils;


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_13812__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Spatially encodes input using weighted spherical harmonics.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Tables = __nested_webpack_require_13812__(3);
const Utils = __nested_webpack_require_13812__(0);


/**
 * @class Encoder
 * @description Spatially encodes input using weighted spherical harmonics.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Number} options.azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} options.elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Encoder(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Encoder
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Encoder
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.azimuth == undefined) {
    options.azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (options.elevation == undefined) {
    options.elevation = Utils.DEFAULT_ELEVATION;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  this._context = context;

  // Create I/O nodes.
  this.input = context.createGain();
  this._channelGain = [];
  this._merger = undefined;
  this.output = context.createGain();

  // Set initial order, angle and source width.
  this.setAmbisonicOrder(options.ambisonicOrder);
  this._azimuth = options.azimuth;
  this._elevation = options.elevation;
  this.setSourceWidth(options.sourceWidth);
}

/**
 * Set the desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
Encoder.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);

  this.input.disconnect();
  for (let i = 0; i < this._channelGain.length; i++) {
    this._channelGain[i].disconnect();
  }
  if (this._merger != undefined) {
    this._merger.disconnect();
  }
  delete this._channelGain;
  delete this._merger;

  // Create audio graph.
  let numChannels = (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);
  this._merger = this._context.createChannelMerger(numChannels);
  this._channelGain = new Array(numChannels);
  for (let i = 0; i < numChannels; i++) {
    this._channelGain[i] = this._context.createGain();
    this.input.connect(this._channelGain[i]);
    this._channelGain[i].connect(this._merger, 0, i);
  }
  this._merger.connect(this.output);
};


/**
 * Set the direction of the encoded source signal.
 * @param {Number} azimuth
 * Azimuth (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_AZIMUTH DEFAULT_AZIMUTH}.
 * @param {Number} elevation
 * Elevation (in degrees). Defaults to
 * {@linkcode Utils.DEFAULT_ELEVATION DEFAULT_ELEVATION}.
 */
Encoder.prototype.setDirection = function(azimuth, elevation) {
  // Format input direction to nearest indices.
  if (azimuth == undefined || isNaN(azimuth)) {
    azimuth = Utils.DEFAULT_AZIMUTH;
  }
  if (elevation == undefined || isNaN(elevation)) {
    elevation = Utils.DEFAULT_ELEVATION;
  }

  // Store the formatted input (for updating source width).
  this._azimuth = azimuth;
  this._elevation = elevation;

  // Format direction for index lookups.
  azimuth = Math.round(azimuth % 360);
  if (azimuth < 0) {
    azimuth += 360;
  }
  elevation = Math.round(Math.min(90, Math.max(-90, elevation))) + 90;

  // Assign gains to each output.
  this._channelGain[0].gain.value = Tables.MAX_RE_WEIGHTS[this._spreadIndex][0];
  for (let i = 1; i <= this._ambisonicOrder; i++) {
    let degreeWeight = Tables.MAX_RE_WEIGHTS[this._spreadIndex][i];
    for (let j = -i; j <= i; j++) {
      let acnChannel = (i * i) + i + j;
      let elevationIndex = i * (i + 1) / 2 + Math.abs(j) - 1;
      let val = Tables.SPHERICAL_HARMONICS[1][elevation][elevationIndex];
      if (j != 0) {
        let azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j - 1;
        if (j < 0) {
          azimuthIndex = Tables.SPHERICAL_HARMONICS_MAX_ORDER + j;
        }
        val *= Tables.SPHERICAL_HARMONICS[0][azimuth][azimuthIndex];
      }
      this._channelGain[acnChannel].gain.value = val * degreeWeight;
    }
  }
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Encoder.prototype.setSourceWidth = function(sourceWidth) {
  // The MAX_RE_WEIGHTS is a 360 x (Tables.SPHERICAL_HARMONICS_MAX_ORDER+1)
  // size table.
  this._spreadIndex = Math.min(359, Math.max(0, Math.round(sourceWidth)));
  this.setDirection(this._azimuth, this._elevation);
};


/**
 * Validate the provided ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 * @return {Number} Validated/adjusted ambisonic order.
 * @private
 */
Encoder.validateAmbisonicOrder = function(ambisonicOrder) {
  if (isNaN(ambisonicOrder) || ambisonicOrder == undefined) {
    Utils.log('Error: Invalid ambisonic order',
    options.ambisonicOrder, '\nUsing ambisonicOrder=1 instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder < 1) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Min order is 1)',
    '\nUsing min order instead.');
    ambisonicOrder = 1;
  } else if (ambisonicOrder > Tables.SPHERICAL_HARMONICS_MAX_ORDER) {
    Utils.log('Error: Unable to render ambisonic order',
    options.ambisonicOrder, '(Max order is',
    Tables.SPHERICAL_HARMONICS_MAX_ORDER, ')\nUsing max order instead.');
    options.ambisonicOrder = Tables.SPHERICAL_HARMONICS_MAX_ORDER;
  }
  return ambisonicOrder;
};


module.exports = Encoder;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_21131__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Listener model to spatialize sources in an environment.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Omnitone = __nested_webpack_require_21131__(12);
const Encoder = __nested_webpack_require_21131__(1);
const Utils = __nested_webpack_require_21131__(0);


/**
 * @class Listener
 * @description Listener model to spatialize sources in an environment.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.position
 * Initial position (in meters), where origin is the center of
 * the room. Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The listener's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The listener's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 */
function Listener(context, options) {
  // Public variables.
  /**
   * Position (in meters).
   * @member {Float32Array} position
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Listener
   * @instance
   */
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Listener
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} ambisonicOutput
   * @memberof Listener
   * @instance
   */
  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }

  // Member variables.
  this.position = new Float32Array(3);
  this._tempMatrix3 = new Float32Array(9);

  // Select the appropriate HRIR filters using 2-channel chunks since
  // multichannel audio is not yet supported by a majority of browsers.
  this._ambisonicOrder =
    Encoder.validateAmbisonicOrder(options.ambisonicOrder);

    // Create audio nodes.
  this._context = context;
  if (this._ambisonicOrder == 1) {
    this._renderer = Omnitone.Omnitone.createFOARenderer(context, {});
  } else if (this._ambisonicOrder > 1) {
    this._renderer = Omnitone.Omnitone.createHOARenderer(context, {
      ambisonicOrder: this._ambisonicOrder,
    });
  }

  // These nodes are created in order to safely asynchronously load Omnitone
  // while the rest of the scene is being created.
  this.input = context.createGain();
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();

  // Initialize Omnitone (async) and connect to audio graph when complete.
  let that = this;
  this._renderer.initialize().then(function() {
    // Connect pre-rotated soundfield to renderer.
    that.input.connect(that._renderer.input);

    // Connect rotated soundfield to ambisonic output.
    if (that._ambisonicOrder > 1) {
      that._renderer._hoaRotator.output.connect(that.ambisonicOutput);
    } else {
      that._renderer._foaRotator.output.connect(that.ambisonicOutput);
    }

    // Connect binaurally-rendered soundfield to binaural output.
    that._renderer.output.connect(that.output);
  });

  // Set orientation and update rotation matrix accordingly.
  this.setOrientation(options.forward[0], options.forward[1],
    options.forward[2], options.up[0], options.up[1], options.up[2]);
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Listener.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
  upX, upY, upZ) {
  let right = Utils.crossProduct([forwardX, forwardY, forwardZ],
    [upX, upY, upZ]);
  this._tempMatrix3[0] = right[0];
  this._tempMatrix3[1] = right[1];
  this._tempMatrix3[2] = right[2];
  this._tempMatrix3[3] = upX;
  this._tempMatrix3[4] = upY;
  this._tempMatrix3[5] = upZ;
  this._tempMatrix3[6] = forwardX;
  this._tempMatrix3[7] = forwardY;
  this._tempMatrix3[8] = forwardZ;
  this._renderer.setRotationMatrix3(this._tempMatrix3);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix4
 * The Three.js Matrix4 object representing the listener's world transform.
 */
Listener.prototype.setFromMatrix = function(matrix4) {
  // Update ambisonic rotation matrix internally.
  this._renderer.setRotationMatrix4(matrix4.elements);

  // Extract position from matrix.
  this.position[0] = matrix4.elements[12];
  this.position[1] = matrix4.elements[13];
  this.position[2] = matrix4.elements[14];
};


module.exports = Listener;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Pre-computed lookup tables for encoding ambisonic sources.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * Pre-computed Spherical Harmonics Coefficients.
 *
 * This function generates an efficient lookup table of SH coefficients. It
 * exploits the way SHs are generated (i.e. Ylm = Nlm * Plm * Em). Since Nlm
 * & Plm coefficients only depend on theta, and Em only depends on phi, we
 * can separate the equation along these lines. Em does not depend on
 * degree, so we only need to compute (2 * l) per azimuth Em total and
 * Nlm * Plm is symmetrical across indexes, so only positive indexes are
 * computed ((l + 1) * (l + 2) / 2 - 1) per elevation.
 * @type {Float32Array}
 */
exports.SPHERICAL_HARMONICS =
[
  [
    [0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000],
    [0.052336, 0.034899, 0.017452, 0.999848, 0.999391, 0.998630],
    [0.104528, 0.069756, 0.034899, 0.999391, 0.997564, 0.994522],
    [0.156434, 0.104528, 0.052336, 0.998630, 0.994522, 0.987688],
    [0.207912, 0.139173, 0.069756, 0.997564, 0.990268, 0.978148],
    [0.258819, 0.173648, 0.087156, 0.996195, 0.984808, 0.965926],
    [0.309017, 0.207912, 0.104528, 0.994522, 0.978148, 0.951057],
    [0.358368, 0.241922, 0.121869, 0.992546, 0.970296, 0.933580],
    [0.406737, 0.275637, 0.139173, 0.990268, 0.961262, 0.913545],
    [0.453990, 0.309017, 0.156434, 0.987688, 0.951057, 0.891007],
    [0.500000, 0.342020, 0.173648, 0.984808, 0.939693, 0.866025],
    [0.544639, 0.374607, 0.190809, 0.981627, 0.927184, 0.838671],
    [0.587785, 0.406737, 0.207912, 0.978148, 0.913545, 0.809017],
    [0.629320, 0.438371, 0.224951, 0.974370, 0.898794, 0.777146],
    [0.669131, 0.469472, 0.241922, 0.970296, 0.882948, 0.743145],
    [0.707107, 0.500000, 0.258819, 0.965926, 0.866025, 0.707107],
    [0.743145, 0.529919, 0.275637, 0.961262, 0.848048, 0.669131],
    [0.777146, 0.559193, 0.292372, 0.956305, 0.829038, 0.629320],
    [0.809017, 0.587785, 0.309017, 0.951057, 0.809017, 0.587785],
    [0.838671, 0.615661, 0.325568, 0.945519, 0.788011, 0.544639],
    [0.866025, 0.642788, 0.342020, 0.939693, 0.766044, 0.500000],
    [0.891007, 0.669131, 0.358368, 0.933580, 0.743145, 0.453990],
    [0.913545, 0.694658, 0.374607, 0.927184, 0.719340, 0.406737],
    [0.933580, 0.719340, 0.390731, 0.920505, 0.694658, 0.358368],
    [0.951057, 0.743145, 0.406737, 0.913545, 0.669131, 0.309017],
    [0.965926, 0.766044, 0.422618, 0.906308, 0.642788, 0.258819],
    [0.978148, 0.788011, 0.438371, 0.898794, 0.615661, 0.207912],
    [0.987688, 0.809017, 0.453990, 0.891007, 0.587785, 0.156434],
    [0.994522, 0.829038, 0.469472, 0.882948, 0.559193, 0.104528],
    [0.998630, 0.848048, 0.484810, 0.874620, 0.529919, 0.052336],
    [1.000000, 0.866025, 0.500000, 0.866025, 0.500000, 0.000000],
    [0.998630, 0.882948, 0.515038, 0.857167, 0.469472, -0.052336],
    [0.994522, 0.898794, 0.529919, 0.848048, 0.438371, -0.104528],
    [0.987688, 0.913545, 0.544639, 0.838671, 0.406737, -0.156434],
    [0.978148, 0.927184, 0.559193, 0.829038, 0.374607, -0.207912],
    [0.965926, 0.939693, 0.573576, 0.819152, 0.342020, -0.258819],
    [0.951057, 0.951057, 0.587785, 0.809017, 0.309017, -0.309017],
    [0.933580, 0.961262, 0.601815, 0.798636, 0.275637, -0.358368],
    [0.913545, 0.970296, 0.615661, 0.788011, 0.241922, -0.406737],
    [0.891007, 0.978148, 0.629320, 0.777146, 0.207912, -0.453990],
    [0.866025, 0.984808, 0.642788, 0.766044, 0.173648, -0.500000],
    [0.838671, 0.990268, 0.656059, 0.754710, 0.139173, -0.544639],
    [0.809017, 0.994522, 0.669131, 0.743145, 0.104528, -0.587785],
    [0.777146, 0.997564, 0.681998, 0.731354, 0.069756, -0.629320],
    [0.743145, 0.999391, 0.694658, 0.719340, 0.034899, -0.669131],
    [0.707107, 1.000000, 0.707107, 0.707107, 0.000000, -0.707107],
    [0.669131, 0.999391, 0.719340, 0.694658, -0.034899, -0.743145],
    [0.629320, 0.997564, 0.731354, 0.681998, -0.069756, -0.777146],
    [0.587785, 0.994522, 0.743145, 0.669131, -0.104528, -0.809017],
    [0.544639, 0.990268, 0.754710, 0.656059, -0.139173, -0.838671],
    [0.500000, 0.984808, 0.766044, 0.642788, -0.173648, -0.866025],
    [0.453990, 0.978148, 0.777146, 0.629320, -0.207912, -0.891007],
    [0.406737, 0.970296, 0.788011, 0.615661, -0.241922, -0.913545],
    [0.358368, 0.961262, 0.798636, 0.601815, -0.275637, -0.933580],
    [0.309017, 0.951057, 0.809017, 0.587785, -0.309017, -0.951057],
    [0.258819, 0.939693, 0.819152, 0.573576, -0.342020, -0.965926],
    [0.207912, 0.927184, 0.829038, 0.559193, -0.374607, -0.978148],
    [0.156434, 0.913545, 0.838671, 0.544639, -0.406737, -0.987688],
    [0.104528, 0.898794, 0.848048, 0.529919, -0.438371, -0.994522],
    [0.052336, 0.882948, 0.857167, 0.515038, -0.469472, -0.998630],
    [0.000000, 0.866025, 0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, 0.848048, 0.874620, 0.484810, -0.529919, -0.998630],
    [-0.104528, 0.829038, 0.882948, 0.469472, -0.559193, -0.994522],
    [-0.156434, 0.809017, 0.891007, 0.453990, -0.587785, -0.987688],
    [-0.207912, 0.788011, 0.898794, 0.438371, -0.615661, -0.978148],
    [-0.258819, 0.766044, 0.906308, 0.422618, -0.642788, -0.965926],
    [-0.309017, 0.743145, 0.913545, 0.406737, -0.669131, -0.951057],
    [-0.358368, 0.719340, 0.920505, 0.390731, -0.694658, -0.933580],
    [-0.406737, 0.694658, 0.927184, 0.374607, -0.719340, -0.913545],
    [-0.453990, 0.669131, 0.933580, 0.358368, -0.743145, -0.891007],
    [-0.500000, 0.642788, 0.939693, 0.342020, -0.766044, -0.866025],
    [-0.544639, 0.615661, 0.945519, 0.325568, -0.788011, -0.838671],
    [-0.587785, 0.587785, 0.951057, 0.309017, -0.809017, -0.809017],
    [-0.629320, 0.559193, 0.956305, 0.292372, -0.829038, -0.777146],
    [-0.669131, 0.529919, 0.961262, 0.275637, -0.848048, -0.743145],
    [-0.707107, 0.500000, 0.965926, 0.258819, -0.866025, -0.707107],
    [-0.743145, 0.469472, 0.970296, 0.241922, -0.882948, -0.669131],
    [-0.777146, 0.438371, 0.974370, 0.224951, -0.898794, -0.629320],
    [-0.809017, 0.406737, 0.978148, 0.207912, -0.913545, -0.587785],
    [-0.838671, 0.374607, 0.981627, 0.190809, -0.927184, -0.544639],
    [-0.866025, 0.342020, 0.984808, 0.173648, -0.939693, -0.500000],
    [-0.891007, 0.309017, 0.987688, 0.156434, -0.951057, -0.453990],
    [-0.913545, 0.275637, 0.990268, 0.139173, -0.961262, -0.406737],
    [-0.933580, 0.241922, 0.992546, 0.121869, -0.970296, -0.358368],
    [-0.951057, 0.207912, 0.994522, 0.104528, -0.978148, -0.309017],
    [-0.965926, 0.173648, 0.996195, 0.087156, -0.984808, -0.258819],
    [-0.978148, 0.139173, 0.997564, 0.069756, -0.990268, -0.207912],
    [-0.987688, 0.104528, 0.998630, 0.052336, -0.994522, -0.156434],
    [-0.994522, 0.069756, 0.999391, 0.034899, -0.997564, -0.104528],
    [-0.998630, 0.034899, 0.999848, 0.017452, -0.999391, -0.052336],
    [-1.000000, 0.000000, 1.000000, 0.000000, -1.000000, -0.000000],
    [-0.998630, -0.034899, 0.999848, -0.017452, -0.999391, 0.052336],
    [-0.994522, -0.069756, 0.999391, -0.034899, -0.997564, 0.104528],
    [-0.987688, -0.104528, 0.998630, -0.052336, -0.994522, 0.156434],
    [-0.978148, -0.139173, 0.997564, -0.069756, -0.990268, 0.207912],
    [-0.965926, -0.173648, 0.996195, -0.087156, -0.984808, 0.258819],
    [-0.951057, -0.207912, 0.994522, -0.104528, -0.978148, 0.309017],
    [-0.933580, -0.241922, 0.992546, -0.121869, -0.970296, 0.358368],
    [-0.913545, -0.275637, 0.990268, -0.139173, -0.961262, 0.406737],
    [-0.891007, -0.309017, 0.987688, -0.156434, -0.951057, 0.453990],
    [-0.866025, -0.342020, 0.984808, -0.173648, -0.939693, 0.500000],
    [-0.838671, -0.374607, 0.981627, -0.190809, -0.927184, 0.544639],
    [-0.809017, -0.406737, 0.978148, -0.207912, -0.913545, 0.587785],
    [-0.777146, -0.438371, 0.974370, -0.224951, -0.898794, 0.629320],
    [-0.743145, -0.469472, 0.970296, -0.241922, -0.882948, 0.669131],
    [-0.707107, -0.500000, 0.965926, -0.258819, -0.866025, 0.707107],
    [-0.669131, -0.529919, 0.961262, -0.275637, -0.848048, 0.743145],
    [-0.629320, -0.559193, 0.956305, -0.292372, -0.829038, 0.777146],
    [-0.587785, -0.587785, 0.951057, -0.309017, -0.809017, 0.809017],
    [-0.544639, -0.615661, 0.945519, -0.325568, -0.788011, 0.838671],
    [-0.500000, -0.642788, 0.939693, -0.342020, -0.766044, 0.866025],
    [-0.453990, -0.669131, 0.933580, -0.358368, -0.743145, 0.891007],
    [-0.406737, -0.694658, 0.927184, -0.374607, -0.719340, 0.913545],
    [-0.358368, -0.719340, 0.920505, -0.390731, -0.694658, 0.933580],
    [-0.309017, -0.743145, 0.913545, -0.406737, -0.669131, 0.951057],
    [-0.258819, -0.766044, 0.906308, -0.422618, -0.642788, 0.965926],
    [-0.207912, -0.788011, 0.898794, -0.438371, -0.615661, 0.978148],
    [-0.156434, -0.809017, 0.891007, -0.453990, -0.587785, 0.987688],
    [-0.104528, -0.829038, 0.882948, -0.469472, -0.559193, 0.994522],
    [-0.052336, -0.848048, 0.874620, -0.484810, -0.529919, 0.998630],
    [-0.000000, -0.866025, 0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, -0.882948, 0.857167, -0.515038, -0.469472, 0.998630],
    [0.104528, -0.898794, 0.848048, -0.529919, -0.438371, 0.994522],
    [0.156434, -0.913545, 0.838671, -0.544639, -0.406737, 0.987688],
    [0.207912, -0.927184, 0.829038, -0.559193, -0.374607, 0.978148],
    [0.258819, -0.939693, 0.819152, -0.573576, -0.342020, 0.965926],
    [0.309017, -0.951057, 0.809017, -0.587785, -0.309017, 0.951057],
    [0.358368, -0.961262, 0.798636, -0.601815, -0.275637, 0.933580],
    [0.406737, -0.970296, 0.788011, -0.615661, -0.241922, 0.913545],
    [0.453990, -0.978148, 0.777146, -0.629320, -0.207912, 0.891007],
    [0.500000, -0.984808, 0.766044, -0.642788, -0.173648, 0.866025],
    [0.544639, -0.990268, 0.754710, -0.656059, -0.139173, 0.838671],
    [0.587785, -0.994522, 0.743145, -0.669131, -0.104528, 0.809017],
    [0.629320, -0.997564, 0.731354, -0.681998, -0.069756, 0.777146],
    [0.669131, -0.999391, 0.719340, -0.694658, -0.034899, 0.743145],
    [0.707107, -1.000000, 0.707107, -0.707107, -0.000000, 0.707107],
    [0.743145, -0.999391, 0.694658, -0.719340, 0.034899, 0.669131],
    [0.777146, -0.997564, 0.681998, -0.731354, 0.069756, 0.629320],
    [0.809017, -0.994522, 0.669131, -0.743145, 0.104528, 0.587785],
    [0.838671, -0.990268, 0.656059, -0.754710, 0.139173, 0.544639],
    [0.866025, -0.984808, 0.642788, -0.766044, 0.173648, 0.500000],
    [0.891007, -0.978148, 0.629320, -0.777146, 0.207912, 0.453990],
    [0.913545, -0.970296, 0.615661, -0.788011, 0.241922, 0.406737],
    [0.933580, -0.961262, 0.601815, -0.798636, 0.275637, 0.358368],
    [0.951057, -0.951057, 0.587785, -0.809017, 0.309017, 0.309017],
    [0.965926, -0.939693, 0.573576, -0.819152, 0.342020, 0.258819],
    [0.978148, -0.927184, 0.559193, -0.829038, 0.374607, 0.207912],
    [0.987688, -0.913545, 0.544639, -0.838671, 0.406737, 0.156434],
    [0.994522, -0.898794, 0.529919, -0.848048, 0.438371, 0.104528],
    [0.998630, -0.882948, 0.515038, -0.857167, 0.469472, 0.052336],
    [1.000000, -0.866025, 0.500000, -0.866025, 0.500000, 0.000000],
    [0.998630, -0.848048, 0.484810, -0.874620, 0.529919, -0.052336],
    [0.994522, -0.829038, 0.469472, -0.882948, 0.559193, -0.104528],
    [0.987688, -0.809017, 0.453990, -0.891007, 0.587785, -0.156434],
    [0.978148, -0.788011, 0.438371, -0.898794, 0.615661, -0.207912],
    [0.965926, -0.766044, 0.422618, -0.906308, 0.642788, -0.258819],
    [0.951057, -0.743145, 0.406737, -0.913545, 0.669131, -0.309017],
    [0.933580, -0.719340, 0.390731, -0.920505, 0.694658, -0.358368],
    [0.913545, -0.694658, 0.374607, -0.927184, 0.719340, -0.406737],
    [0.891007, -0.669131, 0.358368, -0.933580, 0.743145, -0.453990],
    [0.866025, -0.642788, 0.342020, -0.939693, 0.766044, -0.500000],
    [0.838671, -0.615661, 0.325568, -0.945519, 0.788011, -0.544639],
    [0.809017, -0.587785, 0.309017, -0.951057, 0.809017, -0.587785],
    [0.777146, -0.559193, 0.292372, -0.956305, 0.829038, -0.629320],
    [0.743145, -0.529919, 0.275637, -0.961262, 0.848048, -0.669131],
    [0.707107, -0.500000, 0.258819, -0.965926, 0.866025, -0.707107],
    [0.669131, -0.469472, 0.241922, -0.970296, 0.882948, -0.743145],
    [0.629320, -0.438371, 0.224951, -0.974370, 0.898794, -0.777146],
    [0.587785, -0.406737, 0.207912, -0.978148, 0.913545, -0.809017],
    [0.544639, -0.374607, 0.190809, -0.981627, 0.927184, -0.838671],
    [0.500000, -0.342020, 0.173648, -0.984808, 0.939693, -0.866025],
    [0.453990, -0.309017, 0.156434, -0.987688, 0.951057, -0.891007],
    [0.406737, -0.275637, 0.139173, -0.990268, 0.961262, -0.913545],
    [0.358368, -0.241922, 0.121869, -0.992546, 0.970296, -0.933580],
    [0.309017, -0.207912, 0.104528, -0.994522, 0.978148, -0.951057],
    [0.258819, -0.173648, 0.087156, -0.996195, 0.984808, -0.965926],
    [0.207912, -0.139173, 0.069756, -0.997564, 0.990268, -0.978148],
    [0.156434, -0.104528, 0.052336, -0.998630, 0.994522, -0.987688],
    [0.104528, -0.069756, 0.034899, -0.999391, 0.997564, -0.994522],
    [0.052336, -0.034899, 0.017452, -0.999848, 0.999391, -0.998630],
    [0.000000, -0.000000, 0.000000, -1.000000, 1.000000, -1.000000],
    [-0.052336, 0.034899, -0.017452, -0.999848, 0.999391, -0.998630],
    [-0.104528, 0.069756, -0.034899, -0.999391, 0.997564, -0.994522],
    [-0.156434, 0.104528, -0.052336, -0.998630, 0.994522, -0.987688],
    [-0.207912, 0.139173, -0.069756, -0.997564, 0.990268, -0.978148],
    [-0.258819, 0.173648, -0.087156, -0.996195, 0.984808, -0.965926],
    [-0.309017, 0.207912, -0.104528, -0.994522, 0.978148, -0.951057],
    [-0.358368, 0.241922, -0.121869, -0.992546, 0.970296, -0.933580],
    [-0.406737, 0.275637, -0.139173, -0.990268, 0.961262, -0.913545],
    [-0.453990, 0.309017, -0.156434, -0.987688, 0.951057, -0.891007],
    [-0.500000, 0.342020, -0.173648, -0.984808, 0.939693, -0.866025],
    [-0.544639, 0.374607, -0.190809, -0.981627, 0.927184, -0.838671],
    [-0.587785, 0.406737, -0.207912, -0.978148, 0.913545, -0.809017],
    [-0.629320, 0.438371, -0.224951, -0.974370, 0.898794, -0.777146],
    [-0.669131, 0.469472, -0.241922, -0.970296, 0.882948, -0.743145],
    [-0.707107, 0.500000, -0.258819, -0.965926, 0.866025, -0.707107],
    [-0.743145, 0.529919, -0.275637, -0.961262, 0.848048, -0.669131],
    [-0.777146, 0.559193, -0.292372, -0.956305, 0.829038, -0.629320],
    [-0.809017, 0.587785, -0.309017, -0.951057, 0.809017, -0.587785],
    [-0.838671, 0.615661, -0.325568, -0.945519, 0.788011, -0.544639],
    [-0.866025, 0.642788, -0.342020, -0.939693, 0.766044, -0.500000],
    [-0.891007, 0.669131, -0.358368, -0.933580, 0.743145, -0.453990],
    [-0.913545, 0.694658, -0.374607, -0.927184, 0.719340, -0.406737],
    [-0.933580, 0.719340, -0.390731, -0.920505, 0.694658, -0.358368],
    [-0.951057, 0.743145, -0.406737, -0.913545, 0.669131, -0.309017],
    [-0.965926, 0.766044, -0.422618, -0.906308, 0.642788, -0.258819],
    [-0.978148, 0.788011, -0.438371, -0.898794, 0.615661, -0.207912],
    [-0.987688, 0.809017, -0.453990, -0.891007, 0.587785, -0.156434],
    [-0.994522, 0.829038, -0.469472, -0.882948, 0.559193, -0.104528],
    [-0.998630, 0.848048, -0.484810, -0.874620, 0.529919, -0.052336],
    [-1.000000, 0.866025, -0.500000, -0.866025, 0.500000, 0.000000],
    [-0.998630, 0.882948, -0.515038, -0.857167, 0.469472, 0.052336],
    [-0.994522, 0.898794, -0.529919, -0.848048, 0.438371, 0.104528],
    [-0.987688, 0.913545, -0.544639, -0.838671, 0.406737, 0.156434],
    [-0.978148, 0.927184, -0.559193, -0.829038, 0.374607, 0.207912],
    [-0.965926, 0.939693, -0.573576, -0.819152, 0.342020, 0.258819],
    [-0.951057, 0.951057, -0.587785, -0.809017, 0.309017, 0.309017],
    [-0.933580, 0.961262, -0.601815, -0.798636, 0.275637, 0.358368],
    [-0.913545, 0.970296, -0.615661, -0.788011, 0.241922, 0.406737],
    [-0.891007, 0.978148, -0.629320, -0.777146, 0.207912, 0.453990],
    [-0.866025, 0.984808, -0.642788, -0.766044, 0.173648, 0.500000],
    [-0.838671, 0.990268, -0.656059, -0.754710, 0.139173, 0.544639],
    [-0.809017, 0.994522, -0.669131, -0.743145, 0.104528, 0.587785],
    [-0.777146, 0.997564, -0.681998, -0.731354, 0.069756, 0.629320],
    [-0.743145, 0.999391, -0.694658, -0.719340, 0.034899, 0.669131],
    [-0.707107, 1.000000, -0.707107, -0.707107, 0.000000, 0.707107],
    [-0.669131, 0.999391, -0.719340, -0.694658, -0.034899, 0.743145],
    [-0.629320, 0.997564, -0.731354, -0.681998, -0.069756, 0.777146],
    [-0.587785, 0.994522, -0.743145, -0.669131, -0.104528, 0.809017],
    [-0.544639, 0.990268, -0.754710, -0.656059, -0.139173, 0.838671],
    [-0.500000, 0.984808, -0.766044, -0.642788, -0.173648, 0.866025],
    [-0.453990, 0.978148, -0.777146, -0.629320, -0.207912, 0.891007],
    [-0.406737, 0.970296, -0.788011, -0.615661, -0.241922, 0.913545],
    [-0.358368, 0.961262, -0.798636, -0.601815, -0.275637, 0.933580],
    [-0.309017, 0.951057, -0.809017, -0.587785, -0.309017, 0.951057],
    [-0.258819, 0.939693, -0.819152, -0.573576, -0.342020, 0.965926],
    [-0.207912, 0.927184, -0.829038, -0.559193, -0.374607, 0.978148],
    [-0.156434, 0.913545, -0.838671, -0.544639, -0.406737, 0.987688],
    [-0.104528, 0.898794, -0.848048, -0.529919, -0.438371, 0.994522],
    [-0.052336, 0.882948, -0.857167, -0.515038, -0.469472, 0.998630],
    [-0.000000, 0.866025, -0.866025, -0.500000, -0.500000, 1.000000],
    [0.052336, 0.848048, -0.874620, -0.484810, -0.529919, 0.998630],
    [0.104528, 0.829038, -0.882948, -0.469472, -0.559193, 0.994522],
    [0.156434, 0.809017, -0.891007, -0.453990, -0.587785, 0.987688],
    [0.207912, 0.788011, -0.898794, -0.438371, -0.615661, 0.978148],
    [0.258819, 0.766044, -0.906308, -0.422618, -0.642788, 0.965926],
    [0.309017, 0.743145, -0.913545, -0.406737, -0.669131, 0.951057],
    [0.358368, 0.719340, -0.920505, -0.390731, -0.694658, 0.933580],
    [0.406737, 0.694658, -0.927184, -0.374607, -0.719340, 0.913545],
    [0.453990, 0.669131, -0.933580, -0.358368, -0.743145, 0.891007],
    [0.500000, 0.642788, -0.939693, -0.342020, -0.766044, 0.866025],
    [0.544639, 0.615661, -0.945519, -0.325568, -0.788011, 0.838671],
    [0.587785, 0.587785, -0.951057, -0.309017, -0.809017, 0.809017],
    [0.629320, 0.559193, -0.956305, -0.292372, -0.829038, 0.777146],
    [0.669131, 0.529919, -0.961262, -0.275637, -0.848048, 0.743145],
    [0.707107, 0.500000, -0.965926, -0.258819, -0.866025, 0.707107],
    [0.743145, 0.469472, -0.970296, -0.241922, -0.882948, 0.669131],
    [0.777146, 0.438371, -0.974370, -0.224951, -0.898794, 0.629320],
    [0.809017, 0.406737, -0.978148, -0.207912, -0.913545, 0.587785],
    [0.838671, 0.374607, -0.981627, -0.190809, -0.927184, 0.544639],
    [0.866025, 0.342020, -0.984808, -0.173648, -0.939693, 0.500000],
    [0.891007, 0.309017, -0.987688, -0.156434, -0.951057, 0.453990],
    [0.913545, 0.275637, -0.990268, -0.139173, -0.961262, 0.406737],
    [0.933580, 0.241922, -0.992546, -0.121869, -0.970296, 0.358368],
    [0.951057, 0.207912, -0.994522, -0.104528, -0.978148, 0.309017],
    [0.965926, 0.173648, -0.996195, -0.087156, -0.984808, 0.258819],
    [0.978148, 0.139173, -0.997564, -0.069756, -0.990268, 0.207912],
    [0.987688, 0.104528, -0.998630, -0.052336, -0.994522, 0.156434],
    [0.994522, 0.069756, -0.999391, -0.034899, -0.997564, 0.104528],
    [0.998630, 0.034899, -0.999848, -0.017452, -0.999391, 0.052336],
    [1.000000, 0.000000, -1.000000, -0.000000, -1.000000, 0.000000],
    [0.998630, -0.034899, -0.999848, 0.017452, -0.999391, -0.052336],
    [0.994522, -0.069756, -0.999391, 0.034899, -0.997564, -0.104528],
    [0.987688, -0.104528, -0.998630, 0.052336, -0.994522, -0.156434],
    [0.978148, -0.139173, -0.997564, 0.069756, -0.990268, -0.207912],
    [0.965926, -0.173648, -0.996195, 0.087156, -0.984808, -0.258819],
    [0.951057, -0.207912, -0.994522, 0.104528, -0.978148, -0.309017],
    [0.933580, -0.241922, -0.992546, 0.121869, -0.970296, -0.358368],
    [0.913545, -0.275637, -0.990268, 0.139173, -0.961262, -0.406737],
    [0.891007, -0.309017, -0.987688, 0.156434, -0.951057, -0.453990],
    [0.866025, -0.342020, -0.984808, 0.173648, -0.939693, -0.500000],
    [0.838671, -0.374607, -0.981627, 0.190809, -0.927184, -0.544639],
    [0.809017, -0.406737, -0.978148, 0.207912, -0.913545, -0.587785],
    [0.777146, -0.438371, -0.974370, 0.224951, -0.898794, -0.629320],
    [0.743145, -0.469472, -0.970296, 0.241922, -0.882948, -0.669131],
    [0.707107, -0.500000, -0.965926, 0.258819, -0.866025, -0.707107],
    [0.669131, -0.529919, -0.961262, 0.275637, -0.848048, -0.743145],
    [0.629320, -0.559193, -0.956305, 0.292372, -0.829038, -0.777146],
    [0.587785, -0.587785, -0.951057, 0.309017, -0.809017, -0.809017],
    [0.544639, -0.615661, -0.945519, 0.325568, -0.788011, -0.838671],
    [0.500000, -0.642788, -0.939693, 0.342020, -0.766044, -0.866025],
    [0.453990, -0.669131, -0.933580, 0.358368, -0.743145, -0.891007],
    [0.406737, -0.694658, -0.927184, 0.374607, -0.719340, -0.913545],
    [0.358368, -0.719340, -0.920505, 0.390731, -0.694658, -0.933580],
    [0.309017, -0.743145, -0.913545, 0.406737, -0.669131, -0.951057],
    [0.258819, -0.766044, -0.906308, 0.422618, -0.642788, -0.965926],
    [0.207912, -0.788011, -0.898794, 0.438371, -0.615661, -0.978148],
    [0.156434, -0.809017, -0.891007, 0.453990, -0.587785, -0.987688],
    [0.104528, -0.829038, -0.882948, 0.469472, -0.559193, -0.994522],
    [0.052336, -0.848048, -0.874620, 0.484810, -0.529919, -0.998630],
    [0.000000, -0.866025, -0.866025, 0.500000, -0.500000, -1.000000],
    [-0.052336, -0.882948, -0.857167, 0.515038, -0.469472, -0.998630],
    [-0.104528, -0.898794, -0.848048, 0.529919, -0.438371, -0.994522],
    [-0.156434, -0.913545, -0.838671, 0.544639, -0.406737, -0.987688],
    [-0.207912, -0.927184, -0.829038, 0.559193, -0.374607, -0.978148],
    [-0.258819, -0.939693, -0.819152, 0.573576, -0.342020, -0.965926],
    [-0.309017, -0.951057, -0.809017, 0.587785, -0.309017, -0.951057],
    [-0.358368, -0.961262, -0.798636, 0.601815, -0.275637, -0.933580],
    [-0.406737, -0.970296, -0.788011, 0.615661, -0.241922, -0.913545],
    [-0.453990, -0.978148, -0.777146, 0.629320, -0.207912, -0.891007],
    [-0.500000, -0.984808, -0.766044, 0.642788, -0.173648, -0.866025],
    [-0.544639, -0.990268, -0.754710, 0.656059, -0.139173, -0.838671],
    [-0.587785, -0.994522, -0.743145, 0.669131, -0.104528, -0.809017],
    [-0.629320, -0.997564, -0.731354, 0.681998, -0.069756, -0.777146],
    [-0.669131, -0.999391, -0.719340, 0.694658, -0.034899, -0.743145],
    [-0.707107, -1.000000, -0.707107, 0.707107, -0.000000, -0.707107],
    [-0.743145, -0.999391, -0.694658, 0.719340, 0.034899, -0.669131],
    [-0.777146, -0.997564, -0.681998, 0.731354, 0.069756, -0.629320],
    [-0.809017, -0.994522, -0.669131, 0.743145, 0.104528, -0.587785],
    [-0.838671, -0.990268, -0.656059, 0.754710, 0.139173, -0.544639],
    [-0.866025, -0.984808, -0.642788, 0.766044, 0.173648, -0.500000],
    [-0.891007, -0.978148, -0.629320, 0.777146, 0.207912, -0.453990],
    [-0.913545, -0.970296, -0.615661, 0.788011, 0.241922, -0.406737],
    [-0.933580, -0.961262, -0.601815, 0.798636, 0.275637, -0.358368],
    [-0.951057, -0.951057, -0.587785, 0.809017, 0.309017, -0.309017],
    [-0.965926, -0.939693, -0.573576, 0.819152, 0.342020, -0.258819],
    [-0.978148, -0.927184, -0.559193, 0.829038, 0.374607, -0.207912],
    [-0.987688, -0.913545, -0.544639, 0.838671, 0.406737, -0.156434],
    [-0.994522, -0.898794, -0.529919, 0.848048, 0.438371, -0.104528],
    [-0.998630, -0.882948, -0.515038, 0.857167, 0.469472, -0.052336],
    [-1.000000, -0.866025, -0.500000, 0.866025, 0.500000, -0.000000],
    [-0.998630, -0.848048, -0.484810, 0.874620, 0.529919, 0.052336],
    [-0.994522, -0.829038, -0.469472, 0.882948, 0.559193, 0.104528],
    [-0.987688, -0.809017, -0.453990, 0.891007, 0.587785, 0.156434],
    [-0.978148, -0.788011, -0.438371, 0.898794, 0.615661, 0.207912],
    [-0.965926, -0.766044, -0.422618, 0.906308, 0.642788, 0.258819],
    [-0.951057, -0.743145, -0.406737, 0.913545, 0.669131, 0.309017],
    [-0.933580, -0.719340, -0.390731, 0.920505, 0.694658, 0.358368],
    [-0.913545, -0.694658, -0.374607, 0.927184, 0.719340, 0.406737],
    [-0.891007, -0.669131, -0.358368, 0.933580, 0.743145, 0.453990],
    [-0.866025, -0.642788, -0.342020, 0.939693, 0.766044, 0.500000],
    [-0.838671, -0.615661, -0.325568, 0.945519, 0.788011, 0.544639],
    [-0.809017, -0.587785, -0.309017, 0.951057, 0.809017, 0.587785],
    [-0.777146, -0.559193, -0.292372, 0.956305, 0.829038, 0.629320],
    [-0.743145, -0.529919, -0.275637, 0.961262, 0.848048, 0.669131],
    [-0.707107, -0.500000, -0.258819, 0.965926, 0.866025, 0.707107],
    [-0.669131, -0.469472, -0.241922, 0.970296, 0.882948, 0.743145],
    [-0.629320, -0.438371, -0.224951, 0.974370, 0.898794, 0.777146],
    [-0.587785, -0.406737, -0.207912, 0.978148, 0.913545, 0.809017],
    [-0.544639, -0.374607, -0.190809, 0.981627, 0.927184, 0.838671],
    [-0.500000, -0.342020, -0.173648, 0.984808, 0.939693, 0.866025],
    [-0.453990, -0.309017, -0.156434, 0.987688, 0.951057, 0.891007],
    [-0.406737, -0.275637, -0.139173, 0.990268, 0.961262, 0.913545],
    [-0.358368, -0.241922, -0.121869, 0.992546, 0.970296, 0.933580],
    [-0.309017, -0.207912, -0.104528, 0.994522, 0.978148, 0.951057],
    [-0.258819, -0.173648, -0.087156, 0.996195, 0.984808, 0.965926],
    [-0.207912, -0.139173, -0.069756, 0.997564, 0.990268, 0.978148],
    [-0.156434, -0.104528, -0.052336, 0.998630, 0.994522, 0.987688],
    [-0.104528, -0.069756, -0.034899, 0.999391, 0.997564, 0.994522],
    [-0.052336, -0.034899, -0.017452, 0.999848, 0.999391, 0.998630],
  ],
  [
    [-1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     -1.000000, -0.000000, 0.000000, -0.000000],
    [-0.999848, 0.017452, 0.999543, -0.030224, 0.000264,
     -0.999086, 0.042733, -0.000590, 0.000004],
    [-0.999391, 0.034899, 0.998173, -0.060411, 0.001055,
     -0.996348, 0.085356, -0.002357, 0.000034],
    [-0.998630, 0.052336, 0.995891, -0.090524, 0.002372,
     -0.991791, 0.127757, -0.005297, 0.000113],
    [-0.997564, 0.069756, 0.992701, -0.120527, 0.004214,
     -0.985429, 0.169828, -0.009400, 0.000268],
    [-0.996195, 0.087156, 0.988606, -0.150384, 0.006578,
     -0.977277, 0.211460, -0.014654, 0.000523],
    [-0.994522, 0.104528, 0.983611, -0.180057, 0.009462,
     -0.967356, 0.252544, -0.021043, 0.000903],
    [-0.992546, 0.121869, 0.977722, -0.209511, 0.012862,
     -0.955693, 0.292976, -0.028547, 0.001431],
    [-0.990268, 0.139173, 0.970946, -0.238709, 0.016774,
     -0.942316, 0.332649, -0.037143, 0.002131],
    [-0.987688, 0.156434, 0.963292, -0.267617, 0.021193,
     -0.927262, 0.371463, -0.046806, 0.003026],
    [-0.984808, 0.173648, 0.954769, -0.296198, 0.026114,
     -0.910569, 0.409317, -0.057505, 0.004140],
    [-0.981627, 0.190809, 0.945388, -0.324419, 0.031530,
     -0.892279, 0.446114, -0.069209, 0.005492],
    [-0.978148, 0.207912, 0.935159, -0.352244, 0.037436,
     -0.872441, 0.481759, -0.081880, 0.007105],
    [-0.974370, 0.224951, 0.924096, -0.379641, 0.043823,
     -0.851105, 0.516162, -0.095481, 0.008999],
    [-0.970296, 0.241922, 0.912211, -0.406574, 0.050685,
     -0.828326, 0.549233, -0.109969, 0.011193],
    [-0.965926, 0.258819, 0.899519, -0.433013, 0.058013,
     -0.804164, 0.580889, -0.125300, 0.013707],
    [-0.961262, 0.275637, 0.886036, -0.458924, 0.065797,
     -0.778680, 0.611050, -0.141427, 0.016556],
    [-0.956305, 0.292372, 0.871778, -0.484275, 0.074029,
     -0.751940, 0.639639, -0.158301, 0.019758],
    [-0.951057, 0.309017, 0.856763, -0.509037, 0.082698,
     -0.724012, 0.666583, -0.175868, 0.023329],
    [-0.945519, 0.325568, 0.841008, -0.533178, 0.091794,
     -0.694969, 0.691816, -0.194075, 0.027281],
    [-0.939693, 0.342020, 0.824533, -0.556670, 0.101306,
     -0.664885, 0.715274, -0.212865, 0.031630],
    [-0.933580, 0.358368, 0.807359, -0.579484, 0.111222,
     -0.633837, 0.736898, -0.232180, 0.036385],
    [-0.927184, 0.374607, 0.789505, -0.601592, 0.121529,
     -0.601904, 0.756637, -0.251960, 0.041559],
    [-0.920505, 0.390731, 0.770994, -0.622967, 0.132217,
     -0.569169, 0.774442, -0.272143, 0.047160],
    [-0.913545, 0.406737, 0.751848, -0.643582, 0.143271,
     -0.535715, 0.790270, -0.292666, 0.053196],
    [-0.906308, 0.422618, 0.732091, -0.663414, 0.154678,
     -0.501627, 0.804083, -0.313464, 0.059674],
    [-0.898794, 0.438371, 0.711746, -0.682437, 0.166423,
     -0.466993, 0.815850, -0.334472, 0.066599],
    [-0.891007, 0.453990, 0.690839, -0.700629, 0.178494,
     -0.431899, 0.825544, -0.355623, 0.073974],
    [-0.882948, 0.469472, 0.669395, -0.717968, 0.190875,
     -0.396436, 0.833145, -0.376851, 0.081803],
    [-0.874620, 0.484810, 0.647439, -0.734431, 0.203551,
     -0.360692, 0.838638, -0.398086, 0.090085],
    [-0.866025, 0.500000, 0.625000, -0.750000, 0.216506,
     -0.324760, 0.842012, -0.419263, 0.098821],
    [-0.857167, 0.515038, 0.602104, -0.764655, 0.229726,
     -0.288728, 0.843265, -0.440311, 0.108009],
    [-0.848048, 0.529919, 0.578778, -0.778378, 0.243192,
     -0.252688, 0.842399, -0.461164, 0.117644],
    [-0.838671, 0.544639, 0.555052, -0.791154, 0.256891,
     -0.216730, 0.839422, -0.481753, 0.127722],
    [-0.829038, 0.559193, 0.530955, -0.802965, 0.270803,
     -0.180944, 0.834347, -0.502011, 0.138237],
    [-0.819152, 0.573576, 0.506515, -0.813798, 0.284914,
     -0.145420, 0.827194, -0.521871, 0.149181],
    [-0.809017, 0.587785, 0.481763, -0.823639, 0.299204,
     -0.110246, 0.817987, -0.541266, 0.160545],
    [-0.798636, 0.601815, 0.456728, -0.832477, 0.313658,
     -0.075508, 0.806757, -0.560132, 0.172317],
    [-0.788011, 0.615661, 0.431441, -0.840301, 0.328257,
     -0.041294, 0.793541, -0.578405, 0.184487],
    [-0.777146, 0.629320, 0.405934, -0.847101, 0.342984,
     -0.007686, 0.778379, -0.596021, 0.197040],
    [-0.766044, 0.642788, 0.380236, -0.852869, 0.357821,
     0.025233, 0.761319, -0.612921, 0.209963],
    [-0.754710, 0.656059, 0.354380, -0.857597, 0.372749,
     0.057383, 0.742412, -0.629044, 0.223238],
    [-0.743145, 0.669131, 0.328396, -0.861281, 0.387751,
     0.088686, 0.721714, -0.644334, 0.236850],
    [-0.731354, 0.681998, 0.302317, -0.863916, 0.402807,
     0.119068, 0.699288, -0.658734, 0.250778],
    [-0.719340, 0.694658, 0.276175, -0.865498, 0.417901,
     0.148454, 0.675199, -0.672190, 0.265005],
    [-0.707107, 0.707107, 0.250000, -0.866025, 0.433013,
     0.176777, 0.649519, -0.684653, 0.279508],
    [-0.694658, 0.719340, 0.223825, -0.865498, 0.448125,
     0.203969, 0.622322, -0.696073, 0.294267],
    [-0.681998, 0.731354, 0.197683, -0.863916, 0.463218,
     0.229967, 0.593688, -0.706405, 0.309259],
    [-0.669131, 0.743145, 0.171604, -0.861281, 0.478275,
     0.254712, 0.563700, -0.715605, 0.324459],
    [-0.656059, 0.754710, 0.145620, -0.857597, 0.493276,
     0.278147, 0.532443, -0.723633, 0.339844],
    [-0.642788, 0.766044, 0.119764, -0.852869, 0.508205,
     0.300221, 0.500009, -0.730451, 0.355387],
    [-0.629320, 0.777146, 0.094066, -0.847101, 0.523041,
     0.320884, 0.466490, -0.736025, 0.371063],
    [-0.615661, 0.788011, 0.068559, -0.840301, 0.537768,
     0.340093, 0.431982, -0.740324, 0.386845],
    [-0.601815, 0.798636, 0.043272, -0.832477, 0.552367,
     0.357807, 0.396584, -0.743320, 0.402704],
    [-0.587785, 0.809017, 0.018237, -0.823639, 0.566821,
     0.373991, 0.360397, -0.744989, 0.418613],
    [-0.573576, 0.819152, -0.006515, -0.813798, 0.581112,
     0.388612, 0.323524, -0.745308, 0.434544],
    [-0.559193, 0.829038, -0.030955, -0.802965, 0.595222,
     0.401645, 0.286069, -0.744262, 0.450467],
    [-0.544639, 0.838671, -0.055052, -0.791154, 0.609135,
     0.413066, 0.248140, -0.741835, 0.466352],
    [-0.529919, 0.848048, -0.078778, -0.778378, 0.622833,
     0.422856, 0.209843, -0.738017, 0.482171],
    [-0.515038, 0.857167, -0.102104, -0.764655, 0.636300,
     0.431004, 0.171288, -0.732801, 0.497894],
    [-0.500000, 0.866025, -0.125000, -0.750000, 0.649519,
     0.437500, 0.132583, -0.726184, 0.513490],
    [-0.484810, 0.874620, -0.147439, -0.734431, 0.662474,
     0.442340, 0.093837, -0.718167, 0.528929],
    [-0.469472, 0.882948, -0.169395, -0.717968, 0.675150,
     0.445524, 0.055160, -0.708753, 0.544183],
    [-0.453990, 0.891007, -0.190839, -0.700629, 0.687531,
     0.447059, 0.016662, -0.697950, 0.559220],
    [-0.438371, 0.898794, -0.211746, -0.682437, 0.699602,
     0.446953, -0.021550, -0.685769, 0.574011],
    [-0.422618, 0.906308, -0.232091, -0.663414, 0.711348,
     0.445222, -0.059368, -0.672226, 0.588528],
    [-0.406737, 0.913545, -0.251848, -0.643582, 0.722755,
     0.441884, -0.096684, -0.657339, 0.602741],
    [-0.390731, 0.920505, -0.270994, -0.622967, 0.733809,
     0.436964, -0.133395, -0.641130, 0.616621],
    [-0.374607, 0.927184, -0.289505, -0.601592, 0.744496,
     0.430488, -0.169397, -0.623624, 0.630141],
    [-0.358368, 0.933580, -0.307359, -0.579484, 0.754804,
     0.422491, -0.204589, -0.604851, 0.643273],
    [-0.342020, 0.939693, -0.324533, -0.556670, 0.764720,
     0.413008, -0.238872, -0.584843, 0.655990],
    [-0.325568, 0.945519, -0.341008, -0.533178, 0.774231,
     0.402081, -0.272150, -0.563635, 0.668267],
    [-0.309017, 0.951057, -0.356763, -0.509037, 0.783327,
     0.389754, -0.304329, -0.541266, 0.680078],
    [-0.292372, 0.956305, -0.371778, -0.484275, 0.791997,
     0.376077, -0.335319, -0.517778, 0.691399],
    [-0.275637, 0.961262, -0.386036, -0.458924, 0.800228,
     0.361102, -0.365034, -0.493216, 0.702207],
    [-0.258819, 0.965926, -0.399519, -0.433013, 0.808013,
     0.344885, -0.393389, -0.467627, 0.712478],
    [-0.241922, 0.970296, -0.412211, -0.406574, 0.815340,
     0.327486, -0.420306, -0.441061, 0.722191],
    [-0.224951, 0.974370, -0.424096, -0.379641, 0.822202,
     0.308969, -0.445709, -0.413572, 0.731327],
    [-0.207912, 0.978148, -0.435159, -0.352244, 0.828589,
     0.289399, -0.469527, -0.385215, 0.739866],
    [-0.190809, 0.981627, -0.445388, -0.324419, 0.834495,
     0.268846, -0.491693, -0.356047, 0.747790],
    [-0.173648, 0.984808, -0.454769, -0.296198, 0.839912,
     0.247382, -0.512145, -0.326129, 0.755082],
    [-0.156434, 0.987688, -0.463292, -0.267617, 0.844832,
     0.225081, -0.530827, -0.295521, 0.761728],
    [-0.139173, 0.990268, -0.470946, -0.238709, 0.849251,
     0.202020, -0.547684, -0.264287, 0.767712],
    [-0.121869, 0.992546, -0.477722, -0.209511, 0.853163,
     0.178279, -0.562672, -0.232494, 0.773023],
    [-0.104528, 0.994522, -0.483611, -0.180057, 0.856563,
     0.153937, -0.575747, -0.200207, 0.777648],
    [-0.087156, 0.996195, -0.488606, -0.150384, 0.859447,
     0.129078, -0.586872, -0.167494, 0.781579],
    [-0.069756, 0.997564, -0.492701, -0.120527, 0.861811,
     0.103786, -0.596018, -0.134426, 0.784806],
    [-0.052336, 0.998630, -0.495891, -0.090524, 0.863653,
     0.078146, -0.603158, -0.101071, 0.787324],
    [-0.034899, 0.999391, -0.498173, -0.060411, 0.864971,
     0.052243, -0.608272, -0.067500, 0.789126],
    [-0.017452, 0.999848, -0.499543, -0.030224, 0.865762,
     0.026165, -0.611347, -0.033786, 0.790208],
    [0.000000, 1.000000, -0.500000, 0.000000, 0.866025,
     -0.000000, -0.612372, 0.000000, 0.790569],
    [0.017452, 0.999848, -0.499543, 0.030224, 0.865762,
     -0.026165, -0.611347, 0.033786, 0.790208],
    [0.034899, 0.999391, -0.498173, 0.060411, 0.864971,
     -0.052243, -0.608272, 0.067500, 0.789126],
    [0.052336, 0.998630, -0.495891, 0.090524, 0.863653,
     -0.078146, -0.603158, 0.101071, 0.787324],
    [0.069756, 0.997564, -0.492701, 0.120527, 0.861811,
     -0.103786, -0.596018, 0.134426, 0.784806],
    [0.087156, 0.996195, -0.488606, 0.150384, 0.859447,
     -0.129078, -0.586872, 0.167494, 0.781579],
    [0.104528, 0.994522, -0.483611, 0.180057, 0.856563,
     -0.153937, -0.575747, 0.200207, 0.777648],
    [0.121869, 0.992546, -0.477722, 0.209511, 0.853163,
     -0.178279, -0.562672, 0.232494, 0.773023],
    [0.139173, 0.990268, -0.470946, 0.238709, 0.849251,
     -0.202020, -0.547684, 0.264287, 0.767712],
    [0.156434, 0.987688, -0.463292, 0.267617, 0.844832,
     -0.225081, -0.530827, 0.295521, 0.761728],
    [0.173648, 0.984808, -0.454769, 0.296198, 0.839912,
     -0.247382, -0.512145, 0.326129, 0.755082],
    [0.190809, 0.981627, -0.445388, 0.324419, 0.834495,
     -0.268846, -0.491693, 0.356047, 0.747790],
    [0.207912, 0.978148, -0.435159, 0.352244, 0.828589,
     -0.289399, -0.469527, 0.385215, 0.739866],
    [0.224951, 0.974370, -0.424096, 0.379641, 0.822202,
     -0.308969, -0.445709, 0.413572, 0.731327],
    [0.241922, 0.970296, -0.412211, 0.406574, 0.815340,
     -0.327486, -0.420306, 0.441061, 0.722191],
    [0.258819, 0.965926, -0.399519, 0.433013, 0.808013,
     -0.344885, -0.393389, 0.467627, 0.712478],
    [0.275637, 0.961262, -0.386036, 0.458924, 0.800228,
     -0.361102, -0.365034, 0.493216, 0.702207],
    [0.292372, 0.956305, -0.371778, 0.484275, 0.791997,
     -0.376077, -0.335319, 0.517778, 0.691399],
    [0.309017, 0.951057, -0.356763, 0.509037, 0.783327,
     -0.389754, -0.304329, 0.541266, 0.680078],
    [0.325568, 0.945519, -0.341008, 0.533178, 0.774231,
     -0.402081, -0.272150, 0.563635, 0.668267],
    [0.342020, 0.939693, -0.324533, 0.556670, 0.764720,
     -0.413008, -0.238872, 0.584843, 0.655990],
    [0.358368, 0.933580, -0.307359, 0.579484, 0.754804,
     -0.422491, -0.204589, 0.604851, 0.643273],
    [0.374607, 0.927184, -0.289505, 0.601592, 0.744496,
     -0.430488, -0.169397, 0.623624, 0.630141],
    [0.390731, 0.920505, -0.270994, 0.622967, 0.733809,
     -0.436964, -0.133395, 0.641130, 0.616621],
    [0.406737, 0.913545, -0.251848, 0.643582, 0.722755,
     -0.441884, -0.096684, 0.657339, 0.602741],
    [0.422618, 0.906308, -0.232091, 0.663414, 0.711348,
     -0.445222, -0.059368, 0.672226, 0.588528],
    [0.438371, 0.898794, -0.211746, 0.682437, 0.699602,
     -0.446953, -0.021550, 0.685769, 0.574011],
    [0.453990, 0.891007, -0.190839, 0.700629, 0.687531,
     -0.447059, 0.016662, 0.697950, 0.559220],
    [0.469472, 0.882948, -0.169395, 0.717968, 0.675150,
     -0.445524, 0.055160, 0.708753, 0.544183],
    [0.484810, 0.874620, -0.147439, 0.734431, 0.662474,
     -0.442340, 0.093837, 0.718167, 0.528929],
    [0.500000, 0.866025, -0.125000, 0.750000, 0.649519,
     -0.437500, 0.132583, 0.726184, 0.513490],
    [0.515038, 0.857167, -0.102104, 0.764655, 0.636300,
     -0.431004, 0.171288, 0.732801, 0.497894],
    [0.529919, 0.848048, -0.078778, 0.778378, 0.622833,
     -0.422856, 0.209843, 0.738017, 0.482171],
    [0.544639, 0.838671, -0.055052, 0.791154, 0.609135,
     -0.413066, 0.248140, 0.741835, 0.466352],
    [0.559193, 0.829038, -0.030955, 0.802965, 0.595222,
     -0.401645, 0.286069, 0.744262, 0.450467],
    [0.573576, 0.819152, -0.006515, 0.813798, 0.581112,
     -0.388612, 0.323524, 0.745308, 0.434544],
    [0.587785, 0.809017, 0.018237, 0.823639, 0.566821,
     -0.373991, 0.360397, 0.744989, 0.418613],
    [0.601815, 0.798636, 0.043272, 0.832477, 0.552367,
     -0.357807, 0.396584, 0.743320, 0.402704],
    [0.615661, 0.788011, 0.068559, 0.840301, 0.537768,
     -0.340093, 0.431982, 0.740324, 0.386845],
    [0.629320, 0.777146, 0.094066, 0.847101, 0.523041,
     -0.320884, 0.466490, 0.736025, 0.371063],
    [0.642788, 0.766044, 0.119764, 0.852869, 0.508205,
     -0.300221, 0.500009, 0.730451, 0.355387],
    [0.656059, 0.754710, 0.145620, 0.857597, 0.493276,
     -0.278147, 0.532443, 0.723633, 0.339844],
    [0.669131, 0.743145, 0.171604, 0.861281, 0.478275,
     -0.254712, 0.563700, 0.715605, 0.324459],
    [0.681998, 0.731354, 0.197683, 0.863916, 0.463218,
     -0.229967, 0.593688, 0.706405, 0.309259],
    [0.694658, 0.719340, 0.223825, 0.865498, 0.448125,
     -0.203969, 0.622322, 0.696073, 0.294267],
    [0.707107, 0.707107, 0.250000, 0.866025, 0.433013,
     -0.176777, 0.649519, 0.684653, 0.279508],
    [0.719340, 0.694658, 0.276175, 0.865498, 0.417901,
     -0.148454, 0.675199, 0.672190, 0.265005],
    [0.731354, 0.681998, 0.302317, 0.863916, 0.402807,
     -0.119068, 0.699288, 0.658734, 0.250778],
    [0.743145, 0.669131, 0.328396, 0.861281, 0.387751,
     -0.088686, 0.721714, 0.644334, 0.236850],
    [0.754710, 0.656059, 0.354380, 0.857597, 0.372749,
     -0.057383, 0.742412, 0.629044, 0.223238],
    [0.766044, 0.642788, 0.380236, 0.852869, 0.357821,
     -0.025233, 0.761319, 0.612921, 0.209963],
    [0.777146, 0.629320, 0.405934, 0.847101, 0.342984,
     0.007686, 0.778379, 0.596021, 0.197040],
    [0.788011, 0.615661, 0.431441, 0.840301, 0.328257,
     0.041294, 0.793541, 0.578405, 0.184487],
    [0.798636, 0.601815, 0.456728, 0.832477, 0.313658,
     0.075508, 0.806757, 0.560132, 0.172317],
    [0.809017, 0.587785, 0.481763, 0.823639, 0.299204,
     0.110246, 0.817987, 0.541266, 0.160545],
    [0.819152, 0.573576, 0.506515, 0.813798, 0.284914,
     0.145420, 0.827194, 0.521871, 0.149181],
    [0.829038, 0.559193, 0.530955, 0.802965, 0.270803,
     0.180944, 0.834347, 0.502011, 0.138237],
    [0.838671, 0.544639, 0.555052, 0.791154, 0.256891,
     0.216730, 0.839422, 0.481753, 0.127722],
    [0.848048, 0.529919, 0.578778, 0.778378, 0.243192,
     0.252688, 0.842399, 0.461164, 0.117644],
    [0.857167, 0.515038, 0.602104, 0.764655, 0.229726,
     0.288728, 0.843265, 0.440311, 0.108009],
    [0.866025, 0.500000, 0.625000, 0.750000, 0.216506,
     0.324760, 0.842012, 0.419263, 0.098821],
    [0.874620, 0.484810, 0.647439, 0.734431, 0.203551,
     0.360692, 0.838638, 0.398086, 0.090085],
    [0.882948, 0.469472, 0.669395, 0.717968, 0.190875,
     0.396436, 0.833145, 0.376851, 0.081803],
    [0.891007, 0.453990, 0.690839, 0.700629, 0.178494,
     0.431899, 0.825544, 0.355623, 0.073974],
    [0.898794, 0.438371, 0.711746, 0.682437, 0.166423,
     0.466993, 0.815850, 0.334472, 0.066599],
    [0.906308, 0.422618, 0.732091, 0.663414, 0.154678,
     0.501627, 0.804083, 0.313464, 0.059674],
    [0.913545, 0.406737, 0.751848, 0.643582, 0.143271,
     0.535715, 0.790270, 0.292666, 0.053196],
    [0.920505, 0.390731, 0.770994, 0.622967, 0.132217,
     0.569169, 0.774442, 0.272143, 0.047160],
    [0.927184, 0.374607, 0.789505, 0.601592, 0.121529,
     0.601904, 0.756637, 0.251960, 0.041559],
    [0.933580, 0.358368, 0.807359, 0.579484, 0.111222,
     0.633837, 0.736898, 0.232180, 0.036385],
    [0.939693, 0.342020, 0.824533, 0.556670, 0.101306,
     0.664885, 0.715274, 0.212865, 0.031630],
    [0.945519, 0.325568, 0.841008, 0.533178, 0.091794,
     0.694969, 0.691816, 0.194075, 0.027281],
    [0.951057, 0.309017, 0.856763, 0.509037, 0.082698,
     0.724012, 0.666583, 0.175868, 0.023329],
    [0.956305, 0.292372, 0.871778, 0.484275, 0.074029,
     0.751940, 0.639639, 0.158301, 0.019758],
    [0.961262, 0.275637, 0.886036, 0.458924, 0.065797,
     0.778680, 0.611050, 0.141427, 0.016556],
    [0.965926, 0.258819, 0.899519, 0.433013, 0.058013,
     0.804164, 0.580889, 0.125300, 0.013707],
    [0.970296, 0.241922, 0.912211, 0.406574, 0.050685,
     0.828326, 0.549233, 0.109969, 0.011193],
    [0.974370, 0.224951, 0.924096, 0.379641, 0.043823,
     0.851105, 0.516162, 0.095481, 0.008999],
    [0.978148, 0.207912, 0.935159, 0.352244, 0.037436,
     0.872441, 0.481759, 0.081880, 0.007105],
    [0.981627, 0.190809, 0.945388, 0.324419, 0.031530,
     0.892279, 0.446114, 0.069209, 0.005492],
    [0.984808, 0.173648, 0.954769, 0.296198, 0.026114,
     0.910569, 0.409317, 0.057505, 0.004140],
    [0.987688, 0.156434, 0.963292, 0.267617, 0.021193,
     0.927262, 0.371463, 0.046806, 0.003026],
    [0.990268, 0.139173, 0.970946, 0.238709, 0.016774,
     0.942316, 0.332649, 0.037143, 0.002131],
    [0.992546, 0.121869, 0.977722, 0.209511, 0.012862,
     0.955693, 0.292976, 0.028547, 0.001431],
    [0.994522, 0.104528, 0.983611, 0.180057, 0.009462,
     0.967356, 0.252544, 0.021043, 0.000903],
    [0.996195, 0.087156, 0.988606, 0.150384, 0.006578,
     0.977277, 0.211460, 0.014654, 0.000523],
    [0.997564, 0.069756, 0.992701, 0.120527, 0.004214,
     0.985429, 0.169828, 0.009400, 0.000268],
    [0.998630, 0.052336, 0.995891, 0.090524, 0.002372,
     0.991791, 0.127757, 0.005297, 0.000113],
    [0.999391, 0.034899, 0.998173, 0.060411, 0.001055,
     0.996348, 0.085356, 0.002357, 0.000034],
    [0.999848, 0.017452, 0.999543, 0.030224, 0.000264,
     0.999086, 0.042733, 0.000590, 0.000004],
    [1.000000, -0.000000, 1.000000, -0.000000, 0.000000,
     1.000000, -0.000000, 0.000000, -0.000000],
  ],
];


/** @type {Number} */
exports.SPHERICAL_HARMONICS_AZIMUTH_RESOLUTION =
  exports.SPHERICAL_HARMONICS[0].length;


/** @type {Number} */
exports.SPHERICAL_HARMONICS_ELEVATION_RESOLUTION =
  exports.SPHERICAL_HARMONICS[1].length;


/**
 * The maximum allowed ambisonic order.
 * @type {Number}
 */
exports.SPHERICAL_HARMONICS_MAX_ORDER =
  exports.SPHERICAL_HARMONICS[0][0].length / 2;


/**
 * Pre-computed per-band weighting coefficients for producing energy-preserving
 * Max-Re sources.
 */
exports.MAX_RE_WEIGHTS =
[
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.000000, 1.000000, 1.000000, 1.000000],
  [1.003236, 1.002156, 0.999152, 0.990038],
  [1.032370, 1.021194, 0.990433, 0.898572],
  [1.062694, 1.040231, 0.979161, 0.799806],
  [1.093999, 1.058954, 0.964976, 0.693603],
  [1.126003, 1.077006, 0.947526, 0.579890],
  [1.158345, 1.093982, 0.926474, 0.458690],
  [1.190590, 1.109437, 0.901512, 0.330158],
  [1.222228, 1.122890, 0.872370, 0.194621],
  [1.252684, 1.133837, 0.838839, 0.052614],
  [1.281987, 1.142358, 0.801199, 0.000000],
  [1.312073, 1.150207, 0.760839, 0.000000],
  [1.343011, 1.157424, 0.717799, 0.000000],
  [1.374649, 1.163859, 0.671999, 0.000000],
  [1.406809, 1.169354, 0.623371, 0.000000],
  [1.439286, 1.173739, 0.571868, 0.000000],
  [1.471846, 1.176837, 0.517465, 0.000000],
  [1.504226, 1.178465, 0.460174, 0.000000],
  [1.536133, 1.178438, 0.400043, 0.000000],
  [1.567253, 1.176573, 0.337165, 0.000000],
  [1.597247, 1.172695, 0.271688, 0.000000],
  [1.625766, 1.166645, 0.203815, 0.000000],
  [1.652455, 1.158285, 0.133806, 0.000000],
  [1.676966, 1.147506, 0.061983, 0.000000],
  [1.699006, 1.134261, 0.000000, 0.000000],
  [1.720224, 1.119789, 0.000000, 0.000000],
  [1.741631, 1.104810, 0.000000, 0.000000],
  [1.763183, 1.089330, 0.000000, 0.000000],
  [1.784837, 1.073356, 0.000000, 0.000000],
  [1.806548, 1.056898, 0.000000, 0.000000],
  [1.828269, 1.039968, 0.000000, 0.000000],
  [1.849952, 1.022580, 0.000000, 0.000000],
  [1.871552, 1.004752, 0.000000, 0.000000],
  [1.893018, 0.986504, 0.000000, 0.000000],
  [1.914305, 0.967857, 0.000000, 0.000000],
  [1.935366, 0.948837, 0.000000, 0.000000],
  [1.956154, 0.929471, 0.000000, 0.000000],
  [1.976625, 0.909790, 0.000000, 0.000000],
  [1.996736, 0.889823, 0.000000, 0.000000],
  [2.016448, 0.869607, 0.000000, 0.000000],
  [2.035721, 0.849175, 0.000000, 0.000000],
  [2.054522, 0.828565, 0.000000, 0.000000],
  [2.072818, 0.807816, 0.000000, 0.000000],
  [2.090581, 0.786964, 0.000000, 0.000000],
  [2.107785, 0.766051, 0.000000, 0.000000],
  [2.124411, 0.745115, 0.000000, 0.000000],
  [2.140439, 0.724196, 0.000000, 0.000000],
  [2.155856, 0.703332, 0.000000, 0.000000],
  [2.170653, 0.682561, 0.000000, 0.000000],
  [2.184823, 0.661921, 0.000000, 0.000000],
  [2.198364, 0.641445, 0.000000, 0.000000],
  [2.211275, 0.621169, 0.000000, 0.000000],
  [2.223562, 0.601125, 0.000000, 0.000000],
  [2.235230, 0.581341, 0.000000, 0.000000],
  [2.246289, 0.561847, 0.000000, 0.000000],
  [2.256751, 0.542667, 0.000000, 0.000000],
  [2.266631, 0.523826, 0.000000, 0.000000],
  [2.275943, 0.505344, 0.000000, 0.000000],
  [2.284707, 0.487239, 0.000000, 0.000000],
  [2.292939, 0.469528, 0.000000, 0.000000],
  [2.300661, 0.452225, 0.000000, 0.000000],
  [2.307892, 0.435342, 0.000000, 0.000000],
  [2.314654, 0.418888, 0.000000, 0.000000],
  [2.320969, 0.402870, 0.000000, 0.000000],
  [2.326858, 0.387294, 0.000000, 0.000000],
  [2.332343, 0.372164, 0.000000, 0.000000],
  [2.337445, 0.357481, 0.000000, 0.000000],
  [2.342186, 0.343246, 0.000000, 0.000000],
  [2.346585, 0.329458, 0.000000, 0.000000],
  [2.350664, 0.316113, 0.000000, 0.000000],
  [2.354442, 0.303208, 0.000000, 0.000000],
  [2.357937, 0.290738, 0.000000, 0.000000],
  [2.361168, 0.278698, 0.000000, 0.000000],
  [2.364152, 0.267080, 0.000000, 0.000000],
  [2.366906, 0.255878, 0.000000, 0.000000],
  [2.369446, 0.245082, 0.000000, 0.000000],
  [2.371786, 0.234685, 0.000000, 0.000000],
  [2.373940, 0.224677, 0.000000, 0.000000],
  [2.375923, 0.215048, 0.000000, 0.000000],
  [2.377745, 0.205790, 0.000000, 0.000000],
  [2.379421, 0.196891, 0.000000, 0.000000],
  [2.380959, 0.188342, 0.000000, 0.000000],
  [2.382372, 0.180132, 0.000000, 0.000000],
  [2.383667, 0.172251, 0.000000, 0.000000],
  [2.384856, 0.164689, 0.000000, 0.000000],
  [2.385945, 0.157435, 0.000000, 0.000000],
  [2.386943, 0.150479, 0.000000, 0.000000],
  [2.387857, 0.143811, 0.000000, 0.000000],
  [2.388694, 0.137421, 0.000000, 0.000000],
  [2.389460, 0.131299, 0.000000, 0.000000],
  [2.390160, 0.125435, 0.000000, 0.000000],
  [2.390801, 0.119820, 0.000000, 0.000000],
  [2.391386, 0.114445, 0.000000, 0.000000],
  [2.391921, 0.109300, 0.000000, 0.000000],
  [2.392410, 0.104376, 0.000000, 0.000000],
  [2.392857, 0.099666, 0.000000, 0.000000],
  [2.393265, 0.095160, 0.000000, 0.000000],
  [2.393637, 0.090851, 0.000000, 0.000000],
  [2.393977, 0.086731, 0.000000, 0.000000],
  [2.394288, 0.082791, 0.000000, 0.000000],
  [2.394571, 0.079025, 0.000000, 0.000000],
  [2.394829, 0.075426, 0.000000, 0.000000],
  [2.395064, 0.071986, 0.000000, 0.000000],
  [2.395279, 0.068699, 0.000000, 0.000000],
  [2.395475, 0.065558, 0.000000, 0.000000],
  [2.395653, 0.062558, 0.000000, 0.000000],
  [2.395816, 0.059693, 0.000000, 0.000000],
  [2.395964, 0.056955, 0.000000, 0.000000],
  [2.396099, 0.054341, 0.000000, 0.000000],
  [2.396222, 0.051845, 0.000000, 0.000000],
  [2.396334, 0.049462, 0.000000, 0.000000],
  [2.396436, 0.047186, 0.000000, 0.000000],
  [2.396529, 0.045013, 0.000000, 0.000000],
  [2.396613, 0.042939, 0.000000, 0.000000],
  [2.396691, 0.040959, 0.000000, 0.000000],
  [2.396761, 0.039069, 0.000000, 0.000000],
  [2.396825, 0.037266, 0.000000, 0.000000],
  [2.396883, 0.035544, 0.000000, 0.000000],
  [2.396936, 0.033901, 0.000000, 0.000000],
  [2.396984, 0.032334, 0.000000, 0.000000],
  [2.397028, 0.030838, 0.000000, 0.000000],
  [2.397068, 0.029410, 0.000000, 0.000000],
  [2.397104, 0.028048, 0.000000, 0.000000],
  [2.397137, 0.026749, 0.000000, 0.000000],
  [2.397167, 0.025509, 0.000000, 0.000000],
  [2.397194, 0.024326, 0.000000, 0.000000],
  [2.397219, 0.023198, 0.000000, 0.000000],
  [2.397242, 0.022122, 0.000000, 0.000000],
  [2.397262, 0.021095, 0.000000, 0.000000],
  [2.397281, 0.020116, 0.000000, 0.000000],
  [2.397298, 0.019181, 0.000000, 0.000000],
  [2.397314, 0.018290, 0.000000, 0.000000],
  [2.397328, 0.017441, 0.000000, 0.000000],
  [2.397341, 0.016630, 0.000000, 0.000000],
  [2.397352, 0.015857, 0.000000, 0.000000],
  [2.397363, 0.015119, 0.000000, 0.000000],
  [2.397372, 0.014416, 0.000000, 0.000000],
  [2.397381, 0.013745, 0.000000, 0.000000],
  [2.397389, 0.013106, 0.000000, 0.000000],
  [2.397396, 0.012496, 0.000000, 0.000000],
  [2.397403, 0.011914, 0.000000, 0.000000],
  [2.397409, 0.011360, 0.000000, 0.000000],
  [2.397414, 0.010831, 0.000000, 0.000000],
  [2.397419, 0.010326, 0.000000, 0.000000],
  [2.397424, 0.009845, 0.000000, 0.000000],
  [2.397428, 0.009387, 0.000000, 0.000000],
  [2.397432, 0.008949, 0.000000, 0.000000],
  [2.397435, 0.008532, 0.000000, 0.000000],
  [2.397438, 0.008135, 0.000000, 0.000000],
  [2.397441, 0.007755, 0.000000, 0.000000],
  [2.397443, 0.007394, 0.000000, 0.000000],
  [2.397446, 0.007049, 0.000000, 0.000000],
  [2.397448, 0.006721, 0.000000, 0.000000],
  [2.397450, 0.006407, 0.000000, 0.000000],
  [2.397451, 0.006108, 0.000000, 0.000000],
  [2.397453, 0.005824, 0.000000, 0.000000],
  [2.397454, 0.005552, 0.000000, 0.000000],
  [2.397456, 0.005293, 0.000000, 0.000000],
  [2.397457, 0.005046, 0.000000, 0.000000],
  [2.397458, 0.004811, 0.000000, 0.000000],
  [2.397459, 0.004586, 0.000000, 0.000000],
  [2.397460, 0.004372, 0.000000, 0.000000],
  [2.397461, 0.004168, 0.000000, 0.000000],
  [2.397461, 0.003974, 0.000000, 0.000000],
  [2.397462, 0.003788, 0.000000, 0.000000],
  [2.397463, 0.003611, 0.000000, 0.000000],
  [2.397463, 0.003443, 0.000000, 0.000000],
  [2.397464, 0.003282, 0.000000, 0.000000],
  [2.397464, 0.003129, 0.000000, 0.000000],
  [2.397465, 0.002983, 0.000000, 0.000000],
  [2.397465, 0.002844, 0.000000, 0.000000],
  [2.397465, 0.002711, 0.000000, 0.000000],
  [2.397466, 0.002584, 0.000000, 0.000000],
  [2.397466, 0.002464, 0.000000, 0.000000],
  [2.397466, 0.002349, 0.000000, 0.000000],
  [2.397466, 0.002239, 0.000000, 0.000000],
  [2.397467, 0.002135, 0.000000, 0.000000],
  [2.397467, 0.002035, 0.000000, 0.000000],
  [2.397467, 0.001940, 0.000000, 0.000000],
  [2.397467, 0.001849, 0.000000, 0.000000],
  [2.397467, 0.001763, 0.000000, 0.000000],
  [2.397467, 0.001681, 0.000000, 0.000000],
  [2.397468, 0.001602, 0.000000, 0.000000],
  [2.397468, 0.001527, 0.000000, 0.000000],
  [2.397468, 0.001456, 0.000000, 0.000000],
  [2.397468, 0.001388, 0.000000, 0.000000],
  [2.397468, 0.001323, 0.000000, 0.000000],
  [2.397468, 0.001261, 0.000000, 0.000000],
  [2.397468, 0.001202, 0.000000, 0.000000],
  [2.397468, 0.001146, 0.000000, 0.000000],
  [2.397468, 0.001093, 0.000000, 0.000000],
  [2.397468, 0.001042, 0.000000, 0.000000],
  [2.397468, 0.000993, 0.000000, 0.000000],
  [2.397468, 0.000947, 0.000000, 0.000000],
  [2.397468, 0.000902, 0.000000, 0.000000],
  [2.397468, 0.000860, 0.000000, 0.000000],
  [2.397468, 0.000820, 0.000000, 0.000000],
  [2.397469, 0.000782, 0.000000, 0.000000],
  [2.397469, 0.000745, 0.000000, 0.000000],
  [2.397469, 0.000710, 0.000000, 0.000000],
  [2.397469, 0.000677, 0.000000, 0.000000],
  [2.397469, 0.000646, 0.000000, 0.000000],
  [2.397469, 0.000616, 0.000000, 0.000000],
  [2.397469, 0.000587, 0.000000, 0.000000],
  [2.397469, 0.000559, 0.000000, 0.000000],
  [2.397469, 0.000533, 0.000000, 0.000000],
  [2.397469, 0.000508, 0.000000, 0.000000],
  [2.397469, 0.000485, 0.000000, 0.000000],
  [2.397469, 0.000462, 0.000000, 0.000000],
  [2.397469, 0.000440, 0.000000, 0.000000],
  [2.397469, 0.000420, 0.000000, 0.000000],
  [2.397469, 0.000400, 0.000000, 0.000000],
  [2.397469, 0.000381, 0.000000, 0.000000],
  [2.397469, 0.000364, 0.000000, 0.000000],
  [2.397469, 0.000347, 0.000000, 0.000000],
  [2.397469, 0.000330, 0.000000, 0.000000],
  [2.397469, 0.000315, 0.000000, 0.000000],
  [2.397469, 0.000300, 0.000000, 0.000000],
  [2.397469, 0.000286, 0.000000, 0.000000],
  [2.397469, 0.000273, 0.000000, 0.000000],
  [2.397469, 0.000260, 0.000000, 0.000000],
  [2.397469, 0.000248, 0.000000, 0.000000],
  [2.397469, 0.000236, 0.000000, 0.000000],
  [2.397469, 0.000225, 0.000000, 0.000000],
  [2.397469, 0.000215, 0.000000, 0.000000],
  [2.397469, 0.000205, 0.000000, 0.000000],
  [2.397469, 0.000195, 0.000000, 0.000000],
  [2.397469, 0.000186, 0.000000, 0.000000],
  [2.397469, 0.000177, 0.000000, 0.000000],
  [2.397469, 0.000169, 0.000000, 0.000000],
  [2.397469, 0.000161, 0.000000, 0.000000],
  [2.397469, 0.000154, 0.000000, 0.000000],
  [2.397469, 0.000147, 0.000000, 0.000000],
  [2.397469, 0.000140, 0.000000, 0.000000],
  [2.397469, 0.000133, 0.000000, 0.000000],
  [2.397469, 0.000127, 0.000000, 0.000000],
  [2.397469, 0.000121, 0.000000, 0.000000],
  [2.397469, 0.000115, 0.000000, 0.000000],
  [2.397469, 0.000110, 0.000000, 0.000000],
  [2.397469, 0.000105, 0.000000, 0.000000],
  [2.397469, 0.000100, 0.000000, 0.000000],
  [2.397469, 0.000095, 0.000000, 0.000000],
  [2.397469, 0.000091, 0.000000, 0.000000],
  [2.397469, 0.000087, 0.000000, 0.000000],
  [2.397469, 0.000083, 0.000000, 0.000000],
  [2.397469, 0.000079, 0.000000, 0.000000],
  [2.397469, 0.000075, 0.000000, 0.000000],
  [2.397469, 0.000071, 0.000000, 0.000000],
  [2.397469, 0.000068, 0.000000, 0.000000],
  [2.397469, 0.000065, 0.000000, 0.000000],
  [2.397469, 0.000062, 0.000000, 0.000000],
  [2.397469, 0.000059, 0.000000, 0.000000],
  [2.397469, 0.000056, 0.000000, 0.000000],
  [2.397469, 0.000054, 0.000000, 0.000000],
  [2.397469, 0.000051, 0.000000, 0.000000],
  [2.397469, 0.000049, 0.000000, 0.000000],
  [2.397469, 0.000046, 0.000000, 0.000000],
  [2.397469, 0.000044, 0.000000, 0.000000],
  [2.397469, 0.000042, 0.000000, 0.000000],
  [2.397469, 0.000040, 0.000000, 0.000000],
  [2.397469, 0.000038, 0.000000, 0.000000],
  [2.397469, 0.000037, 0.000000, 0.000000],
  [2.397469, 0.000035, 0.000000, 0.000000],
  [2.397469, 0.000033, 0.000000, 0.000000],
  [2.397469, 0.000032, 0.000000, 0.000000],
  [2.397469, 0.000030, 0.000000, 0.000000],
  [2.397469, 0.000029, 0.000000, 0.000000],
  [2.397469, 0.000027, 0.000000, 0.000000],
  [2.397469, 0.000026, 0.000000, 0.000000],
  [2.397469, 0.000025, 0.000000, 0.000000],
  [2.397469, 0.000024, 0.000000, 0.000000],
  [2.397469, 0.000023, 0.000000, 0.000000],
  [2.397469, 0.000022, 0.000000, 0.000000],
  [2.397469, 0.000021, 0.000000, 0.000000],
  [2.397469, 0.000020, 0.000000, 0.000000],
  [2.397469, 0.000019, 0.000000, 0.000000],
  [2.397469, 0.000018, 0.000000, 0.000000],
  [2.397469, 0.000017, 0.000000, 0.000000],
  [2.397469, 0.000016, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000015, 0.000000, 0.000000],
  [2.397469, 0.000014, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000013, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000012, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000011, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000010, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000009, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000008, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000007, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000006, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000005, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000004, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000003, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000002, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
  [2.397469, 0.000001, 0.000000, 0.000000],
];


/** @type {Number} */
exports.MAX_RE_WEIGHTS_RESOLUTION = exports.MAX_RE_WEIGHTS.length;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_88844__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Source model to spatialize an audio buffer.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Directivity = __nested_webpack_require_88844__(5);
const Attenuation = __nested_webpack_require_88844__(6);
const Encoder = __nested_webpack_require_88844__(1);
const Utils = __nested_webpack_require_88844__(0);


/**
 * @class Source
 * @description Source model to spatialize an audio buffer.
 * @param {ResonanceAudio} scene Associated {@link ResonanceAudio
 * ResonanceAudio} instance.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 */
function Source(scene, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Source
   * @instance
   */
  /**
   *
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.position == undefined) {
    options.position = Utils.DEFAULT_POSITION.slice();
  }
  if (options.forward == undefined) {
    options.forward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.up == undefined) {
    options.up = Utils.DEFAULT_UP.slice();
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ROLLOFF;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_SOURCE_GAIN;
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }
  if (options.sourceWidth == undefined) {
    options.sourceWidth = Utils.DEFAULT_SOURCE_WIDTH;
  }

  // Member variables.
  this._scene = scene;
  this._position = options.position;
  this._forward = options.forward;
  this._up = options.up;
  this._dx = new Float32Array(3);
  this._right = Utils.crossProduct(this._forward, this._up);

  // Create audio nodes.
  let context = scene._context;
  this.input = context.createGain();
  this._directivity = new Directivity(context, {
    alpha: options.alpha,
    sharpness: options.sharpness,
  });
  this._toEarly = context.createGain();
  this._toLate = context.createGain();
  this._attenuation = new Attenuation(context, {
    minDistance: options.minDistance,
    maxDistance: options.maxDistance,
    rolloff: options.rolloff,
  });
  this._encoder = new Encoder(context, {
    ambisonicOrder: scene._ambisonicOrder,
    sourceWidth: options.sourceWidth,
  });

  // Connect nodes.
  this.input.connect(this._toLate);
  this._toLate.connect(scene._room.late.input);

  this.input.connect(this._attenuation.input);
  this._attenuation.output.connect(this._toEarly);
  this._toEarly.connect(scene._room.early.input);

  this._attenuation.output.connect(this._directivity.input);
  this._directivity.output.connect(this._encoder.input);

  this._encoder.output.connect(scene._listener.input);

  // Assign initial conditions.
  this.setPosition(
    options.position[0], options.position[1], options.position[2]);
  this.input.gain.value = options.gain;
};


/**
 * Set source's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Source.prototype.setPosition = function(x, y, z) {
  // Assign new position.
  this._position[0] = x;
  this._position[1] = y;
  this._position[2] = z;

  // Handle far-field effect.
  let distance = this._scene._room.getDistanceOutsideRoom(
    this._position[0], this._position[1], this._position[2]);
    let gain = _computeDistanceOutsideRoom(distance);
  this._toLate.gain.value = gain;
  this._toEarly.gain.value = gain;

  this._update();
};


// Update the source when changing the listener's position.
Source.prototype._update = function() {
  // Compute distance to listener.
  for (let i = 0; i < 3; i++) {
    this._dx[i] = this._position[i] - this._scene._listener.position[i];
  }
  let distance = Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[1] * this._dx[1] + this._dx[2] * this._dx[2]);
  if (distance > 0) {
    // Normalize direction vector.
    this._dx[0] /= distance;
    this._dx[1] /= distance;
    this._dx[2] /= distance;
  }

  // Compuete angle of direction vector.
  let azimuth = Math.atan2(-this._dx[0], this._dx[2]) *
    Utils.RADIANS_TO_DEGREES;
  let elevation = Math.atan2(this._dx[1], Math.sqrt(this._dx[0] * this._dx[0] +
    this._dx[2] * this._dx[2])) * Utils.RADIANS_TO_DEGREES;

  // Set distance/directivity/direction values.
  this._attenuation.setDistance(distance);
  this._directivity.computeAngle(this._forward, this._dx);
  this._encoder.setDirection(azimuth, elevation);
};


/**
 * Set source's rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Source.prototype.setRolloff = function(rolloff) {
  this._attenuation.setRolloff(rolloff);
};


/**
 * Set source's minimum distance (in meters).
 * @param {Number} minDistance
 */
Source.prototype.setMinDistance = function(minDistance) {
  this._attenuation.minDistance = minDistance;
};


/**
 * Set source's maximum distance (in meters).
 * @param {Number} maxDistance
 */
Source.prototype.setMaxDistance = function(maxDistance) {
  this._attenuation.maxDistance = maxDistance;
};


/**
 * Set source's gain (linear).
 * @param {Number} gain
 */
Source.prototype.setGain = function(gain) {
  this.input.gain.value = gain;
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
Source.prototype.setOrientation = function(forwardX, forwardY, forwardZ,
    upX, upY, upZ) {
  this._forward[0] = forwardX;
  this._forward[1] = forwardY;
  this._forward[2] = forwardZ;
  this._up[0] = upX;
  this._up[1] = upY;
  this._up[2] = upZ;
  this._right = Utils.crossProduct(this._forward, this._up);
};


// TODO(bitllama): Make sure this works with Three.js as intended.
/**
 * Set source's position and orientation using a
 * Three.js modelViewMatrix object.
 * @param {Float32Array} matrix4
 * The Matrix4 representing the object position and rotation in world space.
 */
Source.prototype.setFromMatrix = function(matrix4) {
  this._right[0] = matrix4.elements[0];
  this._right[1] = matrix4.elements[1];
  this._right[2] = matrix4.elements[2];
  this._up[0] = matrix4.elements[4];
  this._up[1] = matrix4.elements[5];
  this._up[2] = matrix4.elements[6];
  this._forward[0] = matrix4.elements[8];
  this._forward[1] = matrix4.elements[9];
  this._forward[2] = matrix4.elements[10];

  // Normalize to remove scaling.
  this._right = Utils.normalizeVector(this._right);
  this._up = Utils.normalizeVector(this._up);
  this._forward = Utils.normalizeVector(this._forward);

  // Update position.
  this.setPosition(
    matrix4.elements[12], matrix4.elements[13], matrix4.elements[14]);
};


/**
 * Set the source width (in degrees). Where 0 degrees is a point source and 360
 * degrees is an omnidirectional source.
 * @param {Number} sourceWidth (in degrees).
 */
Source.prototype.setSourceWidth = function(sourceWidth) {
  this._encoder.setSourceWidth(sourceWidth);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 */
Source.prototype.setDirectivityPattern = function(alpha, sharpness) {
  this._directivity.setPattern(alpha, sharpness);
  this.setPosition(this._position[0], this._position[1], this._position[2]);
};


/**
 * Determine the distance a source is outside of a room. Attenuate gain going
 * to the reflections and reverb when the source is outside of the room.
 * @param {Number} distance Distance in meters.
 * @return {Number} Gain (linear) of source.
 * @private
 */
function _computeDistanceOutsideRoom(distance) {
  // We apply a linear ramp from 1 to 0 as the source is up to 1m outside.
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.SOURCE_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  return gain;
}


module.exports = Source;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_99936__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Directivity/occlusion filter.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_99936__(0);


/**
 * @class Directivity
 * @description Directivity/occlusion filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.alpha
 * Determines directivity pattern (0 to 1). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf). See
 * {@link Directivity#setPattern setPattern} for more details. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
function Directivity(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Directivity
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Directivity
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.alpha == undefined) {
    options.alpha = Utils.DEFAULT_DIRECTIVITY_ALPHA;
  }
  if (options.sharpness == undefined) {
    options.sharpness = Utils.DEFAULT_DIRECTIVITY_SHARPNESS;
  }

  // Create audio node.
  this._context = context;
  this._lowpass = context.createBiquadFilter();

  // Initialize filter coefficients.
  this._lowpass.type = 'lowpass';
  this._lowpass.Q.value = 0;
  this._lowpass.frequency.value = context.sampleRate * 0.5;

  this._cosTheta = 0;
  this.setPattern(options.alpha, options.sharpness);

  // Input/Output proxy.
  this.input = this._lowpass;
  this.output = this._lowpass;
}


/**
 * Compute the filter using the source's forward orientation and the listener's
 * position.
 * @param {Float32Array} forward The source's forward vector.
 * @param {Float32Array} direction The direction from the source to the
 * listener.
 */
Directivity.prototype.computeAngle = function(forward, direction) {
  let forwardNorm = Utils.normalizeVector(forward);
  let directionNorm = Utils.normalizeVector(direction);
  let coeff = 1;
  if (this._alpha > Utils.EPSILON_FLOAT) {
    let cosTheta = forwardNorm[0] * directionNorm[0] +
      forwardNorm[1] * directionNorm[1] + forwardNorm[2] * directionNorm[2];
    coeff = (1 - this._alpha) + this._alpha * cosTheta;
    coeff = Math.pow(Math.abs(coeff), this._sharpness);
  }
  this._lowpass.frequency.value = this._context.sampleRate * 0.5 * coeff;
};


/**
 * Set source's directivity pattern (defined by alpha), where 0 is an
 * omnidirectional pattern, 1 is a bidirectional pattern, 0.5 is a cardiod
 * pattern. The sharpness of the pattern is increased exponenentially.
 * @param {Number} alpha
 * Determines directivity pattern (0 to 1).
 * @param {Number} sharpness
 * Determines the sharpness of the directivity pattern (1 to Inf).
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 */
Directivity.prototype.setPattern = function(alpha, sharpness) {
  // Clamp and set values.
  this._alpha = Math.min(1, Math.max(0, alpha));
  this._sharpness = Math.max(1, sharpness);

  // Update angle calculation using new values.
  this.computeAngle([this._cosTheta * this._cosTheta, 0, 0], [1, 0, 0]);
};


module.exports = Directivity;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_104304__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Distance-based attenuation filter.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Utils = __nested_webpack_require_104304__(0);


/**
 * @class Attenuation
 * @description Distance-based attenuation filter.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 */
function Attenuation(context, options) {
  // Public variables.
  /**
   * Min. distance (in meters).
   * @member {Number} minDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Max. distance (in meters).
   * @member {Number} maxDistance
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof Attenuation
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Attenuation
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.minDistance == undefined) {
    options.minDistance = Utils.DEFAULT_MIN_DISTANCE;
  }
  if (options.maxDistance == undefined) {
    options.maxDistance = Utils.DEFAULT_MAX_DISTANCE;
  }
  if (options.rolloff == undefined) {
    options.rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  }

  // Assign values.
  this.minDistance = options.minDistance;
  this.maxDistance = options.maxDistance;
  this.setRolloff(options.rolloff);

  // Create node.
  this._gainNode = context.createGain();

  // Initialize distance to max distance.
  this.setDistance(options.maxDistance);

  // Input/Output proxy.
  this.input = this._gainNode;
  this.output = this._gainNode;
}


/**
 * Set distance from the listener.
 * @param {Number} distance Distance (in meters).
 */
Attenuation.prototype.setDistance = function(distance) {
  let gain = 1;
  if (this._rolloff == 'logarithmic') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        // Compute the distance attenuation value by the logarithmic curve
        // "1 / (d + 1)" with an offset of |minDistance|.
        let relativeDistance = distance - this.minDistance;
        let attenuation = 1 / (relativeDistance + 1);
        let attenuationMax = 1 / (range + 1);
        gain = (attenuation - attenuationMax) / (1 - attenuationMax);
      }
    }
  } else if (this._rolloff == 'linear') {
    if (distance > this.maxDistance) {
      gain = 0;
    } else if (distance > this.minDistance) {
      let range = this.maxDistance - this.minDistance;
      if (range > Utils.EPSILON_FLOAT) {
        gain = (this.maxDistance - distance) / range;
      }
    }
  }
  this._gainNode.gain.value = gain;
};


/**
 * Set rolloff.
 * @param {string} rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}.
 */
Attenuation.prototype.setRolloff = function(rolloff) {
  let isValidModel = ~Utils.ATTENUATION_ROLLOFFS.indexOf(rolloff);
  if (rolloff == undefined || !isValidModel) {
    if (!isValidModel) {
      Utils.log('Invalid rolloff model (\"' + rolloff +
        '\"). Using default: \"' + Utils.DEFAULT_ATTENUATION_ROLLOFF + '\".');
    }
    rolloff = Utils.DEFAULT_ATTENUATION_ROLLOFF;
  } else {
    rolloff = rolloff.toString().toLowerCase();
  }
  this._rolloff = rolloff;
};


module.exports = Attenuation;


/***/ }),
/* 7 */
/***/ (function(module, exports, __nested_webpack_require_109231__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Complete room model with early and late reflections.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const LateReflections = __nested_webpack_require_109231__(8);
const EarlyReflections = __nested_webpack_require_109231__(9);
const Utils = __nested_webpack_require_109231__(0);


/**
 * Generate absorption coefficients from material names.
 * @param {Object} materials
 * @return {Object}
 */
function _getCoefficientsFromMaterials(materials) {
  // Initialize coefficients to use defaults.
  let coefficients = {};
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property)) {
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }

  // Sanitize materials.
  if (materials == undefined) {
    materials = {};
    Object.assign(materials, Utils.DEFAULT_ROOM_MATERIALS);
  }

  // Assign coefficients using provided materials.
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (Utils.DEFAULT_ROOM_MATERIALS.hasOwnProperty(property) &&
        materials.hasOwnProperty(property)) {
      if (materials[property] in Utils.ROOM_MATERIAL_COEFFICIENTS) {
        coefficients[property] =
          Utils.ROOM_MATERIAL_COEFFICIENTS[materials[property]];
      } else {
        Utils.log('Material \"' + materials[property] + '\" on wall \"' +
          property + '\" not found. Using \"' +
          Utils.DEFAULT_ROOM_MATERIALS[property] + '\".');
      }
    } else {
      Utils.log('Wall \"' + property + '\" is not defined. Default used.');
    }
  }
  return coefficients;
}

/**
 * Sanitize coefficients.
 * @param {Object} coefficients
 * @return {Object}
 */
function _sanitizeCoefficients(coefficients) {
  if (coefficients == undefined) {
    coefficients = {};
  }
  for (let property in Utils.DEFAULT_ROOM_MATERIALS) {
    if (!(coefficients.hasOwnProperty(property))) {
      // If element is not present, use default coefficients.
      coefficients[property] = Utils.ROOM_MATERIAL_COEFFICIENTS[
        Utils.DEFAULT_ROOM_MATERIALS[property]];
    }
  }
  return coefficients;
}

/**
 * Sanitize dimensions.
 * @param {Object} dimensions
 * @return {Object}
 */
function _sanitizeDimensions(dimensions) {
  if (dimensions == undefined) {
    dimensions = {};
  }
  for (let property in Utils.DEFAULT_ROOM_DIMENSIONS) {
    if (!(dimensions.hasOwnProperty(property))) {
      dimensions[property] = Utils.DEFAULT_ROOM_DIMENSIONS[property];
    }
  }
  return dimensions;
}

/**
 * Compute frequency-dependent reverb durations.
 * @param {Object} dimensions
 * @param {Object} coefficients
 * @param {Number} speedOfSound
 * @return {Array}
 */
function _getDurationsFromProperties(dimensions, coefficients, speedOfSound) {
  let durations = new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);

  // Sanitize inputs.
  dimensions = _sanitizeDimensions(dimensions);
  coefficients = _sanitizeCoefficients(coefficients);
  if (speedOfSound == undefined) {
    speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Acoustic constant.
  let k = Utils.TWENTY_FOUR_LOG10 / speedOfSound;

  // Compute volume, skip if room is not present.
  let volume = dimensions.width * dimensions.height * dimensions.depth;
  if (volume < Utils.ROOM_MIN_VOLUME) {
    return durations;
  }

  // Room surface area.
  let leftRightArea = dimensions.width * dimensions.height;
  let floorCeilingArea = dimensions.width * dimensions.depth;
  let frontBackArea = dimensions.depth * dimensions.height;
  let totalArea = 2 * (leftRightArea + floorCeilingArea + frontBackArea);
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Effective absorptive area.
    let absorbtionArea =
      (coefficients.left[i] + coefficients.right[i]) * leftRightArea +
      (coefficients.down[i] + coefficients.up[i]) * floorCeilingArea +
      (coefficients.front[i] + coefficients.back[i]) * frontBackArea;
    let meanAbsorbtionArea = absorbtionArea / totalArea;

    // Compute reverberation using Eyring equation [1].
    // [1] Beranek, Leo L. "Analysis of Sabine and Eyring equations and their
    //     application to concert hall audience and chair absorption." The
    //     Journal of the Acoustical Society of America, Vol. 120, No. 3.
    //     (2006), pp. 1399-1399.
    durations[i] = Utils.ROOM_EYRING_CORRECTION_COEFFICIENT * k * volume /
      (-totalArea * Math.log(1 - meanAbsorbtionArea) + 4 *
      Utils.ROOM_AIR_ABSORPTION_COEFFICIENTS[i] * volume);
  }
  return durations;
}


/**
 * Compute reflection coefficients from absorption coefficients.
 * @param {Object} absorptionCoefficients
 * @return {Object}
 */
function _computeReflectionCoefficients(absorptionCoefficients) {
  let reflectionCoefficients = [];
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute average absorption coefficient (per wall).
      reflectionCoefficients[property] = 0;
      for (let j = 0; j < Utils.NUMBER_REFLECTION_AVERAGING_BANDS; j++) {
        let bandIndex = j + Utils.ROOM_STARTING_AVERAGING_BAND;
        reflectionCoefficients[property] +=
          absorptionCoefficients[property][bandIndex];
      }
      reflectionCoefficients[property] /=
        Utils.NUMBER_REFLECTION_AVERAGING_BANDS;

      // Convert absorption coefficient to reflection coefficient.
      reflectionCoefficients[property] =
        Math.sqrt(1 - reflectionCoefficients[property]);
    }
  }
  return reflectionCoefficients;
}


/**
 * @class Room
 * @description Model that manages early and late reflections using acoustic
 * properties and listener position relative to a rectangular room.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function Room(context, options) {
  // Public variables.
  /**
   * EarlyReflections {@link EarlyReflections EarlyReflections} submodule.
   * @member {AudioNode} early
   * @memberof Room
   * @instance
   */
  /**
   * LateReflections {@link LateReflections LateReflections} submodule.
   * @member {AudioNode} late
   * @memberof Room
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof Room
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Sanitize room-properties-related arguments.
  options.dimensions = _sanitizeDimensions(options.dimensions);
  let absorptionCoefficients = _getCoefficientsFromMaterials(options.materials);
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  let durations = _getDurationsFromProperties(options.dimensions,
    absorptionCoefficients, options.speedOfSound);

  // Construct submodules for early and late reflections.
  this.early = new EarlyReflections(context, {
    dimensions: options.dimensions,
    coefficients: reflectionCoefficients,
    speedOfSound: options.speedOfSound,
    listenerPosition: options.listenerPosition,
  });
  this.late = new LateReflections(context, {
    durations: durations,
  });

  this.speedOfSound = options.speedOfSound;

  // Construct auxillary audio nodes.
  this.output = context.createGain();
  this.early.output.connect(this.output);
  this._merger = context.createChannelMerger(4);

  this.late.output.connect(this._merger, 0, 0);
  this._merger.connect(this.output);
}


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} materials Named acoustic materials per wall. Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 */
Room.prototype.setProperties = function(dimensions, materials) {
  // Compute late response.
  let absorptionCoefficients = _getCoefficientsFromMaterials(materials);
  let durations = _getDurationsFromProperties(dimensions,
    absorptionCoefficients, this.speedOfSound);
  this.late.setDurations(durations);

  // Compute early response.
  this.early.speedOfSound = this.speedOfSound;
  let reflectionCoefficients =
    _computeReflectionCoefficients(absorptionCoefficients);
  this.early.setRoomProperties(dimensions, reflectionCoefficients);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
Room.prototype.setListenerPosition = function(x, y, z) {
  this.early.speedOfSound = this.speedOfSound;
  this.early.setListenerPosition(x, y, z);

  // Disable room effects if the listener is outside the room boundaries.
  let distance = this.getDistanceOutsideRoom(x, y, z);
  let gain = 1;
  if (distance > Utils.EPSILON_FLOAT) {
    gain = 1 - distance / Utils.LISTENER_MAX_OUTSIDE_ROOM_DISTANCE;

    // Clamp gain between 0 and 1.
    gain = Math.max(0, Math.min(1, gain));
  }
  this.output.gain.value = gain;
};


/**
 * Compute distance outside room of provided position (in meters).
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return {Number}
 * Distance outside room (in meters). Returns 0 if inside room.
 */
Room.prototype.getDistanceOutsideRoom = function(x, y, z) {
  let dx = Math.max(0, -this.early._halfDimensions.width - x,
    x - this.early._halfDimensions.width);
    let dy = Math.max(0, -this.early._halfDimensions.height - y,
    y - this.early._halfDimensions.height);
    let dz = Math.max(0, -this.early._halfDimensions.depth - z,
    z - this.early._halfDimensions.depth);
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};


module.exports = Room;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_120970__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Late reverberation filter for Ambisonic content.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_120970__(0);


/**
 * @class LateReflections
 * @description Late-reflections reverberation filter for Ambisonic content.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Array} options.durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * FREQUDEFAULT_REVERB_FREQUENCY_BANDSENCY_BANDS}. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_DURATIONS DEFAULT_REVERB_DURATIONS}.
 * @param {Number} options.predelay Pre-delay (in milliseconds). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_PREDELAY DEFAULT_REVERB_PREDELAY}.
 * @param {Number} options.gain Output gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_GAIN DEFAULT_REVERB_GAIN}.
 * @param {Number} options.bandwidth Bandwidth (in octaves) for each frequency
 * band. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_BANDWIDTH DEFAULT_REVERB_BANDWIDTH}.
 * @param {Number} options.tailonset Length (in milliseconds) of impulse
 * response to apply a half-Hann window. Defaults to
 * {@linkcode Utils.DEFAULT_REVERB_TAIL_ONSET DEFAULT_REVERB_TAIL_ONSET}.
 */
function LateReflections(context, options) {
  // Public variables.
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof LateReflections
   * @instance
   */
  /**
   * Mono (1-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof LateReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.durations == undefined) {
    options.durations = Utils.DEFAULT_REVERB_DURATIONS.slice();
  }
  if (options.predelay == undefined) {
    options.predelay = Utils.DEFAULT_REVERB_PREDELAY;
  }
  if (options.gain == undefined) {
    options.gain = Utils.DEFAULT_REVERB_GAIN;
  }
  if (options.bandwidth == undefined) {
    options.bandwidth = Utils.DEFAULT_REVERB_BANDWIDTH;
  }
  if (options.tailonset == undefined) {
    options.tailonset = Utils.DEFAULT_REVERB_TAIL_ONSET;
  }

  // Assign pre-computed variables.
  let delaySecs = options.predelay / 1000;
  this._bandwidthCoeff = options.bandwidth * Utils.LOG2_DIV2;
  this._tailonsetSamples = options.tailonset / 1000;

  // Create nodes.
  this._context = context;
  this.input = context.createGain();
  this._predelay = context.createDelay(delaySecs);
  this._convolver = context.createConvolver();
  this.output = context.createGain();

  // Set reverb attenuation.
  this.output.gain.value = options.gain;

  // Disable normalization.
  this._convolver.normalize = false;

  // Connect nodes.
  this.input.connect(this._predelay);
  this._predelay.connect(this._convolver);
  this._convolver.connect(this.output);

  // Compute IR using RT60 values.
  this.setDurations(options.durations);
}


/**
 * Re-compute a new impulse response by providing Multiband RT60 durations.
 * @param {Array} durations
 * Multiband RT60 durations (in seconds) for each frequency band, listed as
 * {@linkcode Utils.DEFAULT_REVERB_FREQUENCY_BANDS
 * DEFAULT_REVERB_FREQUENCY_BANDS}.
 */
LateReflections.prototype.setDurations = function(durations) {
  if (durations.length !== Utils.NUMBER_REVERB_FREQUENCY_BANDS) {
    Utils.log('Warning: invalid number of RT60 values provided to reverb.');
    return;
  }

  // Compute impulse response.
  let durationsSamples =
    new Float32Array(Utils.NUMBER_REVERB_FREQUENCY_BANDS);
    let sampleRate = this._context.sampleRate;

  for (let i = 0; i < durations.length; i++) {
    // Clamp within suitable range.
    durations[i] =
      Math.max(0, Math.min(Utils.DEFAULT_REVERB_MAX_DURATION, durations[i]));

    // Convert seconds to samples.
    durationsSamples[i] = Math.round(durations[i] * sampleRate *
      Utils.DEFAULT_REVERB_DURATION_MULTIPLIER);
  };

  // Determine max RT60 length in samples.
  let durationsSamplesMax = 0;
  for (let i = 0; i < durationsSamples.length; i++) {
    if (durationsSamples[i] > durationsSamplesMax) {
      durationsSamplesMax = durationsSamples[i];
    }
  }

  // Skip this step if there is no reverberation to compute.
  if (durationsSamplesMax < 1) {
    durationsSamplesMax = 1;
  }

  // Create impulse response buffer.
  let buffer = this._context.createBuffer(1, durationsSamplesMax, sampleRate);
  let bufferData = buffer.getChannelData(0);

  // Create noise signal (computed once, referenced in each band's routine).
  let noiseSignal = new Float32Array(durationsSamplesMax);
  for (let i = 0; i < durationsSamplesMax; i++) {
    noiseSignal[i] = Math.random() * 2 - 1;
  }

  // Compute the decay rate per-band and filter the decaying noise signal.
  for (let i = 0; i < Utils.NUMBER_REVERB_FREQUENCY_BANDS; i++) {
    // Compute decay rate.
    let decayRate = -Utils.LOG1000 / durationsSamples[i];

    // Construct a standard one-zero, two-pole bandpass filter:
    // H(z) = (b0 * z^0 + b1 * z^-1 + b2 * z^-2) / (1 + a1 * z^-1 + a2 * z^-2)
    let omega = Utils.TWO_PI *
      Utils.DEFAULT_REVERB_FREQUENCY_BANDS[i] / sampleRate;
    let sinOmega = Math.sin(omega);
    let alpha = sinOmega * Math.sinh(this._bandwidthCoeff * omega / sinOmega);
    let a0CoeffReciprocal = 1 / (1 + alpha);
    let b0Coeff = alpha * a0CoeffReciprocal;
    let a1Coeff = -2 * Math.cos(omega) * a0CoeffReciprocal;
    let a2Coeff = (1 - alpha) * a0CoeffReciprocal;

    // We optimize since b2 = -b0, b1 = 0.
    // Update equation for two-pole bandpass filter:
    //   u[n] = x[n] - a1 * x[n-1] - a2 * x[n-2]
    //   y[n] = b0 * (u[n] - u[n-2])
    let um1 = 0;
    let um2 = 0;
    for (let j = 0; j < durationsSamples[i]; j++) {
      // Exponentially-decaying white noise.
      let x = noiseSignal[j] * Math.exp(decayRate * j);

      // Filter signal with bandpass filter and add to output.
      let u = x - a1Coeff * um1 - a2Coeff * um2;
      bufferData[j] += b0Coeff * (u - um2);

      // Update coefficients.
      um2 = um1;
      um1 = u;
    }
  }

  // Create and apply half of a Hann window to the beginning of the
  // impulse response.
  let halfHannLength =
    Math.round(this._tailonsetSamples);
  for (let i = 0; i < Math.min(bufferData.length, halfHannLength); i++) {
    let halfHann =
      0.5 * (1 - Math.cos(Utils.TWO_PI * i / (2 * halfHannLength - 1)));
      bufferData[i] *= halfHann;
  }
  this._convolver.buffer = buffer;
};


module.exports = LateReflections;


/***/ }),
/* 9 */
/***/ (function(module, exports, __nested_webpack_require_128486__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Ray-tracing-based early reflections model.
 * @author Andrew Allen <bitllama@google.com>
 */



// Internal dependencies.
const Utils = __nested_webpack_require_128486__(0);


/**
 * @class EarlyReflections
 * @description Ray-tracing-based early reflections model.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Object} options.dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 * @param {Number} options.speedOfSound
 * (in meters / second). Defaults to {@linkcode Utils.DEFAULT_SPEED_OF_SOUND
 * DEFAULT_SPEED_OF_SOUND}.
 * @param {Float32Array} options.listenerPosition
 * (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 */
function EarlyReflections(context, options) {
  // Public variables.
  /**
   * The room's speed of sound (in meters/second).
   * @member {Number} speedOfSound
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * Mono (1-channel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} input
   * @memberof EarlyReflections
   * @instance
   */
  /**
   * First-order ambisonic (4-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof EarlyReflections
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.coefficients == undefined) {
    options.coefficients = {};
    Object.assign(options.coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }

  // Assign room's speed of sound.
  this.speedOfSound = options.speedOfSound;

  // Create nodes.
  this.input = context.createGain();
  this.output = context.createGain();
  this._lowpass = context.createBiquadFilter();
  this._delays = {};
  this._gains = {}; // gainPerWall = (ReflectionCoeff / Attenuation)
  this._inverters = {}; // 3 of these are needed for right/back/down walls.
  this._merger = context.createChannelMerger(4); // First-order encoding only.

  // Connect audio graph for each wall reflection.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property] =
        context.createDelay(Utils.MAX_DURATION);
      this._gains[property] = context.createGain();
    }
  }
  this._inverters.right = context.createGain();
  this._inverters.down = context.createGain();
  this._inverters.back = context.createGain();

  // Initialize lowpass filter.
  this._lowpass.type = 'lowpass';
  this._lowpass.frequency.value = Utils.DEFAULT_REFLECTION_CUTOFF_FREQUENCY;
  this._lowpass.Q.value = 0;

  // Initialize encoder directions, set delay times and gains to 0.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._delays[property].delayTime.value = 0;
      this._gains[property].gain.value = 0;
    }
  }

  // Initialize inverters for opposite walls ('right', 'down', 'back' only).
  this._inverters.right.gain.value = -1;
  this._inverters.down.gain.value = -1;
  this._inverters.back.gain.value = -1;

  // Connect nodes.
  this.input.connect(this._lowpass);
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      this._lowpass.connect(this._delays[property]);
      this._delays[property].connect(this._gains[property]);
      this._gains[property].connect(this._merger, 0, 0);
    }
  }

  // Connect gains to ambisonic channel output.
  // Left: [1 1 0 0]
  // Right: [1 -1 0 0]
  // Up: [1 0 1 0]
  // Down: [1 0 -1 0]
  // Front: [1 0 0 1]
  // Back: [1 0 0 -1]
  this._gains.left.connect(this._merger, 0, 1);

  this._gains.right.connect(this._inverters.right);
  this._inverters.right.connect(this._merger, 0, 1);

  this._gains.up.connect(this._merger, 0, 2);

  this._gains.down.connect(this._inverters.down);
  this._inverters.down.connect(this._merger, 0, 2);

  this._gains.front.connect(this._merger, 0, 3);

  this._gains.back.connect(this._inverters.back);
  this._inverters.back.connect(this._merger, 0, 3);
  this._merger.connect(this.output);

  // Initialize.
  this._listenerPosition = options.listenerPosition;
  this.setRoomProperties(options.dimensions, options.coefficients);
}


/**
 * Set the listener's position (in meters),
 * where [0,0,0] is the center of the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
EarlyReflections.prototype.setListenerPosition = function(x, y, z) {
  // Assign listener position.
  this._listenerPosition = [x, y, z];

  // Determine distances to each wall.
  let distances = {
    left: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width + x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    right: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.width - x) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    front: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth + z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    back: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.depth - z) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    down: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height + y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
    up: Utils.DEFAULT_REFLECTION_MULTIPLIER * Math.max(0,
      this._halfDimensions.height - y) + Utils.DEFAULT_REFLECTION_MIN_DISTANCE,
  };

  // Assign delay & attenuation values using distances.
  for (let property in Utils.DEFAULT_REFLECTION_COEFFICIENTS) {
    if (Utils.DEFAULT_REFLECTION_COEFFICIENTS
        .hasOwnProperty(property)) {
      // Compute and assign delay (in seconds).
      let delayInSecs = distances[property] / this.speedOfSound;
      this._delays[property].delayTime.value = delayInSecs;

      // Compute and assign gain, uses logarithmic rolloff: "g = R / (d + 1)"
      let attenuation = this._coefficients[property] / distances[property];
      this._gains[property].gain.value = attenuation;
    }
  }
};


/**
 * Set the room's properties which determines the characteristics of
 * reflections.
 * @param {Object} dimensions
 * Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} coefficients
 * Frequency-independent reflection coeffs per wall. Defaults to
 * {@linkcode Utils.DEFAULT_REFLECTION_COEFFICIENTS
 * DEFAULT_REFLECTION_COEFFICIENTS}.
 */
EarlyReflections.prototype.setRoomProperties = function(dimensions,
                                                        coefficients) {
  if (dimensions == undefined) {
    dimensions = {};
    Object.assign(dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (coefficients == undefined) {
    coefficients = {};
    Object.assign(coefficients, Utils.DEFAULT_REFLECTION_COEFFICIENTS);
  }
  this._coefficients = coefficients;

  // Sanitize dimensions and store half-dimensions.
  this._halfDimensions = {};
  this._halfDimensions.width = dimensions.width * 0.5;
  this._halfDimensions.height = dimensions.height * 0.5;
  this._halfDimensions.depth = dimensions.depth * 0.5;

  // Update listener position with new room properties.
  this.setListenerPosition(this._listenerPosition[0],
    this._listenerPosition[1], this._listenerPosition[2]);
};


module.exports = EarlyReflections;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_137320__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Primary namespace for ResonanceAudio library.
 * @author Andrew Allen <bitllama@google.com>
 */

 


// Main module.
exports.ResonanceAudio = __nested_webpack_require_137320__(11);


// Testable Submodules.
exports.ResonanceAudio.Attenuation = __nested_webpack_require_137320__(6);
exports.ResonanceAudio.Directivity = __nested_webpack_require_137320__(5);
exports.ResonanceAudio.EarlyReflections = __nested_webpack_require_137320__(9);
exports.ResonanceAudio.Encoder = __nested_webpack_require_137320__(1);
exports.ResonanceAudio.LateReflections = __nested_webpack_require_137320__(8);
exports.ResonanceAudio.Listener = __nested_webpack_require_137320__(2);
exports.ResonanceAudio.Room = __nested_webpack_require_137320__(7);
exports.ResonanceAudio.Source = __nested_webpack_require_137320__(4);
exports.ResonanceAudio.Tables = __nested_webpack_require_137320__(3);
exports.ResonanceAudio.Utils = __nested_webpack_require_137320__(0);
exports.ResonanceAudio.Version = __nested_webpack_require_137320__(13);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_138892__) {

"use strict";
/**
 * @license
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio library name space and common utilities.
 * @author Andrew Allen <bitllama@google.com>
 */




// Internal dependencies.
const Listener = __nested_webpack_require_138892__(2);
const Source = __nested_webpack_require_138892__(4);
const Room = __nested_webpack_require_138892__(7);
const Encoder = __nested_webpack_require_138892__(1);
const Utils = __nested_webpack_require_138892__(0);


/**
 * @class ResonanceAudio
 * @description Main class for managing sources, room and listener models.
 * @param {AudioContext} context
 * Associated {@link
https://developer.mozilla.org/en-US/docs/Web/API/AudioContext AudioContext}.
 * @param {Object} options
 * @param {Number} options.ambisonicOrder
 * Desired ambisonic Order. Defaults to
 * {@linkcode Utils.DEFAULT_AMBISONIC_ORDER DEFAULT_AMBISONIC_ORDER}.
 * @param {Float32Array} options.listenerPosition
 * The listener's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.listenerForward
 * The listener's initial forward vector.
 * Defaults to {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.listenerUp
 * The listener's initial up vector.
 * Defaults to {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Object} options.dimensions Room dimensions (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_ROOM_DIMENSIONS DEFAULT_ROOM_DIMENSIONS}.
 * @param {Object} options.materials Named acoustic materials per wall.
 * Defaults to {@linkcode Utils.DEFAULT_ROOM_MATERIALS DEFAULT_ROOM_MATERIALS}.
 * @param {Number} options.speedOfSound
 * (in meters/second). Defaults to
 * {@linkcode Utils.DEFAULT_SPEED_OF_SOUND DEFAULT_SPEED_OF_SOUND}.
 */
function ResonanceAudio(context, options) {
  // Public variables.
  /**
   * Binaurally-rendered stereo (2-channel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}.
   * @member {AudioNode} output
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) input {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For rendering input soundfields).
   * @member {AudioNode} ambisonicInput
   * @memberof ResonanceAudio
   * @instance
   */
  /**
   * Ambisonic (multichannel) output {@link
   * https://developer.mozilla.org/en-US/docs/Web/API/AudioNode AudioNode}
   * (For allowing external rendering / post-processing).
   * @member {AudioNode} ambisonicOutput
   * @memberof ResonanceAudio
   * @instance
   */

  // Use defaults for undefined arguments.
  if (options == undefined) {
    options = {};
  }
  if (options.ambisonicOrder == undefined) {
    options.ambisonicOrder = Utils.DEFAULT_AMBISONIC_ORDER;
  }
  if (options.listenerPosition == undefined) {
    options.listenerPosition = Utils.DEFAULT_POSITION.slice();
  }
  if (options.listenerForward == undefined) {
    options.listenerForward = Utils.DEFAULT_FORWARD.slice();
  }
  if (options.listenerUp == undefined) {
    options.listenerUp = Utils.DEFAULT_UP.slice();
  }
  if (options.dimensions == undefined) {
    options.dimensions = {};
    Object.assign(options.dimensions, Utils.DEFAULT_ROOM_DIMENSIONS);
  }
  if (options.materials == undefined) {
    options.materials = {};
    Object.assign(options.materials, Utils.DEFAULT_ROOM_MATERIALS);
  }
  if (options.speedOfSound == undefined) {
    options.speedOfSound = Utils.DEFAULT_SPEED_OF_SOUND;
  }

  // Create member submodules.
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(options.ambisonicOrder);
  this._sources = [];
  this._room = new Room(context, {
    listenerPosition: options.listenerPosition,
    dimensions: options.dimensions,
    materials: options.materials,
    speedOfSound: options.speedOfSound,
  });
  this._listener = new Listener(context, {
    ambisonicOrder: options.ambisonicOrder,
    position: options.listenerPosition,
    forward: options.listenerForward,
    up: options.listenerUp,
  });

  // Create auxillary audio nodes.
  this._context = context;
  this.output = context.createGain();
  this.ambisonicOutput = context.createGain();
  this.ambisonicInput = this._listener.input;

  // Connect audio graph.
  this._room.output.connect(this._listener.input);
  this._listener.output.connect(this.output);
  this._listener.ambisonicOutput.connect(this.ambisonicOutput);
}


/**
 * Create a new source for the scene.
 * @param {Object} options
 * @param {Float32Array} options.position
 * The source's initial position (in meters), where origin is the center of
 * the room. Defaults to {@linkcode Utils.DEFAULT_POSITION DEFAULT_POSITION}.
 * @param {Float32Array} options.forward
 * The source's initial forward vector. Defaults to
 * {@linkcode Utils.DEFAULT_FORWARD DEFAULT_FORWARD}.
 * @param {Float32Array} options.up
 * The source's initial up vector. Defaults to
 * {@linkcode Utils.DEFAULT_UP DEFAULT_UP}.
 * @param {Number} options.minDistance
 * Min. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MIN_DISTANCE DEFAULT_MIN_DISTANCE}.
 * @param {Number} options.maxDistance
 * Max. distance (in meters). Defaults to
 * {@linkcode Utils.DEFAULT_MAX_DISTANCE DEFAULT_MAX_DISTANCE}.
 * @param {string} options.rolloff
 * Rolloff model to use, chosen from options in
 * {@linkcode Utils.ATTENUATION_ROLLOFFS ATTENUATION_ROLLOFFS}. Defaults to
 * {@linkcode Utils.DEFAULT_ATTENUATION_ROLLOFF DEFAULT_ATTENUATION_ROLLOFF}.
 * @param {Number} options.gain Input gain (linear). Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_GAIN DEFAULT_SOURCE_GAIN}.
 * @param {Number} options.alpha Directivity alpha. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_ALPHA DEFAULT_DIRECTIVITY_ALPHA}.
 * @param {Number} options.sharpness Directivity sharpness. Defaults to
 * {@linkcode Utils.DEFAULT_DIRECTIVITY_SHARPNESS
 * DEFAULT_DIRECTIVITY_SHARPNESS}.
 * @param {Number} options.sourceWidth
 * Source width (in degrees). Where 0 degrees is a point source and 360 degrees
 * is an omnidirectional source. Defaults to
 * {@linkcode Utils.DEFAULT_SOURCE_WIDTH DEFAULT_SOURCE_WIDTH}.
 * @return {Source}
 */
ResonanceAudio.prototype.createSource = function(options) {
  // Create a source and push it to the internal sources array, returning
  // the object's reference to the user.
  let source = new Source(this, options);
  this._sources[this._sources.length] = source;
  return source;
};


/**
 * Set the scene's desired ambisonic order.
 * @param {Number} ambisonicOrder Desired ambisonic order.
 */
ResonanceAudio.prototype.setAmbisonicOrder = function(ambisonicOrder) {
  this._ambisonicOrder = Encoder.validateAmbisonicOrder(ambisonicOrder);
};


/**
 * Set the room's dimensions and wall materials.
 * @param {Object} dimensions Room dimensions (in meters).
 * @param {Object} materials Named acoustic materials per wall.
 */
ResonanceAudio.prototype.setRoomProperties = function(dimensions, materials) {
  this._room.setProperties(dimensions, materials);
};


/**
 * Set the listener's position (in meters), where origin is the center of
 * the room.
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 */
ResonanceAudio.prototype.setListenerPosition = function(x, y, z) {
  // Update listener position.
  this._listener.position[0] = x;
  this._listener.position[1] = y;
  this._listener.position[2] = z;
  this._room.setListenerPosition(x, y, z);

  // Update sources with new listener position.
  this._sources.forEach(function(element) {
     element._update();
  });
};


/**
 * Set the source's orientation using forward and up vectors.
 * @param {Number} forwardX
 * @param {Number} forwardY
 * @param {Number} forwardZ
 * @param {Number} upX
 * @param {Number} upY
 * @param {Number} upZ
 */
ResonanceAudio.prototype.setListenerOrientation = function(forwardX, forwardY,
  forwardZ, upX, upY, upZ) {
  this._listener.setOrientation(forwardX, forwardY, forwardZ, upX, upY, upZ);
};


/**
 * Set the listener's position and orientation using a Three.js Matrix4 object.
 * @param {Object} matrix
 * The Three.js Matrix4 object representing the listener's world transform.
 */
ResonanceAudio.prototype.setListenerFromMatrix = function(matrix) {
  this._listener.setFromMatrix(matrix);

  // Update the rest of the scene using new listener position.
  this.setListenerPosition(this._listener.position[0],
    this._listener.position[1], this._listener.position[2]);
};


/**
 * Set the speed of sound.
 * @param {Number} speedOfSound
 */
ResonanceAudio.prototype.setSpeedOfSound = function(speedOfSound) {
  this._room.speedOfSound = speedOfSound;
};


module.exports = ResonanceAudio;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else { var i, a; }
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_148723__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_148723__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_148723__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_148723__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_148723__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_148723__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_148723__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_148723__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_148723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_148723__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_148723__(__nested_webpack_require_148723__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library common utilities.
 */


/**
 * Omnitone library logging function.
 * @param {any} Message to be printed out.
 */
exports.log = function() {
  window.console.log.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #BBDEFB; color: #FF5722; font-weight: 500', 'font-weight: 300',
    'color: #AAA',
  ]);
};


/**
 * Omnitone library error-throwing function.
 * @param {any} Message to be printed out.
 */
exports.throw = function() {
  window.console.error.apply(window.console, [
    '%c[Omnitone]%c ' + Array.prototype.slice.call(arguments).join(' ') +
        ' %c(@' + performance.now().toFixed(2) + 'ms)',
    'background: #C62828; color: #FFEBEE; font-weight: 800', 'font-weight: 400',
    'color: #AAA',
  ]);

  throw new Error(false);
};


// Static temp storage for matrix inversion.
let a00;
let a01;
let a02;
let a03;
let a10;
let a11;
let a12;
let a13;
let a20;
let a21;
let a22;
let a23;
let a30;
let a31;
let a32;
let a33;
let b00;
let b01;
let b02;
let b03;
let b04;
let b05;
let b06;
let b07;
let b08;
let b09;
let b10;
let b11;
let det;


/**
 * A 4x4 matrix inversion utility. This does not handle the case when the
 * arguments are not proper 4x4 matrices.
 * @param {Float32Array} out   The inverted result.
 * @param {Float32Array} a     The source matrix.
 * @return {Float32Array} out
 */
exports.invertMatrix4 = function(out, a) {
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  a30 = a[12];
  a31 = a[13];
  a32 = a[14];
  a33 = a[15];
  b00 = a00 * a11 - a01 * a10;
  b01 = a00 * a12 - a02 * a10;
  b02 = a00 * a13 - a03 * a10;
  b03 = a01 * a12 - a02 * a11;
  b04 = a01 * a13 - a03 * a11;
  b05 = a02 * a13 - a03 * a12;
  b06 = a20 * a31 - a21 * a30;
  b07 = a20 * a32 - a22 * a30;
  b08 = a20 * a33 - a23 * a30;
  b09 = a21 * a32 - a22 * a31;
  b10 = a21 * a33 - a23 * a31;
  b11 = a22 * a33 - a23 * a32;
  det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
};


/**
 * Check if a value is defined in the ENUM dictionary.
 * @param {Object} enumDictionary - ENUM dictionary.
 * @param {Number|String} entryValue - a value to probe.
 * @return {Boolean}
 */
exports.isDefinedENUMEntry = function(enumDictionary, entryValue) {
  for (let enumKey in enumDictionary) {
    if (entryValue === enumDictionary[enumKey]) {
      return true;
    }
  }
  return false;
};


/**
 * Check if the given object is an instance of BaseAudioContext.
 * @param {AudioContext} context - A context object to be checked.
 * @return {Boolean}
 */
exports.isAudioContext = function(context) {
  // TODO(hoch): Update this when BaseAudioContext is available for all
  // browsers.
  return context instanceof AudioContext ||
    context instanceof OfflineAudioContext;
};


/**
 * Check if the given object is a valid AudioBuffer.
 * @param {Object} audioBuffer An AudioBuffer object to be checked.
 * @return {Boolean}
 */
exports.isAudioBuffer = function(audioBuffer) {
  return audioBuffer instanceof AudioBuffer;
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
exports.mergeBufferListByChannel = function(context, bufferList) {
  const bufferLength = bufferList[0].length;
  const bufferSampleRate = bufferList[0].sampleRate;
  let bufferNumberOfChannel = 0;

  for (let i = 0; i < bufferList.length; ++i) {
    if (bufferNumberOfChannel > 32) {
      exports.throw('Utils.mergeBuffer: Number of channels cannot exceed 32.' +
          '(got ' + bufferNumberOfChannel + ')');
    }
    if (bufferLength !== bufferList[i].length) {
      exports.throw('Utils.mergeBuffer: AudioBuffer lengths are ' +
          'inconsistent. (expected ' + bufferLength + ' but got ' +
          bufferList[i].length + ')');
    }
    if (bufferSampleRate !== bufferList[i].sampleRate) {
      exports.throw('Utils.mergeBuffer: AudioBuffer sample rates are ' +
          'inconsistent. (expected ' + bufferSampleRate + ' but got ' +
          bufferList[i].sampleRate + ')');
    }
    bufferNumberOfChannel += bufferList[i].numberOfChannels;
  }

  const buffer = context.createBuffer(bufferNumberOfChannel,
                                      bufferLength,
                                      bufferSampleRate);
  let destinationChannelIndex = 0;
  for (let i = 0; i < bufferList.length; ++i) {
    for (let j = 0; j < bufferList[i].numberOfChannels; ++j) {
      buffer.getChannelData(destinationChannelIndex++).set(
          bufferList[i].getChannelData(j));
    }
  }

  return buffer;
};


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
exports.splitBufferbyChannel = function(context, audioBuffer, splitBy) {
  if (audioBuffer.numberOfChannels <= splitBy) {
    exports.throw('Utils.splitBuffer: Insufficient number of channels. (' +
        audioBuffer.numberOfChannels + ' splitted by ' + splitBy + ')');
  }

  let bufflerList = [];
  let sourceChannelIndex = 0;
  const numberOfSplittedBuffer =
      Math.ceil(audioBuffer.numberOfChannels / splitBy);
  for (let i = 0; i < numberOfSplittedBuffer; ++i) {
    let buffer = context.createBuffer(splitBy,
                                      audioBuffer.length,
                                      audioBuffer.sampleRate);
    for (let j = 0; j < splitBy; ++j) {
      if (sourceChannelIndex < audioBuffer.numberOfChannels) {
        buffer.getChannelData(j).set(
          audioBuffer.getChannelData(sourceChannelIndex++));
      }
    }
    bufflerList.push(buffer);
  }

  return bufferList;
};


/**
 * Converts Base64-encoded string to ArrayBuffer.
 * @param {string} base64String - Base64-encdoed string.
 * @return {ArrayByuffer} Converted ArrayBuffer object.
 */
exports.getArrayBufferFromBase64String = function(base64String) {
  let binaryString = window.atob(base64String);
  let byteArray = new Uint8Array(binaryString.length);
  byteArray.forEach(
    (value, index) => byteArray[index] = binaryString.charCodeAt(index));
  return byteArray.buffer;
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __nested_webpack_require_159425__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Streamlined AudioBuffer loader.
 */




const Utils = __nested_webpack_require_159425__(0);

/**
 * @typedef {string} BufferDataType
 */

/**
 * Buffer data type for ENUM.
 * @enum {BufferDataType}
 */
const BufferDataType = {
  /** @type {string} The data contains Base64-encoded string.. */
  BASE64: 'base64',
  /** @type {string} The data is a URL for audio file. */
  URL: 'url',
};


/**
 * BufferList object mananges the async loading/decoding of multiple
 * AudioBuffers from multiple URLs.
 * @constructor
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} options - Options
 * @param {string} [options.dataType='base64'] - BufferDataType specifier.
 * @param {Boolean} [options.verbose=false] - Log verbosity. |true| prints the
 * individual message from each URL and AudioBuffer.
 */
function BufferList(context, bufferData, options) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('BufferList: Invalid BaseAudioContext.');

  this._options = {
    dataType: BufferDataType.BASE64,
    verbose: false,
  };

  if (options) {
    if (options.dataType &&
        Utils.isDefinedENUMEntry(BufferDataType, options.dataType)) {
      this._options.dataType = options.dataType;
    }
    if (options.verbose) {
      this._options.verbose = Boolean(options.verbose);
    }
  }

  this._bufferList = [];
  this._bufferData = this._options.dataType === BufferDataType.BASE64
      ? bufferData
      : bufferData.slice(0);
  this._numberOfTasks = this._bufferData.length;

  this._resolveHandler = null;
  this._rejectHandler = new Function();
}


/**
 * Starts AudioBuffer loading tasks.
 * @return {Promise<AudioBuffer[]>} The promise resolves with an array of
 * AudioBuffer.
 */
BufferList.prototype.load = function() {
  return new Promise(this._promiseGenerator.bind(this));
};


/**
 * Promise argument generator. Internally starts multiple async loading tasks.
 * @private
 * @param {function} resolve Promise resolver.
 * @param {function} reject Promise reject.
 */
BufferList.prototype._promiseGenerator = function(resolve, reject) {
  if (typeof resolve !== 'function') {
    Utils.throw('BufferList: Invalid Promise resolver.');
  } else {
    this._resolveHandler = resolve;
  }

  if (typeof reject === 'function') {
    this._rejectHandler = reject;
  }

  for (let i = 0; i < this._bufferData.length; ++i) {
    this._options.dataType === BufferDataType.BASE64
        ? this._launchAsyncLoadTask(i)
        : this._launchAsyncLoadTaskXHR(i);
  }
};


/**
 * Run async loading task for Base64-encoded string.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTask = function(taskId) {
  const that = this;
  this._context.decodeAudioData(
      Utils.getArrayBufferFromBase64String(this._bufferData[taskId]),
      function(audioBuffer) {
        that._updateProgress(taskId, audioBuffer);
      },
      function(errorMessage) {
        that._updateProgress(taskId, null);
        const message = 'BufferList: decoding ArrayByffer("' + taskId +
            '" from Base64-encoded data failed. (' + errorMessage + ')';
        Utils.throw(message);
        that._rejectHandler(message);
      });
};


/**
 * Run async loading task via XHR for audio file URLs.
 * @private
 * @param {Number} taskId Task ID number from the ordered list |bufferData|.
 */
BufferList.prototype._launchAsyncLoadTaskXHR = function(taskId) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', this._bufferData[taskId]);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(
          xhr.response,
          function(audioBuffer) {
            that._updateProgress(taskId, audioBuffer);
          },
          function(errorMessage) {
            that._updateProgress(taskId, null);
            const message = 'BufferList: decoding "' +
                that._bufferData[taskId] + '" failed. (' + errorMessage + ')';
            Utils.throw(message);
            that._rejectHandler(message);
          });
    } else {
      const message = 'BufferList: XHR error while loading "' +
          that._bufferData[taskId] + '(' + xhr.statusText + ')';
      Utils.throw(message);
      that._rejectHandler(message);
    }
  };

  xhr.onerror = function(event) {
    Utils.throw(
        'BufferList: XHR network failed on loading "' +
        that._bufferData[taskId] + '".');
    that._updateProgress(taskId, null);
    that._rejectHandler();
  };

  xhr.send();
};


/**
 * Updates the overall progress on loading tasks.
 * @param {Number} taskId Task ID number.
 * @param {AudioBuffer} audioBuffer Decoded AudioBuffer object.
 */
BufferList.prototype._updateProgress = function(taskId, audioBuffer) {
  this._bufferList[taskId] = audioBuffer;

  if (this._options.verbose) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? 'ArrayBuffer(' + taskId + ') from Base64-encoded HRIR'
        : '"' + this._bufferData[taskId] + '"';
    Utils.log('BufferList: ' + messageString + ' successfully loaded.');
  }

  if (--this._numberOfTasks === 0) {
    let messageString = this._options.dataType === BufferDataType.BASE64
        ? this._bufferData.length + ' AudioBuffers from Base64-encoded HRIRs'
        : this._bufferData.length + ' files via XHR';
    Utils.log('BufferList: ' + messageString + ' loaded successfully.');
    this._resolveHandler(this._bufferList);
  }
};


module.exports = BufferList;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file An audio channel router to resolve different channel layouts between
 * browsers.
 */




/**
 * @typedef {Number[]} ChannelMap
 */

/**
 * Channel map dictionary ENUM.
 * @enum {ChannelMap}
 */
const ChannelMap = {
  /** @type {Number[]} - ACN channel map for Chrome and FireFox. (FFMPEG) */
  DEFAULT: [0, 1, 2, 3],
  /** @type {Number[]} - Safari's 4-channel map for AAC codec. */
  SAFARI: [2, 0, 1, 3],
  /** @type {Number[]} - ACN > FuMa conversion map. */
  FUMA: [0, 3, 1, 2],
};


/**
 * Channel router for FOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 */
function FOARouter(context, channelMap) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._merger = this._context.createChannelMerger(4);

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;

  this.setChannelMap(channelMap || ChannelMap.DEFAULT);
}


/**
 * Sets channel map.
 * @param {Number[]} channelMap - A new channel map for FOA stream.
 */
FOARouter.prototype.setChannelMap = function(channelMap) {
  if (!Array.isArray(channelMap)) {
    return;
  }

  this._channelMap = channelMap;
  this._splitter.disconnect();
  this._splitter.connect(this._merger, 0, this._channelMap[0]);
  this._splitter.connect(this._merger, 1, this._channelMap[1]);
  this._splitter.connect(this._merger, 2, this._channelMap[2]);
  this._splitter.connect(this._merger, 3, this._channelMap[3]);
};


/**
 * Static channel map ENUM.
 * @static
 * @type {ChannelMap}
 */
FOARouter.ChannelMap = ChannelMap;


module.exports = FOARouter;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for first-order-ambisonics decoding.
 */




/**
 * First-order-ambisonic decoder based on gain node network.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOARotator(context) {
  this._context = context;

  this._splitter = this._context.createChannelSplitter(4);
  this._inY = this._context.createGain();
  this._inZ = this._context.createGain();
  this._inX = this._context.createGain();
  this._m0 = this._context.createGain();
  this._m1 = this._context.createGain();
  this._m2 = this._context.createGain();
  this._m3 = this._context.createGain();
  this._m4 = this._context.createGain();
  this._m5 = this._context.createGain();
  this._m6 = this._context.createGain();
  this._m7 = this._context.createGain();
  this._m8 = this._context.createGain();
  this._outY = this._context.createGain();
  this._outZ = this._context.createGain();
  this._outX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  // ACN channel ordering: [1, 2, 3] => [-Y, Z, -X]
  // Y (from channel 1)
  this._splitter.connect(this._inY, 1);
  // Z (from channel 2)
  this._splitter.connect(this._inZ, 2);
  // X (from channel 3)
  this._splitter.connect(this._inX, 3);
  this._inY.gain.value = -1;
  this._inX.gain.value = -1;

  // Apply the rotation in the world space.
  // |Y|   | m0  m3  m6 |   | Y * m0 + Z * m3 + X * m6 |   | Yr |
  // |Z| * | m1  m4  m7 | = | Y * m1 + Z * m4 + X * m7 | = | Zr |
  // |X|   | m2  m5  m8 |   | Y * m2 + Z * m5 + X * m8 |   | Xr |
  this._inY.connect(this._m0);
  this._inY.connect(this._m1);
  this._inY.connect(this._m2);
  this._inZ.connect(this._m3);
  this._inZ.connect(this._m4);
  this._inZ.connect(this._m5);
  this._inX.connect(this._m6);
  this._inX.connect(this._m7);
  this._inX.connect(this._m8);
  this._m0.connect(this._outY);
  this._m1.connect(this._outZ);
  this._m2.connect(this._outX);
  this._m3.connect(this._outY);
  this._m4.connect(this._outZ);
  this._m5.connect(this._outX);
  this._m6.connect(this._outY);
  this._m7.connect(this._outZ);
  this._m8.connect(this._outX);

  // Transform 3: world space to audio space.
  // W -> W (to channel 0)
  this._splitter.connect(this._merger, 0, 0);
  // Y (to channel 1)
  this._outY.connect(this._merger, 0, 1);
  // Z (to channel 2)
  this._outZ.connect(this._merger, 0, 2);
  // X (to channel 3)
  this._outX.connect(this._merger, 0, 3);
  this._outY.gain.value = -1;
  this._outX.gain.value = -1;

  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // input/output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  this._m0.gain.value = rotationMatrix3[0];
  this._m1.gain.value = rotationMatrix3[1];
  this._m2.gain.value = rotationMatrix3[2];
  this._m3.gain.value = rotationMatrix3[3];
  this._m4.gain.value = rotationMatrix3[4];
  this._m5.gain.value = rotationMatrix3[5];
  this._m6.gain.value = rotationMatrix3[6];
  this._m7.gain.value = rotationMatrix3[7];
  this._m8.gain.value = rotationMatrix3[8];
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._m0.gain.value = rotationMatrix4[0];
  this._m1.gain.value = rotationMatrix4[1];
  this._m2.gain.value = rotationMatrix4[2];
  this._m3.gain.value = rotationMatrix4[4];
  this._m4.gain.value = rotationMatrix4[5];
  this._m5.gain.value = rotationMatrix4[6];
  this._m6.gain.value = rotationMatrix4[8];
  this._m7.gain.value = rotationMatrix4[9];
  this._m8.gain.value = rotationMatrix4[10];
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix3 = function() {
  return [
    this._m0.gain.value, this._m1.gain.value, this._m2.gain.value,
    this._m3.gain.value, this._m4.gain.value, this._m5.gain.value,
    this._m6.gain.value, this._m7.gain.value, this._m8.gain.value,
  ];
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
FOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._m0.gain.value;
  rotationMatrix4[1] = this._m1.gain.value;
  rotationMatrix4[2] = this._m2.gain.value;
  rotationMatrix4[4] = this._m3.gain.value;
  rotationMatrix4[5] = this._m4.gain.value;
  rotationMatrix4[6] = this._m5.gain.value;
  rotationMatrix4[8] = this._m6.gain.value;
  rotationMatrix4[9] = this._m7.gain.value;
  rotationMatrix4[10] = this._m8.gain.value;
  return rotationMatrix4;
};


module.exports = FOARotator;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized FOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * FOAConvolver. A collection of 2 stereo convolvers for 4-channel FOA stream.
 * @constructor
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (i.e. 2 stereo AudioBuffers for FOA)
 */
function FOAConvolver(context, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  this._buildAudioGraph();

  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 *
 * @private
 */
FOAConvolver.prototype._buildAudioGraph = function() {
  this._splitterWYZX = this._context.createChannelSplitter(4);
  this._mergerWY = this._context.createChannelMerger(2);
  this._mergerZX = this._context.createChannelMerger(2);
  this._convolverWY = this._context.createConvolver();
  this._convolverZX = this._context.createConvolver();
  this._splitterWY = this._context.createChannelSplitter(2);
  this._splitterZX = this._context.createChannelSplitter(2);
  this._inverter = this._context.createGain();
  this._mergerBinaural = this._context.createChannelMerger(2);
  this._summingBus = this._context.createGain();

  // Group W and Y, then Z and X.
  this._splitterWYZX.connect(this._mergerWY, 0, 0);
  this._splitterWYZX.connect(this._mergerWY, 1, 1);
  this._splitterWYZX.connect(this._mergerZX, 2, 0);
  this._splitterWYZX.connect(this._mergerZX, 3, 1);

  // Create a network of convolvers using splitter/merger.
  this._mergerWY.connect(this._convolverWY);
  this._mergerZX.connect(this._convolverZX);
  this._convolverWY.connect(this._splitterWY);
  this._convolverZX.connect(this._splitterZX);
  this._splitterWY.connect(this._mergerBinaural, 0, 0);
  this._splitterWY.connect(this._mergerBinaural, 0, 1);
  this._splitterWY.connect(this._mergerBinaural, 1, 0);
  this._splitterWY.connect(this._inverter, 1, 0);
  this._inverter.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 0, 0);
  this._splitterZX.connect(this._mergerBinaural, 0, 1);
  this._splitterZX.connect(this._mergerBinaural, 1, 0);
  this._splitterZX.connect(this._mergerBinaural, 1, 1);

  // By default, WebAudio's convolver does the normalization based on IR's
  // energy. For the precise convolution, it must be disabled before the buffer
  // assignment.
  this._convolverWY.normalize = false;
  this._convolverZX.normalize = false;

  // For asymmetric degree.
  this._inverter.gain.value = -1;

  // Input/output proxy.
  this.input = this._splitterWYZX;
  this.output = this._summingBus;
};


/**
 * Assigns 2 HRIR AudioBuffers to 2 convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
FOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  this._convolverWY.buffer = hrirBufferList[0];
  this._convolverZX.buffer = hrirBufferList[1];
  this._isBufferLoaded = true;
};


/**
 * Enable FOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
FOAConvolver.prototype.enable = function() {
  this._mergerBinaural.connect(this._summingBus);
  this._active = true;
};


/**
 * Disable FOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
FOAConvolver.prototype.disable = function() {
  this._mergerBinaural.disconnect();
  this._active = false;
};


module.exports = FOAConvolver;


/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_178724__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileOverview DEPRECATED at V1. Audio buffer loading utility.
 */



const Utils = __nested_webpack_require_178724__(0);

/**
 * Streamlined audio file loader supports Promise.
 * @param {Object} context          AudioContext
 * @param {Object} audioFileData    Audio file info as [{name, url}]
 * @param {Function} resolve        Resolution handler for promise.
 * @param {Function} reject         Rejection handler for promise.
 * @param {Function} progress       Progress event handler.
 */
function AudioBufferManager(context, audioFileData, resolve, reject, progress) {
  this._context = context;

  this._buffers = new Map();
  this._loadingTasks = {};

  this._resolve = resolve;
  this._reject = reject;
  this._progress = progress;

  // Iterating file loading.
  for (let i = 0; i < audioFileData.length; i++) {
    const fileInfo = audioFileData[i];

    // Check for duplicates filename and quit if it happens.
    if (this._loadingTasks.hasOwnProperty(fileInfo.name)) {
      Utils.log('Duplicated filename when loading: ' + fileInfo.name);
      return;
    }

    // Mark it as pending (0)
    this._loadingTasks[fileInfo.name] = 0;
    this._loadAudioFile(fileInfo);
  }
}

AudioBufferManager.prototype._loadAudioFile = function(fileInfo) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', fileInfo.url);
  xhr.responseType = 'arraybuffer';

  const that = this;
  xhr.onload = function() {
    if (xhr.status === 200) {
      that._context.decodeAudioData(xhr.response,
        function(buffer) {
          // Utils.log('File loaded: ' + fileInfo.url);
          that._done(fileInfo.name, buffer);
        },
        function(message) {
          Utils.log('Decoding failure: '
            + fileInfo.url + ' (' + message + ')');
          that._done(fileInfo.name, null);
        });
    } else {
      Utils.log('XHR Error: ' + fileInfo.url + ' (' + xhr.statusText
        + ')');
      that._done(fileInfo.name, null);
    }
  };

  // TODO: fetch local resources if XHR fails.
  xhr.onerror = function(event) {
    Utils.log('XHR Network failure: ' + fileInfo.url);
    that._done(fileInfo.name, null);
  };

  xhr.send();
};

AudioBufferManager.prototype._done = function(filename, buffer) {
  // Label the loading task.
  this._loadingTasks[filename] = buffer !== null ? 'loaded' : 'failed';

  // A failed task will be a null buffer.
  this._buffers.set(filename, buffer);

  this._updateProgress(filename);
};

AudioBufferManager.prototype._updateProgress = function(filename) {
  let numberOfFinishedTasks = 0;
  let numberOfFailedTask = 0;
  let numberOfTasks = 0;

  for (const task in this._loadingTasks) {
    if (Object.prototype.hasOwnProperty.call(this._loadingTasks, task)) {
      numberOfTasks++;
      if (this._loadingTasks[task] === 'loaded') {
        numberOfFinishedTasks++;
      } else if (this._loadingTasks[task] === 'failed') {
        numberOfFailedTask++;
      }
    }
  }

  if (typeof this._progress === 'function') {
    this._progress(filename, numberOfFinishedTasks, numberOfTasks);
    return;
  }

  if (numberOfFinishedTasks === numberOfTasks) {
    this._resolve(this._buffers);
    return;
  }

  if (numberOfFinishedTasks + numberOfFailedTask === numberOfTasks) {
    this._reject(this._buffers);
    return;
  }
};

module.exports = AudioBufferManager;


/***/ }),
/* 6 */
/***/ (function(module, exports, __nested_webpack_require_182743__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Phase matched filter for first-order-ambisonics decoding.
 */



const Utils = __nested_webpack_require_182743__(0);


// Static parameters.
const CROSSOVER_FREQUENCY = 690;
const GAIN_COEFFICIENTS = [1.4142, 0.8166, 0.8166, 0.8166];


/**
 * Generate the coefficients for dual band filter.
 * @param {Number} crossoverFrequency
 * @param {Number} sampleRate
 * @return {Object} Filter coefficients.
 */
function generateDualBandCoefficients(crossoverFrequency, sampleRate) {
  const k = Math.tan(Math.PI * crossoverFrequency / sampleRate);
  const k2 = k * k;
  const denominator = k2 + 2 * k + 1;

  return {
    lowpassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    lowpassB: [k2 / denominator, 2 * k2 / denominator, k2 / denominator],
    hipassA: [1, 2 * (k2 - 1) / denominator, (k2 - 2 * k + 1) / denominator],
    hipassB: [1 / denominator, -2 * 1 / denominator, 1 / denominator],
  };
}


/**
 * FOAPhaseMatchedFilter: A set of filters (LP/HP) with a crossover frequency to
 * compensate the gain of high frequency contents without a phase difference.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 */
function FOAPhaseMatchedFilter(context) {
  this._context = context;

  this._input = this._context.createGain();

  if (!this._context.createIIRFilter) {
    Utils.log('IIR filter is missing. Using Biquad filter instead.');
    this._lpf = this._context.createBiquadFilter();
    this._hpf = this._context.createBiquadFilter();
    this._lpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.frequency.value = CROSSOVER_FREQUENCY;
    this._hpf.type = 'highpass';
  } else {
    const coef = generateDualBandCoefficients(CROSSOVER_FREQUENCY,
                                              this._context.sampleRate);
    this._lpf = this._context.createIIRFilter(coef.lowpassB, coef.lowpassA);
    this._hpf = this._context.createIIRFilter(coef.hipassB, coef.hipassA);
  }

  this._splitterLow = this._context.createChannelSplitter(4);
  this._splitterHigh = this._context.createChannelSplitter(4);
  this._gainHighW = this._context.createGain();
  this._gainHighY = this._context.createGain();
  this._gainHighZ = this._context.createGain();
  this._gainHighX = this._context.createGain();
  this._merger = this._context.createChannelMerger(4);

  this._input.connect(this._hpf);
  this._hpf.connect(this._splitterHigh);
  this._splitterHigh.connect(this._gainHighW, 0);
  this._splitterHigh.connect(this._gainHighY, 1);
  this._splitterHigh.connect(this._gainHighZ, 2);
  this._splitterHigh.connect(this._gainHighX, 3);
  this._gainHighW.connect(this._merger, 0, 0);
  this._gainHighY.connect(this._merger, 0, 1);
  this._gainHighZ.connect(this._merger, 0, 2);
  this._gainHighX.connect(this._merger, 0, 3);

  this._input.connect(this._lpf);
  this._lpf.connect(this._splitterLow);
  this._splitterLow.connect(this._merger, 0, 0);
  this._splitterLow.connect(this._merger, 1, 1);
  this._splitterLow.connect(this._merger, 2, 2);
  this._splitterLow.connect(this._merger, 3, 3);

  // Apply gain correction to hi-passed pressure and velocity components:
  // Inverting sign is necessary as the low-passed and high-passed portion are
  // out-of-phase after the filtering.
  const now = this._context.currentTime;
  this._gainHighW.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[0], now);
  this._gainHighY.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[1], now);
  this._gainHighZ.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[2], now);
  this._gainHighX.gain.setValueAtTime(-1 * GAIN_COEFFICIENTS[3], now);

  // Input/output Proxy.
  this.input = this._input;
  this.output = this._merger;
}


module.exports = FOAPhaseMatchedFilter;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Virtual speaker abstraction for first-order-ambisonics decoding.
 */




/**
 * DEPRECATED at V1: A virtual speaker with ambisonic decoding gain coefficients
 * and HRTF convolution for first-order-ambisonics stream. Note that the
 * subgraph directly connects to context's destination.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options for speaker.
 * @param {Number[]} options.coefficients - Decoding coefficients for (W,Y,Z,X).
 * @param {AudioBuffer} options.IR - Stereo IR buffer for HRTF convolution.
 * @param {Number} options.gain - Post-gain for the speaker.
 */
function FOAVirtualSpeaker(context, options) {
  if (options.IR.numberOfChannels !== 2) {
    throw new Error('IR does not have 2 channels. cannot proceed.');
  }

  this._active = false;
  this._context = context;

  this._input = this._context.createChannelSplitter(4);
  this._cW = this._context.createGain();
  this._cY = this._context.createGain();
  this._cZ = this._context.createGain();
  this._cX = this._context.createGain();
  this._convolver = this._context.createConvolver();
  this._gain = this._context.createGain();

  this._input.connect(this._cW, 0);
  this._input.connect(this._cY, 1);
  this._input.connect(this._cZ, 2);
  this._input.connect(this._cX, 3);
  this._cW.connect(this._convolver);
  this._cY.connect(this._convolver);
  this._cZ.connect(this._convolver);
  this._cX.connect(this._convolver);
  this._convolver.connect(this._gain);
  this._gain.connect(this._context.destination);

  this.enable();

  this._convolver.normalize = false;
  this._convolver.buffer = options.IR;
  this._gain.gain.value = options.gain;

  // Set gain coefficients for FOA ambisonic streams.
  this._cW.gain.value = options.coefficients[0];
  this._cY.gain.value = options.coefficients[1];
  this._cZ.gain.value = options.coefficients[2];
  this._cX.gain.value = options.coefficients[3];

  // Input proxy. Output directly connects to the destination.
  this.input = this._input;
}


FOAVirtualSpeaker.prototype.enable = function() {
  this._gain.connect(this._context.destination);
  this._active = true;
};


FOAVirtualSpeaker.prototype.disable = function() {
  this._gain.disconnect();
  this._active = false;
};


module.exports = FOAVirtualSpeaker;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file A collection of convolvers. Can be used for the optimized HOA binaural
 * rendering. (e.g. SH-MaxRe HRTFs)
 */




/**
 * A convolver network for N-channel HOA stream.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 */
function HOAConvolver(context, ambisonicOrder, hrirBufferList) {
  this._context = context;

  this._active = false;
  this._isBufferLoaded = false;

  // The number of channels K based on the ambisonic order N where K = (N+1)^2.
  this._ambisonicOrder = ambisonicOrder;
  this._numberOfChannels =
      (this._ambisonicOrder + 1) * (this._ambisonicOrder + 1);

  this._buildAudioGraph();
  if (hrirBufferList) {
    this.setHRIRBufferList(hrirBufferList);
  }

  this.enable();
}


/**
 * Build the internal audio graph.
 * For TOA convolution:
 *   input -> splitter(16) -[0,1]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[2,3]-> merger(2) -> convolver(2) -> splitter(2)
 *                         -[4,5]-> ... (6 more, 8 branches total)
 * @private
 */
HOAConvolver.prototype._buildAudioGraph = function() {
  const numberOfStereoChannels = Math.ceil(this._numberOfChannels / 2);

  this._inputSplitter =
      this._context.createChannelSplitter(this._numberOfChannels);
  this._stereoMergers = [];
  this._convolvers = [];
  this._stereoSplitters = [];
  this._positiveIndexSphericalHarmonics = this._context.createGain();
  this._negativeIndexSphericalHarmonics = this._context.createGain();
  this._inverter = this._context.createGain();
  this._binauralMerger = this._context.createChannelMerger(2);
  this._outputGain = this._context.createGain();

  for (let i = 0; i < numberOfStereoChannels; ++i) {
    this._stereoMergers[i] = this._context.createChannelMerger(2);
    this._convolvers[i] = this._context.createConvolver();
    this._stereoSplitters[i] = this._context.createChannelSplitter(2);
    this._convolvers[i].normalize = false;
  }

  for (let l = 0; l <= this._ambisonicOrder; ++l) {
    for (let m = -l; m <= l; m++) {
      // We compute the ACN index (k) of ambisonics channel using the degree (l)
      // and index (m): k = l^2 + l + m
      const acnIndex = l * l + l + m;
      const stereoIndex = Math.floor(acnIndex / 2);

      // Split channels from input into array of stereo convolvers.
      // Then create a network of mergers that produces the stereo output.
      this._inputSplitter.connect(
          this._stereoMergers[stereoIndex], acnIndex, acnIndex % 2);
      this._stereoMergers[stereoIndex].connect(this._convolvers[stereoIndex]);
      this._convolvers[stereoIndex].connect(this._stereoSplitters[stereoIndex]);

      // Positive index (m >= 0) spherical harmonics are symmetrical around the
      // front axis, while negative index (m < 0) spherical harmonics are
      // anti-symmetrical around the front axis. We will exploit this symmetry
      // to reduce the number of convolutions required when rendering to a
      // symmetrical binaural renderer.
      if (m >= 0) {
        this._stereoSplitters[stereoIndex].connect(
            this._positiveIndexSphericalHarmonics, acnIndex % 2);
      } else {
        this._stereoSplitters[stereoIndex].connect(
            this._negativeIndexSphericalHarmonics, acnIndex % 2);
      }
    }
  }

  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._positiveIndexSphericalHarmonics.connect(this._binauralMerger, 0, 1);
  this._negativeIndexSphericalHarmonics.connect(this._binauralMerger, 0, 0);
  this._negativeIndexSphericalHarmonics.connect(this._inverter);
  this._inverter.connect(this._binauralMerger, 0, 1);

  // For asymmetric index.
  this._inverter.gain.value = -1;

  // Input/Output proxy.
  this.input = this._inputSplitter;
  this.output = this._outputGain;
};


/**
 * Assigns N HRIR AudioBuffers to N convolvers: Note that we use 2 stereo
 * convolutions for 4-channel direct convolution. Using mono convolver or
 * 4-channel convolver is not viable because mono convolution wastefully
 * produces the stereo outputs, and the 4-ch convolver does cross-channel
 * convolution. (See Web Audio API spec)
 * @param {AudioBuffer[]} hrirBufferList - An array of stereo AudioBuffers for
 * convolvers.
 */
HOAConvolver.prototype.setHRIRBufferList = function(hrirBufferList) {
  // After these assignments, the channel data in the buffer is immutable in
  // FireFox. (i.e. neutered) So we should avoid re-assigning buffers, otherwise
  // an exception will be thrown.
  if (this._isBufferLoaded) {
    return;
  }

  for (let i = 0; i < hrirBufferList.length; ++i) {
    this._convolvers[i].buffer = hrirBufferList[i];
  }

  this._isBufferLoaded = true;
};


/**
 * Enable HOAConvolver instance. The audio graph will be activated and pulled by
 * the WebAudio engine. (i.e. consume CPU cycle)
 */
HOAConvolver.prototype.enable = function() {
  this._binauralMerger.connect(this._outputGain);
  this._active = true;
};


/**
 * Disable HOAConvolver instance. The inner graph will be disconnected from the
 * audio destination, thus no CPU cycle will be consumed.
 */
HOAConvolver.prototype.disable = function() {
  this._binauralMerger.disconnect();
  this._active = false;
};


module.exports = HOAConvolver;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Sound field rotator for higher-order-ambisonics decoding.
 */




/**
 * Kronecker Delta function.
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getKroneckerDelta(i, j) {
  return i === j ? 1 : 0;
}


/**
 * A helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1)x(2l+1) matrix. [2] uses an odd convention of
 * referring to the rows and columns using centered indices, so the middle row
 * and column are (0, 0) and the upper left would have negative coordinates.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @param {Number} gainValue
 */
function setCenteredElement(matrix, l, i, j, gainValue) {
  const index = (j + l) * (2 * l + 1) + (i + l);
  // Row-wise indexing.
  matrix[l - 1][index].gain.value = gainValue;
}


/**
 * This is a helper function to allow us to access a matrix array in the same
 * manner, assuming it is a (2l+1) x (2l+1) matrix.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} l
 * @param {Number} i
 * @param {Number} j
 * @return {Number}
 */
function getCenteredElement(matrix, l, i, j) {
  // Row-wise indexing.
  const index = (j + l) * (2 * l + 1) + (i + l);
  return matrix[l - 1][index].gain.value;
}


/**
 * Helper function defined in [2] that is used by the functions U, V, W.
 * This should not be called on its own, as U, V, and W (and their coefficients)
 * select the appropriate matrix elements to access arguments |a| and |b|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} i
 * @param {Number} a
 * @param {Number} b
 * @param {Number} l
 * @return {Number}
 */
function getP(matrix, i, a, b, l) {
  if (b === l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, l - 1) -
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, -l + 1);
  } else if (b === -l) {
    return getCenteredElement(matrix, 1, i, 1) *
        getCenteredElement(matrix, l - 1, a, -l + 1) +
        getCenteredElement(matrix, 1, i, -1) *
        getCenteredElement(matrix, l - 1, a, l - 1);
  } else {
    return getCenteredElement(matrix, 1, i, 0) *
        getCenteredElement(matrix, l - 1, a, b);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getU(matrix, m, n, l) {
  // Although [1, 2] split U into three cases for m == 0, m < 0, m > 0
  // the actual values are the same for all three cases.
  return getP(matrix, 0, m, n, l);
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getV(matrix, m, n, l) {
  if (m === 0) {
    return getP(matrix, 1, 1, n, l) + getP(matrix, -1, -1, n, l);
  } else if (m > 0) {
    const d = getKroneckerDelta(m, 1);
    return getP(matrix, 1, m - 1, n, l) * Math.sqrt(1 + d) -
        getP(matrix, -1, -m + 1, n, l) * (1 - d);
  } else {
    // Note there is apparent errata in [1,2,2b] dealing with this particular
    // case. [2b] writes it should be P*(1-d)+P*(1-d)^0.5
    // [1] writes it as P*(1+d)+P*(1-d)^0.5, but going through the math by hand,
    // you must have it as P*(1-d)+P*(1+d)^0.5 to form a 2^.5 term, which
    // parallels the case where m > 0.
    const d = getKroneckerDelta(m, -1);
    return getP(matrix, 1, m + 1, n, l) * (1 - d) +
        getP(matrix, -1, -m - 1, n, l) * Math.sqrt(1 + d);
  }
}


/**
 * The functions U, V, and W should only be called if the correspondingly
 * named coefficient u, v, w from the function ComputeUVWCoeff() is non-zero.
 * When the coefficient is 0, these would attempt to access matrix elements that
 * are out of bounds. The vector of rotations, |r|, must have the |l - 1|
 * previously completed band rotations. These functions are valid for |l >= 2|.
 * @param {Number[]} matrix N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Number}
 */
function getW(matrix, m, n, l) {
  // Whenever this happens, w is also 0 so W can be anything.
  if (m === 0) {
    return 0;
  }

  return m > 0 ? getP(matrix, 1, m + 1, n, l) + getP(matrix, -1, -m - 1, n, l) :
                 getP(matrix, 1, m - 1, n, l) - getP(matrix, -1, -m + 1, n, l);
}


/**
 * Calculates the coefficients applied to the U, V, and W functions. Because
 * their equations share many common terms they are computed simultaneously.
 * @param {Number} m
 * @param {Number} n
 * @param {Number} l
 * @return {Array} 3 coefficients for U, V and W functions.
 */
function computeUVWCoeff(m, n, l) {
  const d = getKroneckerDelta(m, 0);
  const reciprocalDenominator =
      Math.abs(n) === l ? 1 / (2 * l * (2 * l - 1)) : 1 / ((l + n) * (l - n));

  return [
    Math.sqrt((l + m) * (l - m) * reciprocalDenominator),
    0.5 * (1 - 2 * d) * Math.sqrt((1 + d) *
                                  (l + Math.abs(m) - 1) *
                                  (l + Math.abs(m)) *
                                  reciprocalDenominator),
    -0.5 * (1 - d) * Math.sqrt((l - Math.abs(m) - 1) * (l - Math.abs(m))) *
        reciprocalDenominator,
  ];
}


/**
 * Calculates the (2l+1) x (2l+1) rotation matrix for the band l.
 * This uses the matrices computed for band 1 and band l-1 to compute the
 * matrix for band l. |rotations| must contain the previously computed l-1
 * rotation matrices.
 * This implementation comes from p. 5 (6346), Table 1 and 2 in [2] taking
 * into account the corrections from [2b].
 * @param {Number[]} matrix - N matrices of gainNodes, each with where
 * n=1,2,...,N.
 * @param {Number} l
 */
function computeBandRotation(matrix, l) {
  // The lth band rotation matrix has rows and columns equal to the number of
  // coefficients within that band (-l <= m <= l implies 2l + 1 coefficients).
  for (let m = -l; m <= l; m++) {
    for (let n = -l; n <= l; n++) {
      const uvwCoefficients = computeUVWCoeff(m, n, l);

      // The functions U, V, W are only safe to call if the coefficients
      // u, v, w are not zero.
      if (Math.abs(uvwCoefficients[0]) > 0) {
        uvwCoefficients[0] *= getU(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[1]) > 0) {
        uvwCoefficients[1] *= getV(matrix, m, n, l);
      }
      if (Math.abs(uvwCoefficients[2]) > 0) {
        uvwCoefficients[2] *= getW(matrix, m, n, l);
      }

      setCenteredElement(
          matrix, l, m, n,
          uvwCoefficients[0] + uvwCoefficients[1] + uvwCoefficients[2]);
    }
  }
}


/**
 * Compute the HOA rotation matrix after setting the transform matrix.
 * @param {Array} matrix - N matrices of gainNodes, each with (2n+1) x (2n+1)
 * elements, where n=1,2,...,N.
 */
function computeHOAMatrices(matrix) {
  // We start by computing the 2nd-order matrix from the 1st-order matrix.
  for (let i = 2; i <= matrix.length; i++) {
    computeBandRotation(matrix, i);
  }
}


/**
 * Higher-order-ambisonic decoder based on gain node network. We expect
 * the order of the channels to conform to ACN ordering. Below are the helper
 * methods to compute SH rotation using recursion. The code uses maths described
 * in the following papers:
 *  [1] R. Green, "Spherical Harmonic Lighting: The Gritty Details", GDC 2003,
 *      http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf
 *  [2] J. Ivanic and K. Ruedenberg, "Rotation Matrices for Real
 *      Spherical Harmonics. Direct Determination by Recursion", J. Phys.
 *      Chem., vol. 100, no. 15, pp. 6342-6347, 1996.
 *      http://pubs.acs.org/doi/pdf/10.1021/jp953350u
 *  [2b] Corrections to initial publication:
 *       http://pubs.acs.org/doi/pdf/10.1021/jp9833350
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 */
function HOARotator(context, ambisonicOrder) {
  this._context = context;
  this._ambisonicOrder = ambisonicOrder;

  // We need to determine the number of channels K based on the ambisonic order
  // N where K = (N + 1)^2.
  const numberOfChannels = (ambisonicOrder + 1) * (ambisonicOrder + 1);

  this._splitter = this._context.createChannelSplitter(numberOfChannels);
  this._merger = this._context.createChannelMerger(numberOfChannels);

  // Create a set of per-order rotation matrices using gain nodes.
  this._gainNodeMatrix = [];
  let orderOffset;
  let rows;
  let inputIndex;
  let outputIndex;
  let matrixIndex;
  for (let i = 1; i <= ambisonicOrder; i++) {
    // Each ambisonic order requires a separate (2l + 1) x (2l + 1) rotation
    // matrix. We compute the offset value as the first channel index of the
    // current order where
    //   k_last = l^2 + l + m,
    // and m = -l
    //   k_last = l^2
    orderOffset = i * i;

    // Uses row-major indexing.
    rows = (2 * i + 1);

    this._gainNodeMatrix[i - 1] = [];
    for (let j = 0; j < rows; j++) {
      inputIndex = orderOffset + j;
      for (let k = 0; k < rows; k++) {
        outputIndex = orderOffset + k;
        matrixIndex = j * rows + k;
        this._gainNodeMatrix[i - 1][matrixIndex] = this._context.createGain();
        this._splitter.connect(
            this._gainNodeMatrix[i - 1][matrixIndex], inputIndex);
        this._gainNodeMatrix[i - 1][matrixIndex].connect(
            this._merger, 0, outputIndex);
      }
    }
  }

  // W-channel is not involved in rotation, skip straight to ouput.
  this._splitter.connect(this._merger, 0, 0);

  // Default Identity matrix.
  this.setRotationMatrix3(new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]));

  // Input/Output proxy.
  this.input = this._splitter;
  this.output = this._merger;
}


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  for (let i = 0; i < 9; ++i) {
    this._gainNodeMatrix[0][i].gain.value = rotationMatrix3[i];
  }
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  this._gainNodeMatrix[0][0].gain.value = rotationMatrix4[0];
  this._gainNodeMatrix[0][1].gain.value = rotationMatrix4[1];
  this._gainNodeMatrix[0][2].gain.value = rotationMatrix4[2];
  this._gainNodeMatrix[0][3].gain.value = rotationMatrix4[4];
  this._gainNodeMatrix[0][4].gain.value = rotationMatrix4[5];
  this._gainNodeMatrix[0][5].gain.value = rotationMatrix4[6];
  this._gainNodeMatrix[0][6].gain.value = rotationMatrix4[8];
  this._gainNodeMatrix[0][7].gain.value = rotationMatrix4[9];
  this._gainNodeMatrix[0][8].gain.value = rotationMatrix4[10];
  computeHOAMatrices(this._gainNodeMatrix);
};


/**
 * Returns the current 3x3 rotation matrix.
 * @return {Number[]} - A 3x3 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix3 = function() {
  let rotationMatrix3 = new Float32Array(9);
  for (let i = 0; i < 9; ++i) {
    rotationMatrix3[i] = this._gainNodeMatrix[0][i].gain.value;
  }
  return rotationMatrix3;
};


/**
 * Returns the current 4x4 rotation matrix.
 * @return {Number[]} - A 4x4 rotation matrix. (column-major)
 */
HOARotator.prototype.getRotationMatrix4 = function() {
  let rotationMatrix4 = new Float32Array(16);
  rotationMatrix4[0] = this._gainNodeMatrix[0][0].gain.value;
  rotationMatrix4[1] = this._gainNodeMatrix[0][1].gain.value;
  rotationMatrix4[2] = this._gainNodeMatrix[0][2].gain.value;
  rotationMatrix4[4] = this._gainNodeMatrix[0][3].gain.value;
  rotationMatrix4[5] = this._gainNodeMatrix[0][4].gain.value;
  rotationMatrix4[6] = this._gainNodeMatrix[0][5].gain.value;
  rotationMatrix4[8] = this._gainNodeMatrix[0][6].gain.value;
  rotationMatrix4[9] = this._gainNodeMatrix[0][7].gain.value;
  rotationMatrix4[10] = this._gainNodeMatrix[0][8].gain.value;
  return rotationMatrix4;
};


/**
 * Get the current ambisonic order.
 * @return {Number}
 */
HOARotator.prototype.getAmbisonicOrder = function() {
  return this._ambisonicOrder;
};


module.exports = HOARotator;


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_210444__) {

"use strict";
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Namespace for Omnitone library.
 */




exports.Omnitone = __nested_webpack_require_210444__(11);


/***/ }),
/* 11 */
/***/ (function(module, exports, __nested_webpack_require_211260__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone library name space and user-facing APIs.
 */




const BufferList = __nested_webpack_require_211260__(1);
const FOAConvolver = __nested_webpack_require_211260__(4);
const FOADecoder = __nested_webpack_require_211260__(12);
const FOAPhaseMatchedFilter = __nested_webpack_require_211260__(6);
const FOARenderer = __nested_webpack_require_211260__(14);
const FOARotator = __nested_webpack_require_211260__(3);
const FOARouter = __nested_webpack_require_211260__(2);
const FOAVirtualSpeaker = __nested_webpack_require_211260__(7);
const HOAConvolver = __nested_webpack_require_211260__(8);
const HOARenderer = __nested_webpack_require_211260__(16);
const HOARotator = __nested_webpack_require_211260__(9);
const Polyfill = __nested_webpack_require_211260__(19);
const Utils = __nested_webpack_require_211260__(0);
const Version = __nested_webpack_require_211260__(20);

// DEPRECATED in V1, in favor of BufferList.
const AudioBufferManager = __nested_webpack_require_211260__(5);


/**
 * Omnitone namespace.
 * @namespace
 */
let Omnitone = {};


/**
 * @typedef {Object} BrowserInfo
 * @property {string} name - Browser name.
 * @property {string} version - Browser version.
 */

/**
 * An object contains the detected browser name and version.
 * @memberOf Omnitone
 * @static {BrowserInfo}
 */
Omnitone.browserInfo = Polyfill.getBrowserInfo();


// DEPRECATED in V1. DO. NOT. USE.
Omnitone.loadAudioBuffers = function(context, speakerData) {
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(context, speakerData, function(buffers) {
      resolve(buffers);
    }, reject);
  });
};


/**
 * Performs the async loading/decoding of multiple AudioBuffers from multiple
 * URLs.
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {string[]} bufferData - An ordered list of URLs.
 * @param {Object} [options] - BufferList options.
 * @param {String} [options.dataType='url'] - BufferList data type.
 * @return {Promise<AudioBuffer[]>} - The promise resolves with an array of
 * AudioBuffer.
 */
Omnitone.createBufferList = function(context, bufferData, options) {
  const bufferList =
      new BufferList(context, bufferData, options || {dataType: 'url'});
  return bufferList.load();
};


/**
 * Perform channel-wise merge on multiple AudioBuffers. The sample rate and
 * the length of buffers to be merged must be identical.
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer[]} bufferList - An array of AudioBuffers to be merged
 * channel-wise.
 * @return {AudioBuffer} - A single merged AudioBuffer.
 */
Omnitone.mergeBufferListByChannel = Utils.mergeBufferListByChannel;


/**
 * Perform channel-wise split by the given channel count. For example,
 * 1 x AudioBuffer(8) -> splitBuffer(context, buffer, 2) -> 4 x AudioBuffer(2).
 * @static
 * @function
 * @param {BaseAudioContext} context - Associated BaseAudioContext.
 * @param {AudioBuffer} audioBuffer - An AudioBuffer to be splitted.
 * @param {Number} splitBy - Number of channels to be splitted.
 * @return {AudioBuffer[]} - An array of splitted AudioBuffers.
 */
Omnitone.splitBufferbyChannel = Utils.splitBufferbyChannel;


/**
 * Creates an instance of FOA Convolver.
 * @see FOAConvolver
 * @param {BaseAudioContext} context The associated AudioContext.
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * @return {FOAConvolver}
 */
Omnitone.createFOAConvolver = function(context, hrirBufferList) {
  return new FOAConvolver(context, hrirBufferList);
};


/**
 * Create an instance of FOA Router.
 * @see FOARouter
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number[]} channelMap - Routing destination array.
 * @return {FOARouter}
 */
Omnitone.createFOARouter = function(context, channelMap) {
  return new FOARouter(context, channelMap);
};


/**
 * Create an instance of FOA Rotator.
 * @see FOARotator
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOARotator}
 */
Omnitone.createFOARotator = function(context) {
  return new FOARotator(context);
};


/**
 * Create an instance of FOAPhaseMatchedFilter.
 * @ignore
 * @see FOAPhaseMatchedFilter
 * @param {AudioContext} context - Associated AudioContext.
 * @return {FOAPhaseMatchedFilter}
 */
Omnitone.createFOAPhaseMatchedFilter = function(context) {
  return new FOAPhaseMatchedFilter(context);
};


/**
 * Create an instance of FOAVirtualSpeaker. For parameters, refer the
 * definition of VirtualSpeaker class.
 * @ignore
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} options - Options.
 * @return {FOAVirtualSpeaker}
 */
Omnitone.createFOAVirtualSpeaker = function(context, options) {
  return new FOAVirtualSpeaker(context, options);
};


/**
 * DEPRECATED. Use FOARenderer instance.
 * @see FOARenderer
 * @param {AudioContext} context - Associated AudioContext.
 * @param {DOMElement} videoElement - Video or Audio DOM element to be streamed.
 * @param {Object} options - Options for FOA decoder.
 * @param {String} options.baseResourceUrl - Base URL for resources.
 * (base path for HRIR files)
 * @param {Number} [options.postGain=26.0] - Post-decoding gain compensation.
 * @param {Array} [options.routingDestination]  Custom channel layout.
 * @return {FOADecoder}
 */
Omnitone.createFOADecoder = function(context, videoElement, options) {
  Utils.log('WARNING: FOADecoder is deprecated in favor of FOARenderer.');
  return new FOADecoder(context, videoElement, options);
};


/**
 * Create a FOARenderer, the first-order ambisonic decoder and the optimized
 * binaural renderer.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {FOARenderer}
 */
Omnitone.createFOARenderer = function(context, config) {
  return new FOARenderer(context, config);
};


/**
 * Creates HOARotator for higher-order ambisonics rotation.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order.
 * @return {HOARotator}
 */
Omnitone.createHOARotator = function(context, ambisonicOrder) {
  return new HOARotator(context, ambisonicOrder);
};


/**
 * Creates HOAConvolver performs the multi-channel convolution for the optmized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Number} ambisonicOrder - Ambisonic order. (2 or 3)
 * @param {AudioBuffer[]} [hrirBufferList] - An ordered-list of stereo
 * AudioBuffers for convolution. (SOA: 5 AudioBuffers, TOA: 8 AudioBuffers)
 * @return {HOAConvovler}
 */
Omnitone.createHOAConvolver = function(
    context, ambisonicOrder, hrirBufferList) {
  return new HOAConvolver(context, ambisonicOrder, hrirBufferList);
};


/**
 * Creates HOARenderer for higher-order ambisonic decoding and the optimized
 * binaural rendering.
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 * @return {HOARenderer}
 */
Omnitone.createHOARenderer = function(context, config) {
  return new HOARenderer(context, config);
};


// Handler Preload Tasks.
// - Detects the browser information.
// - Prints out the version number.
(function() {
  Utils.log('Version ' + Version + ' (running ' +
      Omnitone.browserInfo.name + ' ' + Omnitone.browserInfo.version +
      ' on ' + Omnitone.browserInfo.platform +')');
  if (Omnitone.browserInfo.name.toLowerCase() === 'safari') {
    Polyfill.patchSafari();
    Utils.log(Omnitone.browserInfo.name + ' detected. Appliying polyfill...');
  }
})();


module.exports = Omnitone;


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_219960__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOA decoder, DEPRECATED in favor of FOARenderer.
 */



const AudioBufferManager = __nested_webpack_require_219960__(5);
const FOARouter = __nested_webpack_require_219960__(2);
const FOARotator = __nested_webpack_require_219960__(3);
const FOAPhaseMatchedFilter = __nested_webpack_require_219960__(6);
const FOAVirtualSpeaker = __nested_webpack_require_219960__(7);
const FOASpeakerData = __nested_webpack_require_219960__(13);
const Utils = __nested_webpack_require_219960__(0);

// By default, Omnitone fetches IR from the spatial media repository.
const HRTFSET_URL = 'https://raw.githubusercontent.com/GoogleChrome/omnitone/master/build/resources/';

// Post gain compensation value.
let POST_GAIN_DB = 0;


/**
 * Omnitone FOA decoder.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {VideoElement} videoElement - Target video (or audio) element for
 * streaming.
 * @param {Object} options
 * @param {String} options.HRTFSetUrl - Base URL for the cube HRTF sets.
 * @param {Number} options.postGainDB - Post-decoding gain compensation in dB.
 * @param {Number[]} options.channelMap - Custom channel map.
 */
function FOADecoder(context, videoElement, options) {
  this._isDecoderReady = false;
  this._context = context;
  this._videoElement = videoElement;
  this._decodingMode = 'ambisonic';

  this._postGainDB = POST_GAIN_DB;
  this._HRTFSetUrl = HRTFSET_URL;
  this._channelMap = FOARouter.ChannelMap.DEFAULT; // ACN

  if (options) {
    if (options.postGainDB) {
      this._postGainDB = options.postGainDB;
    }
    if (options.HRTFSetUrl) {
      this._HRTFSetUrl = options.HRTFSetUrl;
    }
    if (options.channelMap) {
      this._channelMap = options.channelMap;
    }
  }

  // Rearrange speaker data based on |options.HRTFSetUrl|.
  this._speakerData = [];
  for (let i = 0; i < FOASpeakerData.length; ++i) {
    this._speakerData.push({
      name: FOASpeakerData[i].name,
      url: this._HRTFSetUrl + '/' + FOASpeakerData[i].url,
      coef: FOASpeakerData[i].coef,
    });
  }

  this._tempMatrix4 = new Float32Array(16);
}


/**
 * Initialize and load the resources for the decode.
 * @return {Promise}
 */
FOADecoder.prototype.initialize = function() {
  Utils.log('Initializing... (mode: ' + this._decodingMode + ')');

  // Rerouting channels if necessary.
  let channelMapString = this._channelMap.toString();
  let defaultChannelMapString = FOARouter.ChannelMap.DEFAULT.toString();
  if (channelMapString !== defaultChannelMapString) {
    Utils.log('Remapping channels ([' + defaultChannelMapString + '] -> ['
      + channelMapString + '])');
  }

  this._audioElementSource =
      this._context.createMediaElementSource(this._videoElement);
  this._foaRouter = new FOARouter(this._context, this._channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaPhaseMatchedFilter = new FOAPhaseMatchedFilter(this._context);

  this._audioElementSource.connect(this._foaRouter.input);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaPhaseMatchedFilter.input);

  this._foaVirtualSpeakers = [];

  // Bypass signal path.
  this._bypass = this._context.createGain();
  this._audioElementSource.connect(this._bypass);

  // Get the linear amplitude from the post gain option, which is in decibel.
  const postGainLinear = Math.pow(10, this._postGainDB/20);
  Utils.log('Gain compensation: ' + postGainLinear + ' (' + this._postGainDB
    + 'dB)');

  // This returns a promise so developers can use the decoder when it is ready.
  const that = this;
  return new Promise(function(resolve, reject) {
    new AudioBufferManager(that._context, that._speakerData,
      function(buffers) {
        for (let i = 0; i < that._speakerData.length; ++i) {
          that._foaVirtualSpeakers[i] = new FOAVirtualSpeaker(that._context, {
            coefficients: that._speakerData[i].coef,
            IR: buffers.get(that._speakerData[i].name),
            gain: postGainLinear,
          });

          that._foaPhaseMatchedFilter.output.connect(
            that._foaVirtualSpeakers[i].input);
        }

        // Set the decoding mode.
        that.setMode(that._decodingMode);
        that._isDecoderReady = true;
        Utils.log('HRTF IRs are loaded successfully. The decoder is ready.');
        resolve();
      }, reject);
  });
};

/**
 * Set the rotation matrix for the sound field rotation.
 * @param {Array} rotationMatrix      3x3 rotation matrix (row-major
 *                                    representation)
 */
FOADecoder.prototype.setRotationMatrix = function(rotationMatrix) {
  this._foaRotator.setRotationMatrix(rotationMatrix);
};


/**
 * Update the rotation matrix from a Three.js camera object.
 * @param  {Object} cameraMatrix      The Matrix4 obejct of Three.js the camera.
 */
FOADecoder.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};

/**
 * Set the decoding mode.
 * @param {String} mode               Decoding mode. When the mode is 'bypass'
 *                                    the decoder is disabled and bypass the
 *                                    input stream to the output. Setting the
 *                                    mode to 'ambisonic' activates the decoder.
 *                                    When the mode is 'off', all the
 *                                    processing is completely turned off saving
 *                                    the CPU power.
 */
FOADecoder.prototype.setMode = function(mode) {
  if (mode === this._decodingMode) {
    return;
  }

  switch (mode) {
    case 'bypass':
      this._decodingMode = 'bypass';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.connect(this._context.destination);
      break;

    case 'ambisonic':
      this._decodingMode = 'ambisonic';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].enable();
      }
      this._bypass.disconnect();
      break;

    case 'off':
      this._decodingMode = 'off';
      for (let i = 0; i < this._foaVirtualSpeakers.length; ++i) {
        this._foaVirtualSpeakers[i].disable();
      }
      this._bypass.disconnect();
      break;

    default:
      break;
  }

  Utils.log('Decoding mode changed. (' + mode + ')');
};

module.exports = FOADecoder;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data for FOAVirtualSpeaker. Each entry contains the URL for IR files and
 * the gain coefficients for the associated IR files. Note that the order of
 * coefficients follows the ACN channel ordering. (W,Y,Z,X)
 * @type {Object[]}
 */
const FOASpeakerData = [{
  name: 'E35_A135',
  url: 'E35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, -0.216495],
}, {
  name: 'E35_A-135',
  url: 'E35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, -0.216495],
}, {
  name: 'E-35_A135',
  url: 'E-35_A135.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, -0.216495],
}, {
  name: 'E-35_A-135',
  url: 'E-35_A-135.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, -0.216495],
}, {
  name: 'E35_A45',
  url: 'E35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, 0.21653, 0.216495],
}, {
  name: 'E35_A-45',
  url: 'E35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, 0.21653, 0.216495],
}, {
  name: 'E-35_A45',
  url: 'E-35_A45.wav',
  gainFactor: 1,
  coef: [.1250, 0.216495, -0.21653, 0.216495],
}, {
  name: 'E-35_A-45',
  url: 'E-35_A-45.wav',
  gainFactor: 1,
  coef: [.1250, -0.216495, -0.21653, 0.216495],
}];


module.exports = FOASpeakerData;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_229122__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone FOARenderer. This is user-facing API for the first-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_229122__(1);
const FOAConvolver = __nested_webpack_require_229122__(4);
const FOAHrirBase64 = __nested_webpack_require_229122__(15);
const FOARotator = __nested_webpack_require_229122__(3);
const FOARouter = __nested_webpack_require_229122__(2);
const Utils = __nested_webpack_require_229122__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


/**
 * Omnitone FOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Array} [config.channelMap] - Custom channel routing map. Useful for
 * handling the inconsistency in browser's multichannel audio decoding.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function FOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('FOARenderer: Invalid BaseAudioContext.');

  this._config = {
    channelMap: FOARouter.ChannelMap.DEFAULT,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config) {
    if (config.channelMap) {
      if (Array.isArray(config.channelMap) && config.channelMap.length === 4) {
        this._config.channelMap = config.channelMap;
      } else {
        Utils.throw(
            'FOARenderer: Invalid channel map. (got ' + config.channelMap
            + ')');
      }
    }

    if (config.hrirPathList) {
      if (Array.isArray(config.hrirPathList) &&
          config.hrirPathList.length === 2) {
        this._config.pathList = config.hrirPathList;
      } else {
        Utils.throw(
            'FOARenderer: Invalid HRIR URLs. It must be an array with ' +
            '2 URLs to HRIR files. (got ' + config.hrirPathList + ')');
      }
    }

    if (config.renderingMode) {
      if (Object.values(RenderingMode).includes(config.renderingMode)) {
        this._config.renderingMode = config.renderingMode;
      } else {
        Utils.log(
            'FOARenderer: Invalid rendering mode order. (got' +
            config.renderingMode + ') Fallbacks to the mode "ambisonic".');
      }
    }
  }

  this._buildAudioGraph();

  this._tempMatrix4 = new Float32Array(16);
  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
FOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._foaRouter = new FOARouter(this._context, this._config.channelMap);
  this._foaRotator = new FOARotator(this._context);
  this._foaConvolver = new FOAConvolver(this._context);
  this.input.connect(this._foaRouter.input);
  this.input.connect(this._bypass);
  this._foaRouter.output.connect(this._foaRotator.input);
  this._foaRotator.output.connect(this._foaConvolver.input);
  this._foaConvolver.output.connect(this.output);

  this.input.channelCount = 4;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
FOARenderer.prototype._initializeCallback = function(resolve, reject) {
  const bufferList = this._config.pathList
      ? new BufferList(this._context, this._config.pathList, {dataType: 'url'})
      : new BufferList(this._context, FOAHrirBase64);
  bufferList.load().then(
      function(hrirBufferList) {
        this._foaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('FOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'FOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
FOARenderer.prototype.initialize = function() {
  Utils.log(
      'FOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('FOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Set the channel map.
 * @param {Number[]} channelMap - Custom channel routing for FOA stream.
 */
FOARenderer.prototype.setChannelMap = function(channelMap) {
  if (!this._isRendererReady) {
    return;
  }

  if (channelMap.toString() !== this._config.channelMap.toString()) {
    Utils.log(
        'Remapping channels ([' + this._config.channelMap.toString() +
        '] -> [' + channelMap.toString() + ']).');
    this._config.channelMap = channelMap.slice();
    this._foaRouter.setChannelMap(this._config.channelMap);
  }
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
FOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._foaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the rotation matrix from a Three.js camera object. Depreated in V1, and
 * this exists only for the backward compatiblity. Instead, use
 * |setRotatationMatrix4()| with Three.js |camera.worldMatrix.elements|.
 * @deprecated
 * @param {Object} cameraMatrix - Matrix4 from Three.js |camera.matrix|.
 */
FOARenderer.prototype.setRotationMatrixFromCamera = function(cameraMatrix) {
  if (!this._isRendererReady) {
    return;
  }

  // Extract the inner array elements and inverse. (The actual view rotation is
  // the opposite of the camera movement.)
  Utils.invertMatrix4(this._tempMatrix4, cameraMatrix.elements);
  this._foaRotator.setRotationMatrix4(this._tempMatrix4);
};


/**
 * Set the rendering mode.
 * @param {RenderingMode} mode - Rendering mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
FOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._foaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._foaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._foaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'FOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('FOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = FOARenderer;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

const OmnitoneFOAHrirBase64 = [
"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",
];

module.exports = OmnitoneFOAHrirBase64;


/***/ }),
/* 16 */
/***/ (function(module, exports, __nested_webpack_require_240610__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @file Omnitone HOARenderer. This is user-facing API for the higher-order
 * ambisonic decoder and the optimized binaural renderer.
 */



const BufferList = __nested_webpack_require_240610__(1);
const HOAConvolver = __nested_webpack_require_240610__(8);
const HOARotator = __nested_webpack_require_240610__(9);
const TOAHrirBase64 = __nested_webpack_require_240610__(17);
const SOAHrirBase64 = __nested_webpack_require_240610__(18);
const Utils = __nested_webpack_require_240610__(0);


/**
 * @typedef {string} RenderingMode
 */

/**
 * Rendering mode ENUM.
 * @enum {RenderingMode}
 */
const RenderingMode = {
  /** @type {string} Use ambisonic rendering. */
  AMBISONIC: 'ambisonic',
  /** @type {string} Bypass. No ambisonic rendering. */
  BYPASS: 'bypass',
  /** @type {string} Disable audio output. */
  OFF: 'off',
};


// Currently SOA and TOA are only supported.
const SupportedAmbisonicOrder = [2, 3];


/**
 * Omnitone HOA renderer class. Uses the optimized convolution technique.
 * @constructor
 * @param {AudioContext} context - Associated AudioContext.
 * @param {Object} config
 * @param {Number} [config.ambisonicOrder=3] - Ambisonic order.
 * @param {Array} [config.hrirPathList] - A list of paths to HRIR files. It
 * overrides the internal HRIR list if given.
 * @param {RenderingMode} [config.renderingMode='ambisonic'] - Rendering mode.
 */
function HOARenderer(context, config) {
  this._context = Utils.isAudioContext(context) ?
      context :
      Utils.throw('HOARenderer: Invalid BaseAudioContext.');

  this._config = {
    ambisonicOrder: 3,
    renderingMode: RenderingMode.AMBISONIC,
  };

  if (config && config.ambisonicOrder) {
    if (SupportedAmbisonicOrder.includes(config.ambisonicOrder)) {
      this._config.ambisonicOrder = config.ambisonicOrder;
    } else {
      Utils.log(
          'HOARenderer: Invalid ambisonic order. (got ' +
          config.ambisonicOrder + ') Fallbacks to 3rd-order ambisonic.');
    }
  }

  this._config.numberOfChannels =
      (this._config.ambisonicOrder + 1) * (this._config.ambisonicOrder + 1);
  this._config.numberOfStereoChannels =
      Math.ceil(this._config.numberOfChannels / 2);

  if (config && config.hrirPathList) {
    if (Array.isArray(config.hrirPathList) &&
        config.hrirPathList.length === this._config.numberOfStereoChannels) {
      this._config.pathList = config.hrirPathList;
    } else {
      Utils.throw(
          'HOARenderer: Invalid HRIR URLs. It must be an array with ' +
          this._config.numberOfStereoChannels + ' URLs to HRIR files.' +
          ' (got ' + config.hrirPathList + ')');
    }
  }

  if (config && config.renderingMode) {
    if (Object.values(RenderingMode).includes(config.renderingMode)) {
      this._config.renderingMode = config.renderingMode;
    } else {
      Utils.log(
          'HOARenderer: Invalid rendering mode. (got ' +
          config.renderingMode + ') Fallbacks to "ambisonic".');
    }
  }

  this._buildAudioGraph();

  this._isRendererReady = false;
}


/**
 * Builds the internal audio graph.
 * @private
 */
HOARenderer.prototype._buildAudioGraph = function() {
  this.input = this._context.createGain();
  this.output = this._context.createGain();
  this._bypass = this._context.createGain();
  this._hoaRotator = new HOARotator(this._context, this._config.ambisonicOrder);
  this._hoaConvolver =
      new HOAConvolver(this._context, this._config.ambisonicOrder);
  this.input.connect(this._hoaRotator.input);
  this.input.connect(this._bypass);
  this._hoaRotator.output.connect(this._hoaConvolver.input);
  this._hoaConvolver.output.connect(this.output);

  this.input.channelCount = this._config.numberOfChannels;
  this.input.channelCountMode = 'explicit';
  this.input.channelInterpretation = 'discrete';
};


/**
 * Internal callback handler for |initialize| method.
 * @private
 * @param {function} resolve - Resolution handler.
 * @param {function} reject - Rejection handler.
 */
HOARenderer.prototype._initializeCallback = function(resolve, reject) {
  let bufferList;
  if (this._config.pathList) {
    bufferList =
        new BufferList(this._context, this._config.pathList, {dataType: 'url'});
  } else {
    bufferList = this._config.ambisonicOrder === 2
        ? new BufferList(this._context, SOAHrirBase64)
        : new BufferList(this._context, TOAHrirBase64);
  }

  bufferList.load().then(
      function(hrirBufferList) {
        this._hoaConvolver.setHRIRBufferList(hrirBufferList);
        this.setRenderingMode(this._config.renderingMode);
        this._isRendererReady = true;
        Utils.log('HOARenderer: HRIRs loaded successfully. Ready.');
        resolve();
      }.bind(this),
      function() {
        const errorMessage = 'HOARenderer: HRIR loading/decoding failed.';
        Utils.throw(errorMessage);
        reject(errorMessage);
      });
};


/**
 * Initializes and loads the resource for the renderer.
 * @return {Promise}
 */
HOARenderer.prototype.initialize = function() {
  Utils.log(
      'HOARenderer: Initializing... (mode: ' + this._config.renderingMode +
      ', ambisonic order: ' + this._config.ambisonicOrder + ')');

  return new Promise(this._initializeCallback.bind(this), function(error) {
    Utils.throw('HOARenderer: Initialization failed. (' + error + ')');
  });
};


/**
 * Updates the rotation matrix with 3x3 matrix.
 * @param {Number[]} rotationMatrix3 - A 3x3 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix3 = function(rotationMatrix3) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix3(rotationMatrix3);
};


/**
 * Updates the rotation matrix with 4x4 matrix.
 * @param {Number[]} rotationMatrix4 - A 4x4 rotation matrix. (column-major)
 */
HOARenderer.prototype.setRotationMatrix4 = function(rotationMatrix4) {
  if (!this._isRendererReady) {
    return;
  }

  this._hoaRotator.setRotationMatrix4(rotationMatrix4);
};


/**
 * Set the decoding mode.
 * @param {RenderingMode} mode - Decoding mode.
 *  - 'ambisonic': activates the ambisonic decoding/binaurl rendering.
 *  - 'bypass': bypasses the input stream directly to the output. No ambisonic
 *    decoding or encoding.
 *  - 'off': all the processing off saving the CPU power.
 */
HOARenderer.prototype.setRenderingMode = function(mode) {
  if (mode === this._config.renderingMode) {
    return;
  }

  switch (mode) {
    case RenderingMode.AMBISONIC:
      this._hoaConvolver.enable();
      this._bypass.disconnect();
      break;
    case RenderingMode.BYPASS:
      this._hoaConvolver.disable();
      this._bypass.connect(this.output);
      break;
    case RenderingMode.OFF:
      this._hoaConvolver.disable();
      this._bypass.disconnect();
      break;
    default:
      Utils.log(
          'HOARenderer: Rendering mode "' + mode + '" is not ' +
          'supported.');
      return;
  }

  this._config.renderingMode = mode;
  Utils.log('HOARenderer: Rendering mode changed. (' + mode + ')');
};


module.exports = HOARenderer;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

const OmnitoneTOAHrirBase64 = [
"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AAD7/wEAAgD7//7/AQD8/wAAAwD8//3/AwD9/wAAAgD9//z/AwD/////AgD+//z/AwAAAP7/AQD///3/AgABAP3/AAAAAP3/AgACAPz///8BAP3/AQACAP3//v8BAP7/AAABAP3//v8CAP7///8BAP7//f8CAP////8AAAAA/v8CAAAAAAAAAAAA/v8BAAAAAAD//wAA//8AAP//AAD//wAA//8AAP//",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA/////wAAAQD+////AAAGAP3/OAABAIIAAwBv//f/E/0QAK0ADQCzA/7/8P4u/0cBDQCJA6ABbQDg/w7/z/9o+Vn/SPnL/1//Ef+2+jr9RfZgA5QFZwILDFj+PAb2/nEFKgKk/R0Dlv6b/FUDsP6YAoj9SgAT/iL/tAPwAv8A0P6zAr7/dwAnAf39uP22/skA2v///2YCoP4UAUsAZgF2AJH+4P70/rz9+f+U/Xv/8v7CAcb+TACS/kwAv/+x/tX9oP71/oL/1f8nAEUAZwGtAAgAIgC/AD4BaP8GAGH/dQDF/64Arf8nAakAhAH9/+kAQQD3AFb/q/8p/yIAR/8FAPD/ZAA/AIYA3v8tADQADQBp/3f/CwABAP3/Wf8OANj/WwDH/xoAe/8DAKz/zv96/z8A3f/J/5X/IAD5//j/q//c/+//RADq//D/vv8pADUAFQDI/y8ACAAbANb/OwD3/+3/9f/e/wcAIAAeAMH/8/8xAC0AEADW/+3/HAADAPv/8P8DAOL/OwD3/xcACQAHAM//5f8XAAcAz//T/9D/HgD9////yf/e//v/AgD//9H/6/////H/+/8hAAIA9//7/w0AFgAQAPL/2v/8/xsAGQABANz/9P8YAAQA/v/y/wMA5v8YAAkAAAAAAAMA7/8KABgADwDs//j/BwATABsA8P/1//z/BAAMAAAA9P/s/xAA/v8GAAkA/v/p/wMACwALAP7/9P/p/wcADQAFAPb/7//4/w0ACAD8//b//v/1/wMACwD1//T/8P/8/wAACQDz/+f/5P8GAAkABQD5//D/+v8FAA0AAwD///T/AgACABAA/v8CAPD/+/8FAAoA9f/3//f//v8GAP7/9v/t//z/+f8AAPj/+v/3/wEA+v8HAPr//P/5/wQA//8DAPr/+P/3/wYA///+//X/+//5/wQA/f/7//X/+//4/wMA/f/8//j//v/9/wYA///8//f/AgAAAAUA/f/6//n/AwACAAIA/f/7//z/AwACAAAA/f/6//3/AgADAP7//f/7/wAAAwAFAPz////8/wMAAgAEAPv//v/+/wMAAgADAPv//v///wMAAQABAPv//f8AAAIAAAD///v//f8BAAIA///+//z//v8CAAIA/v/9//3///8CAAEA/v/9//7/AAACAAAA/v/9////AAABAAAA/f/9/wAAAQABAP///f/+/wEAAQAAAP///v/+/wEAAQD///7//v///wEAAQD///7//v///wEAAAD+//7///8AAAAAAAD+//7///8AAAAA///+//7///8AAAAA////////AAAAAP////////////8AAP//////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAAAAAAABAAAAAAD//////////////v////3/////////+//8////AQD9//z/9f8BAAIA+f8dACgAWQBxAJX/qv+Y/uz9aP9k/7UDUQQBAiQA4Pgi/AkB0gKaBsD/+fxp/vz9CQSp/I/+ywDO+vMD0fzK/PABcgBeBfoBv/+uAuH9Sf5gAy39awMmBWUBuP9fA9/9fgDj/2/+EACaACcCSv9Z/2j/rv7hAA0AWf55/7L84P7E/SIAT/67AMv/tf+FAA7/1v+7/gv/IP+E/sQA+P5aAXz/tP9XAFX/tP8o/4r/j//e/yQAMv9mAJT/rgCr/9X/EwCb//H/9f7F/6D/EAAoAK3//v+e/zsAh/+B/7r/if/C/2r/4P/z/6//HwCy/0IA7/9ZALT/y/80ACgA9v/J/9//DgA5ADUALQARADIACwAfAOf/NgArACMACQBBAEcAGAAjAC4AWQBUAHcAAAAfACEAIAAcAPj/CADk/yQA7v89AEEAFwD5/xYA6f8aAOX/AADF/zQADwAUAOT/BQDr/yUA6P8XAOf/HADR/0AA8P8nAAgACQDt/ycAKAAHAPH/IQDz/xsACADn//n/DgADAA4A8P///8z/GgDN/yMA/f8QANj/MwACAC0ACwAOAO3/JgAZAAUACgAAAA4AIgAaAAkADwACAAAAHQATAAUABQACAAgACwAjAO////8AAA8ABQAPAPL//f8GAAsABgAGAPD/8v8GAPz/CAD6//H/6v8PAAgABgD4//3/9v8aAAgABwD1//7//v8QAAoACAD//wUA9v8QAAoABAAFAAgAAgAJAAoAAwD//w0AAgD//wcA/v8DAAoABQAFABUABAAKAAYABwAHAA8ACgAGAAwADwAMAAkAEAAJAAgADwAMAAgADgAJAAUACQAPAAUACwAHAAEABgAIAAEABAAGAP//AgAJAAAAAgAEAP7///8IAAIA//8GAAEAAQAJAAIA/v8EAAMA//8JAAEA/v8DAAMA/v8HAAMA/f8BAAUA/v8FAAMA/v8BAAcA//8DAAMA/v8BAAYA//8CAAMA/////wcAAAAAAAMAAAD//wYAAQD+/wMAAQD//wUAAQD+/wIAAgD//wQAAgD+/wEAAwD//wMAAwD+/wEAAwD//wIAAwD//wEABAAAAAEABAD//wAABAABAAAAAwAAAAAABAABAP//AwABAAAAAwACAP//AgACAAAAAwACAP//AgACAAAAAgACAAAAAQADAAAAAQACAAAAAQADAAAAAQACAAAAAAACAAEAAAACAAEAAAACAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAABAAEAAAAAAAAAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAAAAP//AAD//wAA//8AAAAA//8AAP//AAACAAAA+f8BAAYA///4/wIA//8AAA8A/v/V/wEAEwA9AAEBRwA2AF7/kfog/3gBwv99CDYBU/qtAUX/AP7OAfkAX/o9B38FSfwaAuT14/60BAr8CQAI/tfyIQTzAXP+egdUBBwBof7TBMT8bAWi/5EEWwBRAAAKyfxE/8b88vp6ACP+PAF4/qD8MQNM/ygCJ/2XAPD9kP5gAVT/iP9I/lEB4P8qAD0BFAGa/+7/DgB2AOP98gFm/u/+Vv5/AG8ASP9gAM//qv9w//oAcv+2/jIBHgA7/6D/oAAGAKH/lADT/wAAggC8AAYAkP9yAEcAkf8BAOD/RAAr/zUANwDt/xQAJQAkAMT/zwA/AOH/xv9zAGsANQBTAIcALAAvACIATACy/xMADADg/xcAWABvAJL/7f9VAPb/EgDt/wcA4f8kAPP/5P+h/wgACQDy//r/LgAQAMn/8/9CAOX/5v/S/9//3P8pABYAuP/s/w8AFgDt/+3/7v/w/9j/5/8GAOf/2P/2//P//v8kABMAuf/m/xoADADZ/+r/3P8KAAUAKwDe/wsA3P8VAAAADgAfAB0ACAAMAF4AGgAhAPL/MwDz/0kABAAKAPX/LwAbAAkA9v/s/+3/8/8CABAAAADm//n/BQALAAUAAQDj//n/JQAVAPX/9v/+/wIAEQABAPP/8P/1/wAABgD6/+3/7//o//j/DAD8/+b/8P8IAAkABgD4//D/8P8UAAoAAwD4/wAA+f8OAAcAAAAFAPX/9v8TAAkA8v8EAPb/9/8dAA0A7/8CAPn/+f8SAAQA8/8CAOf/+v8DAAgA9P////H//P8IAAUA8//0/wIAAQAGAAgA9//7/wAA+/8EAP//+P/+////AgACAAsA8v/+/wIABQD7/wgA9v/7/wMABAD5/wAA/P/3/wEAAQD7//7//P/1/wQA///3//r////3/wMAAwD1//r/AwD6////AgD4//n/AwD8//7/AgD4//n/AwD+//3/AQD4//n/BQD///n/AAD6//j/BAABAPj/AAD9//v/AwADAPj//v/+//z/AwAEAPj//v8BAP7/AQADAPj//f8CAP////8EAPr//P8DAAAA/v8CAPv//P8DAAEA/f8BAP3//f8DAAIA/P8AAP7//f8DAAIA/P///wAA/f8BAAIA+//+/wEA//8AAAEA+//+/wEA/////wEA/P/+/wEA///+/wAA/f/9/wEAAAD9/wAA/f/+/wEAAQD8/////v/+/wAAAQD8////////////AQD9////AAD/////AAD+////AAAAAP//AAD///////8AAP//AAD//wAA//8AAP//",
];

module.exports = OmnitoneTOAHrirBase64;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

const OmnitoneSOAHrirBase64 = [
"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/P////v//P8CAAQA+//+//3//f8CAAUA+v/9//////8AAAQA+v/8////AAD//wIA+//8/wAAAQD+/wEA+//8/wAAAgD9/////P/9/wEAAgD8//7//f/9/wAAAgD8//3//v/+////AQD8//z/////////AAD8//3///8AAP7/AAD9//7///8AAP7////+//////8AAP7////+////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD//////v8AAP///////wAAAAAAAP7/AQABAAAABwD///X/BQAjAPL/CQDb/9D/GAAb/7sAYwCW/z0BcP/X/7T/2QDW+wH8yANCCCUJ5QT++UXmhPwhA78FuAxH+p78ifudBlAG9vmu/lAK2fdlB///cfjoCa0E7Akn9Yb/zvba+AkAHPywBGEBFwUNAL8AXAAGA20DFvmR/kz+F/06Ag/+GwHl/5EEKgJd/q0AP/ym/9n6EfxY/2H+/QFtAC4C6QBDAaMCo/20/+3/3f/p/fL9rv9V/6cBhQHuAX4AcwJYAaH/IP/P/gsApP0LAe7/sQBuAI0AAgGDAE4BzACe/5X//v+v/+f+Zf+gAOv/5QBhAOIApAANASYAuP+h/8b/HQBr/9//bACWAGEAFAB5AD0AWQDU/+D/Yf/p//D/s/+R/4QAMQBvABEAkQBfABQAJgDW/wwA8/8XALz/vf8zAFAAKwD1/zEAPwDJ/x0A7/8LAOX/FwDR//H/EQAdAO//6P8QAFEA2f8WABEAMgDy/xIA+f/s/xAALgDv////HQAvAPT/+f8iAAYAEgAFABoAGgD//w0A+f/0/xsAHgDx/9f/GAACAPH/8f8JAPf/GwALABEA7/8cAPT/CgD2//j/BQD8/+3/OgAgAAYA9f8PAN7/DgD9/9r/1//3/+3/9//1//b/8//5//f/AgAJAOf/+v8OAAMACwD9/+7/5f8eAAEA9//q//7/8P8WAP7/+//4/wIA+f8TAAIA9f/5/wcA+P8iAAgA9v/n/xoA//8gAAUABwDj/wAA9v8BAAUAFQDn/wMA7v8QABAAEQDm/wwA8f8aAAAABwDu/wcACgASAAEA7//w//f/BgARAAkA6P/3/wcADgAKAAYA4f/4/wYADgAAAPr/8P/9/xQACgAHAPn/7//9/xEAAgD+//L/8v/8/xUAAwDw//H/9f8CAAsA/v/q//L/+f8FAAYA/P/r//j///8GAAkA+//o//j/AQAIAP//+v/o//v/CAAIAPv/+P/w/wEACQAHAPj/+f/0/wIACwAFAPb/+f/4/wQACwACAPP/+f/+/wYACAD///L/+/8BAAYABQD9//P//P8FAAUAAgD7//T//f8HAAQA///7//f///8IAAMA/P/6//r/AQAIAAEA+v/6//3/AgAHAAAA+f/7/wAAAwAFAP7/+P/8/wIAAgACAP3/+f/9/wMAAwAAAPz/+v/+/wQAAgD+//z/+/8AAAQAAQD8//z//f8BAAQAAAD7//3///8BAAMA///7//3/AAACAAEA/v/7//7/AQABAAAA/v/9////AQAAAP///v/+////AAD/////////////////////////////",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD////////+//////8AAAAA/v/+/wAAAQD8//3/CQAJAP3/+v8PAAcApABlABkBkwCO/i//lfqa/HQAcf/3BdkCzwJcBCMC0wMN/9/9wgI7AaECYfxV/Tf83vhn/xrt8Owx/8n7cgHABYb43QcZDh4WugNrA7P74gHu/9z/zv0t/acCiQHY/iv4qQOl/ysCE/0//XT9Sf4O//j9xfupAn394gHO+rsCXAFIAxQC9wIXBgcD2AQuAnb/9gJh/6wAVfxEAI4Bvf7oAFv/bALsAMQBe/88/joAT/4dAH39/v9LAXn/gwDI//QBdABcAA0A7f4lAMn///+9/tv/iABp/13/pP/dALv/w/8MAHv//f+y/6////7U/5AAZP+Z/8r/nQDR/5r/DwDr/xAA4v+s/3z/+P9uAOv/t/82AGcAHgCb/yQAFQBGAM7/CgD3/xoAegAaAOz/CgBHAA8Adv8/AAAABQC2/xIAAAA7ABQAKgCj/z4AAQAXAJz/JAADAAcA8f/1/2AAAQAlAPD/NgDx/1wA7v/4/wMAZADv//3/HQAkAFoA8P9FAPv/FgBIAPf/WQAHAEUACQD0/xIAQwDu/wMAwP9VALn/XwCw/yEA5f8sAPj/FgDD/1YAyv8rAOX/HQDo//j/IQAQACAAHwD9/yQAHQBAABgABQAiAAUAKAD3/wkACwAKAAMABwAJAPb/+f8GAOr/JQAHABMA6P8TAA4AGgD//woA8/8ZAP//GADu/w0A9v8SAAMABwD4/wQA5P8XAAQACgDq/wUA+/8VAAcACADs/xIAAAATAPH/+v/1//T/7f///+z/+v/y/+//9/8KAAcACgAJAPT/BAAKAAAABgAIAPL/9v8KAAMABAACAPr/9v8OAAIA+P/x//v/+f8MAPb/+P/w/wQA9f8MAPn////7/woA/v8PAAEAAgD1/xAAAQAPAP//AwD//xQABwALAAAABgADABAAAgAHAAAACAABAA8ABQAFAAMABwAEAA4ABwADAAEACQAFAAoAAwD//wAACQADAAUAAQD/////CAABAAMAAAD/////BwACAAEAAAD/////BwACAP7///8BAAAABgABAP7///8CAAAABAAAAP7///8DAAAAAwAAAP3///8DAAAAAQAAAP3//v8EAAAAAAD+//////8EAP/////+/wAA/v8EAP/////+/wEA/v8EAP///v/+/wIA//8DAP///v/+/wIA//8BAP///v/+/wMA//8BAP/////+/wMA//8AAP//AAD+/wQA//8AAP7/AQD//wIA////////AQD//wIA////////AQAAAAEAAAAAAP//AQD//wEAAAAAAP//AQAAAAEAAAAAAAAA",
"UklGRiQEAABXQVZFZm10IBAAAAABAAIAgLsAAADuAgAEABAAZGF0YQAEAAD+/wAA+v8AAPz/AAD//wAA/f8AAAEAAAD+/wAACQAAAAQAAAAZAAAAtgAAAFsBAABW/gAAH/oAAGcBAABoBwAAlAAAAO3/AAARAQAA+wIAAEoEAACe/gAAiv4AALD0AADJ8wAAkQQAAF34AABi8QAAPQAAAAH2AAD19AAADAMAAJwGAACTEAAA0AwAAJkHAACOBwAAuQEAANcDAAC6AgAAHwUAAHEFAAB0AwAAbgEAADz+AADYAQAAGAAAAJwCAADgAAAA//0AAMn+AAAT/AAAwP8AAOn9AAAJAAAAewEAAOn+AACN/wAAOv0AAO3+AADN/gAAcP8AACj/AACq/gAA+f4AAML9AACa/wAA/f4AAN7/AABo/wAA6/4AAE//AAAC/wAAEQAAAHX/AAB0AAAA5f8AAEwAAAB3AAAA5/8AAMIAAABCAAAAzgAAAE8AAAB3AAAAKAAAADMAAACqAAAALwAAAK4AAAASAAAAVgAAACgAAAAtAAAATAAAAP3/AAA7AAAA2/8AACQAAADw/wAALQAAADEAAAAlAAAAbAAAADMAAABUAAAAEAAAACgAAAD1/wAA9v8AAPr/AADu/wAALgAAABIAAABUAAAARAAAAGUAAABGAAAAOAAAAGAAAAAuAAAARQAAACEAAAAfAAAAAAAAAAkAAAAQAAAAAwAAABIAAADs/wAAEAAAAAYAAAASAAAAIgAAABEAAAADAAAABAAAAA8AAAD4/wAAHQAAAAsAAAAIAAAADgAAAP//AAAcAAAADwAAAAYAAAASAAAAFwAAAAMAAAAYAAAAEgAAAPr/AAAQAAAADQAAAAoAAAD3/wAABgAAAPb/AADf/wAA/v8AAPL/AAD6/wAAFAAAAAQAAAAEAAAAGwAAAAEAAAAMAAAAIAAAAAIAAAAdAAAAGAAAAAIAAAAcAAAAEgAAAAcAAAAeAAAADwAAAAQAAAAeAAAABAAAAAYAAAAZAAAAAQAAAA4AAAATAAAA/v8AAAoAAAAOAAAA+/8AAAsAAAAJAAAA+f8AAAsAAAABAAAA+f8AAAoAAAD9/wAA+v8AAAcAAAD5/wAA+v8AAAUAAAD3/wAA/f8AAAQAAAD2/wAAAAAAAAEAAAD3/wAAAgAAAAAAAAD4/wAAAwAAAP7/AAD6/wAABAAAAP3/AAD8/wAABAAAAPv/AAD+/wAAAwAAAPv/AAD//wAAAQAAAPv/AAAAAAAAAAAAAPv/AAACAAAA//8AAPz/AAACAAAA/v8AAP3/AAACAAAA/f8AAP7/AAABAAAA/f8AAP//AAABAAAA/f8AAAAAAAAAAAAA/v8AAAEAAAAAAAAA//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
];

module.exports = OmnitoneSOAHrirBase64;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Cross-browser support polyfill for Omnitone library.
 */




/**
 * Detects browser type and version.
 * @return {string[]} - An array contains the detected browser name and version.
 */
exports.getBrowserInfo = function() {
  const ua = navigator.userAgent;
  let M = ua.match(
      /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*([\d\.]+)/i) ||
      [];
  let tem;

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return {name: 'IE', version: (tem[1] || '')};
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\bOPR|Edge\/(\d+)/);
    if (tem != null) {
      return {name: 'Opera', version: tem[1]};
    }
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/([\d.]+)/i)) != null) {
    M.splice(1, 1, tem[1]);
  }

  let platform = ua.match(/android|ipad|iphone/i);
  if (!platform) {
    platform = ua.match(/cros|linux|mac os x|windows/i);
  }

  return {
    name: M[0],
    version: M[1],
    platform: platform ? platform[0] : 'unknown',
  };
};


/**
 * Patches AudioContext if the prefixed API is found.
 */
exports.patchSafari = function() {
  if (window.webkitAudioContext && window.webkitOfflineAudioContext) {
    window.AudioContext = window.webkitAudioContext;
    window.OfflineAudioContext = window.webkitOfflineAudioContext;
  }
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file Omnitone version.
 */




/**
 * Omnitone library version
 * @type {String}
 */
module.exports = '1.0.6';


/***/ })
/******/ ]);
});

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file ResonanceAudio version.
 * @author Andrew Allen <bitllama@google.com>
 */




/**
 * ResonanceAudio library version
 * @type {String}
 */
module.exports = '0.0.4';


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/three/src/math/Euler.js":
/*!**********************************************!*\
  !*** ./node_modules/three/src/math/Euler.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Euler": function() { return /* binding */ Euler; }
/* harmony export */ });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4.js */ "./node_modules/three/src/math/Matrix4.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");





const _matrix = /*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - (0,_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__.clamp)( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion.setFromEuler( this );

		return this.setFromQuaternion( _quaternion, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new _Vector3_js__WEBPACK_IMPORTED_MODULE_3__.Vector3( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];




/***/ }),

/***/ "./node_modules/three/src/math/MathUtils.js":
/*!**************************************************!*\
  !*** ./node_modules/three/src/math/MathUtils.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEG2RAD": function() { return /* binding */ DEG2RAD; },
/* harmony export */   "RAD2DEG": function() { return /* binding */ RAD2DEG; },
/* harmony export */   "generateUUID": function() { return /* binding */ generateUUID; },
/* harmony export */   "clamp": function() { return /* binding */ clamp; },
/* harmony export */   "euclideanModulo": function() { return /* binding */ euclideanModulo; },
/* harmony export */   "mapLinear": function() { return /* binding */ mapLinear; },
/* harmony export */   "inverseLerp": function() { return /* binding */ inverseLerp; },
/* harmony export */   "lerp": function() { return /* binding */ lerp; },
/* harmony export */   "damp": function() { return /* binding */ damp; },
/* harmony export */   "pingpong": function() { return /* binding */ pingpong; },
/* harmony export */   "smoothstep": function() { return /* binding */ smoothstep; },
/* harmony export */   "smootherstep": function() { return /* binding */ smootherstep; },
/* harmony export */   "randInt": function() { return /* binding */ randInt; },
/* harmony export */   "randFloat": function() { return /* binding */ randFloat; },
/* harmony export */   "randFloatSpread": function() { return /* binding */ randFloatSpread; },
/* harmony export */   "seededRandom": function() { return /* binding */ seededRandom; },
/* harmony export */   "degToRad": function() { return /* binding */ degToRad; },
/* harmony export */   "radToDeg": function() { return /* binding */ radToDeg; },
/* harmony export */   "isPowerOfTwo": function() { return /* binding */ isPowerOfTwo; },
/* harmony export */   "ceilPowerOfTwo": function() { return /* binding */ ceilPowerOfTwo; },
/* harmony export */   "floorPowerOfTwo": function() { return /* binding */ floorPowerOfTwo; },
/* harmony export */   "setQuaternionFromProperEuler": function() { return /* binding */ setQuaternionFromProperEuler; }
/* harmony export */ });
const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toUpperCase() here flattens concatenated strings to save heap memory space.
	return uuid.toUpperCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

		 } else {

		return 0;

		 }

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s % 2147483647;

	// Park-Miller algorithm

	_seed = _seed * 16807 % 2147483647;

	return ( _seed - 1 ) / 2147483646;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}







/***/ }),

/***/ "./node_modules/three/src/math/Matrix4.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Matrix4.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix4": function() { return /* binding */ Matrix4; }
/* harmony export */ });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./node_modules/three/src/math/Vector3.js");


class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _y = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();
const _z = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__.Vector3();




/***/ }),

/***/ "./node_modules/three/src/math/Quaternion.js":
/*!***************************************************!*\
  !*** ./node_modules/three/src/math/Quaternion.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quaternion": function() { return /* binding */ Quaternion; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");


class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		console.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );
		return qm.slerpQuaternions( qa, qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		this.copy( qa ).slerp( qb, t );

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;




/***/ }),

/***/ "./node_modules/three/src/math/Vector3.js":
/*!************************************************!*\
  !*** ./node_modules/three/src/math/Vector3.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector3": function() { return /* binding */ Vector3; }
/* harmony export */ });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./node_modules/three/src/math/MathUtils.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./node_modules/three/src/math/Quaternion.js");



class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3();
const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__.Quaternion();




/***/ }),

/***/ "./src/global.ts":
/*!***********************!*\
  !*** ./src/global.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var detect_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! detect-browser */ "./node_modules/detect-browser/es/index.js");
/* harmony import */ var _isIos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isIos */ "./src/isIos.ts");


window.addEventListener("load", function () {
    var browser = (0,detect_browser__WEBPACK_IMPORTED_MODULE_1__.detect)();
    console.log(browser);
    console.log(navigator.userAgent);
    //iOS we will redirect to non ar version anyway
    if (_isIos__WEBPACK_IMPORTED_MODULE_0__.isIos)
        return;
    if (browser.os !== "Android OS" && browser.os !== "android")
        return;
    if (browser.name !== "chrome" && browser.name !== "chromium-webview") {
        document.querySelector("#error-overlay").innerHTML = "\n    <div>This site only supports the <a href='https://play.google.com/store/apps/details?id=com.android.chrome'>Chrome web browser on Android.</a></div>;\n    ";
        document.querySelector("#error-overlay").style.display = "flex";
    }
});
window.addEventListener("error", function (event) {
    document.querySelector("#error-overlay").innerHTML = "<div>Oops! An error<br><br>Please refresh the page and try again.<br><br><span style=\"font-size: 0.5em\">" + event.message + "</span></div>";
    document.querySelector("#error-overlay").style.display = "flex";
});


/***/ }),

/***/ "./src/isIos.ts":
/*!**********************!*\
  !*** ./src/isIos.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIos": function() { return /* binding */ isIos; }
/* harmony export */ });
var isIos = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) ||
    (navigator.userAgent.includes("Mac") && "ontouchend" in document);


/***/ }),

/***/ "./src/loadMedia.ts":
/*!**************************!*\
  !*** ./src/loadMedia.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadMedia": function() { return /* binding */ loadMedia; }
/* harmony export */ });
function loadMedia(state, params) {
    var _this = this;
    state.loaded = false;
    state.numLoaded = 0;
    state.numItems = params.el.children.length;
    state.bufferSources = [];
    console.log(params.audioContext.sampleRate);
    state.requests = [];
    console.log("Loading " + state.numItems + " audio elements");
    var sampleRate = params.audioContext.sampleRate;
    state.progress = Array(params.el.children.length).fill(0);
    Array.from(params.el.children).forEach(function (anchorEl, index) {
        if (anchorEl.tagName !== "A") {
            console.error("The loader should only have <a> children");
        }
        var originalUrl = anchorEl.getAttribute("href");
        var url = sampleRate === 48000
            ? originalUrl.slice(0, -3) + "48." + originalUrl.slice(-3)
            : sampleRate === 44100
                ? originalUrl.slice(0, -3) + "44." + originalUrl.slice(-3)
                : null;
        if (!url)
            throw Error("Unsupported sample rate " + sampleRate);
        state.bufferSources.push(params.audioContext.createBufferSource());
        var request = new XMLHttpRequest();
        state.requests.push(request);
        request.addEventListener("progress", childProgress.bind(_this, state, params, index));
        request.addEventListener("load", childLoadSuccess.bind(_this, state, params, index));
        request.addEventListener("error", childError.bind(_this, index));
        request.addEventListener("abort", childAbort.bind(_this, index));
        request.open("GET", url);
        request.responseType = "arraybuffer";
        request.send();
    });
}
function childProgress(state, params, index, event) {
    var percent = event.total ? event.loaded / event.total : 0;
    state.progress[index] = percent;
    var totalPercent = state.progress.reduce(function (prev, cur) { return prev + cur; }) / state.progress.length;
    params.onProgress(totalPercent);
}
function childLoadSuccess(state, params, index) {
    console.log("Loaded " + index);
    var data = state.requests[index].response;
    //safari doesn't support promise based decode
    params.audioContext.decodeAudioData(data, function (buffer) {
        state.bufferSources[index].buffer = buffer;
        state.numLoaded += 1;
        if (state.numLoaded >= state.numItems) {
            console.log("Loaded all items");
            state.loaded = true;
            params.onSuccess(params.barcodeData, state.bufferSources);
        }
    }, function () {
        childError(index);
    });
}
function childError(index, event) {
    throw Error("Couldn't load piece " + index + ".");
}
function childAbort(index) {
    console.log("Aborting load item " + index);
}


/***/ }),

/***/ "./src/loadResonance.ts":
/*!******************************!*\
  !*** ./src/loadResonance.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadResonance": function() { return /* binding */ loadResonance; }
/* harmony export */ });
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resonance-audio */ "./node_modules/resonance-audio/build/resonance-audio.js");
/* harmony import */ var resonance_audio__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(resonance_audio__WEBPACK_IMPORTED_MODULE_0__);

function loadResonance(audioContext) {
    console.log("Loading resonance");
    var ambisonicOrder = 1;
    var resonanceAudioScene = new resonance_audio__WEBPACK_IMPORTED_MODULE_0__.ResonanceAudio(audioContext, { ambisonicOrder: ambisonicOrder });
    resonanceAudioScene.setRoomProperties({ width: 10, height: 8, depth: 10 }, {
        back: "brick-bare",
        left: "brick-bare",
        right: "brick-bare",
        front: "brick-bare",
        down: "plywood-panel",
        up: "transparent",
    });
    resonanceAudioScene.output.connect(audioContext.destination);
    return resonanceAudioScene;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!******************!*\
  !*** ./src/p.ts ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/src/math/Euler */ "./node_modules/three/src/math/Euler.js");
/* harmony import */ var three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/src/math/Vector3 */ "./node_modules/three/src/math/Vector3.js");
/* harmony import */ var three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/src/math/Quaternion */ "./node_modules/three/src/math/Quaternion.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nunjucks */ "./node_modules/nunjucks/browser/nunjucks.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nunjucks__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global */ "./src/global.ts");
/* harmony import */ var _loadResonance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loadResonance */ "./src/loadResonance.ts");
/* harmony import */ var _loadMedia__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loadMedia */ "./src/loadMedia.ts");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};







var index = Number.parseInt(window.location.pathname.match(/\/?(\d+)\.html/)[1]);
nunjucks__WEBPACK_IMPORTED_MODULE_0__.configure("templates", { autoescape: true });
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("loader-" + index + ".njk"));
document.write(nunjucks__WEBPACK_IMPORTED_MODULE_0__.render("scene-" + index + ".njk"));
var loadMediaState = {};
var resonanceAudioScene;
var audioContext;
var orientationPermission = undefined;
var degtorad = Math.PI / 180;
var xAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0);
var yAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var zAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var upAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, -1, 0);
var forwardAxis = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 1);
var initialDirection = undefined;
var q0 = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var quaternion = new three_src_math_Quaternion__WEBPACK_IMPORTED_MODULE_5__.Quaternion();
var alphaOffset = 0;
var forward = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -1);
var up = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);
var eulerOrigin = new three_src_math_Euler__WEBPACK_IMPORTED_MODULE_6__.Euler(Math.PI / 2, 0, 0, "YZX");
var freezeCheckboxEl = document.getElementById("freeze-checkbox");
var animationTimeline = [];
var timelineLoop = null;
var animationTimelineIndex = -1;
var animationStartTime = 0;
var entities = [];
window.addEventListener("load", function () {
    document.body.querySelector("#play-overlay").classList.remove("fade-out");
    audioContext = new window.AudioContext();
    resonanceAudioScene = (0,_loadResonance__WEBPACK_IMPORTED_MODULE_2__.loadResonance)(audioContext);
    var loaderEl = document.querySelector("[loader]");
    (0,_loadMedia__WEBPACK_IMPORTED_MODULE_3__.loadMedia)(loadMediaState, {
        el: loaderEl,
        audioContext: audioContext,
        onSuccess: mediaLoaded,
        onProgress: function (percent) {
            var loadingButton = document.querySelector("#play-button");
            if (loadingButton)
                loadingButton.innerText = "Loading " + Math.round(percent * 98) + "%...";
        },
        barcodeData: index.toString(),
        loadingBarcodeContainer: { loadingBarcode: index },
    });
    loadEntities();
});
function loadEntities() {
    document.body.querySelectorAll("[resonance-source]").forEach(function (e) {
        var _a;
        var index = Number.parseInt(e.getAttribute("resonance-source"));
        var position = e
            .getAttribute("position")
            .split(" ")
            .map(function (i) { return Number.parseFloat(i); });
        var bufferSource = (_a = loadMediaState.bufferSources) === null || _a === void 0 ? void 0 : _a[index];
        var resonanceSource = resonanceAudioScene.createSource();
        bufferSource.connect(resonanceSource.input);
        resonanceSource.setPosition(position[0], position[1], position[2]);
        var animations = extractAnimations(e);
        var mixinAnimations = e.hasAttribute("mixin")
            ? extractAnimations(document.getElementById(e.getAttribute("mixin")))
            : {};
        var entity = {
            el: e,
            position: position,
            index: index,
            bufferSource: bufferSource,
            resonanceSource: resonanceSource,
            animations: __assign(__assign({}, mixinAnimations), animations),
        };
        entities.push(entity);
    });
    document.querySelectorAll("a-entity").forEach(function (e) {
        var attr = Array.from(e.attributes).find(function (attr) { return attr.name.startsWith("animation-timeline"); });
        if (attr) {
            if (timelineLoop !== null)
                throw Error("Found more than one entity with animation-timeline attribute");
            if (attr.value.match(/loop:\s?true/))
                timelineLoop = true;
            else
                timelineLoop = false;
        }
    });
    console.log("loop: " + timelineLoop);
    var t = document.querySelector("a-timeline");
    if (!t)
        throw Error("No animation timeline found");
    var time = 0;
    Array.from(t.children).forEach(function (child) {
        var _a;
        if (child.tagName === "A-TIMELINE-ANIMATION") {
            var name_1 = child.getAttribute("name");
            var target_1 = child.getAttribute("select");
            var entity = entities.find(function (e) { return e.el === document.querySelector(target_1); });
            if (!entity)
                throw Error("Couldn't find entity " + target_1);
            var animation = entity.animations[name_1];
            var startTime = time + ((_a = animation.delay) !== null && _a !== void 0 ? _a : 0);
            var finishTime = startTime + animation.dur;
            animationTimeline.push({
                animation: animation,
                entity: entity,
                startTime: startTime,
                finishTime: finishTime,
            });
            time = finishTime;
        }
        else if (child.tagName === "A-TIMELINE-GROUP") {
            var group_1 = { items: [], finishTime: 0 };
            Array.from(child.children).forEach(function (grandchild) {
                var _a;
                if (grandchild.tagName === "A-TIMELINE-ANIMATION") {
                    var name_2 = "animation__" + grandchild.getAttribute("name");
                    var target_2 = grandchild.getAttribute("select");
                    var entity = entities.find(function (e) { return e.el === document.querySelector(target_2); });
                    if (!entity)
                        throw Error("Couldn't find entity " + target_2);
                    var animation = entity.animations[name_2];
                    var startTime = time + ((_a = animation.delay) !== null && _a !== void 0 ? _a : 0);
                    var finishTime = startTime + animation.dur;
                    group_1.items.push({
                        animation: animation,
                        entity: entity,
                        startTime: startTime,
                        finishTime: finishTime,
                    });
                    group_1.finishTime = Math.max(group_1.finishTime, finishTime);
                }
                else
                    throw Error("Unsupported timeline tag " + grandchild.tagName);
            });
            animationTimeline.push(group_1);
            time = group_1.finishTime;
        }
        else
            throw Error("Unsupported timeline tag " + child.tagName);
    });
    console.log(animationTimeline);
}
function mediaLoaded() {
    var _this = this;
    var button = document.body.querySelector("#play-button");
    button.disabled = false;
    button.innerText = "Play";
    button.addEventListener("click", function () { return __awaiter(_this, void 0, void 0, function () {
        var startTime, message;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    audioContext.resume();
                    startTime = audioContext.currentTime + 1;
                    animationStartTime = Date.now() + 1000;
                    entities.forEach(function (entity) { return entity.bufferSource.start(startTime); });
                    window.setInterval(mainLoop, 50);
                    document.getElementById("title").innerText = "You are listening to the spatial experience.";
                    button.remove();
                    if (!window.DeviceOrientationEvent) return [3 /*break*/, 3];
                    if (!(DeviceOrientationEvent.requestPermission &&
                        orientationPermission !== "denied" &&
                        orientationPermission !== "granted")) return [3 /*break*/, 2];
                    return [4 /*yield*/, DeviceOrientationEvent.requestPermission()];
                case 1:
                    orientationPermission = _a.sent();
                    if (orientationPermission === "denied") {
                        message = document.createElement("p");
                        message.innerText = "You did not give permission to use device motion. Your viewpoint will remain static.";
                        document.body.appendChild(message);
                    }
                    _a.label = 2;
                case 2:
                    window.addEventListener("deviceorientation", throttle(updateListener, 50));
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    }); });
}
function mainLoop() {
    updateEntities();
}
function updateEntities() {
    var _a, _b;
    var now = Date.now();
    //increment the timeline if necessary
    while (now > ((_b = (_a = animationTimeline === null || animationTimeline === void 0 ? void 0 : animationTimeline[animationTimelineIndex]) === null || _a === void 0 ? void 0 : _a.finishTime) !== null && _b !== void 0 ? _b : 0) + animationStartTime) {
        animationTimelineIndex++;
        if (animationTimelineIndex >= animationTimeline.length) {
            if (!timelineLoop)
                return;
            animationStartTime = animationStartTime + animationTimeline[animationTimelineIndex - 1].finishTime;
            animationTimelineIndex = 0;
        }
    }
    //index is less than zero at the start because the audio plays after 1 sec
    if (animationTimelineIndex < 0)
        return;
    //place items
    var a = animationTimeline[animationTimelineIndex];
    //is array
    if ("items" in a) {
        a.items.forEach(function (item) {
            interpolate(item.entity.resonanceSource, Math.max(0, (now - animationStartTime - item.startTime) / (item.finishTime - item.startTime)), item.animation.from, item.animation.to);
        });
    }
    else {
        //single item, not array
        interpolate(a.entity.resonanceSource, Math.max(0, (now - animationStartTime - a.startTime) / (a.finishTime - a.startTime)), a.animation.from, a.animation.to);
    }
}
function updateListener(e) {
    if (freezeCheckboxEl.checked)
        return;
    var alpha = e.alpha ? e.alpha * degtorad + alphaOffset : 0; // Z
    var beta = e.beta ? e.beta * degtorad : 0; // X'
    var gamma = e.gamma ? e.gamma * degtorad : 0; // Y''
    quaternion.setFromEuler(eulerOrigin);
    q0.setFromAxisAngle(zAxis, alpha);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(xAxis, beta);
    quaternion.multiply(q0);
    q0.setFromAxisAngle(yAxis, gamma);
    quaternion.multiply(q0);
    up.copy(upAxis).applyQuaternion(quaternion);
    forward.copy(forwardAxis).applyQuaternion(quaternion);
    if (!initialDirection) {
        initialDirection = new three_src_math_Vector3__WEBPACK_IMPORTED_MODULE_4__.Vector3().projectOnPlane(upAxis).normalize();
        var angle = initialDirection.angleTo(forwardAxis);
        eulerOrigin.y = angle;
    }
    /*document.querySelector("#debug").innerHTML = `${forward.x.toFixed(2)} ${forward.y.toFixed(2)} ${forward.z.toFixed(
      2,
    )}<br>${up.x.toFixed(2)} ${up.y.toFixed(2)} ${up.z.toFixed(2)}<br>
    ${alpha.toFixed(2)} ${beta.toFixed(2)} ${gamma.toFixed(2)}<br>
    ${eulerOrigin.x.toFixed(2)} ${eulerOrigin.y.toFixed(2)} ${eulerOrigin.z.toFixed(2)}`;*/
    //@ts-expect-error - bad typing
    resonanceAudioScene.setListenerOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);
}
function throttle(callback, delay) {
    var prev = 0;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var now = new Date().getTime();
        if (now - prev < delay)
            return;
        prev = now;
        return callback.apply(void 0, args);
    };
}
function extractAnimations(element) {
    var result = {};
    for (var i = 0; i < element.attributes.length; i++) {
        var attr = element.attributes[i];
        if (attr.name.startsWith("animation__") || attr.name === "animation") {
            result[attr.name] = parseAnimation(attr.value);
        }
    }
    return result;
}
function parseAnimation(a) {
    var result = {};
    var data = a.split(";").map(function (e) {
        return e
            .trim()
            .split(":")
            .map(function (e2) { return e2.trim(); });
    });
    for (var i = 0; i < data.length; i++) {
        if (data[i].length < 2)
            continue;
        if (data[i][0] === "from" || data[i][0] === "to") {
            result[data[i][0]] = data[i][1].split(" ").map(function (n) { return Number.parseFloat(n); });
        }
        else if (data[i][0] === "dur" || data[i][0] === "delay") {
            result[data[i][0]] = Number.parseInt(data[i][1]);
        }
        else if (data[i][1] === "true") {
            result[data[i][0]] = true;
        }
        else if (data[i][1] === "false") {
            result[data[i][0]] = false;
        }
        else {
            result[data[i][0]] = data[i][1];
        }
    }
    return result;
}
function interpolate(resonanceSource, t, from, to, easing) {
    if (easing === void 0) { easing = "linear"; }
    switch (easing) {
        case "linear":
            resonanceSource.setPosition(from[0] + t * (to[0] - from[0]), from[1] + t * (to[1] - from[1]), from[2] + t * (to[2] - from[2]));
            break;
        default:
            throw Error("Unhandled easing " + easing);
    }
}

}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9ub2RlX21vZHVsZXMvZGV0ZWN0LWJyb3dzZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL251bmp1Y2tzL2Jyb3dzZXIvbnVuanVja3MuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3Jlc29uYW5jZS1hdWRpby9idWlsZC9yZXNvbmFuY2UtYXVkaW8uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0V1bGVyLmpzIiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi8uL25vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDQuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1F1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vbm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL1ZlY3RvcjMuanMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2dsb2JhbC50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvaXNJb3MudHMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL2xvYWRNZWRpYS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvLi9zcmMvbG9hZFJlc29uYW5jZS50cyIsIndlYnBhY2s6Ly9yYW0tc3BhdGlhbC13ZWIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3JhbS1zcGF0aWFsLXdlYi93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vcmFtLXNwYXRpYWwtd2ViLy4vc3JjL3AudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzQkFBc0IsU0FBSSxJQUFJLFNBQUk7QUFDbEMsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDc0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUM4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LDRCQUE0QixxQkFBcUI7QUFDakQsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsZ0JBQWdCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLCtDQUErQywwREFBMEQsMkNBQTJDLHVDQUF1Qzs7QUFFM0wsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZUFBZSxnQ0FBbUI7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQyxNQUFNOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsT0FBTzs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLG1DQUFtQztBQUNuQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLCtDQUErQywwREFBMEQsMkNBQTJDLHVDQUF1Qzs7QUFFM0wsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssWUFBWSxnQ0FBbUI7O0FBRS9CLFlBQVksZ0NBQW1COztBQUUvQixVQUFVLGdDQUFtQjs7QUFFN0IsVUFBVSxnQ0FBbUI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsTUFBTTtBQUM5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRzs7QUFFbkc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QyxzQ0FBc0M7O0FBRXRDLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0E7QUFDQSxjQUFjLGlDQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixlQUFlLGlDQUFtQjs7QUFFOUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTCxxR0FBcUc7QUFDckcsR0FBRyxNQUFNLEVBSU47QUFDSCxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FB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Qjs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlEQUFpRDs7O0FBR2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtB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OztBQUdBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUEsY0FBYyxpQ0FBbUI7O0FBRWpDO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPLHVDQUF1QyxVQUFVO0FBQ25FLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQSxjQUFjLGlDQUFtQjs7O0FBR2pDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBLG1CQUFtQixpQ0FBbUI7OztBQUd0QyxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBLG1CQUFtQixpQ0FBbUI7QUFDdEMscUJBQXFCLGlDQUFtQjtBQUN4QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLDhCQUE4QixpQ0FBbUI7QUFDakQsb0JBQW9CLGlDQUFtQjtBQUN2QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLGtCQUFrQixpQ0FBbUI7QUFDckMsMEJBQTBCLGlDQUFtQjtBQUM3QyxxQkFBcUIsaUNBQW1CO0FBQ3hDLG9CQUFvQixpQ0FBbUI7QUFDdkMsbUJBQW1CLGlDQUFtQjtBQUN0QyxpQkFBaUIsaUNBQW1CO0FBQ3BDLGNBQWMsaUNBQW1CO0FBQ2pDLGdCQUFnQixpQ0FBbUI7O0FBRW5DO0FBQ0EsMkJBQTJCLGlDQUFtQjs7O0FBRzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsY0FBYztBQUN6QjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixZQUFZLGNBQWM7QUFDMUI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLGNBQWM7QUFDekIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQSwyQkFBMkIsaUNBQW1CO0FBQzlDLGtCQUFrQixpQ0FBbUI7QUFDckMsbUJBQW1CLGlDQUFtQjtBQUN0Qyw4QkFBOEIsaUNBQW1CO0FBQ2pELDBCQUEwQixpQ0FBbUI7QUFDN0MsdUJBQXVCLGlDQUFtQjtBQUMxQyxjQUFjLGlDQUFtQjs7QUFFakM7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUE4QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxtQkFBbUIsaUNBQW1CO0FBQ3RDLHFCQUFxQixpQ0FBbUI7QUFDeEMsc0JBQXNCLGlDQUFtQjtBQUN6QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLGtCQUFrQixpQ0FBbUI7QUFDckMsY0FBYyxpQ0FBbUI7OztBQUdqQztBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLG1CQUFtQixpQ0FBbUI7QUFDdEMscUJBQXFCLGlDQUFtQjtBQUN4QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLHNCQUFzQixpQ0FBbUI7QUFDekMsc0JBQXNCLGlDQUFtQjtBQUN6QyxjQUFjLGlDQUFtQjs7O0FBR2pDO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0JBQWdCO0FBQzlFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsQ0FBQyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdGxPNEM7QUFDTjtBQUNBO0FBQ0E7O0FBRXZDLGtDQUFrQyxnREFBTztBQUN6QyxzQ0FBc0Msc0RBQVU7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEseUJBQXlCLG9EQUFLOztBQUU5Qjs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwyQkFBMkIsb0RBQUs7O0FBRWhDOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHlCQUF5QixvREFBSzs7QUFFOUI7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMkJBQTJCLG9EQUFLOztBQUVoQzs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx5QkFBeUIsb0RBQUs7O0FBRTlCOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJCQUEyQixvREFBSzs7QUFFaEM7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxjQUFjLGdEQUFPOztBQUVyQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25VakI7O0FBRUEsZ0JBQWdCLFNBQVM7O0FBRXpCOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7QUE0QkU7Ozs7Ozs7Ozs7Ozs7Ozs7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QTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVILGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLGdEQUFlOztBQUVqRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFc0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pwQnNCO0FBQ0M7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FB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Q0FBQztBQUNuQyxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQ2xCLGVBQXVCLEVBQ3ZCLENBQVMsRUFDVCxJQUE4QixFQUM5QixFQUE0QixFQUM1QixNQUE0QztJQUE1QywwQ0FBNEM7SUFFNUMsUUFBUSxNQUFNLEVBQUU7UUFDZCxLQUFLLFFBQVE7WUFDWCxlQUFlLENBQUMsV0FBVyxDQUN6QixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUMvQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUMvQixJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoQyxDQUFDO1lBQ0YsTUFBTTtRQUNSO1lBQ0UsTUFBTSxLQUFLLENBQUMsc0JBQW9CLE1BQVEsQ0FBQyxDQUFDO0tBQzdDO0FBQ0gsQ0FBQyIsImZpbGUiOiJwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG52YXIgQnJvd3NlckluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnJvd3NlckluZm8obmFtZSwgdmVyc2lvbiwgb3MpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5vcyA9IG9zO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYnJvd3Nlcic7XG4gICAgfVxuICAgIHJldHVybiBCcm93c2VySW5mbztcbn0oKSk7XG5leHBvcnQgeyBCcm93c2VySW5mbyB9O1xudmFyIE5vZGVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVJbmZvKHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMub3MgPSBwcm9jZXNzLnBsYXRmb3JtO1xuICAgIH1cbiAgICByZXR1cm4gTm9kZUluZm87XG59KCkpO1xuZXhwb3J0IHsgTm9kZUluZm8gfTtcbnZhciBTZWFyY2hCb3REZXZpY2VJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaEJvdERldmljZUluZm8obmFtZSwgdmVyc2lvbiwgb3MsIGJvdCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm9zID0gb3M7XG4gICAgICAgIHRoaXMuYm90ID0gYm90O1xuICAgICAgICB0aGlzLnR5cGUgPSAnYm90LWRldmljZSc7XG4gICAgfVxuICAgIHJldHVybiBTZWFyY2hCb3REZXZpY2VJbmZvO1xufSgpKTtcbmV4cG9ydCB7IFNlYXJjaEJvdERldmljZUluZm8gfTtcbnZhciBCb3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJvdEluZm8oKSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdib3QnO1xuICAgICAgICB0aGlzLmJvdCA9IHRydWU7IC8vIE5PVEU6IGRlcHJlY2F0ZWQgdGVzdCBuYW1lIGluc3RlYWRcbiAgICAgICAgdGhpcy5uYW1lID0gJ2JvdCc7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMub3MgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gQm90SW5mbztcbn0oKSk7XG5leHBvcnQgeyBCb3RJbmZvIH07XG52YXIgUmVhY3ROYXRpdmVJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlYWN0TmF0aXZlSW5mbygpIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlYWN0LW5hdGl2ZSc7XG4gICAgICAgIHRoaXMubmFtZSA9ICdyZWFjdC1uYXRpdmUnO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9zID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0TmF0aXZlSW5mbztcbn0oKSk7XG5leHBvcnQgeyBSZWFjdE5hdGl2ZUluZm8gfTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbnZhciBTRUFSQ0hCT1hfVUFfUkVHRVggPSAvYWxleGF8Ym90fGNyYXdsKGVyfGluZyl8ZmFjZWJvb2tleHRlcm5hbGhpdHxmZWVkYnVybmVyfGdvb2dsZSB3ZWIgcHJldmlld3xuYWdpb3N8cG9zdHJhbmt8cGluZ2RvbXxzbHVycHxzcGlkZXJ8eWFob28hfHlhbmRleC87XG52YXIgU0VBUkNIQk9UX09TX1JFR0VYID0gLyhudWhrfEdvb2dsZWJvdHxZYW1teWJvdHxPcGVuYm90fFNsdXJwfE1TTkJvdHxBc2tcXCBKZWV2ZXNcXC9UZW9tYXxpYV9hcmNoaXZlcikvO1xudmFyIFJFUVVJUkVEX1ZFUlNJT05fUEFSVFMgPSAzO1xudmFyIHVzZXJBZ2VudFJ1bGVzID0gW1xuICAgIFsnYW9sJywgL0FPTFNoaWVsZFxcLyhbMC05XFwuX10rKS9dLFxuICAgIFsnZWRnZScsIC9FZGdlXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydlZGdlLWlvcycsIC9FZGdpT1NcXC8oWzAtOVxcLl9dKykvXSxcbiAgICBbJ3lhbmRleGJyb3dzZXInLCAvWWFCcm93c2VyXFwvKFswLTlcXC5fXSspL10sXG4gICAgWydrYWthb3RhbGsnLCAvS0FLQU9UQUxLXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ3NhbXN1bmcnLCAvU2Ftc3VuZ0Jyb3dzZXJcXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnc2lsaycsIC9cXGJTaWxrXFwvKFswLTkuXy1dKylcXGIvXSxcbiAgICBbJ21pdWknLCAvTWl1aUJyb3dzZXJcXC8oWzAtOVxcLl0rKSQvXSxcbiAgICBbJ2JlYWtlcicsIC9CZWFrZXJCcm93c2VyXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2VkZ2UtY2hyb21pdW0nLCAvRWRnQT9cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFtcbiAgICAgICAgJ2Nocm9taXVtLXdlYnZpZXcnLFxuICAgICAgICAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS8sXG4gICAgXSxcbiAgICBbJ2Nocm9tZScsIC8oPyFDaHJvbS4qT1BSKUNocm9tKD86ZXxpdW0pXFwvKFswLTlcXC5dKykoOj9cXHN8JCkvXSxcbiAgICBbJ3BoYW50b21qcycsIC9QaGFudG9tSlNcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnY3Jpb3MnLCAvQ3JpT1NcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnZmlyZWZveCcsIC9GaXJlZm94XFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSxcbiAgICBbJ2Z4aW9zJywgL0Z4aU9TXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ29wZXJhLW1pbmknLCAvT3BlcmEgTWluaS4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sXG4gICAgWydvcGVyYScsIC9PcGVyYVxcLyhbMC05XFwuXSspKD86XFxzfCQpL10sXG4gICAgWydvcGVyYScsIC9PUFJcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLFxuICAgIFsnaWUnLCAvVHJpZGVudFxcLzdcXC4wLipydlxcOihbMC05XFwuXSspLipcXCkuKkdlY2tvJC9dLFxuICAgIFsnaWUnLCAvTVNJRVxccyhbMC05XFwuXSspOy4qVHJpZGVudFxcL1s0LTddLjAvXSxcbiAgICBbJ2llJywgL01TSUVcXHMoN1xcLjApL10sXG4gICAgWydiYjEwJywgL0JCMTA7XFxzVG91Y2guKlZlcnNpb25cXC8oWzAtOVxcLl0rKS9dLFxuICAgIFsnYW5kcm9pZCcsIC9BbmRyb2lkXFxzKFswLTlcXC5dKykvXSxcbiAgICBbJ2lvcycsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipNb2JpbGUuKlNhZmFyaS4qL10sXG4gICAgWydzYWZhcmknLCAvVmVyc2lvblxcLyhbMC05XFwuX10rKS4qU2FmYXJpL10sXG4gICAgWydmYWNlYm9vaycsIC9GQkFWXFwvKFswLTlcXC5dKykvXSxcbiAgICBbJ2luc3RhZ3JhbScsIC9JbnN0YWdyYW1cXHMoWzAtOVxcLl0rKS9dLFxuICAgIFsnaW9zLXdlYnZpZXcnLCAvQXBwbGVXZWJLaXRcXC8oWzAtOVxcLl0rKS4qTW9iaWxlL10sXG4gICAgWydpb3Mtd2VidmlldycsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipHZWNrb1xcKSQvXSxcbiAgICBbJ3NlYXJjaGJvdCcsIFNFQVJDSEJPWF9VQV9SRUdFWF0sXG5dO1xudmFyIG9wZXJhdGluZ1N5c3RlbVJ1bGVzID0gW1xuICAgIFsnaU9TJywgL2lQKGhvbmV8b2R8YWQpL10sXG4gICAgWydBbmRyb2lkIE9TJywgL0FuZHJvaWQvXSxcbiAgICBbJ0JsYWNrQmVycnkgT1MnLCAvQmxhY2tCZXJyeXxCQjEwL10sXG4gICAgWydXaW5kb3dzIE1vYmlsZScsIC9JRU1vYmlsZS9dLFxuICAgIFsnQW1hem9uIE9TJywgL0tpbmRsZS9dLFxuICAgIFsnV2luZG93cyAzLjExJywgL1dpbjE2L10sXG4gICAgWydXaW5kb3dzIDk1JywgLyhXaW5kb3dzIDk1KXwoV2luOTUpfChXaW5kb3dzXzk1KS9dLFxuICAgIFsnV2luZG93cyA5OCcsIC8oV2luZG93cyA5OCl8KFdpbjk4KS9dLFxuICAgIFsnV2luZG93cyAyMDAwJywgLyhXaW5kb3dzIE5UIDUuMCl8KFdpbmRvd3MgMjAwMCkvXSxcbiAgICBbJ1dpbmRvd3MgWFAnLCAvKFdpbmRvd3MgTlQgNS4xKXwoV2luZG93cyBYUCkvXSxcbiAgICBbJ1dpbmRvd3MgU2VydmVyIDIwMDMnLCAvKFdpbmRvd3MgTlQgNS4yKS9dLFxuICAgIFsnV2luZG93cyBWaXN0YScsIC8oV2luZG93cyBOVCA2LjApL10sXG4gICAgWydXaW5kb3dzIDcnLCAvKFdpbmRvd3MgTlQgNi4xKS9dLFxuICAgIFsnV2luZG93cyA4JywgLyhXaW5kb3dzIE5UIDYuMikvXSxcbiAgICBbJ1dpbmRvd3MgOC4xJywgLyhXaW5kb3dzIE5UIDYuMykvXSxcbiAgICBbJ1dpbmRvd3MgMTAnLCAvKFdpbmRvd3MgTlQgMTAuMCkvXSxcbiAgICBbJ1dpbmRvd3MgTUUnLCAvV2luZG93cyBNRS9dLFxuICAgIFsnT3BlbiBCU0QnLCAvT3BlbkJTRC9dLFxuICAgIFsnU3VuIE9TJywgL1N1bk9TL10sXG4gICAgWydDaHJvbWUgT1MnLCAvQ3JPUy9dLFxuICAgIFsnTGludXgnLCAvKExpbnV4KXwoWDExKS9dLFxuICAgIFsnTWFjIE9TJywgLyhNYWNfUG93ZXJQQyl8KE1hY2ludG9zaCkvXSxcbiAgICBbJ1FOWCcsIC9RTlgvXSxcbiAgICBbJ0JlT1MnLCAvQmVPUy9dLFxuICAgIFsnT1MvMicsIC9PU1xcLzIvXSxcbl07XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0KHVzZXJBZ2VudCkge1xuICAgIGlmICghIXVzZXJBZ2VudCkge1xuICAgICAgICByZXR1cm4gcGFyc2VVc2VyQWdlbnQodXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVVzZXJBZ2VudChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vZGVWZXJzaW9uKCk7XG59XG5mdW5jdGlvbiBtYXRjaFVzZXJBZ2VudCh1YSkge1xuICAgIC8vIG9wdGVkIGZvciB1c2luZyByZWR1Y2UgaGVyZSByYXRoZXIgdGhhbiBBcnJheSNmaXJzdCB3aXRoIGEgcmVnZXgudGVzdCBjYWxsXG4gICAgLy8gdGhpcyBpcyBwcmltYXJpbHkgYmVjYXVzZSB1c2luZyB0aGUgcmVkdWNlIHdlIG9ubHkgcGVyZm9ybSB0aGUgcmVnZXhcbiAgICAvLyBleGVjdXRpb24gb25jZSByYXRoZXIgdGhhbiBvbmNlIGZvciB0aGUgdGVzdCBhbmQgZm9yIHRoZSBleGVjIGFnYWluIGJlbG93XG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHRoYXQgbmVlZHMgdG8gYmUgYmVuY2htYXJrZWQgdGhvdWdoXG4gICAgcmV0dXJuICh1YSAhPT0gJycgJiZcbiAgICAgICAgdXNlckFnZW50UnVsZXMucmVkdWNlKGZ1bmN0aW9uIChtYXRjaGVkLCBfYSkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgICAgICAgICAgcmV0dXJuICEhdWFNYXRjaCAmJiBbYnJvd3NlciwgdWFNYXRjaF07XG4gICAgICAgIH0sIGZhbHNlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnJvd3Nlck5hbWUodWEpIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoVXNlckFnZW50KHVhKTtcbiAgICByZXR1cm4gZGF0YSA/IGRhdGFbMF0gOiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXNlckFnZW50KHVhKSB7XG4gICAgdmFyIG1hdGNoZWRSdWxlID0gbWF0Y2hVc2VyQWdlbnQodWEpO1xuICAgIGlmICghbWF0Y2hlZFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lID0gbWF0Y2hlZFJ1bGVbMF0sIG1hdGNoID0gbWF0Y2hlZFJ1bGVbMV07XG4gICAgaWYgKG5hbWUgPT09ICdzZWFyY2hib3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQm90SW5mbygpO1xuICAgIH1cbiAgICB2YXIgdmVyc2lvblBhcnRzID0gbWF0Y2hbMV0gJiYgbWF0Y2hbMV0uc3BsaXQoL1suX10vKS5zbGljZSgwLCAzKTtcbiAgICBpZiAodmVyc2lvblBhcnRzKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uUGFydHMubGVuZ3RoIDwgUkVRVUlSRURfVkVSU0lPTl9QQVJUUykge1xuICAgICAgICAgICAgdmVyc2lvblBhcnRzID0gX19zcHJlYWRBcnJheXModmVyc2lvblBhcnRzLCBjcmVhdGVWZXJzaW9uUGFydHMoUkVRVUlSRURfVkVSU0lPTl9QQVJUUyAtIHZlcnNpb25QYXJ0cy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmVyc2lvblBhcnRzID0gW107XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmVyc2lvblBhcnRzLmpvaW4oJy4nKTtcbiAgICB2YXIgb3MgPSBkZXRlY3RPUyh1YSk7XG4gICAgdmFyIHNlYXJjaEJvdE1hdGNoID0gU0VBUkNIQk9UX09TX1JFR0VYLmV4ZWModWEpO1xuICAgIGlmIChzZWFyY2hCb3RNYXRjaCAmJiBzZWFyY2hCb3RNYXRjaFsxXSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaEJvdERldmljZUluZm8obmFtZSwgdmVyc2lvbiwgb3MsIHNlYXJjaEJvdE1hdGNoWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCcm93c2VySW5mbyhuYW1lLCB2ZXJzaW9uLCBvcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0T1ModWEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDAsIGNvdW50ID0gb3BlcmF0aW5nU3lzdGVtUnVsZXMubGVuZ3RoOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IG9wZXJhdGluZ1N5c3RlbVJ1bGVzW2lpXSwgb3MgPSBfYVswXSwgcmVnZXggPSBfYVsxXTtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyh1YSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG9zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVWZXJzaW9uKCkge1xuICAgIHZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9uO1xuICAgIHJldHVybiBpc05vZGUgPyBuZXcgTm9kZUluZm8ocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDEpKSA6IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVWZXJzaW9uUGFydHMoY291bnQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvdW50OyBpaSsrKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcwJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKiEgQnJvd3NlciBidW5kbGUgb2YgbnVuanVja3MgMy4yLjMgICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJudW5qdWNrc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJudW5qdWNrc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgZXNjYXBlTWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjMzk7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnXG59O1xudmFyIGVzY2FwZVJlZ2V4ID0gL1smXCInPD5dL2c7XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBrKSB7XG4gIHJldHVybiBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgayk7XG59XG5cbmV4cG9ydHMuaGFzT3duUHJvcCA9IGhhc093blByb3A7XG5cbmZ1bmN0aW9uIGxvb2t1cEVzY2FwZShjaCkge1xuICByZXR1cm4gZXNjYXBlTWFwW2NoXTtcbn1cblxuZnVuY3Rpb24gX3ByZXR0aWZ5RXJyb3IocGF0aCwgd2l0aEludGVybmFscywgZXJyKSB7XG4gIGlmICghZXJyLlVwZGF0ZSkge1xuICAgIC8vIG5vdCBvbmUgb2Ygb3VycywgY2FzdCBpdFxuICAgIGVyciA9IG5ldyBleHBvcnRzLlRlbXBsYXRlRXJyb3IoZXJyKTtcbiAgfVxuXG4gIGVyci5VcGRhdGUocGF0aCk7IC8vIFVubGVzcyB0aGV5IG1hcmtlZCB0aGUgZGV2IGZsYWcsIHNob3cgdGhlbSBhIHRyYWNlIGZyb20gaGVyZVxuXG4gIGlmICghd2l0aEludGVybmFscykge1xuICAgIHZhciBvbGQgPSBlcnI7XG4gICAgZXJyID0gbmV3IEVycm9yKG9sZC5tZXNzYWdlKTtcbiAgICBlcnIubmFtZSA9IG9sZC5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuZXhwb3J0cy5fcHJldHRpZnlFcnJvciA9IF9wcmV0dGlmeUVycm9yO1xuXG5mdW5jdGlvbiBUZW1wbGF0ZUVycm9yKG1lc3NhZ2UsIGxpbmVubywgY29sbm8pIHtcbiAgdmFyIGVycjtcbiAgdmFyIGNhdXNlO1xuXG4gIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBjYXVzZSA9IG1lc3NhZ2U7XG4gICAgbWVzc2FnZSA9IGNhdXNlLm5hbWUgKyBcIjogXCIgKyBjYXVzZS5tZXNzYWdlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZXJyLCBUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbWVzc2FnZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbWVzc2FnZVxuICAgIH0pO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdUZW1wbGF0ZSByZW5kZXIgZXJyb3InXG4gIH0pO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cblxuICB2YXIgZ2V0U3RhY2s7XG5cbiAgaWYgKGNhdXNlKSB7XG4gICAgdmFyIHN0YWNrRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2F1c2UsICdzdGFjaycpO1xuXG4gICAgZ2V0U3RhY2sgPSBzdGFja0Rlc2NyaXB0b3IgJiYgKHN0YWNrRGVzY3JpcHRvci5nZXQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YWNrRGVzY3JpcHRvci52YWx1ZTtcbiAgICB9KTtcblxuICAgIGlmICghZ2V0U3RhY2spIHtcbiAgICAgIGdldFN0YWNrID0gZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG4gICAgICAgIHJldHVybiBjYXVzZS5zdGFjaztcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcblxuICAgIGdldFN0YWNrID0gZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdzdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRTdGFjay5jYWxsKGVycik7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NhdXNlJywge1xuICAgIHZhbHVlOiBjYXVzZVxuICB9KTtcbiAgZXJyLmxpbmVubyA9IGxpbmVubztcbiAgZXJyLmNvbG5vID0gY29sbm87XG4gIGVyci5maXJzdFVwZGF0ZSA9IHRydWU7XG5cbiAgZXJyLlVwZGF0ZSA9IGZ1bmN0aW9uIFVwZGF0ZShwYXRoKSB7XG4gICAgdmFyIG1zZyA9ICcoJyArIChwYXRoIHx8ICd1bmtub3duIHBhdGgnKSArICcpJzsgLy8gb25seSBzaG93IGxpbmVubyArIGNvbG5vIG5leHQgdG8gcGF0aCBvZiB0ZW1wbGF0ZVxuICAgIC8vIHdoZXJlIGVycm9yIG9jY3VycmVkXG5cbiAgICBpZiAodGhpcy5maXJzdFVwZGF0ZSkge1xuICAgICAgaWYgKHRoaXMubGluZW5vICYmIHRoaXMuY29sbm8pIHtcbiAgICAgICAgbXNnICs9IFwiIFtMaW5lIFwiICsgdGhpcy5saW5lbm8gKyBcIiwgQ29sdW1uIFwiICsgdGhpcy5jb2xubyArIFwiXVwiO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxpbmVubykge1xuICAgICAgICBtc2cgKz0gXCIgW0xpbmUgXCIgKyB0aGlzLmxpbmVubyArIFwiXVwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1zZyArPSAnXFxuICc7XG5cbiAgICBpZiAodGhpcy5maXJzdFVwZGF0ZSkge1xuICAgICAgbXNnICs9ICcgJztcbiAgICB9XG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBtc2cgKyAodGhpcy5tZXNzYWdlIHx8ICcnKTtcbiAgICB0aGlzLmZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoVGVtcGxhdGVFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG59IGVsc2Uge1xuICBUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBUZW1wbGF0ZUVycm9yXG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5UZW1wbGF0ZUVycm9yID0gVGVtcGxhdGVFcnJvcjtcblxuZnVuY3Rpb24gZXNjYXBlKHZhbCkge1xuICByZXR1cm4gdmFsLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGxvb2t1cEVzY2FwZSk7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgcmV0dXJuIE9ialByb3RvLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG5cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBPYmpQcm90by50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gYXR0clxuICogQHJldHVybnMgeyhzdHJpbmd8bnVtYmVyKVtdfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfcHJlcGFyZUF0dHJpYnV0ZVBhcnRzKGF0dHIpIHtcbiAgaWYgKCFhdHRyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdHRyLnNwbGl0KCcuJyk7XG4gIH1cblxuICByZXR1cm4gW2F0dHJdO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gICBhdHRyaWJ1dGUgICAgICBBdHRyaWJ1dGUgdmFsdWUuIERvdHMgYWxsb3dlZC5cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihPYmplY3QpOiAqfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0QXR0ckdldHRlcihhdHRyaWJ1dGUpIHtcbiAgdmFyIHBhcnRzID0gX3ByZXBhcmVBdHRyaWJ1dGVQYXJ0cyhhdHRyaWJ1dGUpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBhdHRyR2V0dGVyKGl0ZW0pIHtcbiAgICB2YXIgX2l0ZW0gPSBpdGVtO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTsgLy8gSWYgaXRlbSBpcyBub3QgYW4gb2JqZWN0LCBhbmQgd2Ugc3RpbGwgZ290IHBhcnRzIHRvIGhhbmRsZSwgaXQgbWVhbnNcbiAgICAgIC8vIHRoYXQgc29tZXRoaW5nIGdvZXMgd3JvbmcuIEp1c3Qgcm9sbCBvdXQgdG8gdW5kZWZpbmVkIGluIHRoYXQgY2FzZS5cblxuICAgICAgaWYgKGhhc093blByb3AoX2l0ZW0sIHBhcnQpKSB7XG4gICAgICAgIF9pdGVtID0gX2l0ZW1bcGFydF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfaXRlbTtcbiAgfTtcbn1cblxuZXhwb3J0cy5nZXRBdHRyR2V0dGVyID0gZ2V0QXR0ckdldHRlcjtcblxuZnVuY3Rpb24gZ3JvdXBCeShvYmosIHZhbCwgdGhyb3dPblVuZGVmaW5lZCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBpdGVyYXRvciA9IGlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGdldEF0dHJHZXR0ZXIodmFsKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIHZhciB2YWx1ZSA9IG9ialtpXTtcbiAgICB2YXIga2V5ID0gaXRlcmF0b3IodmFsdWUsIGkpO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIHRocm93T25VbmRlZmluZWQgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJncm91cGJ5OiBhdHRyaWJ1dGUgXFxcIlwiICsgdmFsICsgXCJcXFwiIHJlc29sdmVkIHRvIHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7XG5cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xufVxuXG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBpZiAoIWFycmF5KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBjb250YWlucyA9IHRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgdmFyIGluZGV4ID0gLTE7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaW5kZXhPZihjb250YWlucywgYXJyYXlbaW5kZXhdKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy53aXRob3V0ID0gd2l0aG91dDtcblxuZnVuY3Rpb24gcmVwZWF0KGNoYXJfLCBuKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHN0ciArPSBjaGFyXztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuXG5mdW5jdGlvbiBlYWNoKG9iaiwgZnVuYywgY29udGV4dCkge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXlQcm90by5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBcnJheVByb3RvLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnVuYy5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5lYWNoID0gZWFjaDtcblxuZnVuY3Rpb24gbWFwKG9iaiwgZnVuYykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgaWYgKEFycmF5UHJvdG8ubWFwICYmIG9iai5tYXAgPT09IEFycmF5UHJvdG8ubWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAoZnVuYyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gZnVuYyhvYmpbaV0sIGkpO1xuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgcmVzdWx0cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydHMubWFwID0gbWFwO1xuXG5mdW5jdGlvbiBhc3luY0l0ZXIoYXJyLCBpdGVyLCBjYikge1xuICB2YXIgaSA9IC0xO1xuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaSsrO1xuXG4gICAgaWYgKGkgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBpdGVyKGFycltpXSwgaSwgbmV4dCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZXhwb3J0cy5hc3luY0l0ZXIgPSBhc3luY0l0ZXI7XG5cbmZ1bmN0aW9uIGFzeW5jRm9yKG9iaiwgaXRlciwgY2IpIHtcbiAgdmFyIGtleXMgPSBrZXlzXyhvYmogfHwge30pO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gLTE7XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpKys7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuXG4gICAgaWYgKGkgPCBsZW4pIHtcbiAgICAgIGl0ZXIoaywgb2JqW2tdLCBpLCBsZW4sIG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxuXG4gIG5leHQoKTtcbn1cblxuZXhwb3J0cy5hc3luY0ZvciA9IGFzeW5jRm9yO1xuXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFyciB8fCBbXSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4KTtcbn1cblxuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhPZjtcblxuZnVuY3Rpb24ga2V5c18ob2JqKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4gIHZhciBhcnIgPSBbXTtcblxuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgIGFyci5wdXNoKGspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydHMua2V5cyA9IGtleXNfO1xuXG5mdW5jdGlvbiBfZW50cmllcyhvYmopIHtcbiAgcmV0dXJuIGtleXNfKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIFtrLCBvYmpba11dO1xuICB9KTtcbn1cblxuZXhwb3J0cy5fZW50cmllcyA9IF9lbnRyaWVzO1xuXG5mdW5jdGlvbiBfdmFsdWVzKG9iaikge1xuICByZXR1cm4ga2V5c18ob2JqKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gb2JqW2tdO1xuICB9KTtcbn1cblxuZXhwb3J0cy5fdmFsdWVzID0gX3ZhbHVlcztcblxuZnVuY3Rpb24gZXh0ZW5kKG9iajEsIG9iajIpIHtcbiAgb2JqMSA9IG9iajEgfHwge307XG4gIGtleXNfKG9iajIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBvYmoxW2tdID0gb2JqMltrXTtcbiAgfSk7XG4gIHJldHVybiBvYmoxO1xufVxuXG5leHBvcnRzLl9hc3NpZ24gPSBleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcblxuZnVuY3Rpb24gaW5PcGVyYXRvcihrZXksIHZhbCkge1xuICBpZiAoaXNBcnJheSh2YWwpIHx8IGlzU3RyaW5nKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIHJldHVybiBrZXkgaW4gdmFsO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIFwiaW5cIiBvcGVyYXRvciB0byBzZWFyY2ggZm9yIFwiJyArIGtleSArICdcIiBpbiB1bmV4cGVjdGVkIHR5cGVzLicpO1xufVxuXG5leHBvcnRzLmluT3BlcmF0b3IgPSBpbk9wZXJhdG9yO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4gLy8gQSBzaW1wbGUgY2xhc3Mgc3lzdGVtLCBtb3JlIGRvY3VtZW50YXRpb24gdG8gY29tZVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgRXZlbnRFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBwYXJlbnRXcmFwKHBhcmVudCwgcHJvcCkge1xuICBpZiAodHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBwYXJlbnQgbWV0aG9kXG4gICAgdmFyIHRtcCA9IHRoaXMucGFyZW50OyAvLyBTZXQgcGFyZW50IHRvIHRoZSBwcmV2aW91cyBtZXRob2QsIGNhbGwsIGFuZCByZXN0b3JlXG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB2YXIgcmVzID0gcHJvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucGFyZW50ID0gdG1wO1xuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZENsYXNzKGNscywgbmFtZSwgcHJvcHMpIHtcbiAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgbGliLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICBwcm9wc1trXSA9IHBhcmVudFdyYXAoY2xzLnByb3RvdHlwZVtrXSwgcHJvcHNba10pO1xuICB9KTtcblxuICB2YXIgc3ViY2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9jbHMpIHtcbiAgICBfaW5oZXJpdHNMb29zZShzdWJjbGFzcywgX2Nscyk7XG5cbiAgICBmdW5jdGlvbiBzdWJjbGFzcygpIHtcbiAgICAgIHJldHVybiBfY2xzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3Moc3ViY2xhc3MsIFt7XG4gICAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gc3ViY2xhc3M7XG4gIH0oY2xzKTtcblxuICBsaWIuX2Fzc2lnbihzdWJjbGFzcy5wcm90b3R5cGUsIHByb3BzKTtcblxuICByZXR1cm4gc3ViY2xhc3M7XG59XG5cbnZhciBPYmogPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmooKSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSBuZWNlc3NhcnkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2JqLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7fTtcblxuICBPYmouZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKG5hbWUsIHByb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvcHMgPSBuYW1lO1xuICAgICAgbmFtZSA9ICdhbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBuYW1lLCBwcm9wcyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9iaiwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iajtcbn0oKTtcblxudmFyIEVtaXR0ZXJPYmogPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRW1pdHRlck9iaiwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gRW1pdHRlck9iaigpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRXZlbnRFbWl0dGVyLmNhbGwodGhpcykgfHwgdGhpczsgLy8gVW5mb3J0dW5hdGVseSBuZWNlc3NhcnkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICAoX3RoaXMyID0gX3RoaXMpLmluaXQuYXBwbHkoX3RoaXMyLCBhcmd1bWVudHMpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBFbWl0dGVyT2JqLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge307XG5cbiAgRW1pdHRlck9iai5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQobmFtZSwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9wcyA9IG5hbWU7XG4gICAgICBuYW1lID0gJ2Fub255bW91cyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuZENsYXNzKHRoaXMsIG5hbWUsIHByb3BzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRW1pdHRlck9iaiwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVtaXR0ZXJPYmo7XG59KEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBPYmo6IE9iaixcbiAgRW1pdHRlck9iajogRW1pdHRlck9ialxufTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgYXJyYXlGcm9tID0gQXJyYXkuZnJvbTtcbnZhciBzdXBwb3J0c0l0ZXJhdG9ycyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yICYmIHR5cGVvZiBhcnJheUZyb20gPT09ICdmdW5jdGlvbic7IC8vIEZyYW1lcyBrZWVwIHRyYWNrIG9mIHNjb3BpbmcgYm90aCBhdCBjb21waWxlLXRpbWUgYW5kIHJ1bi10aW1lIHNvXG4vLyB3ZSBrbm93IGhvdyB0byBhY2Nlc3MgdmFyaWFibGVzLiBCbG9jayB0YWdzIGNhbiBpbnRyb2R1Y2Ugc3BlY2lhbFxuLy8gdmFyaWFibGVzLCBmb3IgZXhhbXBsZS5cblxudmFyIEZyYW1lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhbWUocGFyZW50LCBpc29sYXRlV3JpdGVzKSB7XG4gICAgdGhpcy52YXJpYWJsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMudG9wTGV2ZWwgPSBmYWxzZTsgLy8gaWYgdGhpcyBpcyB0cnVlLCB3cml0ZXMgKHNldCkgc2hvdWxkIG5ldmVyIHByb3BhZ2F0ZSB1cHdhcmRzIHBhc3RcbiAgICAvLyB0aGlzIGZyYW1lIHRvIGl0cyBwYXJlbnQgKHRob3VnaCByZWFkcyBtYXkpLlxuXG4gICAgdGhpcy5pc29sYXRlV3JpdGVzID0gaXNvbGF0ZVdyaXRlcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGcmFtZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChuYW1lLCB2YWwsIHJlc29sdmVVcCkge1xuICAgIC8vIEFsbG93IHZhcmlhYmxlcyB3aXRoIGRvdHMgYnkgYXV0b21hdGljYWxseSBjcmVhdGluZyB0aGVcbiAgICAvLyBuZXN0ZWQgc3RydWN0dXJlXG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBvYmogPSB0aGlzLnZhcmlhYmxlcztcbiAgICB2YXIgZnJhbWUgPSB0aGlzO1xuXG4gICAgaWYgKHJlc29sdmVVcCkge1xuICAgICAgaWYgKGZyYW1lID0gdGhpcy5yZXNvbHZlKHBhcnRzWzBdLCB0cnVlKSkge1xuICAgICAgICBmcmFtZS5zZXQobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSBwYXJ0c1tpXTtcblxuICAgICAgaWYgKCFvYmpbaWRdKSB7XG4gICAgICAgIG9ialtpZF0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgb2JqID0gb2JqW2lkXTtcbiAgICB9XG5cbiAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhciB2YWwgPSB0aGlzLnZhcmlhYmxlc1tuYW1lXTtcblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8ubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKG5hbWUpIHtcbiAgICB2YXIgcCA9IHRoaXMucGFyZW50O1xuICAgIHZhciB2YWwgPSB0aGlzLnZhcmlhYmxlc1tuYW1lXTtcblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcCAmJiBwLmxvb2t1cChuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUobmFtZSwgZm9yV3JpdGUpIHtcbiAgICB2YXIgcCA9IGZvcldyaXRlICYmIHRoaXMuaXNvbGF0ZVdyaXRlcyA/IHVuZGVmaW5lZCA6IHRoaXMucGFyZW50O1xuICAgIHZhciB2YWwgPSB0aGlzLnZhcmlhYmxlc1tuYW1lXTtcblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAgJiYgcC5yZXNvbHZlKG5hbWUpO1xuICB9O1xuXG4gIF9wcm90by5wdXNoID0gZnVuY3Rpb24gcHVzaChpc29sYXRlV3JpdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBGcmFtZSh0aGlzLCBpc29sYXRlV3JpdGVzKTtcbiAgfTtcblxuICBfcHJvdG8ucG9wID0gZnVuY3Rpb24gcG9wKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfTtcblxuICByZXR1cm4gRnJhbWU7XG59KCk7XG5cbmZ1bmN0aW9uIG1ha2VNYWNybyhhcmdOYW1lcywga3dhcmdOYW1lcywgZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24gbWFjcm8oKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1hY3JvQXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIG1hY3JvQXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnQ291bnQgPSBudW1BcmdzKG1hY3JvQXJncyk7XG4gICAgdmFyIGFyZ3M7XG4gICAgdmFyIGt3YXJncyA9IGdldEtleXdvcmRBcmdzKG1hY3JvQXJncyk7XG5cbiAgICBpZiAoYXJnQ291bnQgPiBhcmdOYW1lcy5sZW5ndGgpIHtcbiAgICAgIGFyZ3MgPSBtYWNyb0FyZ3Muc2xpY2UoMCwgYXJnTmFtZXMubGVuZ3RoKTsgLy8gUG9zaXRpb25hbCBhcmd1bWVudHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGluIGFzXG4gICAgICAvLyBrZXl3b3JkIGFyZ3VtZW50cyAoZXNzZW50aWFsbHkgZGVmYXVsdCB2YWx1ZXMpXG5cbiAgICAgIG1hY3JvQXJncy5zbGljZShhcmdzLmxlbmd0aCwgYXJnQ291bnQpLmZvckVhY2goZnVuY3Rpb24gKHZhbCwgaSkge1xuICAgICAgICBpZiAoaSA8IGt3YXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAga3dhcmdzW2t3YXJnTmFtZXNbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFyZ3MucHVzaChrd2FyZ3MpO1xuICAgIH0gZWxzZSBpZiAoYXJnQ291bnQgPCBhcmdOYW1lcy5sZW5ndGgpIHtcbiAgICAgIGFyZ3MgPSBtYWNyb0FyZ3Muc2xpY2UoMCwgYXJnQ291bnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gYXJnQ291bnQ7IGkgPCBhcmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJnTmFtZXNbaV07IC8vIEtleXdvcmQgYXJndW1lbnRzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBhc1xuICAgICAgICAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50cywgaS5lLiB0aGUgY2FsbGVyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gdXNlZCB0aGUgbmFtZSBvZiBhIHBvc2l0aW9uYWwgYXJnXG5cbiAgICAgICAgYXJncy5wdXNoKGt3YXJnc1thcmddKTtcbiAgICAgICAgZGVsZXRlIGt3YXJnc1thcmddO1xuICAgICAgfVxuXG4gICAgICBhcmdzLnB1c2goa3dhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IG1hY3JvQXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUtleXdvcmRBcmdzKG9iaikge1xuICBvYmouX19rZXl3b3JkcyA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzS2V5d29yZEFyZ3Mob2JqKSB7XG4gIHJldHVybiBvYmogJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ19fa2V5d29yZHMnKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5d29yZEFyZ3MoYXJncykge1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKGxlbikge1xuICAgIHZhciBsYXN0QXJnID0gYXJnc1tsZW4gLSAxXTtcblxuICAgIGlmIChpc0tleXdvcmRBcmdzKGxhc3RBcmcpKSB7XG4gICAgICByZXR1cm4gbGFzdEFyZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIG51bUFyZ3MoYXJncykge1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGxhc3RBcmcgPSBhcmdzW2xlbiAtIDFdO1xuXG4gIGlmIChpc0tleXdvcmRBcmdzKGxhc3RBcmcpKSB7XG4gICAgcmV0dXJuIGxlbiAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxufSAvLyBBIFNhZmVTdHJpbmcgb2JqZWN0IGluZGljYXRlcyB0aGF0IHRoZSBzdHJpbmcgc2hvdWxkIG5vdCBiZVxuLy8gYXV0b2VzY2FwZWQuIFRoaXMgaGFwcGVucyBtYWdpY2FsbHkgYmVjYXVzZSBhdXRvZXNjYXBpbmcgb25seVxuLy8gb2NjdXJzIG9uIHByaW1pdGl2ZSBzdHJpbmcgb2JqZWN0cy5cblxuXG5mdW5jdGlvbiBTYWZlU3RyaW5nKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhpcy52YWwgPSB2YWw7XG4gIHRoaXMubGVuZ3RoID0gdmFsLmxlbmd0aDtcbn1cblxuU2FmZVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmluZy5wcm90b3R5cGUsIHtcbiAgbGVuZ3RoOiB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiAwXG4gIH1cbn0pO1xuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgcmV0dXJuIHRoaXMudmFsO1xufTtcblxuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMudmFsO1xufTtcblxuZnVuY3Rpb24gY29weVNhZmVuZXNzKGRlc3QsIHRhcmdldCkge1xuICBpZiAoZGVzdCBpbnN0YW5jZW9mIFNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFNhZmVTdHJpbmcodGFyZ2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gbWFya1NhZmUodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IFNhZmVTdHJpbmcodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gd3JhcFNhZmUoYXJncykge1xuICAgICAgdmFyIHJldCA9IHZhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKHJldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwcmVzc1ZhbHVlKHZhbCwgYXV0b2VzY2FwZSkge1xuICB2YWwgPSB2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwgPyB2YWwgOiAnJztcblxuICBpZiAoYXV0b2VzY2FwZSAmJiAhKHZhbCBpbnN0YW5jZW9mIFNhZmVTdHJpbmcpKSB7XG4gICAgdmFsID0gbGliLmVzY2FwZSh2YWwudG9TdHJpbmcoKSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVEZWZpbmVkKHZhbCwgbGluZW5vLCBjb2xubykge1xuICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IGxpYi5UZW1wbGF0ZUVycm9yKCdhdHRlbXB0ZWQgdG8gb3V0cHV0IG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlJywgbGluZW5vICsgMSwgY29sbm8gKyAxKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIG1lbWJlckxvb2t1cChvYmosIHZhbCkge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialt2YWxdLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBvYmpbdmFsXTtcbn1cblxuZnVuY3Rpb24gY2FsbFdyYXAob2JqLCBuYW1lLCBjb250ZXh0LCBhcmdzKSB7XG4gIGlmICghb2JqKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY2FsbCBgJyArIG5hbWUgKyAnYCwgd2hpY2ggaXMgdW5kZWZpbmVkIG9yIGZhbHNleScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjYWxsIGAnICsgbmFtZSArICdgLCB3aGljaCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgcmV0dXJuIG9iai5hcHBseShjb250ZXh0LCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gY29udGV4dE9yRnJhbWVMb29rdXAoY29udGV4dCwgZnJhbWUsIG5hbWUpIHtcbiAgdmFyIHZhbCA9IGZyYW1lLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogY29udGV4dC5sb29rdXAobmFtZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBsaW5lbm8sIGNvbG5vKSB7XG4gIGlmIChlcnJvci5saW5lbm8pIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBsaWIuVGVtcGxhdGVFcnJvcihlcnJvciwgbGluZW5vLCBjb2xubyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNFYWNoKGFyciwgZGltZW4sIGl0ZXIsIGNiKSB7XG4gIGlmIChsaWIuaXNBcnJheShhcnIpKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgbGliLmFzeW5jSXRlcihhcnIsIGZ1bmN0aW9uIGl0ZXJDYWxsYmFjayhpdGVtLCBpLCBuZXh0KSB7XG4gICAgICBzd2l0Y2ggKGRpbWVuKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpdGVyKGl0ZW0sIGksIGxlbiwgbmV4dCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGl0ZXIoaXRlbVswXSwgaXRlbVsxXSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaXRlcihpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdLCBpLCBsZW4sIG5leHQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXRlbS5wdXNoKGksIGxlbiwgbmV4dCk7XG4gICAgICAgICAgaXRlci5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH0gZWxzZSB7XG4gICAgbGliLmFzeW5jRm9yKGFyciwgZnVuY3Rpb24gaXRlckNhbGxiYWNrKGtleSwgdmFsLCBpLCBsZW4sIG5leHQpIHtcbiAgICAgIGl0ZXIoa2V5LCB2YWwsIGksIGxlbiwgbmV4dCk7XG4gICAgfSwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzeW5jQWxsKGFyciwgZGltZW4sIGZ1bmMsIGNiKSB7XG4gIHZhciBmaW5pc2hlZCA9IDA7XG4gIHZhciBsZW47XG4gIHZhciBvdXRwdXRBcnI7XG5cbiAgZnVuY3Rpb24gZG9uZShpLCBvdXRwdXQpIHtcbiAgICBmaW5pc2hlZCsrO1xuICAgIG91dHB1dEFycltpXSA9IG91dHB1dDtcblxuICAgIGlmIChmaW5pc2hlZCA9PT0gbGVuKSB7XG4gICAgICBjYihudWxsLCBvdXRwdXRBcnIuam9pbignJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsaWIuaXNBcnJheShhcnIpKSB7XG4gICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBvdXRwdXRBcnIgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIGNiKG51bGwsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XG5cbiAgICAgICAgc3dpdGNoIChkaW1lbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGZ1bmMoaXRlbSwgaSwgbGVuLCBkb25lKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZnVuYyhpdGVtWzBdLCBpdGVtWzFdLCBpLCBsZW4sIGRvbmUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBmdW5jKGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpdGVtLnB1c2goaSwgbGVuLCBkb25lKTtcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGtleXMgPSBsaWIua2V5cyhhcnIgfHwge30pO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIG91dHB1dEFyciA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgY2IobnVsbCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwga2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW19pXTtcbiAgICAgICAgZnVuYyhrLCBhcnJba10sIF9pLCBsZW4sIGRvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tSXRlcmF0b3IoYXJyKSB7XG4gIGlmICh0eXBlb2YgYXJyICE9PSAnb2JqZWN0JyB8fCBhcnIgPT09IG51bGwgfHwgbGliLmlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNJdGVyYXRvcnMgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFycikge1xuICAgIHJldHVybiBhcnJheUZyb20oYXJyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGcmFtZTogRnJhbWUsXG4gIG1ha2VNYWNybzogbWFrZU1hY3JvLFxuICBtYWtlS2V5d29yZEFyZ3M6IG1ha2VLZXl3b3JkQXJncyxcbiAgbnVtQXJnczogbnVtQXJncyxcbiAgc3VwcHJlc3NWYWx1ZTogc3VwcHJlc3NWYWx1ZSxcbiAgZW5zdXJlRGVmaW5lZDogZW5zdXJlRGVmaW5lZCxcbiAgbWVtYmVyTG9va3VwOiBtZW1iZXJMb29rdXAsXG4gIGNvbnRleHRPckZyYW1lTG9va3VwOiBjb250ZXh0T3JGcmFtZUxvb2t1cCxcbiAgY2FsbFdyYXA6IGNhbGxXcmFwLFxuICBoYW5kbGVFcnJvcjogaGFuZGxlRXJyb3IsXG4gIGlzQXJyYXk6IGxpYi5pc0FycmF5LFxuICBrZXlzOiBsaWIua2V5cyxcbiAgU2FmZVN0cmluZzogU2FmZVN0cmluZyxcbiAgY29weVNhZmVuZXNzOiBjb3B5U2FmZW5lc3MsXG4gIG1hcmtTYWZlOiBtYXJrU2FmZSxcbiAgYXN5bmNFYWNoOiBhc3luY0VhY2gsXG4gIGFzeW5jQWxsOiBhc3luY0FsbCxcbiAgaW5PcGVyYXRvcjogbGliLmluT3BlcmF0b3IsXG4gIGZyb21JdGVyYXRvcjogZnJvbUl0ZXJhdG9yXG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSxcbiAgICBPYmogPSBfcmVxdWlyZS5PYmo7XG5cbmZ1bmN0aW9uIHRyYXZlcnNlQW5kQ2hlY2sob2JqLCB0eXBlLCByZXN1bHRzKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgcmVzdWx0cy5wdXNoKG9iaik7XG4gIH1cblxuICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIG9iai5maW5kQWxsKHR5cGUsIHJlc3VsdHMpO1xuICB9XG59XG5cbnZhciBOb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKE5vZGUsIF9PYmopO1xuXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgcmV0dXJuIF9PYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE5vZGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChsaW5lbm8sIGNvbG5vKSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuICAgIHRoaXMuY29sbm8gPSBjb2xubztcbiAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgICAgLy8gVGhlIGZpcnN0IHR3byBhcmdzIGFyZSBsaW5lL2NvbCBudW1iZXJzLCBzbyBvZmZzZXQgYnkgMlxuICAgICAgdmFyIHZhbCA9IF9hcmd1bWVudHNbaSArIDJdOyAvLyBGaWVsZHMgc2hvdWxkIG5ldmVyIGJlIHVuZGVmaW5lZCwgYnV0IG51bGwuIEl0IG1ha2VzXG4gICAgICAvLyB0ZXN0aW5nIGVhc2llciB0byBub3JtYWxpemUgdmFsdWVzLlxuXG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX3RoaXNbZmllbGRdID0gdmFsO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5maW5kQWxsID0gZnVuY3Rpb24gZmluZEFsbCh0eXBlLCByZXN1bHRzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTm9kZUxpc3QpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQ2hlY2soY2hpbGQsIHR5cGUsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZENoZWNrKF90aGlzMltmaWVsZF0sIHR5cGUsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgX3Byb3RvLml0ZXJGaWVsZHMgPSBmdW5jdGlvbiBpdGVyRmllbGRzKGZ1bmMpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHRoaXMuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICBmdW5jKF90aGlzM1tmaWVsZF0sIGZpZWxkKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTm9kZTtcbn0oT2JqKTsgLy8gQWJzdHJhY3Qgbm9kZXNcblxuXG52YXIgVmFsdWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFZhbHVlLCBfTm9kZSk7XG5cbiAgZnVuY3Rpb24gVmFsdWUoKSB7XG4gICAgcmV0dXJuIF9Ob2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWYWx1ZSwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnVmFsdWUnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWVsZHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBbJ3ZhbHVlJ107XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZhbHVlO1xufShOb2RlKTsgLy8gQ29uY3JldGUgbm9kZXNcblxuXG52YXIgTm9kZUxpc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlMikge1xuICBfaW5oZXJpdHNMb29zZShOb2RlTGlzdCwgX05vZGUyKTtcblxuICBmdW5jdGlvbiBOb2RlTGlzdCgpIHtcbiAgICByZXR1cm4gX05vZGUyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gTm9kZUxpc3QucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuaW5pdCA9IGZ1bmN0aW9uIGluaXQobGluZW5vLCBjb2xubywgbm9kZXMpIHtcbiAgICBfTm9kZTIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBsaW5lbm8sIGNvbG5vLCBub2RlcyB8fCBbXSk7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE5vZGVMaXN0LCBbe1xuICAgIGtleTogXCJ0eXBlbmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdOb2RlTGlzdCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFsnY2hpbGRyZW4nXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9kZUxpc3Q7XG59KE5vZGUpO1xuXG52YXIgUm9vdCA9IE5vZGVMaXN0LmV4dGVuZCgnUm9vdCcpO1xudmFyIExpdGVyYWwgPSBWYWx1ZS5leHRlbmQoJ0xpdGVyYWwnKTtcbnZhciBTeW1ib2wgPSBWYWx1ZS5leHRlbmQoJ1N5bWJvbCcpO1xudmFyIEdyb3VwID0gTm9kZUxpc3QuZXh0ZW5kKCdHcm91cCcpO1xudmFyIEFycmF5Tm9kZSA9IE5vZGVMaXN0LmV4dGVuZCgnQXJyYXknKTtcbnZhciBQYWlyID0gTm9kZS5leHRlbmQoJ1BhaXInLCB7XG4gIGZpZWxkczogWydrZXknLCAndmFsdWUnXVxufSk7XG52YXIgRGljdCA9IE5vZGVMaXN0LmV4dGVuZCgnRGljdCcpO1xudmFyIExvb2t1cFZhbCA9IE5vZGUuZXh0ZW5kKCdMb29rdXBWYWwnLCB7XG4gIGZpZWxkczogWyd0YXJnZXQnLCAndmFsJ11cbn0pO1xudmFyIElmID0gTm9kZS5leHRlbmQoJ0lmJywge1xuICBmaWVsZHM6IFsnY29uZCcsICdib2R5JywgJ2Vsc2VfJ11cbn0pO1xudmFyIElmQXN5bmMgPSBJZi5leHRlbmQoJ0lmQXN5bmMnKTtcbnZhciBJbmxpbmVJZiA9IE5vZGUuZXh0ZW5kKCdJbmxpbmVJZicsIHtcbiAgZmllbGRzOiBbJ2NvbmQnLCAnYm9keScsICdlbHNlXyddXG59KTtcbnZhciBGb3IgPSBOb2RlLmV4dGVuZCgnRm9yJywge1xuICBmaWVsZHM6IFsnYXJyJywgJ25hbWUnLCAnYm9keScsICdlbHNlXyddXG59KTtcbnZhciBBc3luY0VhY2ggPSBGb3IuZXh0ZW5kKCdBc3luY0VhY2gnKTtcbnZhciBBc3luY0FsbCA9IEZvci5leHRlbmQoJ0FzeW5jQWxsJyk7XG52YXIgTWFjcm8gPSBOb2RlLmV4dGVuZCgnTWFjcm8nLCB7XG4gIGZpZWxkczogWyduYW1lJywgJ2FyZ3MnLCAnYm9keSddXG59KTtcbnZhciBDYWxsZXIgPSBNYWNyby5leHRlbmQoJ0NhbGxlcicpO1xudmFyIEltcG9ydCA9IE5vZGUuZXh0ZW5kKCdJbXBvcnQnLCB7XG4gIGZpZWxkczogWyd0ZW1wbGF0ZScsICd0YXJnZXQnLCAnd2l0aENvbnRleHQnXVxufSk7XG5cbnZhciBGcm9tSW1wb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZTMpIHtcbiAgX2luaGVyaXRzTG9vc2UoRnJvbUltcG9ydCwgX05vZGUzKTtcblxuICBmdW5jdGlvbiBGcm9tSW1wb3J0KCkge1xuICAgIHJldHVybiBfTm9kZTMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBGcm9tSW1wb3J0LnByb3RvdHlwZTtcblxuICBfcHJvdG8zLmluaXQgPSBmdW5jdGlvbiBpbml0KGxpbmVubywgY29sbm8sIHRlbXBsYXRlLCBuYW1lcywgd2l0aENvbnRleHQpIHtcbiAgICBfTm9kZTMucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBsaW5lbm8sIGNvbG5vLCB0ZW1wbGF0ZSwgbmFtZXMgfHwgbmV3IE5vZGVMaXN0KCksIHdpdGhDb250ZXh0KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoRnJvbUltcG9ydCwgW3tcbiAgICBrZXk6IFwidHlwZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnRnJvbUltcG9ydCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpZWxkc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFsndGVtcGxhdGUnLCAnbmFtZXMnLCAnd2l0aENvbnRleHQnXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJvbUltcG9ydDtcbn0oTm9kZSk7XG5cbnZhciBGdW5DYWxsID0gTm9kZS5leHRlbmQoJ0Z1bkNhbGwnLCB7XG4gIGZpZWxkczogWyduYW1lJywgJ2FyZ3MnXVxufSk7XG52YXIgRmlsdGVyID0gRnVuQ2FsbC5leHRlbmQoJ0ZpbHRlcicpO1xudmFyIEZpbHRlckFzeW5jID0gRmlsdGVyLmV4dGVuZCgnRmlsdGVyQXN5bmMnLCB7XG4gIGZpZWxkczogWyduYW1lJywgJ2FyZ3MnLCAnc3ltYm9sJ11cbn0pO1xudmFyIEtleXdvcmRBcmdzID0gRGljdC5leHRlbmQoJ0tleXdvcmRBcmdzJyk7XG52YXIgQmxvY2sgPSBOb2RlLmV4dGVuZCgnQmxvY2snLCB7XG4gIGZpZWxkczogWyduYW1lJywgJ2JvZHknXVxufSk7XG52YXIgU3VwZXIgPSBOb2RlLmV4dGVuZCgnU3VwZXInLCB7XG4gIGZpZWxkczogWydibG9ja05hbWUnLCAnc3ltYm9sJ11cbn0pO1xudmFyIFRlbXBsYXRlUmVmID0gTm9kZS5leHRlbmQoJ1RlbXBsYXRlUmVmJywge1xuICBmaWVsZHM6IFsndGVtcGxhdGUnXVxufSk7XG52YXIgRXh0ZW5kcyA9IFRlbXBsYXRlUmVmLmV4dGVuZCgnRXh0ZW5kcycpO1xudmFyIEluY2x1ZGUgPSBOb2RlLmV4dGVuZCgnSW5jbHVkZScsIHtcbiAgZmllbGRzOiBbJ3RlbXBsYXRlJywgJ2lnbm9yZU1pc3NpbmcnXVxufSk7XG52YXIgU2V0ID0gTm9kZS5leHRlbmQoJ1NldCcsIHtcbiAgZmllbGRzOiBbJ3RhcmdldHMnLCAndmFsdWUnXVxufSk7XG52YXIgU3dpdGNoID0gTm9kZS5leHRlbmQoJ1N3aXRjaCcsIHtcbiAgZmllbGRzOiBbJ2V4cHInLCAnY2FzZXMnLCAnZGVmYXVsdCddXG59KTtcbnZhciBDYXNlID0gTm9kZS5leHRlbmQoJ0Nhc2UnLCB7XG4gIGZpZWxkczogWydjb25kJywgJ2JvZHknXVxufSk7XG52YXIgT3V0cHV0ID0gTm9kZUxpc3QuZXh0ZW5kKCdPdXRwdXQnKTtcbnZhciBDYXB0dXJlID0gTm9kZS5leHRlbmQoJ0NhcHR1cmUnLCB7XG4gIGZpZWxkczogWydib2R5J11cbn0pO1xudmFyIFRlbXBsYXRlRGF0YSA9IExpdGVyYWwuZXh0ZW5kKCdUZW1wbGF0ZURhdGEnKTtcbnZhciBVbmFyeU9wID0gTm9kZS5leHRlbmQoJ1VuYXJ5T3AnLCB7XG4gIGZpZWxkczogWyd0YXJnZXQnXVxufSk7XG52YXIgQmluT3AgPSBOb2RlLmV4dGVuZCgnQmluT3AnLCB7XG4gIGZpZWxkczogWydsZWZ0JywgJ3JpZ2h0J11cbn0pO1xudmFyIEluID0gQmluT3AuZXh0ZW5kKCdJbicpO1xudmFyIElzID0gQmluT3AuZXh0ZW5kKCdJcycpO1xudmFyIE9yID0gQmluT3AuZXh0ZW5kKCdPcicpO1xudmFyIEFuZCA9IEJpbk9wLmV4dGVuZCgnQW5kJyk7XG52YXIgTm90ID0gVW5hcnlPcC5leHRlbmQoJ05vdCcpO1xudmFyIEFkZCA9IEJpbk9wLmV4dGVuZCgnQWRkJyk7XG52YXIgQ29uY2F0ID0gQmluT3AuZXh0ZW5kKCdDb25jYXQnKTtcbnZhciBTdWIgPSBCaW5PcC5leHRlbmQoJ1N1YicpO1xudmFyIE11bCA9IEJpbk9wLmV4dGVuZCgnTXVsJyk7XG52YXIgRGl2ID0gQmluT3AuZXh0ZW5kKCdEaXYnKTtcbnZhciBGbG9vckRpdiA9IEJpbk9wLmV4dGVuZCgnRmxvb3JEaXYnKTtcbnZhciBNb2QgPSBCaW5PcC5leHRlbmQoJ01vZCcpO1xudmFyIFBvdyA9IEJpbk9wLmV4dGVuZCgnUG93Jyk7XG52YXIgTmVnID0gVW5hcnlPcC5leHRlbmQoJ05lZycpO1xudmFyIFBvcyA9IFVuYXJ5T3AuZXh0ZW5kKCdQb3MnKTtcbnZhciBDb21wYXJlID0gTm9kZS5leHRlbmQoJ0NvbXBhcmUnLCB7XG4gIGZpZWxkczogWydleHByJywgJ29wcyddXG59KTtcbnZhciBDb21wYXJlT3BlcmFuZCA9IE5vZGUuZXh0ZW5kKCdDb21wYXJlT3BlcmFuZCcsIHtcbiAgZmllbGRzOiBbJ2V4cHInLCAndHlwZSddXG59KTtcbnZhciBDYWxsRXh0ZW5zaW9uID0gTm9kZS5leHRlbmQoJ0NhbGxFeHRlbnNpb24nLCB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoZXh0LCBwcm9wLCBhcmdzLCBjb250ZW50QXJncykge1xuICAgIHRoaXMucGFyZW50KCk7XG4gICAgdGhpcy5leHROYW1lID0gZXh0Ll9fbmFtZSB8fCBleHQ7XG4gICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzIHx8IG5ldyBOb2RlTGlzdCgpO1xuICAgIHRoaXMuY29udGVudEFyZ3MgPSBjb250ZW50QXJncyB8fCBbXTtcbiAgICB0aGlzLmF1dG9lc2NhcGUgPSBleHQuYXV0b2VzY2FwZTtcbiAgfSxcbiAgZmllbGRzOiBbJ2V4dE5hbWUnLCAncHJvcCcsICdhcmdzJywgJ2NvbnRlbnRBcmdzJ11cbn0pO1xudmFyIENhbGxFeHRlbnNpb25Bc3luYyA9IENhbGxFeHRlbnNpb24uZXh0ZW5kKCdDYWxsRXh0ZW5zaW9uQXN5bmMnKTsgLy8gVGhpcyBpcyBoYWNreSwgYnV0IHRoaXMgaXMganVzdCBhIGRlYnVnZ2luZyBmdW5jdGlvbiBhbnl3YXlcblxuZnVuY3Rpb24gcHJpbnQoc3RyLCBpbmRlbnQsIGlubGluZSkge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoJ1xcbicpO1xuICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgaWYgKGxpbmUgJiYgKGlubGluZSAmJiBpID4gMCB8fCAhaW5saW5lKSkge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJyAnLnJlcGVhdChpbmRlbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgbmwgPSBpID09PSBsaW5lcy5sZW5ndGggLSAxID8gJycgOiAnXFxuJztcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShcIlwiICsgbGluZSArIG5sKTtcbiAgfSk7XG59IC8vIFByaW50IHRoZSBBU1QgaW4gYSBuaWNlbHkgZm9ybWF0dGVkIHRyZWUgZm9ybWF0IGZvciBkZWJ1Z2dpblxuXG5cbmZ1bmN0aW9uIHByaW50Tm9kZXMobm9kZSwgaW5kZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAwO1xuICBwcmludChub2RlLnR5cGVuYW1lICsgJzogJywgaW5kZW50KTtcblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgcHJpbnQoJ1xcbicpO1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgcHJpbnROb2RlcyhuLCBpbmRlbnQgKyAyKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQ2FsbEV4dGVuc2lvbikge1xuICAgIHByaW50KG5vZGUuZXh0TmFtZSArIFwiLlwiICsgbm9kZS5wcm9wICsgXCJcXG5cIik7XG5cbiAgICBpZiAobm9kZS5hcmdzKSB7XG4gICAgICBwcmludE5vZGVzKG5vZGUuYXJncywgaW5kZW50ICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY29udGVudEFyZ3MpIHtcbiAgICAgIG5vZGUuY29udGVudEFyZ3MuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICBwcmludE5vZGVzKG4sIGluZGVudCArIDIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBwcm9wcyA9IG51bGw7XG4gICAgbm9kZS5pdGVyRmllbGRzKGZ1bmN0aW9uICh2YWwsIGZpZWxkTmFtZSkge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgbm9kZXMucHVzaChbZmllbGROYW1lLCB2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICAgIHByb3BzW2ZpZWxkTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHByaW50KEpTT04uc3RyaW5naWZ5KHByb3BzLCBudWxsLCAyKSArICdcXG4nLCBudWxsLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnQoJ1xcbicpO1xuICAgIH1cblxuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBmaWVsZE5hbWUgPSBfcmVmWzBdLFxuICAgICAgICAgIG4gPSBfcmVmWzFdO1xuICAgICAgcHJpbnQoXCJbXCIgKyBmaWVsZE5hbWUgKyBcIl0gPT5cIiwgaW5kZW50ICsgMik7XG4gICAgICBwcmludE5vZGVzKG4sIGluZGVudCArIDQpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBOb2RlOiBOb2RlLFxuICBSb290OiBSb290LFxuICBOb2RlTGlzdDogTm9kZUxpc3QsXG4gIFZhbHVlOiBWYWx1ZSxcbiAgTGl0ZXJhbDogTGl0ZXJhbCxcbiAgU3ltYm9sOiBTeW1ib2wsXG4gIEdyb3VwOiBHcm91cCxcbiAgQXJyYXk6IEFycmF5Tm9kZSxcbiAgUGFpcjogUGFpcixcbiAgRGljdDogRGljdCxcbiAgT3V0cHV0OiBPdXRwdXQsXG4gIENhcHR1cmU6IENhcHR1cmUsXG4gIFRlbXBsYXRlRGF0YTogVGVtcGxhdGVEYXRhLFxuICBJZjogSWYsXG4gIElmQXN5bmM6IElmQXN5bmMsXG4gIElubGluZUlmOiBJbmxpbmVJZixcbiAgRm9yOiBGb3IsXG4gIEFzeW5jRWFjaDogQXN5bmNFYWNoLFxuICBBc3luY0FsbDogQXN5bmNBbGwsXG4gIE1hY3JvOiBNYWNybyxcbiAgQ2FsbGVyOiBDYWxsZXIsXG4gIEltcG9ydDogSW1wb3J0LFxuICBGcm9tSW1wb3J0OiBGcm9tSW1wb3J0LFxuICBGdW5DYWxsOiBGdW5DYWxsLFxuICBGaWx0ZXI6IEZpbHRlcixcbiAgRmlsdGVyQXN5bmM6IEZpbHRlckFzeW5jLFxuICBLZXl3b3JkQXJnczogS2V5d29yZEFyZ3MsXG4gIEJsb2NrOiBCbG9jayxcbiAgU3VwZXI6IFN1cGVyLFxuICBFeHRlbmRzOiBFeHRlbmRzLFxuICBJbmNsdWRlOiBJbmNsdWRlLFxuICBTZXQ6IFNldCxcbiAgU3dpdGNoOiBTd2l0Y2gsXG4gIENhc2U6IENhc2UsXG4gIExvb2t1cFZhbDogTG9va3VwVmFsLFxuICBCaW5PcDogQmluT3AsXG4gIEluOiBJbixcbiAgSXM6IElzLFxuICBPcjogT3IsXG4gIEFuZDogQW5kLFxuICBOb3Q6IE5vdCxcbiAgQWRkOiBBZGQsXG4gIENvbmNhdDogQ29uY2F0LFxuICBTdWI6IFN1YixcbiAgTXVsOiBNdWwsXG4gIERpdjogRGl2LFxuICBGbG9vckRpdjogRmxvb3JEaXYsXG4gIE1vZDogTW9kLFxuICBQb3c6IFBvdyxcbiAgTmVnOiBOZWcsXG4gIFBvczogUG9zLFxuICBDb21wYXJlOiBDb21wYXJlLFxuICBDb21wYXJlT3BlcmFuZDogQ29tcGFyZU9wZXJhbmQsXG4gIENhbGxFeHRlbnNpb246IENhbGxFeHRlbnNpb24sXG4gIENhbGxFeHRlbnNpb25Bc3luYzogQ2FsbEV4dGVuc2lvbkFzeW5jLFxuICBwcmludE5vZGVzOiBwcmludE5vZGVzXG59O1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciB0cmFuc2Zvcm1lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgbm9kZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLFxuICAgIFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZS5UZW1wbGF0ZUVycm9yO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgICBGcmFtZSA9IF9yZXF1aXJlMi5GcmFtZTtcblxudmFyIF9yZXF1aXJlMyA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgT2JqID0gX3JlcXVpcmUzLk9iajsgLy8gVGhlc2UgYXJlIGFsbCB0aGUgc2FtZSBmb3Igbm93LCBidXQgc2hvdWxkbid0IGJlIHBhc3NlZCBzdHJhaWdodFxuLy8gdGhyb3VnaFxuXG5cbnZhciBjb21wYXJlT3BzID0ge1xuICAnPT0nOiAnPT0nLFxuICAnPT09JzogJz09PScsXG4gICchPSc6ICchPScsXG4gICchPT0nOiAnIT09JyxcbiAgJzwnOiAnPCcsXG4gICc+JzogJz4nLFxuICAnPD0nOiAnPD0nLFxuICAnPj0nOiAnPj0nXG59O1xuXG52YXIgQ29tcGlsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29tcGlsZXIsIF9PYmopO1xuXG4gIGZ1bmN0aW9uIENvbXBpbGVyKCkge1xuICAgIHJldHVybiBfT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21waWxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHRlbXBsYXRlTmFtZSwgdGhyb3dPblVuZGVmaW5lZCkge1xuICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgIHRoaXMuY29kZWJ1ZiA9IFtdO1xuICAgIHRoaXMubGFzdElkID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5idWZmZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9ICcnO1xuICAgIHRoaXMuaW5CbG9jayA9IGZhbHNlO1xuICAgIHRoaXMudGhyb3dPblVuZGVmaW5lZCA9IHRocm93T25VbmRlZmluZWQ7XG4gIH07XG5cbiAgX3Byb3RvLmZhaWwgPSBmdW5jdGlvbiBmYWlsKG1zZywgbGluZW5vLCBjb2xubykge1xuICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGluZW5vICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbG5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbG5vICs9IDE7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFRlbXBsYXRlRXJyb3IobXNnLCBsaW5lbm8sIGNvbG5vKTtcbiAgfTtcblxuICBfcHJvdG8uX3B1c2hCdWZmZXIgPSBmdW5jdGlvbiBfcHVzaEJ1ZmZlcigpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdGhpcy5idWZmZXJTdGFjay5wdXNoKHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLmJ1ZmZlciA9IGlkO1xuXG4gICAgdGhpcy5fZW1pdChcInZhciBcIiArIHRoaXMuYnVmZmVyICsgXCIgPSBcXFwiXFxcIjtcIik7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgX3Byb3RvLl9wb3BCdWZmZXIgPSBmdW5jdGlvbiBfcG9wQnVmZmVyKCkge1xuICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXJTdGFjay5wb3AoKTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXQgPSBmdW5jdGlvbiBfZW1pdChjb2RlKSB7XG4gICAgdGhpcy5jb2RlYnVmLnB1c2goY29kZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0TGluZSA9IGZ1bmN0aW9uIF9lbWl0TGluZShjb2RlKSB7XG4gICAgdGhpcy5fZW1pdChjb2RlICsgJ1xcbicpO1xuICB9O1xuXG4gIF9wcm90by5fZW1pdExpbmVzID0gZnVuY3Rpb24gX2VtaXRMaW5lcygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGxpbmVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbGluZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgcmV0dXJuIF90aGlzLl9lbWl0TGluZShsaW5lKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXRGdW5jQmVnaW4gPSBmdW5jdGlvbiBfZW1pdEZ1bmNCZWdpbihub2RlLCBuYW1lKSB7XG4gICAgdGhpcy5idWZmZXIgPSAnb3V0cHV0JztcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcblxuICAgIHRoaXMuX2VtaXRMaW5lKFwiZnVuY3Rpb24gXCIgKyBuYW1lICsgXCIoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpIHtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcInZhciBsaW5lbm8gPSBcIiArIG5vZGUubGluZW5vICsgXCI7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgY29sbm8gPSBcIiArIG5vZGUuY29sbm8gKyBcIjtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIHRoaXMuYnVmZmVyICsgXCIgPSBcXFwiXFxcIjtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndHJ5IHsnKTtcbiAgfTtcblxuICBfcHJvdG8uX2VtaXRGdW5jRW5kID0gZnVuY3Rpb24gX2VtaXRGdW5jRW5kKG5vUmV0dXJuKSB7XG4gICAgaWYgKCFub1JldHVybikge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ2NiKG51bGwsICcgKyB0aGlzLmJ1ZmZlciArICcpOycpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlU2NvcGVMZXZlbHMoKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9IGNhdGNoIChlKSB7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnICBjYihydW50aW1lLmhhbmRsZUVycm9yKGUsIGxpbmVubywgY29sbm8pKTsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICB9O1xuXG4gIF9wcm90by5fYWRkU2NvcGVMZXZlbCA9IGZ1bmN0aW9uIF9hZGRTY29wZUxldmVsKCkge1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyArPSAnfSknO1xuICB9O1xuXG4gIF9wcm90by5fY2xvc2VTY29wZUxldmVscyA9IGZ1bmN0aW9uIF9jbG9zZVNjb3BlTGV2ZWxzKCkge1xuICAgIHRoaXMuX2VtaXRMaW5lKHRoaXMuX3Njb3BlQ2xvc2VycyArICc7Jyk7XG5cbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhTY29wZWRTeW50YXggPSBmdW5jdGlvbiBfd2l0aFNjb3BlZFN5bnRheChmdW5jKSB7XG4gICAgdmFyIF9zY29wZUNsb3NlcnMgPSB0aGlzLl9zY29wZUNsb3NlcnM7XG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzID0gJyc7XG4gICAgZnVuYy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fY2xvc2VTY29wZUxldmVscygpO1xuXG4gICAgdGhpcy5fc2NvcGVDbG9zZXJzID0gX3Njb3BlQ2xvc2VycztcbiAgfTtcblxuICBfcHJvdG8uX21ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIF9tYWtlQ2FsbGJhY2socmVzKSB7XG4gICAgdmFyIGVyciA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCcgKyBlcnIgKyAocmVzID8gJywnICsgcmVzIDogJycpICsgJykge1xcbicgKyAnaWYoJyArIGVyciArICcpIHsgY2IoJyArIGVyciArICcpOyByZXR1cm47IH0nO1xuICB9O1xuXG4gIF9wcm90by5fdG1waWQgPSBmdW5jdGlvbiBfdG1waWQoKSB7XG4gICAgdGhpcy5sYXN0SWQrKztcbiAgICByZXR1cm4gJ3RfJyArIHRoaXMubGFzdElkO1xuICB9O1xuXG4gIF9wcm90by5fdGVtcGxhdGVOYW1lID0gZnVuY3Rpb24gX3RlbXBsYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZU5hbWUgPT0gbnVsbCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkodGhpcy50ZW1wbGF0ZU5hbWUpO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZUNoaWxkcmVuID0gZnVuY3Rpb24gX2NvbXBpbGVDaGlsZHJlbihub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgX3RoaXMyLmNvbXBpbGUoY2hpbGQsIGZyYW1lKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVBZ2dyZWdhdGUgPSBmdW5jdGlvbiBfY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgc3RhcnRDaGFyLCBlbmRDaGFyKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAoc3RhcnRDaGFyKSB7XG4gICAgICB0aGlzLl9lbWl0KHN0YXJ0Q2hhcik7XG4gICAgfVxuXG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIF90aGlzMy5fZW1pdCgnLCcpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczMuY29tcGlsZShjaGlsZCwgZnJhbWUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGVuZENoYXIpIHtcbiAgICAgIHRoaXMuX2VtaXQoZW5kQ2hhcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZUV4cHJlc3Npb24gPSBmdW5jdGlvbiBfY29tcGlsZUV4cHJlc3Npb24obm9kZSwgZnJhbWUpIHtcbiAgICAvLyBUT0RPOiBJJ20gbm90IHJlYWxseSBzdXJlIGlmIHRoaXMgdHlwZSBjaGVjayBpcyB3b3J0aCBpdCBvclxuICAgIC8vIG5vdC5cbiAgICB0aGlzLmFzc2VydFR5cGUobm9kZSwgbm9kZXMuTGl0ZXJhbCwgbm9kZXMuU3ltYm9sLCBub2Rlcy5Hcm91cCwgbm9kZXMuQXJyYXksIG5vZGVzLkRpY3QsIG5vZGVzLkZ1bkNhbGwsIG5vZGVzLkNhbGxlciwgbm9kZXMuRmlsdGVyLCBub2Rlcy5Mb29rdXBWYWwsIG5vZGVzLkNvbXBhcmUsIG5vZGVzLklubGluZUlmLCBub2Rlcy5Jbiwgbm9kZXMuSXMsIG5vZGVzLkFuZCwgbm9kZXMuT3IsIG5vZGVzLk5vdCwgbm9kZXMuQWRkLCBub2Rlcy5Db25jYXQsIG5vZGVzLlN1Yiwgbm9kZXMuTXVsLCBub2Rlcy5EaXYsIG5vZGVzLkZsb29yRGl2LCBub2Rlcy5Nb2QsIG5vZGVzLlBvdywgbm9kZXMuTmVnLCBub2Rlcy5Qb3MsIG5vZGVzLkNvbXBhcmUsIG5vZGVzLk5vZGVMaXN0KTtcbiAgICB0aGlzLmNvbXBpbGUobm9kZSwgZnJhbWUpO1xuICB9O1xuXG4gIF9wcm90by5hc3NlcnRUeXBlID0gZnVuY3Rpb24gYXNzZXJ0VHlwZShub2RlKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0eXBlcyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICB0eXBlc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdDtcbiAgICB9KSkge1xuICAgICAgdGhpcy5mYWlsKFwiYXNzZXJ0VHlwZTogaW52YWxpZCB0eXBlOiBcIiArIG5vZGUudHlwZW5hbWUsIG5vZGUubGluZW5vLCBub2RlLmNvbG5vKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDYWxsRXh0ZW5zaW9uID0gZnVuY3Rpb24gY29tcGlsZUNhbGxFeHRlbnNpb24obm9kZSwgZnJhbWUsIGFzeW5jKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYXJncyA9IG5vZGUuYXJncztcbiAgICB2YXIgY29udGVudEFyZ3MgPSBub2RlLmNvbnRlbnRBcmdzO1xuICAgIHZhciBhdXRvZXNjYXBlID0gdHlwZW9mIG5vZGUuYXV0b2VzY2FwZSA9PT0gJ2Jvb2xlYW4nID8gbm9kZS5hdXRvZXNjYXBlIDogdHJ1ZTtcblxuICAgIGlmICghYXN5bmMpIHtcbiAgICAgIHRoaXMuX2VtaXQodGhpcy5idWZmZXIgKyBcIiArPSBydW50aW1lLnN1cHByZXNzVmFsdWUoXCIpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXQoXCJlbnYuZ2V0RXh0ZW5zaW9uKFxcXCJcIiArIG5vZGUuZXh0TmFtZSArIFwiXFxcIilbXFxcIlwiICsgbm9kZS5wcm9wICsgXCJcXFwiXShcIik7XG5cbiAgICB0aGlzLl9lbWl0KCdjb250ZXh0Jyk7XG5cbiAgICBpZiAoYXJncyB8fCBjb250ZW50QXJncykge1xuICAgICAgdGhpcy5fZW1pdCgnLCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBpZiAoIShhcmdzIGluc3RhbmNlb2Ygbm9kZXMuTm9kZUxpc3QpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnY29tcGlsZUNhbGxFeHRlbnNpb246IGFyZ3VtZW50cyBtdXN0IGJlIGEgTm9kZUxpc3QsICcgKyAndXNlIGBwYXJzZXIucGFyc2VTaWduYXR1cmVgJyk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3MuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICAgIC8vIFRhZyBhcmd1bWVudHMgYXJlIHBhc3NlZCBub3JtYWxseSB0byB0aGUgY2FsbC4gTm90ZVxuICAgICAgICAvLyB0aGF0IGtleXdvcmQgYXJndW1lbnRzIGFyZSB0dXJuZWQgaW50byBhIHNpbmdsZSBqc1xuICAgICAgICAvLyBvYmplY3QgYXMgdGhlIGxhc3QgYXJndW1lbnQsIGlmIHRoZXkgZXhpc3QuXG4gICAgICAgIF90aGlzNC5fY29tcGlsZUV4cHJlc3Npb24oYXJnLCBmcmFtZSk7XG5cbiAgICAgICAgaWYgKGkgIT09IGFyZ3MuY2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBjb250ZW50QXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBfdGhpczQuX2VtaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRBcmdzLmxlbmd0aCkge1xuICAgICAgY29udGVudEFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnLCBpKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIF90aGlzNC5fZW1pdCgnLCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIF90aGlzNC5fZW1pdExpbmUoJ2Z1bmN0aW9uKGNiKSB7Jyk7XG5cbiAgICAgICAgICBfdGhpczQuX2VtaXRMaW5lKCdpZighY2IpIHsgY2IgPSBmdW5jdGlvbihlcnIpIHsgaWYoZXJyKSB7IHRocm93IGVycjsgfX19Jyk7XG5cbiAgICAgICAgICB2YXIgaWQgPSBfdGhpczQuX3B1c2hCdWZmZXIoKTtcblxuICAgICAgICAgIF90aGlzNC5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQuY29tcGlsZShhcmcsIGZyYW1lKTtcblxuICAgICAgICAgICAgX3RoaXM0Ll9lbWl0TGluZShcImNiKG51bGwsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXM0Ll9wb3BCdWZmZXIoKTtcblxuICAgICAgICAgIF90aGlzNC5fZW1pdExpbmUoXCJyZXR1cm4gXCIgKyBpZCArIFwiO1wiKTtcblxuICAgICAgICAgIF90aGlzNC5fZW1pdExpbmUoJ30nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczQuX2VtaXQoJ251bGwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fdG1waWQoKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJywgJyArIHRoaXMuX21ha2VDYWxsYmFjayhyZXMpKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUodGhpcy5idWZmZXIgKyBcIiArPSBydW50aW1lLnN1cHByZXNzVmFsdWUoXCIgKyByZXMgKyBcIiwgXCIgKyBhdXRvZXNjYXBlICsgXCIgJiYgZW52Lm9wdHMuYXV0b2VzY2FwZSk7XCIpO1xuXG4gICAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoJyknKTtcblxuICAgICAgdGhpcy5fZW1pdChcIiwgXCIgKyBhdXRvZXNjYXBlICsgXCIgJiYgZW52Lm9wdHMuYXV0b2VzY2FwZSk7XFxuXCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNhbGxFeHRlbnNpb25Bc3luYyA9IGZ1bmN0aW9uIGNvbXBpbGVDYWxsRXh0ZW5zaW9uQXN5bmMobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLmNvbXBpbGVDYWxsRXh0ZW5zaW9uKG5vZGUsIGZyYW1lLCB0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU5vZGVMaXN0ID0gZnVuY3Rpb24gY29tcGlsZU5vZGVMaXN0KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUNoaWxkcmVuKG5vZGUsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUxpdGVyYWwgPSBmdW5jdGlvbiBjb21waWxlTGl0ZXJhbChub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHZhbCA9IG5vZGUudmFsdWUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxuL2csICdcXFxcbicpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKTtcblxuICAgICAgdGhpcy5fZW1pdChcIlxcXCJcIiArIHZhbCArIFwiXFxcIlwiKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ251bGwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdChub2RlLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVN5bWJvbCA9IGZ1bmN0aW9uIGNvbXBpbGVTeW1ib2wobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUudmFsdWU7XG4gICAgdmFyIHYgPSBmcmFtZS5sb29rdXAobmFtZSk7XG5cbiAgICBpZiAodikge1xuICAgICAgdGhpcy5fZW1pdCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdCgncnVudGltZS5jb250ZXh0T3JGcmFtZUxvb2t1cCgnICsgJ2NvbnRleHQsIGZyYW1lLCBcIicgKyBuYW1lICsgJ1wiKScpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUdyb3VwID0gZnVuY3Rpb24gY29tcGlsZUdyb3VwKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgJygnLCAnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlQXJyYXkgPSBmdW5jdGlvbiBjb21waWxlQXJyYXkobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCAnWycsICddJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVEaWN0ID0gZnVuY3Rpb24gY29tcGlsZURpY3Qobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCAneycsICd9Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVQYWlyID0gZnVuY3Rpb24gY29tcGlsZVBhaXIobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIga2V5ID0gbm9kZS5rZXk7XG4gICAgdmFyIHZhbCA9IG5vZGUudmFsdWU7XG5cbiAgICBpZiAoa2V5IGluc3RhbmNlb2Ygbm9kZXMuU3ltYm9sKSB7XG4gICAgICBrZXkgPSBuZXcgbm9kZXMuTGl0ZXJhbChrZXkubGluZW5vLCBrZXkuY29sbm8sIGtleS52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICghKGtleSBpbnN0YW5jZW9mIG5vZGVzLkxpdGVyYWwgJiYgdHlwZW9mIGtleS52YWx1ZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ2NvbXBpbGVQYWlyOiBEaWN0IGtleXMgbXVzdCBiZSBzdHJpbmdzIG9yIG5hbWVzJywga2V5LmxpbmVubywga2V5LmNvbG5vKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBpbGUoa2V5LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCc6ICcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24odmFsLCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJbmxpbmVJZiA9IGZ1bmN0aW9uIGNvbXBpbGVJbmxpbmVJZihub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJygnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmNvbmQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJz8nKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJzonKTtcblxuICAgIGlmIChub2RlLmVsc2VfICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5lbHNlXywgZnJhbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KCdcIlwiJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSW4gPSBmdW5jdGlvbiBjb21waWxlSW4obm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCdydW50aW1lLmluT3BlcmF0b3IoJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcsJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5yaWdodCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSXMgPSBmdW5jdGlvbiBjb21waWxlSXMobm9kZSwgZnJhbWUpIHtcbiAgICAvLyBmaXJzdCwgd2UgbmVlZCB0byB0cnkgdG8gZ2V0IHRoZSBuYW1lIG9mIHRoZSB0ZXN0IGZ1bmN0aW9uLCBpZiBpdCdzIGFcbiAgICAvLyBjYWxsYWJsZSAoaS5lLiwgaGFzIGFyZ3MpIGFuZCBub3QgYSBzeW1ib2wuXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodC5uYW1lID8gbm9kZS5yaWdodC5uYW1lLnZhbHVlIC8vIG90aGVyd2lzZSBnbyB3aXRoIHRoZSBzeW1ib2wgdmFsdWVcbiAgICA6IG5vZGUucmlnaHQudmFsdWU7XG5cbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0VGVzdChcIicgKyByaWdodCArICdcIikuY2FsbChjb250ZXh0LCAnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTsgLy8gY29tcGlsZSB0aGUgYXJndW1lbnRzIGZvciB0aGUgY2FsbGFibGUgaWYgdGhleSBleGlzdFxuXG4gICAgaWYgKG5vZGUucmlnaHQuYXJncykge1xuICAgICAgdGhpcy5fZW1pdCgnLCcpO1xuXG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5yaWdodC5hcmdzLCBmcmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdCgnKSA9PT0gdHJ1ZScpO1xuICB9O1xuXG4gIF9wcm90by5fYmluT3BFbWl0dGVyID0gZnVuY3Rpb24gX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgc3RyKSB7XG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdChzdHIpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQsIGZyYW1lKTtcbiAgfSAvLyBlbnN1cmUgY29uY2F0ZW5hdGlvbiBpbnN0ZWFkIG9mIGFkZGl0aW9uXG4gIC8vIGJ5IGFkZGluZyBlbXB0eSBzdHJpbmcgaW4gYmV0d2VlblxuICA7XG5cbiAgX3Byb3RvLmNvbXBpbGVPciA9IGZ1bmN0aW9uIGNvbXBpbGVPcihub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgfHwgJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVBbmQgPSBmdW5jdGlvbiBjb21waWxlQW5kKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAmJiAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUFkZCA9IGZ1bmN0aW9uIGNvbXBpbGVBZGQobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnICsgJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVDb25jYXQgPSBmdW5jdGlvbiBjb21waWxlQ29uY2F0KG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyArIFwiXCIgKyAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVN1YiA9IGZ1bmN0aW9uIGNvbXBpbGVTdWIobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnIC0gJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVNdWwgPSBmdW5jdGlvbiBjb21waWxlTXVsKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAqICcpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRGl2ID0gZnVuY3Rpb24gY29tcGlsZURpdihub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgLyAnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU1vZCA9IGZ1bmN0aW9uIGNvbXBpbGVNb2Qobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnICUgJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVOb3QgPSBmdW5jdGlvbiBjb21waWxlTm90KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnIScpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGbG9vckRpdiA9IGZ1bmN0aW9uIGNvbXBpbGVGbG9vckRpdihub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ01hdGguZmxvb3IoJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcgLyAnKTtcblxuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVQb3cgPSBmdW5jdGlvbiBjb21waWxlUG93KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgnTWF0aC5wb3coJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcsICcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU5lZyA9IGZ1bmN0aW9uIGNvbXBpbGVOZWcobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCctJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS50YXJnZXQsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVBvcyA9IGZ1bmN0aW9uIGNvbXBpbGVQb3Mobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCcrJyk7XG5cbiAgICB0aGlzLmNvbXBpbGUobm9kZS50YXJnZXQsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNvbXBhcmUgPSBmdW5jdGlvbiBjb21waWxlQ29tcGFyZShub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUuZXhwciwgZnJhbWUpO1xuICAgIG5vZGUub3BzLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7XG4gICAgICBfdGhpczUuX2VtaXQoXCIgXCIgKyBjb21wYXJlT3BzW29wLnR5cGVdICsgXCIgXCIpO1xuXG4gICAgICBfdGhpczUuY29tcGlsZShvcC5leHByLCBmcmFtZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVMb29rdXBWYWwgPSBmdW5jdGlvbiBjb21waWxlTG9va3VwVmFsKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5tZW1iZXJMb29rdXAoKCcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS50YXJnZXQsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXQoJyksJyk7XG5cbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnZhbCwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0Tm9kZU5hbWUgPSBmdW5jdGlvbiBfZ2V0Tm9kZU5hbWUobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlbmFtZSkge1xuICAgICAgY2FzZSAnU3ltYm9sJzpcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG5cbiAgICAgIGNhc2UgJ0Z1bkNhbGwnOlxuICAgICAgICByZXR1cm4gJ3RoZSByZXR1cm4gdmFsdWUgb2YgKCcgKyB0aGlzLl9nZXROb2RlTmFtZShub2RlLm5hbWUpICsgJyknO1xuXG4gICAgICBjYXNlICdMb29rdXBWYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Tm9kZU5hbWUobm9kZS50YXJnZXQpICsgJ1tcIicgKyB0aGlzLl9nZXROb2RlTmFtZShub2RlLnZhbCkgKyAnXCJdJztcblxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnLS1leHByZXNzaW9uLS0nO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZ1bkNhbGwgPSBmdW5jdGlvbiBjb21waWxlRnVuQ2FsbChub2RlLCBmcmFtZSkge1xuICAgIC8vIEtlZXAgdHJhY2sgb2YgbGluZS9jb2wgaW5mbyBhdCBydW50aW1lIGJ5IHNldHRpbmdzXG4gICAgLy8gdmFyaWFibGVzIHdpdGhpbiBhbiBleHByZXNzaW9uLiBBbiBleHByZXNzaW9uIGluIGphdmFzY3JpcHRcbiAgICAvLyBsaWtlICh4LCB5LCB6KSByZXR1cm5zIHRoZSBsYXN0IHZhbHVlLCBhbmQgeCBhbmQgeSBjYW4gYmVcbiAgICAvLyBhbnl0aGluZ1xuICAgIHRoaXMuX2VtaXQoJyhsaW5lbm8gPSAnICsgbm9kZS5saW5lbm8gKyAnLCBjb2xubyA9ICcgKyBub2RlLmNvbG5vICsgJywgJyk7XG5cbiAgICB0aGlzLl9lbWl0KCdydW50aW1lLmNhbGxXcmFwKCcpOyAvLyBDb21waWxlIGl0IGFzIG5vcm1hbC5cblxuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5uYW1lLCBmcmFtZSk7IC8vIE91dHB1dCB0aGUgbmFtZSBvZiB3aGF0IHdlJ3JlIGNhbGxpbmcgc28gd2UgY2FuIGdldCBmcmllbmRseSBlcnJvcnNcbiAgICAvLyBpZiB0aGUgbG9va3VwIGZhaWxzLlxuXG5cbiAgICB0aGlzLl9lbWl0KCcsIFwiJyArIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUubmFtZSkucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiLCBjb250ZXh0LCAnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZS5hcmdzLCBmcmFtZSwgJ1snLCAnXSknKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUZpbHRlciA9IGZ1bmN0aW9uIGNvbXBpbGVGaWx0ZXIobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICB0aGlzLmFzc2VydFR5cGUobmFtZSwgbm9kZXMuU3ltYm9sKTtcblxuICAgIHRoaXMuX2VtaXQoJ2Vudi5nZXRGaWx0ZXIoXCInICsgbmFtZS52YWx1ZSArICdcIikuY2FsbChjb250ZXh0LCAnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZS5hcmdzLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGaWx0ZXJBc3luYyA9IGZ1bmN0aW9uIGNvbXBpbGVGaWx0ZXJBc3luYyhub2RlLCBmcmFtZSkge1xuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgIHZhciBzeW1ib2wgPSBub2RlLnN5bWJvbC52YWx1ZTtcbiAgICB0aGlzLmFzc2VydFR5cGUobmFtZSwgbm9kZXMuU3ltYm9sKTtcbiAgICBmcmFtZS5zZXQoc3ltYm9sLCBzeW1ib2wpO1xuXG4gICAgdGhpcy5fZW1pdCgnZW52LmdldEZpbHRlcihcIicgKyBuYW1lLnZhbHVlICsgJ1wiKS5jYWxsKGNvbnRleHQsICcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLmFyZ3MsIGZyYW1lKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCcsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2soc3ltYm9sKSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVLZXl3b3JkQXJncyA9IGZ1bmN0aW9uIGNvbXBpbGVLZXl3b3JkQXJncyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUubWFrZUtleXdvcmRBcmdzKCcpO1xuXG4gICAgdGhpcy5jb21waWxlRGljdChub2RlLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVTZXQgPSBmdW5jdGlvbiBjb21waWxlU2V0KG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICB2YXIgaWRzID0gW107IC8vIExvb2t1cCB0aGUgdmFyaWFibGUgbmFtZXMgZm9yIGVhY2ggaWRlbnRpZmllciBhbmQgY3JlYXRlXG4gICAgLy8gbmV3IG9uZXMgaWYgbmVjZXNzYXJ5XG5cbiAgICBub2RlLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB2YXIgbmFtZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgIHZhciBpZCA9IGZyYW1lLmxvb2t1cChuYW1lKTtcblxuICAgICAgaWYgKGlkID09PSBudWxsIHx8IGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWQgPSBfdGhpczYuX3RtcGlkKCk7IC8vIE5vdGU6IFRoaXMgcmVsaWVzIG9uIGpzIGFsbG93aW5nIHNjb3BlIGFjcm9zc1xuICAgICAgICAvLyBibG9ja3MsIGluIGNhc2UgdGhpcyBpcyBjcmVhdGVkIGluc2lkZSBhbiBgaWZgXG5cbiAgICAgICAgX3RoaXM2Ll9lbWl0TGluZSgndmFyICcgKyBpZCArICc7Jyk7XG4gICAgICB9XG5cbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9KTtcblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICB0aGlzLl9lbWl0KGlkcy5qb2luKCcgPSAnKSArICcgPSAnKTtcblxuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS52YWx1ZSwgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnOycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KGlkcy5qb2luKCcgPSAnKSArICcgPSAnKTtcblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnOycpO1xuICAgIH1cblxuICAgIG5vZGUudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQsIGkpIHtcbiAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgIHZhciBuYW1lID0gdGFyZ2V0LnZhbHVlOyAvLyBXZSBhcmUgcnVubmluZyB0aGlzIGZvciBldmVyeSB2YXIsIGJ1dCBpdCdzIHZlcnlcbiAgICAgIC8vIHVuY29tbW9uIHRvIGFzc2lnbiB0byBtdWx0aXBsZSB2YXJzIGFueXdheVxuXG4gICAgICBfdGhpczYuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgaWQgKyBcIiwgdHJ1ZSk7XCIpO1xuXG4gICAgICBfdGhpczYuX2VtaXRMaW5lKCdpZihmcmFtZS50b3BMZXZlbCkgeycpO1xuXG4gICAgICBfdGhpczYuX2VtaXRMaW5lKFwiY29udGV4dC5zZXRWYXJpYWJsZShcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcblxuICAgICAgX3RoaXM2Ll9lbWl0TGluZSgnfScpO1xuXG4gICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgICBfdGhpczYuX2VtaXRMaW5lKCdpZihmcmFtZS50b3BMZXZlbCkgeycpO1xuXG4gICAgICAgIF90aGlzNi5fZW1pdExpbmUoXCJjb250ZXh0LmFkZEV4cG9ydChcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcblxuICAgICAgICBfdGhpczYuX2VtaXRMaW5lKCd9Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVTd2l0Y2ggPSBmdW5jdGlvbiBjb21waWxlU3dpdGNoKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICB0aGlzLl9lbWl0KCdzd2l0Y2ggKCcpO1xuXG4gICAgdGhpcy5jb21waWxlKG5vZGUuZXhwciwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdCgnKSB7Jyk7XG5cbiAgICBub2RlLmNhc2VzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICAgIF90aGlzNy5fZW1pdCgnY2FzZSAnKTtcblxuICAgICAgX3RoaXM3LmNvbXBpbGUoYy5jb25kLCBmcmFtZSk7XG5cbiAgICAgIF90aGlzNy5fZW1pdCgnOiAnKTtcblxuICAgICAgX3RoaXM3LmNvbXBpbGUoYy5ib2R5LCBmcmFtZSk7IC8vIHByZXNlcnZlIGZhbGwtdGhyb3VnaHNcblxuXG4gICAgICBpZiAoYy5ib2R5LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBfdGhpczcuX2VtaXRMaW5lKCdicmVhazsnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub2RlLmRlZmF1bHQpIHtcbiAgICAgIHRoaXMuX2VtaXQoJ2RlZmF1bHQ6Jyk7XG5cbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmRlZmF1bHQsIGZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0KCd9Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJZiA9IGZ1bmN0aW9uIGNvbXBpbGVJZihub2RlLCBmcmFtZSwgYXN5bmMpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIHRoaXMuX2VtaXQoJ2lmKCcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5jb25kLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnKSB7Jyk7XG5cbiAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzOC5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgX3RoaXM4Ll9lbWl0KCdjYigpJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobm9kZS5lbHNlXykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ31cXG5lbHNlIHsnKTtcblxuICAgICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzOC5jb21waWxlKG5vZGUuZWxzZV8sIGZyYW1lKTtcblxuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICBfdGhpczguX2VtaXQoJ2NiKCknKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhc3luYykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ31cXG5lbHNlIHsnKTtcblxuICAgICAgdGhpcy5fZW1pdCgnY2IoKScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVJZkFzeW5jID0gZnVuY3Rpb24gY29tcGlsZUlmQXN5bmMobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCcoZnVuY3Rpb24oY2IpIHsnKTtcblxuICAgIHRoaXMuY29tcGlsZUlmKG5vZGUsIGZyYW1lLCB0cnVlKTtcblxuICAgIHRoaXMuX2VtaXQoJ30pKCcgKyB0aGlzLl9tYWtlQ2FsbGJhY2soKSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9lbWl0TG9vcEJpbmRpbmdzID0gZnVuY3Rpb24gX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pIHtcbiAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgIHZhciBiaW5kaW5ncyA9IFt7XG4gICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgdmFsOiBpICsgXCIgKyAxXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnaW5kZXgwJyxcbiAgICAgIHZhbDogaVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdyZXZpbmRleCcsXG4gICAgICB2YWw6IGxlbiArIFwiIC0gXCIgKyBpXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3JldmluZGV4MCcsXG4gICAgICB2YWw6IGxlbiArIFwiIC0gXCIgKyBpICsgXCIgLSAxXCJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZmlyc3QnLFxuICAgICAgdmFsOiBpICsgXCIgPT09IDBcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsYXN0JyxcbiAgICAgIHZhbDogaSArIFwiID09PSBcIiArIGxlbiArIFwiIC0gMVwiXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xlbmd0aCcsXG4gICAgICB2YWw6IGxlblxuICAgIH1dO1xuICAgIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgIF90aGlzOS5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcImxvb3AuXCIgKyBiLm5hbWUgKyBcIlxcXCIsIFwiICsgYi52YWwgKyBcIik7XCIpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRm9yID0gZnVuY3Rpb24gY29tcGlsZUZvcihub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgIC8vIFNvbWUgb2YgdGhpcyBjb2RlIGlzIHVnbHksIGJ1dCBpdCBrZWVwcyB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhcyBmYXN0IGFzIHBvc3NpYmxlLiBGb3JBc3luYyBhbHNvIHNoYXJlcyBzb21lIG9mIHRoaXMsIGJ1dFxuICAgIC8vIG5vdCBtdWNoLlxuICAgIHZhciBpID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBsZW4gPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGFyciA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICBmcmFtZSA9IGZyYW1lLnB1c2goKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9IGZyYW1lLnB1c2goKTsnKTtcblxuICAgIHRoaXMuX2VtaXQoXCJ2YXIgXCIgKyBhcnIgKyBcIiA9IFwiKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuYXJyLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnOycpO1xuXG4gICAgdGhpcy5fZW1pdChcImlmKFwiICsgYXJyICsgXCIpIHtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShhcnIgKyAnID0gcnVudGltZS5mcm9tSXRlcmF0b3IoJyArIGFyciArICcpOycpOyAvLyBJZiBtdWx0aXBsZSBuYW1lcyBhcmUgcGFzc2VkLCB3ZSBuZWVkIHRvIGJpbmQgdGhlbVxuICAgIC8vIGFwcHJvcHJpYXRlbHlcblxuXG4gICAgaWYgKG5vZGUubmFtZSBpbnN0YW5jZW9mIG5vZGVzLkFycmF5KSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIGkgKyBcIjtcIik7IC8vIFRoZSBvYmplY3QgY291bGQgYmUgYW4gYXJyb3kgb3Igb2JqZWN0LiBOb3RlIHRoYXQgdGhlXG4gICAgICAvLyBib2R5IG9mIHRoZSBsb29wIGlzIGR1cGxpY2F0ZWQgZm9yIGVhY2ggY29uZGl0aW9uLCBidXRcbiAgICAgIC8vIHdlIGFyZSBvcHRpbWl6aW5nIGZvciBzcGVlZCBvdmVyIHNpemUuXG5cblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJpZihydW50aW1lLmlzQXJyYXkoXCIgKyBhcnIgKyBcIikpIHtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgbGVuICsgXCIgPSBcIiArIGFyciArIFwiLmxlbmd0aDtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZm9yKFwiICsgaSArIFwiPTA7IFwiICsgaSArIFwiIDwgXCIgKyBhcnIgKyBcIi5sZW5ndGg7IFwiICsgaSArIFwiKyspIHtcIik7IC8vIEJpbmQgZWFjaCBkZWNsYXJlZCB2YXJcblxuXG4gICAgICBub2RlLm5hbWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIHUpIHtcbiAgICAgICAgdmFyIHRpZCA9IF90aGlzMTAuX3RtcGlkKCk7XG5cbiAgICAgICAgX3RoaXMxMC5fZW1pdExpbmUoXCJ2YXIgXCIgKyB0aWQgKyBcIiA9IFwiICsgYXJyICsgXCJbXCIgKyBpICsgXCJdW1wiICsgdSArIFwiXTtcIik7XG5cbiAgICAgICAgX3RoaXMxMC5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgY2hpbGQgKyBcIlxcXCIsIFwiICsgYXJyICsgXCJbXCIgKyBpICsgXCJdW1wiICsgdSArIFwiXSk7XCIpO1xuXG4gICAgICAgIGZyYW1lLnNldChub2RlLm5hbWUuY2hpbGRyZW5bdV0udmFsdWUsIHRpZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG5cbiAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEwLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ30gZWxzZSB7Jyk7IC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5L3ZhbHVlcyBvZiBhbiBvYmplY3RcblxuXG4gICAgICB2YXIgX25vZGUkbmFtZSRjaGlsZHJlbiA9IG5vZGUubmFtZS5jaGlsZHJlbixcbiAgICAgICAgICBrZXkgPSBfbm9kZSRuYW1lJGNoaWxkcmVuWzBdLFxuICAgICAgICAgIHZhbCA9IF9ub2RlJG5hbWUkY2hpbGRyZW5bMV07XG5cbiAgICAgIHZhciBrID0gdGhpcy5fdG1waWQoKTtcblxuICAgICAgdmFyIHYgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgICBmcmFtZS5zZXQoa2V5LnZhbHVlLCBrKTtcbiAgICAgIGZyYW1lLnNldCh2YWwudmFsdWUsIHYpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShpICsgXCIgPSAtMTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgbGVuICsgXCIgPSBydW50aW1lLmtleXMoXCIgKyBhcnIgKyBcIikubGVuZ3RoO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmb3IodmFyIFwiICsgayArIFwiIGluIFwiICsgYXJyICsgXCIpIHtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKGkgKyBcIisrO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJ2YXIgXCIgKyB2ICsgXCIgPSBcIiArIGFyciArIFwiW1wiICsgayArIFwiXTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIGtleS52YWx1ZSArIFwiXFxcIiwgXCIgKyBrICsgXCIpO1wiKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgdmFsLnZhbHVlICsgXCJcXFwiLCBcIiArIHYgKyBcIik7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TG9vcEJpbmRpbmdzKG5vZGUsIGFyciwgaSwgbGVuKTtcblxuICAgICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMTAuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHR5cGljYWwgYXJyYXkgaXRlcmF0aW9uXG4gICAgICB2YXIgX3YgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgICBmcmFtZS5zZXQobm9kZS5uYW1lLnZhbHVlLCBfdik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwidmFyIFwiICsgbGVuICsgXCIgPSBcIiArIGFyciArIFwiLmxlbmd0aDtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZm9yKHZhciBcIiArIGkgKyBcIj0wOyBcIiArIGkgKyBcIiA8IFwiICsgYXJyICsgXCIubGVuZ3RoOyBcIiArIGkgKyBcIisrKSB7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShcInZhciBcIiArIF92ICsgXCIgPSBcIiArIGFyciArIFwiW1wiICsgaSArIFwiXTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIG5vZGUubmFtZS52YWx1ZSArIFwiXFxcIiwgXCIgKyBfdiArIFwiKTtcIik7XG5cbiAgICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMC5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIGlmIChub2RlLmVsc2VfKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnaWYgKCEnICsgbGVuICsgJykgeycpO1xuXG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5lbHNlXywgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9IGZyYW1lLnBvcCgpOycpO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZUFzeW5jTG9vcCA9IGZ1bmN0aW9uIF9jb21waWxlQXN5bmNMb29wKG5vZGUsIGZyYW1lLCBwYXJhbGxlbCkge1xuICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgIC8vIFRoaXMgc2hhcmVzIHNvbWUgY29kZSB3aXRoIHRoZSBGb3IgdGFnLCBidXQgbm90IGVub3VnaCB0b1xuICAgIC8vIHdvcnJ5IGFib3V0LiBUaGlzIGl0ZXJhdGVzIGFjcm9zcyBhbiBvYmplY3QgYXN5bmNocm9ub3VzbHksXG4gICAgLy8gYnV0IG5vdCBpbiBwYXJhbGxlbC5cbiAgICB2YXIgaSA9IHRoaXMuX3RtcGlkKCk7XG5cbiAgICB2YXIgbGVuID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBhcnIgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGFzeW5jTWV0aG9kID0gcGFyYWxsZWwgPyAnYXN5bmNBbGwnIDogJ2FzeW5jRWFjaCc7XG4gICAgZnJhbWUgPSBmcmFtZS5wdXNoKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUgPSBmcmFtZS5wdXNoKCk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0KCd2YXIgJyArIGFyciArICcgPSBydW50aW1lLmZyb21JdGVyYXRvcignKTtcblxuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuYXJyLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnKTsnKTtcblxuICAgIGlmIChub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5BcnJheSkge1xuICAgICAgdmFyIGFycmF5TGVuID0gbm9kZS5uYW1lLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgdGhpcy5fZW1pdChcInJ1bnRpbWUuXCIgKyBhc3luY01ldGhvZCArIFwiKFwiICsgYXJyICsgXCIsIFwiICsgYXJyYXlMZW4gKyBcIiwgZnVuY3Rpb24oXCIpO1xuXG4gICAgICBub2RlLm5hbWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBfdGhpczExLl9lbWl0KG5hbWUudmFsdWUgKyBcIixcIik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdChpICsgJywnICsgbGVuICsgJyxuZXh0KSB7Jyk7XG5cbiAgICAgIG5vZGUubmFtZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBpZCA9IG5hbWUudmFsdWU7XG4gICAgICAgIGZyYW1lLnNldChpZCwgaWQpO1xuXG4gICAgICAgIF90aGlzMTEuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIGlkICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWQgPSBub2RlLm5hbWUudmFsdWU7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKFwicnVudGltZS5cIiArIGFzeW5jTWV0aG9kICsgXCIoXCIgKyBhcnIgKyBcIiwgMSwgZnVuY3Rpb24oXCIgKyBpZCArIFwiLCBcIiArIGkgKyBcIiwgXCIgKyBsZW4gKyBcIixuZXh0KSB7XCIpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUuc2V0KFwiJyArIGlkICsgJ1wiLCAnICsgaWQgKyAnKTsnKTtcblxuICAgICAgZnJhbWUuc2V0KGlkLCBpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG5cbiAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBidWY7XG5cbiAgICAgIGlmIChwYXJhbGxlbCkge1xuICAgICAgICBidWYgPSBfdGhpczExLl9wdXNoQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMTEuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcblxuICAgICAgX3RoaXMxMS5fZW1pdExpbmUoJ25leHQoJyArIGkgKyAoYnVmID8gJywnICsgYnVmIDogJycpICsgJyk7Jyk7XG5cbiAgICAgIGlmIChwYXJhbGxlbCkge1xuICAgICAgICBfdGhpczExLl9wb3BCdWZmZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30sICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2sob3V0cHV0KSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKHRoaXMuYnVmZmVyICsgJyArPSAnICsgb3V0cHV0ICsgJzsnKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5lbHNlXykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmICghJyArIGFyciArICcubGVuZ3RoKSB7Jyk7XG5cbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucG9wKCk7Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVBc3luY0VhY2ggPSBmdW5jdGlvbiBjb21waWxlQXN5bmNFYWNoKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFzeW5jTG9vcChub2RlLCBmcmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVBc3luY0FsbCA9IGZ1bmN0aW9uIGNvbXBpbGVBc3luY0FsbChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2NvbXBpbGVBc3luY0xvb3Aobm9kZSwgZnJhbWUsIHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5fY29tcGlsZU1hY3JvID0gZnVuY3Rpb24gX2NvbXBpbGVNYWNybyhub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGt3YXJncyA9IG51bGw7XG5cbiAgICB2YXIgZnVuY0lkID0gJ21hY3JvXycgKyB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIGtlZXBGcmFtZSA9IGZyYW1lICE9PSB1bmRlZmluZWQ7IC8vIFR5cGUgY2hlY2sgdGhlIGRlZmluaXRpb24gb2YgdGhlIGFyZ3NcblxuICAgIG5vZGUuYXJncy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGkpIHtcbiAgICAgIGlmIChpID09PSBub2RlLmFyZ3MuY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiBhcmcgaW5zdGFuY2VvZiBub2Rlcy5EaWN0KSB7XG4gICAgICAgIGt3YXJncyA9IGFyZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzMTIuYXNzZXJ0VHlwZShhcmcsIG5vZGVzLlN5bWJvbCk7XG5cbiAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHJlYWxOYW1lcyA9IFtdLmNvbmNhdChhcmdzLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIFwibF9cIiArIG4udmFsdWU7XG4gICAgfSksIFsna3dhcmdzJ10pOyAvLyBRdW90ZWQgYXJndW1lbnQgbmFtZXNcblxuICAgIHZhciBhcmdOYW1lcyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBuLnZhbHVlICsgXCJcXFwiXCI7XG4gICAgfSk7XG4gICAgdmFyIGt3YXJnTmFtZXMgPSAoa3dhcmdzICYmIGt3YXJncy5jaGlsZHJlbiB8fCBbXSkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBuLmtleS52YWx1ZSArIFwiXFxcIlwiO1xuICAgIH0pOyAvLyBXZSBwYXNzIGEgZnVuY3Rpb24gdG8gbWFrZU1hY3JvIHdoaWNoIGRlc3RydWN0dXJlcyB0aGVcbiAgICAvLyBhcmd1bWVudHMgc28gc3VwcG9ydCBzZXR0aW5nIHBvc2l0aW9uYWwgYXJncyB3aXRoIGtleXdvcmRzXG4gICAgLy8gYXJncyBhbmQgcGFzc2luZyBrZXl3b3JkIGFyZ3MgYXMgcG9zaXRpb25hbCBhcmdzXG4gICAgLy8gKGVzc2VudGlhbGx5IGRlZmF1bHQgdmFsdWVzKS4gU2VlIHJ1bnRpbWUuanMuXG5cbiAgICB2YXIgY3VyckZyYW1lO1xuXG4gICAgaWYgKGtlZXBGcmFtZSkge1xuICAgICAgY3VyckZyYW1lID0gZnJhbWUucHVzaCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyckZyYW1lID0gbmV3IEZyYW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmVzKFwidmFyIFwiICsgZnVuY0lkICsgXCIgPSBydW50aW1lLm1ha2VNYWNybyhcIiwgXCJbXCIgKyBhcmdOYW1lcy5qb2luKCcsICcpICsgXCJdLCBcIiwgXCJbXCIgKyBrd2FyZ05hbWVzLmpvaW4oJywgJykgKyBcIl0sIFwiLCBcImZ1bmN0aW9uIChcIiArIHJlYWxOYW1lcy5qb2luKCcsICcpICsgXCIpIHtcIiwgJ3ZhciBjYWxsZXJGcmFtZSA9IGZyYW1lOycsICdmcmFtZSA9ICcgKyAoa2VlcEZyYW1lID8gJ2ZyYW1lLnB1c2godHJ1ZSk7JyA6ICduZXcgcnVudGltZS5GcmFtZSgpOycpLCAna3dhcmdzID0ga3dhcmdzIHx8IHt9OycsICdpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGt3YXJncywgXCJjYWxsZXJcIikpIHsnLCAnZnJhbWUuc2V0KFwiY2FsbGVyXCIsIGt3YXJncy5jYWxsZXIpOyB9Jyk7IC8vIEV4cG9zZSB0aGUgYXJndW1lbnRzIHRvIHRoZSB0ZW1wbGF0ZS4gRG9uJ3QgbmVlZCB0byB1c2VcbiAgICAvLyByYW5kb20gbmFtZXMgYmVjYXVzZSB0aGUgZnVuY3Rpb25cbiAgICAvLyB3aWxsIGNyZWF0ZSBhIG5ldyBydW4tdGltZSBzY29wZSBmb3IgdXNcblxuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIF90aGlzMTIuX2VtaXRMaW5lKFwiZnJhbWUuc2V0KFxcXCJcIiArIGFyZy52YWx1ZSArIFwiXFxcIiwgbF9cIiArIGFyZy52YWx1ZSArIFwiKTtcIik7XG5cbiAgICAgIGN1cnJGcmFtZS5zZXQoYXJnLnZhbHVlLCBcImxfXCIgKyBhcmcudmFsdWUpO1xuICAgIH0pOyAvLyBFeHBvc2UgdGhlIGtleXdvcmQgYXJndW1lbnRzXG5cbiAgICBpZiAoa3dhcmdzKSB7XG4gICAgICBrd2FyZ3MuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICB2YXIgbmFtZSA9IHBhaXIua2V5LnZhbHVlO1xuXG4gICAgICAgIF90aGlzMTIuX2VtaXQoXCJmcmFtZS5zZXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIpO1xuXG4gICAgICAgIF90aGlzMTIuX2VtaXQoXCJPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa3dhcmdzLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiKVwiKTtcblxuICAgICAgICBfdGhpczEyLl9lbWl0KFwiID8ga3dhcmdzW1xcXCJcIiArIG5hbWUgKyBcIlxcXCJdIDogXCIpO1xuXG4gICAgICAgIF90aGlzMTIuX2NvbXBpbGVFeHByZXNzaW9uKHBhaXIudmFsdWUsIGN1cnJGcmFtZSk7XG5cbiAgICAgICAgX3RoaXMxMi5fZW1pdCgnKTsnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBidWZmZXJJZCA9IHRoaXMuX3B1c2hCdWZmZXIoKTtcblxuICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMxMi5jb21waWxlKG5vZGUuYm9keSwgY3VyckZyYW1lKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9ICcgKyAoa2VlcEZyYW1lID8gJ2ZyYW1lLnBvcCgpOycgOiAnY2FsbGVyRnJhbWU7JykpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJyZXR1cm4gbmV3IHJ1bnRpbWUuU2FmZVN0cmluZyhcIiArIGJ1ZmZlcklkICsgXCIpO1wiKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd9KTsnKTtcblxuICAgIHRoaXMuX3BvcEJ1ZmZlcigpO1xuXG4gICAgcmV0dXJuIGZ1bmNJZDtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU1hY3JvID0gZnVuY3Rpb24gY29tcGlsZU1hY3JvKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIGZ1bmNJZCA9IHRoaXMuX2NvbXBpbGVNYWNybyhub2RlKTsgLy8gRXhwb3NlIHRoZSBtYWNybyB0byB0aGUgdGVtcGxhdGVzXG5cblxuICAgIHZhciBuYW1lID0gbm9kZS5uYW1lLnZhbHVlO1xuICAgIGZyYW1lLnNldChuYW1lLCBmdW5jSWQpO1xuXG4gICAgaWYgKGZyYW1lLnBhcmVudCkge1xuICAgICAgdGhpcy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyBmdW5jSWQgKyBcIik7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5uYW1lLnZhbHVlLmNoYXJBdCgwKSAhPT0gJ18nKSB7XG4gICAgICAgIHRoaXMuX2VtaXRMaW5lKFwiY29udGV4dC5hZGRFeHBvcnQoXFxcIlwiICsgbmFtZSArIFwiXFxcIik7XCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0TGluZShcImNvbnRleHQuc2V0VmFyaWFibGUoXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyBmdW5jSWQgKyBcIik7XCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNhbGxlciA9IGZ1bmN0aW9uIGNvbXBpbGVDYWxsZXIobm9kZSwgZnJhbWUpIHtcbiAgICAvLyBiYXNpY2FsbHkgYW4gYW5vbnltb3VzIFwibWFjcm8gZXhwcmVzc2lvblwiXG4gICAgdGhpcy5fZW1pdCgnKGZ1bmN0aW9uICgpeycpO1xuXG4gICAgdmFyIGZ1bmNJZCA9IHRoaXMuX2NvbXBpbGVNYWNybyhub2RlLCBmcmFtZSk7XG5cbiAgICB0aGlzLl9lbWl0KFwicmV0dXJuIFwiICsgZnVuY0lkICsgXCI7fSkoKVwiKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBpbGVHZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uIF9jb21waWxlR2V0VGVtcGxhdGUobm9kZSwgZnJhbWUsIGVhZ2VyQ29tcGlsZSwgaWdub3JlTWlzc2luZykge1xuICAgIHZhciBwYXJlbnRUZW1wbGF0ZUlkID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHZhciBwYXJlbnROYW1lID0gdGhpcy5fdGVtcGxhdGVOYW1lKCk7XG5cbiAgICB2YXIgY2IgPSB0aGlzLl9tYWtlQ2FsbGJhY2socGFyZW50VGVtcGxhdGVJZCk7XG5cbiAgICB2YXIgZWFnZXJDb21waWxlQXJnID0gZWFnZXJDb21waWxlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB2YXIgaWdub3JlTWlzc2luZ0FyZyA9IGlnbm9yZU1pc3NpbmcgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgdGhpcy5fZW1pdCgnZW52LmdldFRlbXBsYXRlKCcpO1xuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS50ZW1wbGF0ZSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCIsIFwiICsgZWFnZXJDb21waWxlQXJnICsgXCIsIFwiICsgcGFyZW50TmFtZSArIFwiLCBcIiArIGlnbm9yZU1pc3NpbmdBcmcgKyBcIiwgXCIgKyBjYik7XG5cbiAgICByZXR1cm4gcGFyZW50VGVtcGxhdGVJZDtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUltcG9ydCA9IGZ1bmN0aW9uIGNvbXBpbGVJbXBvcnQobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gbm9kZS50YXJnZXQudmFsdWU7XG5cbiAgICB2YXIgaWQgPSB0aGlzLl9jb21waWxlR2V0VGVtcGxhdGUobm9kZSwgZnJhbWUsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShpZCArICcuZ2V0RXhwb3J0ZWQoJyArIChub2RlLndpdGhDb250ZXh0ID8gJ2NvbnRleHQuZ2V0VmFyaWFibGVzKCksIGZyYW1lLCAnIDogJycpICsgdGhpcy5fbWFrZUNhbGxiYWNrKGlkKSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICBmcmFtZS5zZXQodGFyZ2V0LCBpZCk7XG5cbiAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShcImZyYW1lLnNldChcXFwiXCIgKyB0YXJnZXQgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShcImNvbnRleHQuc2V0VmFyaWFibGUoXFxcIlwiICsgdGFyZ2V0ICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVGcm9tSW1wb3J0ID0gZnVuY3Rpb24gY29tcGlsZUZyb21JbXBvcnQobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG5cbiAgICB2YXIgaW1wb3J0ZWRJZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKGltcG9ydGVkSWQgKyAnLmdldEV4cG9ydGVkKCcgKyAobm9kZS53aXRoQ29udGV4dCA/ICdjb250ZXh0LmdldFZhcmlhYmxlcygpLCBmcmFtZSwgJyA6ICcnKSArIHRoaXMuX21ha2VDYWxsYmFjayhpbXBvcnRlZElkKSk7XG5cbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICBub2RlLm5hbWVzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5hbWVOb2RlKSB7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIHZhciBhbGlhcztcblxuICAgICAgdmFyIGlkID0gX3RoaXMxMy5fdG1waWQoKTtcblxuICAgICAgaWYgKG5hbWVOb2RlIGluc3RhbmNlb2Ygbm9kZXMuUGFpcikge1xuICAgICAgICBuYW1lID0gbmFtZU5vZGUua2V5LnZhbHVlO1xuICAgICAgICBhbGlhcyA9IG5hbWVOb2RlLnZhbHVlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IG5hbWVOb2RlLnZhbHVlO1xuICAgICAgICBhbGlhcyA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMTMuX2VtaXRMaW5lKFwiaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFwiICsgaW1wb3J0ZWRJZCArIFwiLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiKSkge1wiKTtcblxuICAgICAgX3RoaXMxMy5fZW1pdExpbmUoXCJ2YXIgXCIgKyBpZCArIFwiID0gXCIgKyBpbXBvcnRlZElkICsgXCIuXCIgKyBuYW1lICsgXCI7XCIpO1xuXG4gICAgICBfdGhpczEzLl9lbWl0TGluZSgnfSBlbHNlIHsnKTtcblxuICAgICAgX3RoaXMxMy5fZW1pdExpbmUoXCJjYihuZXcgRXJyb3IoXFxcImNhbm5vdCBpbXBvcnQgJ1wiICsgbmFtZSArIFwiJ1xcXCIpKTsgcmV0dXJuO1wiKTtcblxuICAgICAgX3RoaXMxMy5fZW1pdExpbmUoJ30nKTtcblxuICAgICAgZnJhbWUuc2V0KGFsaWFzLCBpZCk7XG5cbiAgICAgIGlmIChmcmFtZS5wYXJlbnQpIHtcbiAgICAgICAgX3RoaXMxMy5fZW1pdExpbmUoXCJmcmFtZS5zZXQoXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIsIFwiICsgaWQgKyBcIik7XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMxMy5fZW1pdExpbmUoXCJjb250ZXh0LnNldFZhcmlhYmxlKFxcXCJcIiArIGFsaWFzICsgXCJcXFwiLCBcIiArIGlkICsgXCIpO1wiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUJsb2NrID0gZnVuY3Rpb24gY29tcGlsZUJsb2NrKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl90bXBpZCgpOyAvLyBJZiB3ZSBhcmUgZXhlY3V0aW5nIG91dHNpZGUgYSBibG9jayAoY3JlYXRpbmcgYSB0b3AtbGV2ZWxcbiAgICAvLyBibG9jayksIHdlIHJlYWxseSBkb24ndCB3YW50IHRvIGV4ZWN1dGUgaXRzIGNvZGUgYmVjYXVzZSBpdFxuICAgIC8vIHdpbGwgZXhlY3V0ZSB0d2ljZTogb25jZSB3aGVuIHRoZSBjaGlsZCB0ZW1wbGF0ZSBydW5zIGFuZFxuICAgIC8vIGFnYWluIHdoZW4gdGhlIHBhcmVudCB0ZW1wbGF0ZSBydW5zLiBOb3RlIHRoYXQgYmxvY2tzXG4gICAgLy8gd2l0aGluIGJsb2NrcyB3aWxsICphbHdheXMqIGV4ZWN1dGUgaW1tZWRpYXRlbHkgKmFuZCpcbiAgICAvLyB3aGVyZXZlciBlbHNlIHRoZXkgYXJlIGludm9rZWQgKGxpa2UgdXNlZCBpbiBhIHBhcmVudFxuICAgIC8vIHRlbXBsYXRlKS4gVGhpcyBtYXkgaGF2ZSBiZWhhdmlvcmFsIGRpZmZlcmVuY2VzIGZyb20gamluamFcbiAgICAvLyBiZWNhdXNlIGJsb2NrcyBjYW4gaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBpdCBzZWVtcyBsaWtlIGFcbiAgICAvLyB3YXN0ZSBvZiBwZXJmb3JtYW5jZSB0byBhbHdheXMgZXhlY3V0ZSBodWdlIHRvcC1sZXZlbFxuICAgIC8vIGJsb2NrcyB0d2ljZVxuXG5cbiAgICBpZiAoIXRoaXMuaW5CbG9jaykge1xuICAgICAgdGhpcy5fZW1pdCgnKHBhcmVudFRlbXBsYXRlID8gZnVuY3Rpb24oZSwgYywgZiwgciwgY2IpIHsgY2IoXCJcIik7IH0gOiAnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0KFwiY29udGV4dC5nZXRCbG9jayhcXFwiXCIgKyBub2RlLm5hbWUudmFsdWUgKyBcIlxcXCIpXCIpO1xuXG4gICAgaWYgKCF0aGlzLmluQmxvY2spIHtcbiAgICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnKGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2soaWQpKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKHRoaXMuYnVmZmVyICsgXCIgKz0gXCIgKyBpZCArIFwiO1wiKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVN1cGVyID0gZnVuY3Rpb24gY29tcGlsZVN1cGVyKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBub2RlLmJsb2NrTmFtZS52YWx1ZTtcbiAgICB2YXIgaWQgPSBub2RlLnN5bWJvbC52YWx1ZTtcblxuICAgIHZhciBjYiA9IHRoaXMuX21ha2VDYWxsYmFjayhpZCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImNvbnRleHQuZ2V0U3VwZXIoZW52LCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBiX1wiICsgbmFtZSArIFwiLCBmcmFtZSwgcnVudGltZSwgXCIgKyBjYik7XG5cbiAgICB0aGlzLl9lbWl0TGluZShpZCArIFwiID0gcnVudGltZS5tYXJrU2FmZShcIiArIGlkICsgXCIpO1wiKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcblxuICAgIGZyYW1lLnNldChpZCwgaWQpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlRXh0ZW5kcyA9IGZ1bmN0aW9uIGNvbXBpbGVFeHRlbmRzKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIGsgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgdmFyIHBhcmVudFRlbXBsYXRlSWQgPSB0aGlzLl9jb21waWxlR2V0VGVtcGxhdGUobm9kZSwgZnJhbWUsIHRydWUsIGZhbHNlKTsgLy8gZXh0ZW5kcyBpcyBhIGR5bmFtaWMgdGFnIGFuZCBjYW4gb2NjdXIgd2l0aGluIGEgYmxvY2sgbGlrZVxuICAgIC8vIGBpZmAsIHNvIGlmIHRoaXMgaGFwcGVucyB3ZSBuZWVkIHRvIGNhcHR1cmUgdGhlIHBhcmVudFxuICAgIC8vIHRlbXBsYXRlIGluIHRoZSB0b3AtbGV2ZWwgc2NvcGVcblxuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJwYXJlbnRUZW1wbGF0ZSA9IFwiICsgcGFyZW50VGVtcGxhdGVJZCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImZvcih2YXIgXCIgKyBrICsgXCIgaW4gcGFyZW50VGVtcGxhdGUuYmxvY2tzKSB7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoXCJjb250ZXh0LmFkZEJsb2NrKFwiICsgayArIFwiLCBwYXJlbnRUZW1wbGF0ZS5ibG9ja3NbXCIgKyBrICsgXCJdKTtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21waWxlSW5jbHVkZSA9IGZ1bmN0aW9uIGNvbXBpbGVJbmNsdWRlKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdExpbmUoJ3ZhciB0YXNrcyA9IFtdOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3Rhc2tzLnB1c2goJyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnVuY3Rpb24oY2FsbGJhY2spIHsnKTtcblxuICAgIHZhciBpZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZmFsc2UsIG5vZGUuaWdub3JlTWlzc2luZyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImNhbGxiYWNrKG51bGwsXCIgKyBpZCArIFwiKTt9KTtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSk7Jyk7XG5cbiAgICB2YXIgaWQyID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd0YXNrcy5wdXNoKCcpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2Z1bmN0aW9uKHRlbXBsYXRlLCBjYWxsYmFjayl7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndGVtcGxhdGUucmVuZGVyKGNvbnRleHQuZ2V0VmFyaWFibGVzKCksIGZyYW1lLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKGlkMikpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2NhbGxiYWNrKG51bGwsJyArIGlkMiArICcpO30pOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3Rhc2tzLnB1c2goJyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZnVuY3Rpb24ocmVzdWx0LCBjYWxsYmFjayl7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSh0aGlzLmJ1ZmZlciArIFwiICs9IHJlc3VsdDtcIik7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnY2FsbGJhY2sobnVsbCk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnZW52LndhdGVyZmFsbCh0YXNrcywgZnVuY3Rpb24oKXsnKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZVRlbXBsYXRlRGF0YSA9IGZ1bmN0aW9uIGNvbXBpbGVUZW1wbGF0ZURhdGEobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLmNvbXBpbGVMaXRlcmFsKG5vZGUsIGZyYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZUNhcHR1cmUgPSBmdW5jdGlvbiBjb21waWxlQ2FwdHVyZShub2RlLCBmcmFtZSkge1xuICAgIHZhciBfdGhpczE0ID0gdGhpcztcblxuICAgIC8vIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgYnVmZmVyIGlkIGFzICdvdXRwdXQnXG4gICAgLy8gc28gdGhlIHNldCBibG9jayB3cml0ZXMgdG8gdGhlIGNhcHR1cmUgb3V0cHV0IGluc3RlYWQgb2YgdGhlIGJ1ZmZlclxuICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLmJ1ZmZlciA9ICdvdXRwdXQnO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJyhmdW5jdGlvbigpIHsnKTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCd2YXIgb3V0cHV0ID0gXCJcIjsnKTtcblxuICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMxNC5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3JldHVybiBvdXRwdXQ7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfSkoKScpOyAvLyBhbmQgb2YgY291cnNlLCByZXZlcnQgYmFjayB0byB0aGUgb2xkIGJ1ZmZlciBpZFxuXG5cbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZU91dHB1dCA9IGZ1bmN0aW9uIGNvbXBpbGVPdXRwdXQobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAvLyBUZW1wbGF0ZURhdGEgaXMgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSBpdCBpcyBuZXZlclxuICAgICAgLy8gYXV0b2VzY2FwZWQsIHNvIHNpbXBseSBvdXRwdXQgaXQgZm9yIG9wdGltaXphdGlvblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuVGVtcGxhdGVEYXRhKSB7XG4gICAgICAgIGlmIChjaGlsZC52YWx1ZSkge1xuICAgICAgICAgIF90aGlzMTUuX2VtaXQoX3RoaXMxNS5idWZmZXIgKyBcIiArPSBcIik7XG5cbiAgICAgICAgICBfdGhpczE1LmNvbXBpbGVMaXRlcmFsKGNoaWxkLCBmcmFtZSk7XG5cbiAgICAgICAgICBfdGhpczE1Ll9lbWl0TGluZSgnOycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczE1Ll9lbWl0KF90aGlzMTUuYnVmZmVyICsgXCIgKz0gcnVudGltZS5zdXBwcmVzc1ZhbHVlKFwiKTtcblxuICAgICAgICBpZiAoX3RoaXMxNS50aHJvd09uVW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3RoaXMxNS5fZW1pdCgncnVudGltZS5lbnN1cmVEZWZpbmVkKCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxNS5jb21waWxlKGNoaWxkLCBmcmFtZSk7XG5cbiAgICAgICAgaWYgKF90aGlzMTUudGhyb3dPblVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzMTUuX2VtaXQoXCIsXCIgKyBub2RlLmxpbmVubyArIFwiLFwiICsgbm9kZS5jb2xubyArIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMTUuX2VtaXQoJywgZW52Lm9wdHMuYXV0b2VzY2FwZSk7XFxuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBpbGVSb290ID0gZnVuY3Rpb24gY29tcGlsZVJvb3Qobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX3RoaXMxNiA9IHRoaXM7XG5cbiAgICBpZiAoZnJhbWUpIHtcbiAgICAgIHRoaXMuZmFpbCgnY29tcGlsZVJvb3Q6IHJvb3Qgbm9kZSBjYW5cXCd0IGhhdmUgZnJhbWUnKTtcbiAgICB9XG5cbiAgICBmcmFtZSA9IG5ldyBGcmFtZSgpO1xuXG4gICAgdGhpcy5fZW1pdEZ1bmNCZWdpbihub2RlLCAncm9vdCcpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3ZhciBwYXJlbnRUZW1wbGF0ZSA9IG51bGw7Jyk7XG5cbiAgICB0aGlzLl9jb21waWxlQ2hpbGRyZW4obm9kZSwgZnJhbWUpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2lmKHBhcmVudFRlbXBsYXRlKSB7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgncGFyZW50VGVtcGxhdGUucm9vdFJlbmRlckZ1bmMoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpOycpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30gZWxzZSB7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShcImNiKG51bGwsIFwiICsgdGhpcy5idWZmZXIgKyBcIik7XCIpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIHRoaXMuX2VtaXRGdW5jRW5kKHRydWUpO1xuXG4gICAgdGhpcy5pbkJsb2NrID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tOYW1lcyA9IFtdO1xuICAgIHZhciBibG9ja3MgPSBub2RlLmZpbmRBbGwobm9kZXMuQmxvY2spO1xuICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaywgaSkge1xuICAgICAgdmFyIG5hbWUgPSBibG9jay5uYW1lLnZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2tOYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UuXCIpO1xuICAgICAgfVxuXG4gICAgICBibG9ja05hbWVzLnB1c2gobmFtZSk7XG5cbiAgICAgIF90aGlzMTYuX2VtaXRGdW5jQmVnaW4oYmxvY2ssIFwiYl9cIiArIG5hbWUpO1xuXG4gICAgICB2YXIgdG1wRnJhbWUgPSBuZXcgRnJhbWUoKTtcblxuICAgICAgX3RoaXMxNi5fZW1pdExpbmUoJ3ZhciBmcmFtZSA9IGZyYW1lLnB1c2godHJ1ZSk7Jyk7XG5cbiAgICAgIF90aGlzMTYuY29tcGlsZShibG9jay5ib2R5LCB0bXBGcmFtZSk7XG5cbiAgICAgIF90aGlzMTYuX2VtaXRGdW5jRW5kKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgncmV0dXJuIHsnKTtcblxuICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaywgaSkge1xuICAgICAgdmFyIGJsb2NrTmFtZSA9IFwiYl9cIiArIGJsb2NrLm5hbWUudmFsdWU7XG5cbiAgICAgIF90aGlzMTYuX2VtaXRMaW5lKGJsb2NrTmFtZSArIFwiOiBcIiArIGJsb2NrTmFtZSArIFwiLFwiKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2VtaXRMaW5lKCdyb290OiByb290XFxufTsnKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgX2NvbXBpbGUgPSB0aGlzWydjb21waWxlJyArIG5vZGUudHlwZW5hbWVdO1xuXG4gICAgaWYgKF9jb21waWxlKSB7XG4gICAgICBfY29tcGlsZS5jYWxsKHRoaXMsIG5vZGUsIGZyYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKFwiY29tcGlsZTogQ2Fubm90IGNvbXBpbGUgbm9kZTogXCIgKyBub2RlLnR5cGVuYW1lLCBub2RlLmxpbmVubywgbm9kZS5jb2xubyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRDb2RlID0gZnVuY3Rpb24gZ2V0Q29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYnVmLmpvaW4oJycpO1xuICB9O1xuXG4gIHJldHVybiBDb21waWxlcjtcbn0oT2JqKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoc3JjLCBhc3luY0ZpbHRlcnMsIGV4dGVuc2lvbnMsIG5hbWUsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuXG4gICAgdmFyIGMgPSBuZXcgQ29tcGlsZXIobmFtZSwgb3B0cy50aHJvd09uVW5kZWZpbmVkKTsgLy8gUnVuIHRoZSBleHRlbnNpb24gcHJlcHJvY2Vzc29ycyBhZ2FpbnN0IHRoZSBzb3VyY2UuXG5cbiAgICB2YXIgcHJlcHJvY2Vzc29ycyA9IChleHRlbnNpb25zIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5wcmVwcm9jZXNzO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuICEhZjtcbiAgICB9KTtcbiAgICB2YXIgcHJvY2Vzc2VkU3JjID0gcHJlcHJvY2Vzc29ycy5yZWR1Y2UoZnVuY3Rpb24gKHMsIHByb2Nlc3Nvcikge1xuICAgICAgcmV0dXJuIHByb2Nlc3NvcihzKTtcbiAgICB9LCBzcmMpO1xuICAgIGMuY29tcGlsZSh0cmFuc2Zvcm1lci50cmFuc2Zvcm0ocGFyc2VyLnBhcnNlKHByb2Nlc3NlZFNyYywgZXh0ZW5zaW9ucywgb3B0cyksIGFzeW5jRmlsdGVycywgbmFtZSkpO1xuICAgIHJldHVybiBjLmdldENvZGUoKTtcbiAgfSxcbiAgQ29tcGlsZXI6IENvbXBpbGVyXG59O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSxcbiAgICBFbWl0dGVyT2JqID0gX3JlcXVpcmUuRW1pdHRlck9iajtcblxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyT2JqKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvYWRlciwgX0VtaXR0ZXJPYmopO1xuXG4gIGZ1bmN0aW9uIExvYWRlcigpIHtcbiAgICByZXR1cm4gX0VtaXR0ZXJPYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExvYWRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZnJvbSksIHRvKTtcbiAgfTtcblxuICBfcHJvdG8uaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIGlzUmVsYXRpdmUoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gZmlsZW5hbWUuaW5kZXhPZignLi8nKSA9PT0gMCB8fCBmaWxlbmFtZS5pbmRleE9mKCcuLi8nKSA9PT0gMDtcbiAgfTtcblxuICByZXR1cm4gTG9hZGVyO1xufShFbWl0dGVyT2JqKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgYXNhcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgX3dhdGVyZmFsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGNvbXBpbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIGZpbHRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCksXG4gICAgRmlsZVN5c3RlbUxvYWRlciA9IF9yZXF1aXJlLkZpbGVTeXN0ZW1Mb2FkZXIsXG4gICAgV2ViTG9hZGVyID0gX3JlcXVpcmUuV2ViTG9hZGVyLFxuICAgIFByZWNvbXBpbGVkTG9hZGVyID0gX3JlcXVpcmUuUHJlY29tcGlsZWRMb2FkZXI7XG5cbnZhciB0ZXN0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgZ2xvYmFscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSxcbiAgICBPYmogPSBfcmVxdWlyZTIuT2JqLFxuICAgIEVtaXR0ZXJPYmogPSBfcmVxdWlyZTIuRW1pdHRlck9iajtcblxudmFyIGdsb2JhbFJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgaGFuZGxlRXJyb3IgPSBnbG9iYWxSdW50aW1lLmhhbmRsZUVycm9yLFxuICAgIEZyYW1lID0gZ2xvYmFsUnVudGltZS5GcmFtZTtcblxudmFyIGV4cHJlc3NBcHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTsgLy8gSWYgdGhlIHVzZXIgaXMgdXNpbmcgdGhlIGFzeW5jIEFQSSwgKmFsd2F5cyogY2FsbCBpdFxuLy8gYXN5bmNocm9ub3VzbHkgZXZlbiBpZiB0aGUgdGVtcGxhdGUgd2FzIHN5bmNocm9ub3VzLlxuXG5cbmZ1bmN0aW9uIGNhbGxiYWNrQXNhcChjYiwgZXJyLCByZXMpIHtcbiAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgY2IoZXJyLCByZXMpO1xuICB9KTtcbn1cbi8qKlxuICogQSBuby1vcCB0ZW1wbGF0ZSwgZm9yIHVzZSB3aXRoIHslIGluY2x1ZGUgaWdub3JlIG1pc3NpbmcgJX1cbiAqL1xuXG5cbnZhciBub29wVG1wbFNyYyA9IHtcbiAgdHlwZTogJ2NvZGUnLFxuICBvYmo6IHtcbiAgICByb290OiBmdW5jdGlvbiByb290KGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsIGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNiKGhhbmRsZUVycm9yKGUsIG51bGwsIG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBFbnZpcm9ubWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VtaXR0ZXJPYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoRW52aXJvbm1lbnQsIF9FbWl0dGVyT2JqKTtcblxuICBmdW5jdGlvbiBFbnZpcm9ubWVudCgpIHtcbiAgICByZXR1cm4gX0VtaXR0ZXJPYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVudmlyb25tZW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobG9hZGVycywgb3B0cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBUaGUgZGV2IGZsYWcgZGV0ZXJtaW5lcyB0aGUgdHJhY2UgdGhhdCdsbCBiZSBzaG93biBvbiBlcnJvcnMuXG4gICAgLy8gSWYgc2V0IHRvIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgdHJhY2UgZnJvbSB0aGUgZXJyb3IgcG9pbnQsXG4gICAgLy8gb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIHRyYWNlIHN0YXJ0aW5nIGZyb20gVGVtcGxhdGUucmVuZGVyXG4gICAgLy8gKHRoZSBmdWxsIHRyYWNlIGZyb20gd2l0aGluIG51bmp1Y2tzIG1heSBjb25mdXNlIGRldmVsb3BlcnMgdXNpbmdcbiAgICAvLyAgdGhlIGxpYnJhcnkpXG4gICAgLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgICBvcHRzID0gdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLm9wdHMuZGV2ID0gISFvcHRzLmRldjsgLy8gVGhlIGF1dG9lc2NhcGUgZmxhZyBzZXRzIGdsb2JhbCBhdXRvZXNjYXBpbmcuIElmIHRydWUsXG4gICAgLy8gZXZlcnkgc3RyaW5nIHZhcmlhYmxlIHdpbGwgYmUgZXNjYXBlZCBieSBkZWZhdWx0LlxuICAgIC8vIElmIGZhbHNlLCBzdHJpbmdzIGNhbiBiZSBtYW51YWxseSBlc2NhcGVkIHVzaW5nIHRoZSBgZXNjYXBlYCBmaWx0ZXIuXG4gICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuXG4gICAgdGhpcy5vcHRzLmF1dG9lc2NhcGUgPSBvcHRzLmF1dG9lc2NhcGUgIT0gbnVsbCA/IG9wdHMuYXV0b2VzY2FwZSA6IHRydWU7IC8vIElmIHRydWUsIHRoaXMgd2lsbCBtYWtlIHRoZSBzeXN0ZW0gdGhyb3cgZXJyb3JzIGlmIHRyeWluZ1xuICAgIC8vIHRvIG91dHB1dCBhIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlXG5cbiAgICB0aGlzLm9wdHMudGhyb3dPblVuZGVmaW5lZCA9ICEhb3B0cy50aHJvd09uVW5kZWZpbmVkO1xuICAgIHRoaXMub3B0cy50cmltQmxvY2tzID0gISFvcHRzLnRyaW1CbG9ja3M7XG4gICAgdGhpcy5vcHRzLmxzdHJpcEJsb2NrcyA9ICEhb3B0cy5sc3RyaXBCbG9ja3M7XG4gICAgdGhpcy5sb2FkZXJzID0gW107XG5cbiAgICBpZiAoIWxvYWRlcnMpIHtcbiAgICAgIC8vIFRoZSBmaWxlc3lzdGVtIGxvYWRlciBpcyBvbmx5IGF2YWlsYWJsZSBzZXJ2ZXItc2lkZVxuICAgICAgaWYgKEZpbGVTeXN0ZW1Mb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJzID0gW25ldyBGaWxlU3lzdGVtTG9hZGVyKCd2aWV3cycpXTtcbiAgICAgIH0gZWxzZSBpZiAoV2ViTG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVycyA9IFtuZXcgV2ViTG9hZGVyKCcvdmlld3MnKV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZGVycyA9IGxpYi5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgICB9IC8vIEl0J3MgZWFzeSB0byB1c2UgcHJlY29tcGlsZWQgdGVtcGxhdGVzOiBqdXN0IGluY2x1ZGUgdGhlbVxuICAgIC8vIGJlZm9yZSB5b3UgY29uZmlndXJlIG51bmp1Y2tzIGFuZCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgIC8vIHBpY2sgaXQgdXAgYW5kIHVzZSBpdFxuXG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQpIHtcbiAgICAgIHRoaXMubG9hZGVycy51bnNoaWZ0KG5ldyBQcmVjb21waWxlZExvYWRlcih3aW5kb3cubnVuanVja3NQcmVjb21waWxlZCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRMb2FkZXJzKCk7XG5cbiAgICB0aGlzLmdsb2JhbHMgPSBnbG9iYWxzKCk7XG4gICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgdGhpcy50ZXN0cyA9IHt9O1xuICAgIHRoaXMuYXN5bmNGaWx0ZXJzID0gW107XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5leHRlbnNpb25zTGlzdCA9IFtdO1xuXG4gICAgbGliLl9lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgICAgICBmaWx0ZXIgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIF90aGlzLmFkZEZpbHRlcihuYW1lLCBmaWx0ZXIpO1xuICAgIH0pO1xuXG4gICAgbGliLl9lbnRyaWVzKHRlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmMlswXSxcbiAgICAgICAgICB0ZXN0ID0gX3JlZjJbMV07XG4gICAgICByZXR1cm4gX3RoaXMuYWRkVGVzdChuYW1lLCB0ZXN0KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRMb2FkZXJzID0gZnVuY3Rpb24gX2luaXRMb2FkZXJzKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5sb2FkZXJzLmZvckVhY2goZnVuY3Rpb24gKGxvYWRlcikge1xuICAgICAgLy8gQ2FjaGluZyBhbmQgY2FjaGUgYnVzdGluZ1xuICAgICAgbG9hZGVyLmNhY2hlID0ge307XG5cbiAgICAgIGlmICh0eXBlb2YgbG9hZGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvYWRlci5vbigndXBkYXRlJywgZnVuY3Rpb24gKG5hbWUsIGZ1bGxuYW1lKSB7XG4gICAgICAgICAgbG9hZGVyLmNhY2hlW25hbWVdID0gbnVsbDtcblxuICAgICAgICAgIF90aGlzMi5lbWl0KCd1cGRhdGUnLCBuYW1lLCBmdWxsbmFtZSwgbG9hZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRlci5vbignbG9hZCcsIGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgICBfdGhpczIuZW1pdCgnbG9hZCcsIG5hbWUsIHNvdXJjZSwgbG9hZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmludmFsaWRhdGVDYWNoZSA9IGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZSgpIHtcbiAgICB0aGlzLmxvYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIuY2FjaGUgPSB7fTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uYWRkRXh0ZW5zaW9uID0gZnVuY3Rpb24gYWRkRXh0ZW5zaW9uKG5hbWUsIGV4dGVuc2lvbikge1xuICAgIGV4dGVuc2lvbi5fX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuZXh0ZW5zaW9uc1tuYW1lXSA9IGV4dGVuc2lvbjtcbiAgICB0aGlzLmV4dGVuc2lvbnNMaXN0LnB1c2goZXh0ZW5zaW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlRXh0ZW5zaW9uID0gZnVuY3Rpb24gcmVtb3ZlRXh0ZW5zaW9uKG5hbWUpIHtcbiAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb24obmFtZSk7XG5cbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXh0ZW5zaW9uc0xpc3QgPSBsaWIud2l0aG91dCh0aGlzLmV4dGVuc2lvbnNMaXN0LCBleHRlbnNpb24pO1xuICAgIGRlbGV0ZSB0aGlzLmV4dGVuc2lvbnNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLmdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEV4dGVuc2lvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uaGFzRXh0ZW5zaW9uID0gZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLmV4dGVuc2lvbnNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLmFkZEdsb2JhbCA9IGZ1bmN0aW9uIGFkZEdsb2JhbChuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuZ2xvYmFsc1tuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nZXRHbG9iYWwgPSBmdW5jdGlvbiBnZXRHbG9iYWwobmFtZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5nbG9iYWxzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbG9iYWwgbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsc1tuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uYWRkRmlsdGVyID0gZnVuY3Rpb24gYWRkRmlsdGVyKG5hbWUsIGZ1bmMsIGFzeW5jKSB7XG4gICAgdmFyIHdyYXBwZWQgPSBmdW5jO1xuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICB0aGlzLmFzeW5jRmlsdGVycy5wdXNoKG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuZmlsdGVyc1tuYW1lXSA9IHdyYXBwZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZpbHRlciA9IGZ1bmN0aW9uIGdldEZpbHRlcihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcnNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbHRlcnNbbmFtZV07XG4gIH07XG5cbiAgX3Byb3RvLmFkZFRlc3QgPSBmdW5jdGlvbiBhZGRUZXN0KG5hbWUsIGZ1bmMpIHtcbiAgICB0aGlzLnRlc3RzW25hbWVdID0gZnVuYztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGVzdCA9IGZ1bmN0aW9uIGdldFRlc3QobmFtZSkge1xuICAgIGlmICghdGhpcy50ZXN0c1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZXN0IG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRlc3RzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5yZXNvbHZlVGVtcGxhdGUgPSBmdW5jdGlvbiByZXNvbHZlVGVtcGxhdGUobG9hZGVyLCBwYXJlbnROYW1lLCBmaWxlbmFtZSkge1xuICAgIHZhciBpc1JlbGF0aXZlID0gbG9hZGVyLmlzUmVsYXRpdmUgJiYgcGFyZW50TmFtZSA/IGxvYWRlci5pc1JlbGF0aXZlKGZpbGVuYW1lKSA6IGZhbHNlO1xuICAgIHJldHVybiBpc1JlbGF0aXZlICYmIGxvYWRlci5yZXNvbHZlID8gbG9hZGVyLnJlc29sdmUocGFyZW50TmFtZSwgZmlsZW5hbWUpIDogZmlsZW5hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRlbXBsYXRlID0gZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZSwgZWFnZXJDb21waWxlLCBwYXJlbnROYW1lLCBpZ25vcmVNaXNzaW5nLCBjYikge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0bXBsID0gbnVsbDtcblxuICAgIGlmIChuYW1lICYmIG5hbWUucmF3KSB7XG4gICAgICAvLyB0aGlzIGZpeGVzIGF1dG9lc2NhcGUgZm9yIHRlbXBsYXRlcyByZWZlcmVuY2VkIGluIHN5bWJvbHNcbiAgICAgIG5hbWUgPSBuYW1lLnJhdztcbiAgICB9XG5cbiAgICBpZiAobGliLmlzRnVuY3Rpb24ocGFyZW50TmFtZSkpIHtcbiAgICAgIGNiID0gcGFyZW50TmFtZTtcbiAgICAgIHBhcmVudE5hbWUgPSBudWxsO1xuICAgICAgZWFnZXJDb21waWxlID0gZWFnZXJDb21waWxlIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsaWIuaXNGdW5jdGlvbihlYWdlckNvbXBpbGUpKSB7XG4gICAgICBjYiA9IGVhZ2VyQ29tcGlsZTtcbiAgICAgIGVhZ2VyQ29tcGlsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgIHRtcGwgPSBuYW1lO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RlbXBsYXRlIG5hbWVzIG11c3QgYmUgYSBzdHJpbmc6ICcgKyBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IHRoaXMubG9hZGVyc1tpXTtcbiAgICAgICAgdG1wbCA9IGxvYWRlci5jYWNoZVt0aGlzLnJlc29sdmVUZW1wbGF0ZShsb2FkZXIsIHBhcmVudE5hbWUsIG5hbWUpXTtcblxuICAgICAgICBpZiAodG1wbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRtcGwpIHtcbiAgICAgIGlmIChlYWdlckNvbXBpbGUpIHtcbiAgICAgICAgdG1wbC5jb21waWxlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYihudWxsLCB0bXBsKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0bXBsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzeW5jUmVzdWx0O1xuXG4gICAgdmFyIGNyZWF0ZVRlbXBsYXRlID0gZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGUoZXJyLCBpbmZvKSB7XG4gICAgICBpZiAoIWluZm8gJiYgIWVyciAmJiAhaWdub3JlTWlzc2luZykge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ3RlbXBsYXRlIG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3VG1wbDtcblxuICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIG5ld1RtcGwgPSBuZXcgVGVtcGxhdGUobm9vcFRtcGxTcmMsIF90aGlzMywgJycsIGVhZ2VyQ29tcGlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUbXBsID0gbmV3IFRlbXBsYXRlKGluZm8uc3JjLCBfdGhpczMsIGluZm8ucGF0aCwgZWFnZXJDb21waWxlKTtcblxuICAgICAgICBpZiAoIWluZm8ubm9DYWNoZSkge1xuICAgICAgICAgIGluZm8ubG9hZGVyLmNhY2hlW25hbWVdID0gbmV3VG1wbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IobnVsbCwgbmV3VG1wbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzeW5jUmVzdWx0ID0gbmV3VG1wbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliLmFzeW5jSXRlcih0aGlzLmxvYWRlcnMsIGZ1bmN0aW9uIChsb2FkZXIsIGksIG5leHQsIGRvbmUpIHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShlcnIsIHNyYykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYykge1xuICAgICAgICAgIHNyYy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgICAgZG9uZShudWxsLCBzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZXNvbHZlIG5hbWUgcmVsYXRpdmUgdG8gcGFyZW50TmFtZVxuXG5cbiAgICAgIG5hbWUgPSB0aGF0LnJlc29sdmVUZW1wbGF0ZShsb2FkZXIsIHBhcmVudE5hbWUsIG5hbWUpO1xuXG4gICAgICBpZiAobG9hZGVyLmFzeW5jKSB7XG4gICAgICAgIGxvYWRlci5nZXRTb3VyY2UobmFtZSwgaGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZShudWxsLCBsb2FkZXIuZ2V0U291cmNlKG5hbWUpKTtcbiAgICAgIH1cbiAgICB9LCBjcmVhdGVUZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmV4cHJlc3MgPSBmdW5jdGlvbiBleHByZXNzKGFwcCkge1xuICAgIHJldHVybiBleHByZXNzQXBwKHRoaXMsIGFwcCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihuYW1lLCBjdHgsIGNiKSB7XG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKGN0eCkpIHtcbiAgICAgIGNiID0gY3R4O1xuICAgICAgY3R4ID0gbnVsbDtcbiAgICB9IC8vIFdlIHN1cHBvcnQgYSBzeW5jaHJvbm91cyBBUEkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWlncmF0ZVxuICAgIC8vIGV4aXN0aW5nIGNvZGUgdG8gYXN5bmMuIFRoaXMgd29ya3MgYmVjYXVzZSBpZiB5b3UgZG9uJ3QgZG9cbiAgICAvLyBhbnl0aGluZyBhc3luYyB3b3JrLCB0aGUgd2hvbGUgdGhpbmcgaXMgYWN0dWFsbHkgcnVuXG4gICAgLy8gc3luY2hyb25vdXNseS5cblxuXG4gICAgdmFyIHN5bmNSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuZ2V0VGVtcGxhdGUobmFtZSwgZnVuY3Rpb24gKGVyciwgdG1wbCkge1xuICAgICAgaWYgKGVyciAmJiBjYikge1xuICAgICAgICBjYWxsYmFja0FzYXAoY2IsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzeW5jUmVzdWx0ID0gdG1wbC5yZW5kZXIoY3R4LCBjYik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlclN0cmluZyA9IGZ1bmN0aW9uIHJlbmRlclN0cmluZyhzcmMsIGN0eCwgb3B0cywgY2IpIHtcbiAgICBpZiAobGliLmlzRnVuY3Rpb24ob3B0cykpIHtcbiAgICAgIGNiID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgdG1wbCA9IG5ldyBUZW1wbGF0ZShzcmMsIHRoaXMsIG9wdHMucGF0aCk7XG4gICAgcmV0dXJuIHRtcGwucmVuZGVyKGN0eCwgY2IpO1xuICB9O1xuXG4gIF9wcm90by53YXRlcmZhbGwgPSBmdW5jdGlvbiB3YXRlcmZhbGwodGFza3MsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKSB7XG4gICAgcmV0dXJuIF93YXRlcmZhbGwodGFza3MsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKTtcbiAgfTtcblxuICByZXR1cm4gRW52aXJvbm1lbnQ7XG59KEVtaXR0ZXJPYmopO1xuXG52YXIgQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iaikge1xuICBfaW5oZXJpdHNMb29zZShDb250ZXh0LCBfT2JqKTtcblxuICBmdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHJldHVybiBfT2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gQ29udGV4dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pbml0ID0gZnVuY3Rpb24gaW5pdChjdHgsIGJsb2NrcywgZW52KSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAvLyBIYXMgdG8gYmUgdGllZCB0byBhbiBlbnZpcm9ubWVudCBzbyB3ZSBjYW4gdGFwIGludG8gaXRzIGdsb2JhbHMuXG4gICAgdGhpcy5lbnYgPSBlbnYgfHwgbmV3IEVudmlyb25tZW50KCk7IC8vIE1ha2UgYSBkdXBsaWNhdGUgb2YgY3R4XG5cbiAgICB0aGlzLmN0eCA9IGxpYi5leHRlbmQoe30sIGN0eCk7XG4gICAgdGhpcy5ibG9ja3MgPSB7fTtcbiAgICB0aGlzLmV4cG9ydGVkID0gW107XG4gICAgbGliLmtleXMoYmxvY2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpczQuYWRkQmxvY2sobmFtZSwgYmxvY2tzW25hbWVdKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8yLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChuYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBvbmUgb2YgdGhlIG1vc3QgY2FsbGVkIGZ1bmN0aW9ucywgc28gb3B0aW1pemUgZm9yXG4gICAgLy8gdGhlIHR5cGljYWwgY2FzZSB3aGVyZSB0aGUgbmFtZSBpc24ndCBpbiB0aGUgZ2xvYmFsc1xuICAgIGlmIChuYW1lIGluIHRoaXMuZW52Lmdsb2JhbHMgJiYgIShuYW1lIGluIHRoaXMuY3R4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW52Lmdsb2JhbHNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmN0eFtuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5zZXRWYXJpYWJsZSA9IGZ1bmN0aW9uIHNldFZhcmlhYmxlKG5hbWUsIHZhbCkge1xuICAgIHRoaXMuY3R4W25hbWVdID0gdmFsO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VmFyaWFibGVzID0gZnVuY3Rpb24gZ2V0VmFyaWFibGVzKCkge1xuICAgIHJldHVybiB0aGlzLmN0eDtcbiAgfTtcblxuICBfcHJvdG8yLmFkZEJsb2NrID0gZnVuY3Rpb24gYWRkQmxvY2sobmFtZSwgYmxvY2spIHtcbiAgICB0aGlzLmJsb2Nrc1tuYW1lXSA9IHRoaXMuYmxvY2tzW25hbWVdIHx8IFtdO1xuICAgIHRoaXMuYmxvY2tzW25hbWVdLnB1c2goYmxvY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QmxvY2sgPSBmdW5jdGlvbiBnZXRCbG9jayhuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmJsb2Nrc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsb2NrIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbbmFtZV1bMF07XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRTdXBlciA9IGZ1bmN0aW9uIGdldFN1cGVyKGVudiwgbmFtZSwgYmxvY2ssIGZyYW1lLCBydW50aW1lLCBjYikge1xuICAgIHZhciBpZHggPSBsaWIuaW5kZXhPZih0aGlzLmJsb2Nrc1tuYW1lXSB8fCBbXSwgYmxvY2spO1xuICAgIHZhciBibGsgPSB0aGlzLmJsb2Nrc1tuYW1lXVtpZHggKyAxXTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICBpZiAoaWR4ID09PSAtMSB8fCAhYmxrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHN1cGVyIGJsb2NrIGF2YWlsYWJsZSBmb3IgXCInICsgbmFtZSArICdcIicpO1xuICAgIH1cblxuICAgIGJsayhlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYik7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRFeHBvcnQgPSBmdW5jdGlvbiBhZGRFeHBvcnQobmFtZSkge1xuICAgIHRoaXMuZXhwb3J0ZWQucHVzaChuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEV4cG9ydGVkID0gZnVuY3Rpb24gZ2V0RXhwb3J0ZWQoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcbiAgICB0aGlzLmV4cG9ydGVkLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGV4cG9ydGVkW25hbWVdID0gX3RoaXM1LmN0eFtuYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwb3J0ZWQ7XG4gIH07XG5cbiAgcmV0dXJuIENvbnRleHQ7XG59KE9iaik7XG5cbnZhciBUZW1wbGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iajIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGVtcGxhdGUsIF9PYmoyKTtcblxuICBmdW5jdGlvbiBUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gX09iajIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBUZW1wbGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5pbml0ID0gZnVuY3Rpb24gaW5pdChzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKSB7XG4gICAgdGhpcy5lbnYgPSBlbnYgfHwgbmV3IEVudmlyb25tZW50KCk7XG5cbiAgICBpZiAobGliLmlzT2JqZWN0KHNyYykpIHtcbiAgICAgIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgdGhpcy50bXBsUHJvcHMgPSBzcmMub2JqO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgdGhpcy50bXBsU3RyID0gc3JjLm9iajtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdGVtcGxhdGUgb2JqZWN0IHR5cGUgXCIgKyBzcmMudHlwZSArIFwiOyBleHBlY3RlZCAnY29kZScsIG9yICdzdHJpbmcnXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGliLmlzU3RyaW5nKHNyYykpIHtcbiAgICAgIHRoaXMudG1wbFN0ciA9IHNyYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcmMgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgc291cmNlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcblxuICAgIGlmIChlYWdlckNvbXBpbGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBsaWIuX3ByZXR0aWZ5RXJyb3IodGhpcy5wYXRoLCB0aGlzLmVudi5vcHRzLmRldiwgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21waWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjdHgsIHBhcmVudEZyYW1lLCBjYikge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBjdHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gY3R4O1xuICAgICAgY3R4ID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyZW50RnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gcGFyZW50RnJhbWU7XG4gICAgICBwYXJlbnRGcmFtZSA9IG51bGw7XG4gICAgfSAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCBmcmFtZSwgd2UgYXJlIGJlaW5nIGNhbGxlZCBmcm9tIGludGVybmFsXG4gICAgLy8gY29kZSBvZiBhbm90aGVyIHRlbXBsYXRlLCBhbmQgdGhlIGludGVybmFsIHN5c3RlbVxuICAgIC8vIGRlcGVuZHMgb24gdGhlIHN5bmMvYXN5bmMgbmF0dXJlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGVcbiAgICAvLyB0byBiZSBpbmhlcml0ZWQsIHNvIGZvcmNlIGFuIGFzeW5jIGNhbGxiYWNrXG5cblxuICAgIHZhciBmb3JjZUFzeW5jID0gIXBhcmVudEZyYW1lOyAvLyBDYXRjaCBjb21waWxlIGVycm9ycyBmb3IgYXN5bmMgcmVuZGVyaW5nXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFyIGVyciA9IGxpYi5fcHJldHRpZnlFcnJvcih0aGlzLnBhdGgsIHRoaXMuZW52Lm9wdHMuZGV2LCBlKTtcblxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja0FzYXAoY2IsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChjdHggfHwge30sIHRoaXMuYmxvY2tzLCB0aGlzLmVudik7XG4gICAgdmFyIGZyYW1lID0gcGFyZW50RnJhbWUgPyBwYXJlbnRGcmFtZS5wdXNoKHRydWUpIDogbmV3IEZyYW1lKCk7XG4gICAgZnJhbWUudG9wTGV2ZWwgPSB0cnVlO1xuICAgIHZhciBzeW5jUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB0aGlzLnJvb3RSZW5kZXJGdW5jKHRoaXMuZW52LCBjb250ZXh0LCBmcmFtZSwgZ2xvYmFsUnVudGltZSwgZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIGFjdHVhbGx5IGEgYnVnIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSAoYmVjYXVzZSB3YXRlcmZhbGxcbiAgICAgIC8vIHRhc2tzIGFyZSBib3RoIG5vdCBwYXNzaW5nIGVycm9ycyB1cCB0aGUgY2hhaW4gb2YgY2FsbGJhY2tzIEFORCBhcmUgbm90XG4gICAgICAvLyBjYXVzaW5nIGEgcmV0dXJuIGZyb20gdGhlIHRvcC1tb3N0IHJlbmRlciBmdW5jdGlvbikuIEJ1dCBmaXhpbmcgdGhhdFxuICAgICAgLy8gd2lsbCByZXF1aXJlIGEgbW9yZSBzdWJzdGFudGlhbCBjaGFuZ2UgdG8gdGhlIGNvbXBpbGVyLlxuICAgICAgaWYgKGRpZEVycm9yICYmIGNiICYmIHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMgdG8gY2JcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyciA9IGxpYi5fcHJldHRpZnlFcnJvcihfdGhpczYucGF0aCwgX3RoaXM2LmVudi5vcHRzLmRldiwgZXJyKTtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGZvcmNlQXN5bmMpIHtcbiAgICAgICAgICBjYWxsYmFja0FzYXAoY2IsIGVyciwgcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihlcnIsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBzeW5jUmVzdWx0ID0gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9O1xuXG4gIF9wcm90bzMuZ2V0RXhwb3J0ZWQgPSBmdW5jdGlvbiBnZXRFeHBvcnRlZChjdHgsIHBhcmVudEZyYW1lLCBjYikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICBpZiAodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcmVudEZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHBhcmVudEZyYW1lO1xuICAgICAgcGFyZW50RnJhbWUgPSBudWxsO1xuICAgIH0gLy8gQ2F0Y2ggY29tcGlsZSBlcnJvcnMgZm9yIGFzeW5jIHJlbmRlcmluZ1xuXG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lID0gcGFyZW50RnJhbWUgPyBwYXJlbnRGcmFtZS5wdXNoKCkgOiBuZXcgRnJhbWUoKTtcbiAgICBmcmFtZS50b3BMZXZlbCA9IHRydWU7IC8vIFJ1biB0aGUgcm9vdFJlbmRlckZ1bmMgdG8gcG9wdWxhdGUgdGhlIGNvbnRleHQgd2l0aCBleHBvcnRlZCB2YXJzXG5cbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KGN0eCB8fCB7fSwgdGhpcy5ibG9ja3MsIHRoaXMuZW52KTtcbiAgICB0aGlzLnJvb3RSZW5kZXJGdW5jKHRoaXMuZW52LCBjb250ZXh0LCBmcmFtZSwgZ2xvYmFsUnVudGltZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgY29udGV4dC5nZXRFeHBvcnRlZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmNvbXBpbGUgPSBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgIGlmICghdGhpcy5jb21waWxlZCkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLl9jb21waWxlID0gZnVuY3Rpb24gX2NvbXBpbGUoKSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKHRoaXMudG1wbFByb3BzKSB7XG4gICAgICBwcm9wcyA9IHRoaXMudG1wbFByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc291cmNlID0gY29tcGlsZXIuY29tcGlsZSh0aGlzLnRtcGxTdHIsIHRoaXMuZW52LmFzeW5jRmlsdGVycywgdGhpcy5lbnYuZXh0ZW5zaW9uc0xpc3QsIHRoaXMucGF0aCwgdGhpcy5lbnYub3B0cyk7XG4gICAgICB2YXIgZnVuYyA9IG5ldyBGdW5jdGlvbihzb3VyY2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG5cbiAgICAgIHByb3BzID0gZnVuYygpO1xuICAgIH1cblxuICAgIHRoaXMuYmxvY2tzID0gdGhpcy5fZ2V0QmxvY2tzKHByb3BzKTtcbiAgICB0aGlzLnJvb3RSZW5kZXJGdW5jID0gcHJvcHMucm9vdDtcbiAgICB0aGlzLmNvbXBpbGVkID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8zLl9nZXRCbG9ja3MgPSBmdW5jdGlvbiBfZ2V0QmxvY2tzKHByb3BzKSB7XG4gICAgdmFyIGJsb2NrcyA9IHt9O1xuICAgIGxpYi5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoay5zbGljZSgwLCAyKSA9PT0gJ2JfJykge1xuICAgICAgICBibG9ja3Nbay5zbGljZSgyKV0gPSBwcm9wc1trXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9O1xuXG4gIHJldHVybiBUZW1wbGF0ZTtcbn0oT2JqKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVudmlyb25tZW50OiBFbnZpcm9ubWVudCxcbiAgVGVtcGxhdGU6IFRlbXBsYXRlXG59O1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBsZXhlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBub2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBPYmogPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLk9iajtcblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmopIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFyc2VyLCBfT2JqKTtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgcmV0dXJuIF9PYmouYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHRva2Vucykge1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMucGVla2VkID0gbnVsbDtcbiAgICB0aGlzLmJyZWFrT25CbG9ja3MgPSBudWxsO1xuICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgdGhpcy5leHRlbnNpb25zID0gW107XG4gIH07XG5cbiAgX3Byb3RvLm5leHRUb2tlbiA9IGZ1bmN0aW9uIG5leHRUb2tlbih3aXRoV2hpdGVzcGFjZSkge1xuICAgIHZhciB0b2s7XG5cbiAgICBpZiAodGhpcy5wZWVrZWQpIHtcbiAgICAgIGlmICghd2l0aFdoaXRlc3BhY2UgJiYgdGhpcy5wZWVrZWQudHlwZSA9PT0gbGV4ZXIuVE9LRU5fV0hJVEVTUEFDRSkge1xuICAgICAgICB0aGlzLnBlZWtlZCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2sgPSB0aGlzLnBlZWtlZDtcbiAgICAgICAgdGhpcy5wZWVrZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRvayA9IHRoaXMudG9rZW5zLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKCF3aXRoV2hpdGVzcGFjZSkge1xuICAgICAgd2hpbGUgKHRvayAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fV0hJVEVTUEFDRSkge1xuICAgICAgICB0b2sgPSB0aGlzLnRva2Vucy5uZXh0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rO1xuICB9O1xuXG4gIF9wcm90by5wZWVrVG9rZW4gPSBmdW5jdGlvbiBwZWVrVG9rZW4oKSB7XG4gICAgdGhpcy5wZWVrZWQgPSB0aGlzLnBlZWtlZCB8fCB0aGlzLm5leHRUb2tlbigpO1xuICAgIHJldHVybiB0aGlzLnBlZWtlZDtcbiAgfTtcblxuICBfcHJvdG8ucHVzaFRva2VuID0gZnVuY3Rpb24gcHVzaFRva2VuKHRvaykge1xuICAgIGlmICh0aGlzLnBlZWtlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdXNoVG9rZW46IGNhbiBvbmx5IHB1c2ggb25lIHRva2VuIG9uIGJldHdlZW4gcmVhZHMnKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlZWtlZCA9IHRvaztcbiAgfTtcblxuICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2csIGxpbmVubywgY29sbm8pIHtcbiAgICBpZiAobGluZW5vID09PSB1bmRlZmluZWQgfHwgY29sbm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCkgfHwge307XG4gICAgICBsaW5lbm8gPSB0b2subGluZW5vO1xuICAgICAgY29sbm8gPSB0b2suY29sbm87XG4gICAgfVxuXG4gICAgaWYgKGxpbmVubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaW5lbm8gKz0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbm8gKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGxpYi5UZW1wbGF0ZUVycm9yKG1zZywgbGluZW5vLCBjb2xubyk7XG4gIH07XG5cbiAgX3Byb3RvLmZhaWwgPSBmdW5jdGlvbiBmYWlsKG1zZywgbGluZW5vLCBjb2xubykge1xuICAgIHRocm93IHRoaXMuZXJyb3IobXNnLCBsaW5lbm8sIGNvbG5vKTtcbiAgfTtcblxuICBfcHJvdG8uc2tpcCA9IGZ1bmN0aW9uIHNraXAodHlwZSkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKCF0b2sgfHwgdG9rLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmV4cGVjdCA9IGZ1bmN0aW9uIGV4cGVjdCh0eXBlKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICBpZiAodG9rLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIHRvay50eXBlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cblxuICAgIHJldHVybiB0b2s7XG4gIH07XG5cbiAgX3Byb3RvLnNraXBWYWx1ZSA9IGZ1bmN0aW9uIHNraXBWYWx1ZSh0eXBlLCB2YWwpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICghdG9rIHx8IHRvay50eXBlICE9PSB0eXBlIHx8IHRvay52YWx1ZSAhPT0gdmFsKSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5za2lwU3ltYm9sID0gZnVuY3Rpb24gc2tpcFN5bWJvbCh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fU1lNQk9MLCB2YWwpO1xuICB9O1xuXG4gIF9wcm90by5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCA9IGZ1bmN0aW9uIGFkdmFuY2VBZnRlckJsb2NrRW5kKG5hbWUpIHtcbiAgICB2YXIgdG9rO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgICBpZiAoIXRvaykge1xuICAgICAgICB0aGlzLmZhaWwoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvay50eXBlICE9PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdhZHZhbmNlQWZ0ZXJCbG9ja0VuZDogZXhwZWN0ZWQgc3ltYm9sIHRva2VuIG9yICcgKyAnZXhwbGljaXQgbmFtZSB0byBiZSBwYXNzZWQnKTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IHRoaXMubmV4dFRva2VuKCkudmFsdWU7XG4gICAgfVxuXG4gICAgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICh0b2sgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX0VORCkge1xuICAgICAgaWYgKHRvay52YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgYmxvY2sgZW5kIGluICcgKyBuYW1lICsgJyBzdGF0ZW1lbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rO1xuICB9O1xuXG4gIF9wcm90by5hZHZhbmNlQWZ0ZXJWYXJpYWJsZUVuZCA9IGZ1bmN0aW9uIGFkdmFuY2VBZnRlclZhcmlhYmxlRW5kKCkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKHRvayAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fVkFSSUFCTEVfRU5EKSB7XG4gICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IHRvay52YWx1ZS5jaGFyQXQodG9rLnZhbHVlLmxlbmd0aCAtIHRoaXMudG9rZW5zLnRhZ3MuVkFSSUFCTEVfRU5ELmxlbmd0aCAtIDEpID09PSAnLSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIHZhcmlhYmxlIGVuZCcpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGb3IgPSBmdW5jdGlvbiBwYXJzZUZvcigpIHtcbiAgICB2YXIgZm9yVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZW5kQmxvY2s7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdmb3InKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Gb3IoZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICAgIGVuZEJsb2NrID0gJ2VuZGZvcic7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ2FzeW5jRWFjaCcpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkFzeW5jRWFjaChmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgICAgZW5kQmxvY2sgPSAnZW5kZWFjaCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ2FzeW5jQWxsJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQXN5bmNBbGwoZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICAgIGVuZEJsb2NrID0gJ2VuZGFsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGb3I6IGV4cGVjdGVkIGZvcntBc3luY30nLCBmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgIH1cblxuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG5cbiAgICBpZiAoIShub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5TeW1ib2wpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRm9yOiB2YXJpYWJsZSBuYW1lIGV4cGVjdGVkIGZvciBsb29wJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnBlZWtUb2tlbigpLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbGV4ZXIuVE9LRU5fQ09NTUEpIHtcbiAgICAgIC8vIGtleS92YWx1ZSBpdGVyYXRpb25cbiAgICAgIHZhciBrZXkgPSBub2RlLm5hbWU7XG4gICAgICBub2RlLm5hbWUgPSBuZXcgbm9kZXMuQXJyYXkoa2V5LmxpbmVubywga2V5LmNvbG5vKTtcbiAgICAgIG5vZGUubmFtZS5hZGRDaGlsZChrZXkpO1xuXG4gICAgICB3aGlsZSAodGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICB2YXIgcHJpbSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIG5vZGUubmFtZS5hZGRDaGlsZChwcmltKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnaW4nKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZvcjogZXhwZWN0ZWQgXCJpblwiIGtleXdvcmQgZm9yIGxvb3AnLCBmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgIH1cblxuICAgIG5vZGUuYXJyID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGZvclRvay52YWx1ZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKGVuZEJsb2NrLCAnZWxzZScpO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnZWxzZScpKSB7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCdlbHNlJyk7XG4gICAgICBub2RlLmVsc2VfID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKGVuZEJsb2NrKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTWFjcm8gPSBmdW5jdGlvbiBwYXJzZU1hY3JvKCkge1xuICAgIHZhciBtYWNyb1RvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnbWFjcm8nKSkge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBtYWNybycpO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZVByaW1hcnkodHJ1ZSk7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlU2lnbmF0dXJlKCk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbm9kZXMuTWFjcm8obWFjcm9Ub2subGluZW5vLCBtYWNyb1Rvay5jb2xubywgbmFtZSwgYXJncyk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChtYWNyb1Rvay52YWx1ZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRtYWNybycpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VDYWxsID0gZnVuY3Rpb24gcGFyc2VDYWxsKCkge1xuICAgIC8vIGEgY2FsbCBibG9jayBpcyBwYXJzZWQgYXMgYSBub3JtYWwgRnVuQ2FsbCwgYnV0IHdpdGggYW4gYWRkZWRcbiAgICAvLyAnY2FsbGVyJyBrd2FyZyB3aGljaCBpcyBhIENhbGxlciBub2RlLlxuICAgIHZhciBjYWxsVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdjYWxsJykpIHtcbiAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgY2FsbCcpO1xuICAgIH1cblxuICAgIHZhciBjYWxsZXJBcmdzID0gdGhpcy5wYXJzZVNpZ25hdHVyZSh0cnVlKSB8fCBuZXcgbm9kZXMuTm9kZUxpc3QoKTtcbiAgICB2YXIgbWFjcm9DYWxsID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGNhbGxUb2sudmFsdWUpO1xuICAgIHZhciBib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRjYWxsJyk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgIHZhciBjYWxsZXJOYW1lID0gbmV3IG5vZGVzLlN5bWJvbChjYWxsVG9rLmxpbmVubywgY2FsbFRvay5jb2xubywgJ2NhbGxlcicpO1xuICAgIHZhciBjYWxsZXJOb2RlID0gbmV3IG5vZGVzLkNhbGxlcihjYWxsVG9rLmxpbmVubywgY2FsbFRvay5jb2xubywgY2FsbGVyTmFtZSwgY2FsbGVyQXJncywgYm9keSk7IC8vIGFkZCB0aGUgYWRkaXRpb25hbCBjYWxsZXIga3dhcmcsIGFkZGluZyBrd2FyZ3MgaWYgbmVjZXNzYXJ5XG5cbiAgICB2YXIgYXJncyA9IG1hY3JvQ2FsbC5hcmdzLmNoaWxkcmVuO1xuXG4gICAgaWYgKCEoYXJnc1thcmdzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2Ygbm9kZXMuS2V5d29yZEFyZ3MpKSB7XG4gICAgICBhcmdzLnB1c2gobmV3IG5vZGVzLktleXdvcmRBcmdzKCkpO1xuICAgIH1cblxuICAgIHZhciBrd2FyZ3MgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAga3dhcmdzLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKGNhbGxUb2subGluZW5vLCBjYWxsVG9rLmNvbG5vLCBjYWxsZXJOYW1lLCBjYWxsZXJOb2RlKSk7XG4gICAgcmV0dXJuIG5ldyBub2Rlcy5PdXRwdXQoY2FsbFRvay5saW5lbm8sIGNhbGxUb2suY29sbm8sIFttYWNyb0NhbGxdKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VXaXRoQ29udGV4dCA9IGZ1bmN0aW9uIHBhcnNlV2l0aENvbnRleHQoKSB7XG4gICAgdmFyIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgdmFyIHdpdGhDb250ZXh0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ3dpdGgnKSkge1xuICAgICAgd2l0aENvbnRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwU3ltYm9sKCd3aXRob3V0JykpIHtcbiAgICAgIHdpdGhDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHdpdGhDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnY29udGV4dCcpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBleHBlY3RlZCBjb250ZXh0IGFmdGVyIHdpdGgvd2l0aG91dCcsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpdGhDb250ZXh0O1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUltcG9ydCA9IGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAgIHZhciBpbXBvcnRUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2ltcG9ydCcpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlSW1wb3J0OiBleHBlY3RlZCBpbXBvcnQnLCBpbXBvcnRUb2subGluZW5vLCBpbXBvcnRUb2suY29sbm8pO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnYXMnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUltcG9ydDogZXhwZWN0ZWQgXCJhc1wiIGtleXdvcmQnLCBpbXBvcnRUb2subGluZW5vLCBpbXBvcnRUb2suY29sbm8pO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHZhciB3aXRoQ29udGV4dCA9IHRoaXMucGFyc2VXaXRoQ29udGV4dCgpO1xuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkltcG9ydChpbXBvcnRUb2subGluZW5vLCBpbXBvcnRUb2suY29sbm8sIHRlbXBsYXRlLCB0YXJnZXQsIHdpdGhDb250ZXh0KTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGltcG9ydFRvay52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRnJvbSA9IGZ1bmN0aW9uIHBhcnNlRnJvbSgpIHtcbiAgICB2YXIgZnJvbVRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnZnJvbScpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgZnJvbScpO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnaW1wb3J0JykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBleHBlY3RlZCBpbXBvcnQnLCBmcm9tVG9rLmxpbmVubywgZnJvbVRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzID0gbmV3IG5vZGVzLk5vZGVMaXN0KCk7XG4gICAgdmFyIHdpdGhDb250ZXh0O1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB2YXIgbmV4dFRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICAgIGlmIChuZXh0VG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX0VORCkge1xuICAgICAgICBpZiAoIW5hbWVzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgaW1wb3J0IG5hbWUnLCBmcm9tVG9rLmxpbmVubywgZnJvbVRvay5jb2xubyk7XG4gICAgICAgIH0gLy8gU2luY2Ugd2UgYXJlIG1hbnVhbGx5IGFkdmFuY2luZyBwYXN0IHRoZSBibG9jayBlbmQsXG4gICAgICAgIC8vIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB3aGl0ZXNwYWNlIGNvbnRyb2wgKG5vcm1hbGx5XG4gICAgICAgIC8vIHRoaXMgaXMgZG9uZSBpbiBgYWR2YW5jZUFmdGVyQmxvY2tFbmRgXG5cblxuICAgICAgICBpZiAobmV4dFRvay52YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZXMuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgY29tbWEnLCBmcm9tVG9rLmxpbmVubywgZnJvbVRvay5jb2xubyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcblxuICAgICAgaWYgKG5hbWUudmFsdWUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IG5hbWVzIHN0YXJ0aW5nIHdpdGggYW4gdW5kZXJzY29yZSBjYW5ub3QgYmUgaW1wb3J0ZWQnLCBuYW1lLmxpbmVubywgbmFtZS5jb2xubyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2FzJykpIHtcbiAgICAgICAgdmFyIGFsaWFzID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgICAgbmFtZXMuYWRkQ2hpbGQobmV3IG5vZGVzLlBhaXIobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIG5hbWUsIGFsaWFzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcy5hZGRDaGlsZChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2l0aENvbnRleHQgPSB0aGlzLnBhcnNlV2l0aENvbnRleHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLkZyb21JbXBvcnQoZnJvbVRvay5saW5lbm8sIGZyb21Ub2suY29sbm8sIHRlbXBsYXRlLCBuYW1lcywgd2l0aENvbnRleHQpO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUJsb2NrID0gZnVuY3Rpb24gcGFyc2VCbG9jaygpIHtcbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdibG9jaycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlQmxvY2s6IGV4cGVjdGVkIGJsb2NrJywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5CbG9jayh0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG5cbiAgICBpZiAoIShub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5TeW1ib2wpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlQmxvY2s6IHZhcmlhYmxlIG5hbWUgZXhwZWN0ZWQnLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGJsb2NrJyk7XG4gICAgdGhpcy5za2lwU3ltYm9sKCdlbmRibG9jaycpO1xuICAgIHRoaXMuc2tpcFN5bWJvbChub2RlLm5hbWUudmFsdWUpO1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0b2spIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VCbG9jazogZXhwZWN0ZWQgZW5kYmxvY2ssIGdvdCBlbmQgb2YgZmlsZScpO1xuICAgIH1cblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodG9rLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VFeHRlbmRzID0gZnVuY3Rpb24gcGFyc2VFeHRlbmRzKCkge1xuICAgIHZhciB0YWdOYW1lID0gJ2V4dGVuZHMnO1xuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2wodGFnTmFtZSkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VUZW1wbGF0ZVJlZjogZXhwZWN0ZWQgJyArIHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkV4dGVuZHModGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICBub2RlLnRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSW5jbHVkZSA9IGZ1bmN0aW9uIHBhcnNlSW5jbHVkZSgpIHtcbiAgICB2YXIgdGFnTmFtZSA9ICdpbmNsdWRlJztcbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKHRhZ05hbWUpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlSW5jbHVkZTogZXhwZWN0ZWQgJyArIHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG5vZGVzLkluY2x1ZGUodGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICBub2RlLnRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2lnbm9yZScpICYmIHRoaXMuc2tpcFN5bWJvbCgnbWlzc2luZycpKSB7XG4gICAgICBub2RlLmlnbm9yZU1pc3NpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJZiA9IGZ1bmN0aW9uIHBhcnNlSWYoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpZicpIHx8IHRoaXMuc2tpcFN5bWJvbCgnZWxpZicpIHx8IHRoaXMuc2tpcFN5bWJvbCgnZWxzZWlmJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSWYodGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaWZBc3luYycpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLklmQXN5bmModGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUlmOiBleHBlY3RlZCBpZiwgZWxpZiwgb3IgZWxzZWlmJywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICBub2RlLmNvbmQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VsaWYnLCAnZWxzZWlmJywgJ2Vsc2UnLCAnZW5kaWYnKTtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIHN3aXRjaCAodG9rICYmIHRvay52YWx1ZSkge1xuICAgICAgY2FzZSAnZWxzZWlmJzpcbiAgICAgIGNhc2UgJ2VsaWYnOlxuICAgICAgICBub2RlLmVsc2VfID0gdGhpcy5wYXJzZUlmKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbHNlJzpcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBub2RlLmVsc2VfID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRpZicpO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlbmRpZic6XG4gICAgICAgIG5vZGUuZWxzZV8gPSBudWxsO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlSWY6IGV4cGVjdGVkIGVsaWYsIGVsc2UsIG9yIGVuZGlmLCBnb3QgZW5kIG9mIGZpbGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTZXQgPSBmdW5jdGlvbiBwYXJzZVNldCgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdzZXQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZVNldDogZXhwZWN0ZWQgc2V0JywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5TZXQodGFnLmxpbmVubywgdGFnLmNvbG5vLCBbXSk7XG4gICAgdmFyIHRhcmdldDtcblxuICAgIHdoaWxlICh0YXJnZXQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpKSB7XG4gICAgICBub2RlLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuXG4gICAgICBpZiAoIXRoaXMuc2tpcChsZXhlci5UT0tFTl9DT01NQSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJz0nKSkge1xuICAgICAgaWYgKCF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQkxPQ0tfRU5EKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU2V0OiBleHBlY3RlZCA9IG9yIGJsb2NrIGVuZCBpbiBzZXQgdGFnJywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuYm9keSA9IG5ldyBub2Rlcy5DYXB0dXJlKHRhZy5saW5lbm8sIHRhZy5jb2xubywgdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRzZXQnKSk7XG4gICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0YWcudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN3aXRjaCA9IGZ1bmN0aW9uIHBhcnNlU3dpdGNoKCkge1xuICAgIC8qXG4gICAgICogU3RvcmUgdGhlIHRhZyBuYW1lcyBpbiB2YXJpYWJsZXMgaW4gY2FzZSBzb21lb25lIGV2ZXIgd2FudHMgdG9cbiAgICAgKiBjdXN0b21pemUgdGhpcy5cbiAgICAgKi9cbiAgICB2YXIgc3dpdGNoU3RhcnQgPSAnc3dpdGNoJztcbiAgICB2YXIgc3dpdGNoRW5kID0gJ2VuZHN3aXRjaCc7XG4gICAgdmFyIGNhc2VTdGFydCA9ICdjYXNlJztcbiAgICB2YXIgY2FzZURlZmF1bHQgPSAnZGVmYXVsdCc7IC8vIEdldCB0aGUgc3dpdGNoIHRhZy5cblxuICAgIHZhciB0YWcgPSB0aGlzLnBlZWtUb2tlbigpOyAvLyBmYWlsIGVhcmx5IGlmIHdlIGdldCBzb21lIHVuZXhwZWN0ZWQgdGFnLlxuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woc3dpdGNoU3RhcnQpICYmICF0aGlzLnNraXBTeW1ib2woY2FzZVN0YXJ0KSAmJiAhdGhpcy5za2lwU3ltYm9sKGNhc2VEZWZhdWx0KSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZVN3aXRjaDogZXhwZWN0ZWQgXCJzd2l0Y2gsXCIgXCJjYXNlXCIgb3IgXCJkZWZhdWx0XCInLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH0gLy8gcGFyc2UgdGhlIHN3aXRjaCBleHByZXNzaW9uXG5cblxuICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgLy8gYWR2YW5jZSB1bnRpbCBhIHN0YXJ0IG9mIGEgY2FzZSwgYSBkZWZhdWx0IGNhc2Ugb3IgYW4gZW5kc3dpdGNoLlxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChzd2l0Y2hTdGFydCk7XG4gICAgdGhpcy5wYXJzZVVudGlsQmxvY2tzKGNhc2VTdGFydCwgY2FzZURlZmF1bHQsIHN3aXRjaEVuZCk7IC8vIHRoaXMgaXMgdGhlIGZpcnN0IGNhc2UuIGl0IGNvdWxkIGFsc28gYmUgYW4gZW5kc3dpdGNoLCB3ZSdsbCBjaGVjay5cblxuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpOyAvLyBjcmVhdGUgbmV3IHZhcmlhYmxlcyBmb3Igb3VyIGNhc2VzIGFuZCBkZWZhdWx0IGNhc2UuXG5cbiAgICB2YXIgY2FzZXMgPSBbXTtcbiAgICB2YXIgZGVmYXVsdENhc2U7IC8vIHdoaWxlIHdlJ3JlIGRlYWxpbmcgd2l0aCBuZXcgY2FzZXMgbm9kZXMuLi5cblxuICAgIGRvIHtcbiAgICAgIC8vIHNraXAgdGhlIHN0YXJ0IHN5bWJvbCBhbmQgZ2V0IHRoZSBjYXNlIGV4cHJlc3Npb25cbiAgICAgIHRoaXMuc2tpcFN5bWJvbChjYXNlU3RhcnQpO1xuICAgICAgdmFyIGNvbmQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChzd2l0Y2hTdGFydCk7IC8vIGdldCB0aGUgYm9keSBvZiB0aGUgY2FzZSBub2RlIGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIGNhc2VzLlxuXG4gICAgICB2YXIgYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcyhjYXNlU3RhcnQsIGNhc2VEZWZhdWx0LCBzd2l0Y2hFbmQpO1xuICAgICAgY2FzZXMucHVzaChuZXcgbm9kZXMuQ2FzZSh0b2subGluZSwgdG9rLmNvbCwgY29uZCwgYm9keSkpOyAvLyBnZXQgb3VyIG5leHQgY2FzZVxuXG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIH0gd2hpbGUgKHRvayAmJiB0b2sudmFsdWUgPT09IGNhc2VTdGFydCk7IC8vIHdlIGVpdGhlciBoYXZlIGEgZGVmYXVsdCBjYXNlIG9yIGEgc3dpdGNoIGVuZC5cblxuXG4gICAgc3dpdGNoICh0b2sudmFsdWUpIHtcbiAgICAgIGNhc2UgY2FzZURlZmF1bHQ6XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgZGVmYXVsdENhc2UgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3Moc3dpdGNoRW5kKTtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBzd2l0Y2hFbmQ6XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG90aGVyd2lzZSBiYWlsIGJlY2F1c2UgRU9GXG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VTd2l0Y2g6IGV4cGVjdGVkIFwiY2FzZSxcIiBcImRlZmF1bHRcIiBvciBcImVuZHN3aXRjaCxcIiBnb3QgRU9GLicpO1xuICAgIH0gLy8gYW5kIHJldHVybiB0aGUgc3dpdGNoIG5vZGUuXG5cblxuICAgIHJldHVybiBuZXcgbm9kZXMuU3dpdGNoKHRhZy5saW5lbm8sIHRhZy5jb2xubywgZXhwciwgY2FzZXMsIGRlZmF1bHRDYXNlKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTdGF0ZW1lbnQgPSBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICh0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fU1lNQk9MKSB7XG4gICAgICB0aGlzLmZhaWwoJ3RhZyBuYW1lIGV4cGVjdGVkJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5icmVha09uQmxvY2tzICYmIGxpYi5pbmRleE9mKHRoaXMuYnJlYWtPbkJsb2NrcywgdG9rLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rLnZhbHVlKSB7XG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJhdygpO1xuXG4gICAgICBjYXNlICd2ZXJiYXRpbSc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmF3KCd2ZXJiYXRpbScpO1xuXG4gICAgICBjYXNlICdpZic6XG4gICAgICBjYXNlICdpZkFzeW5jJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZigpO1xuXG4gICAgICBjYXNlICdmb3InOlxuICAgICAgY2FzZSAnYXN5bmNFYWNoJzpcbiAgICAgIGNhc2UgJ2FzeW5jQWxsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3IoKTtcblxuICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG5cbiAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4dGVuZHMoKTtcblxuICAgICAgY2FzZSAnaW5jbHVkZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW5jbHVkZSgpO1xuXG4gICAgICBjYXNlICdzZXQnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNldCgpO1xuXG4gICAgICBjYXNlICdtYWNybyc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWFjcm8oKTtcblxuICAgICAgY2FzZSAnY2FsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbCgpO1xuXG4gICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydCgpO1xuXG4gICAgICBjYXNlICdmcm9tJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGcm9tKCk7XG5cbiAgICAgIGNhc2UgJ2ZpbHRlcic6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsdGVyU3RhdGVtZW50KCk7XG5cbiAgICAgIGNhc2UgJ3N3aXRjaCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmV4dGVuc2lvbnNbaV07XG5cbiAgICAgICAgICAgIGlmIChsaWIuaW5kZXhPZihleHQudGFncyB8fCBbXSwgdG9rLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dC5wYXJzZSh0aGlzLCBub2RlcywgbGV4ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmFpbCgndW5rbm93biBibG9jayB0YWc6ICcgKyB0b2sudmFsdWUsIHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUmF3ID0gZnVuY3Rpb24gcGFyc2VSYXcodGFnTmFtZSkge1xuICAgIHRhZ05hbWUgPSB0YWdOYW1lIHx8ICdyYXcnO1xuICAgIHZhciBlbmRUYWdOYW1lID0gJ2VuZCcgKyB0YWdOYW1lOyAvLyBMb29rIGZvciB1cGNvbWluZyByYXcgYmxvY2tzIChpZ25vcmUgYWxsIG90aGVyIGtpbmRzIG9mIGJsb2NrcylcblxuICAgIHZhciByYXdCbG9ja1JlZ2V4ID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KXslXFxcXHMqKCcgKyB0YWdOYW1lICsgJ3wnICsgZW5kVGFnTmFtZSArICcpXFxcXHMqKD89JX0pJX0nKTtcbiAgICB2YXIgcmF3TGV2ZWwgPSAxO1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgbWF0Y2hlcyA9IG51bGw7IC8vIFNraXAgb3BlbmluZyByYXcgdG9rZW5cbiAgICAvLyBLZWVwIHRoaXMgdG9rZW4gdG8gdHJhY2sgbGluZSBhbmQgY29sdW1uIG51bWJlcnNcblxuICAgIHZhciBiZWd1biA9IHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTsgLy8gRXhpdCB3aGVuIHRoZXJlJ3Mgbm90aGluZyB0byBtYXRjaFxuICAgIC8vIG9yIHdoZW4gd2UndmUgZm91bmQgdGhlIG1hdGNoaW5nIFwiZW5kcmF3XCIgYmxvY2tcblxuICAgIHdoaWxlICgobWF0Y2hlcyA9IHRoaXMudG9rZW5zLl9leHRyYWN0UmVnZXgocmF3QmxvY2tSZWdleCkpICYmIHJhd0xldmVsID4gMCkge1xuICAgICAgdmFyIGFsbCA9IG1hdGNoZXNbMF07XG4gICAgICB2YXIgcHJlID0gbWF0Y2hlc1sxXTtcbiAgICAgIHZhciBibG9ja05hbWUgPSBtYXRjaGVzWzJdOyAvLyBBZGp1c3QgcmF3bGV2ZWxcblxuICAgICAgaWYgKGJsb2NrTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgICByYXdMZXZlbCArPSAxO1xuICAgICAgfSBlbHNlIGlmIChibG9ja05hbWUgPT09IGVuZFRhZ05hbWUpIHtcbiAgICAgICAgcmF3TGV2ZWwgLT0gMTtcbiAgICAgIH0gLy8gQWRkIHRvIHN0clxuXG5cbiAgICAgIGlmIChyYXdMZXZlbCA9PT0gMCkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGV4Y2x1ZGUgdGhlIGxhc3QgXCJlbmRyYXdcIlxuICAgICAgICBzdHIgKz0gcHJlOyAvLyBNb3ZlIHRva2VuaXplciB0byBiZWdpbm5pbmcgb2YgZW5kcmF3IGJsb2NrXG5cbiAgICAgICAgdGhpcy50b2tlbnMuYmFja04oYWxsLmxlbmd0aCAtIHByZS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGFsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLk91dHB1dChiZWd1bi5saW5lbm8sIGJlZ3VuLmNvbG5vLCBbbmV3IG5vZGVzLlRlbXBsYXRlRGF0YShiZWd1bi5saW5lbm8sIGJlZ3VuLmNvbG5vLCBzdHIpXSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUG9zdGZpeCA9IGZ1bmN0aW9uIHBhcnNlUG9zdGZpeChub2RlKSB7XG4gICAgdmFyIGxvb2t1cDtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIHdoaWxlICh0b2spIHtcbiAgICAgIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRnVuQ2FsbCh0b2subGluZW5vLCB0b2suY29sbm8sIG5vZGUsIHRoaXMucGFyc2VTaWduYXR1cmUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9MRUZUX0JSQUNLRVQpIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgIGxvb2t1cCA9IHRoaXMucGFyc2VBZ2dyZWdhdGUoKTtcblxuICAgICAgICBpZiAobG9va3VwLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ2ludmFsaWQgaW5kZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTG9va3VwVmFsKHRvay5saW5lbm8sIHRvay5jb2xubywgbm9kZSwgbG9va3VwLmNoaWxkcmVuWzBdKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX09QRVJBVE9SICYmIHRvay52YWx1ZSA9PT0gJy4nKSB7XG4gICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgICAgICBpZiAodmFsLnR5cGUgIT09IGxleGVyLlRPS0VOX1NZTUJPTCkge1xuICAgICAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgbmFtZSBhcyBsb29rdXAgdmFsdWUsIGdvdCAnICsgdmFsLnZhbHVlLCB2YWwubGluZW5vLCB2YWwuY29sbm8pO1xuICAgICAgICB9IC8vIE1ha2UgYSBsaXRlcmFsIHN0cmluZyBiZWNhdXNlIGl0J3Mgbm90IGEgdmFyaWFibGVcbiAgICAgICAgLy8gcmVmZXJlbmNlXG5cblxuICAgICAgICBsb29rdXAgPSBuZXcgbm9kZXMuTGl0ZXJhbCh2YWwubGluZW5vLCB2YWwuY29sbm8sIHZhbC52YWx1ZSk7XG4gICAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTG9va3VwVmFsKHRvay5saW5lbm8sIHRvay5jb2xubywgbm9kZSwgbG9va3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlSW5saW5lSWYoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VJbmxpbmVJZiA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lSWYoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlT3IoKTtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2lmJykpIHtcbiAgICAgIHZhciBjb25kTm9kZSA9IHRoaXMucGFyc2VPcigpO1xuICAgICAgdmFyIGJvZHlOb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSW5saW5lSWYobm9kZS5saW5lbm8sIG5vZGUuY29sbm8pO1xuICAgICAgbm9kZS5ib2R5ID0gYm9keU5vZGU7XG4gICAgICBub2RlLmNvbmQgPSBjb25kTm9kZTtcblxuICAgICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnZWxzZScpKSB7XG4gICAgICAgIG5vZGUuZWxzZV8gPSB0aGlzLnBhcnNlT3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZWxzZV8gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU9yID0gZnVuY3Rpb24gcGFyc2VPcigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VBbmQoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBTeW1ib2woJ29yJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VBbmQoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuT3Iobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VBbmQgPSBmdW5jdGlvbiBwYXJzZUFuZCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VOb3QoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBTeW1ib2woJ2FuZCcpKSB7XG4gICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlTm90KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkFuZChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZU5vdCA9IGZ1bmN0aW9uIHBhcnNlTm90KCkge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnbm90JykpIHtcbiAgICAgIHJldHVybiBuZXcgbm9kZXMuTm90KHRvay5saW5lbm8sIHRvay5jb2xubywgdGhpcy5wYXJzZU5vdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZUluKCk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlSW4gPSBmdW5jdGlvbiBwYXJzZUluKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5wYXJzZUlzKCk7XG5cbiAgICB3aGlsZSAoMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZXh0IHRva2VuIGlzICdub3QnXG4gICAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgICAgaWYgKCF0b2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnZlcnQgPSB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fU1lNQk9MICYmIHRvay52YWx1ZSA9PT0gJ25vdCc7IC8vIGlmIGl0IHdhc24ndCAnbm90JywgcHV0IGl0IGJhY2tcblxuICAgICAgaWYgKCFpbnZlcnQpIHtcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaW4nKSkge1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnBhcnNlSXMoKTtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Jbihub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV3IG5vZGVzLk5vdChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlJ2QgZm91bmQgYSAnbm90JyBidXQgdGhpcyB3YXNuJ3QgYW4gJ2luJywgcHV0IGJhY2sgdGhlICdub3QnXG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0gLy8gSSBwdXQgdGhpcyByaWdodCBhZnRlciBcImluXCIgaW4gdGhlIG9wZXJhdG9yIHByZWNlZGVuY2Ugc3RhY2suIFRoYXQgY2FuXG4gIC8vIG9idmlvdXNseSBiZSBjaGFuZ2VkIHRvIGJlIGNsb3NlciB0byBKaW5qYS5cbiAgO1xuXG4gIF9wcm90by5wYXJzZUlzID0gZnVuY3Rpb24gcGFyc2VJcygpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VDb21wYXJlKCk7IC8vIGxvb2sgZm9yIGFuIGlzXG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpcycpKSB7XG4gICAgICAvLyBsb29rIGZvciBhIG5vdFxuICAgICAgdmFyIG5vdCA9IHRoaXMuc2tpcFN5bWJvbCgnbm90Jyk7IC8vIGdldCB0aGUgbmV4dCBub2RlXG5cbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VDb21wYXJlKCk7IC8vIGNyZWF0ZSBhbiBJcyBub2RlIHVzaW5nIHRoZSBuZXh0IG5vZGUgYW5kIHRoZSBpbmZvIGZyb20gb3VyIElzIG5vZGUuXG5cbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSXMobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTsgLy8gaWYgd2UgaGF2ZSBhIE5vdCwgY3JlYXRlIGEgTm90IG5vZGUgZnJvbSBvdXIgSXMgbm9kZS5cblxuICAgICAgaWYgKG5vdCkge1xuICAgICAgICBub2RlID0gbmV3IG5vZGVzLk5vdChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSk7XG4gICAgICB9XG4gICAgfSAvLyByZXR1cm4gdGhlIG5vZGUuXG5cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUNvbXBhcmUgPSBmdW5jdGlvbiBwYXJzZUNvbXBhcmUoKSB7XG4gICAgdmFyIGNvbXBhcmVPcHMgPSBbJz09JywgJz09PScsICchPScsICchPT0nLCAnPCcsICc+JywgJzw9JywgJz49J107XG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlQ29uY2F0KCk7XG4gICAgdmFyIG9wcyA9IFtdO1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgICAgaWYgKCF0b2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmVPcHMuaW5kZXhPZih0b2sudmFsdWUpICE9PSAtMSkge1xuICAgICAgICBvcHMucHVzaChuZXcgbm9kZXMuQ29tcGFyZU9wZXJhbmQodG9rLmxpbmVubywgdG9rLmNvbG5vLCB0aGlzLnBhcnNlQ29uY2F0KCksIHRvay52YWx1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgbm9kZXMuQ29tcGFyZShvcHNbMF0ubGluZW5vLCBvcHNbMF0uY29sbm8sIGV4cHIsIG9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgfSAvLyBmaW5kcyB0aGUgJ34nIGZvciBzdHJpbmcgY29uY2F0ZW5hdGlvblxuICA7XG5cbiAgX3Byb3RvLnBhcnNlQ29uY2F0ID0gZnVuY3Rpb24gcGFyc2VDb25jYXQoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlQWRkKCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fVElMREUsICd+JykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VBZGQoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQ29uY2F0KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQWRkID0gZnVuY3Rpb24gcGFyc2VBZGQoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlU3ViKCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcrJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VTdWIoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQWRkKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlU3ViID0gZnVuY3Rpb24gcGFyc2VTdWIoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlTXVsKCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICctJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VNdWwoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU3ViKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTXVsID0gZnVuY3Rpb24gcGFyc2VNdWwoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlRGl2KCk7XG5cbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcqJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VEaXYoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuTXVsKG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBub2RlLCBub2RlMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRGl2ID0gZnVuY3Rpb24gcGFyc2VEaXYoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnBhcnNlRmxvb3JEaXYoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy8nKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZUZsb29yRGl2KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkRpdihub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUZsb29yRGl2ID0gZnVuY3Rpb24gcGFyc2VGbG9vckRpdigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VNb2QoKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy8vJykpIHtcbiAgICAgIHZhciBub2RlMiA9IHRoaXMucGFyc2VNb2QoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRmxvb3JEaXYobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VNb2QgPSBmdW5jdGlvbiBwYXJzZU1vZCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VQb3coKTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJyUnKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZVBvdygpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Nb2Qobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUsIG5vZGUyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VQb3cgPSBmdW5jdGlvbiBwYXJzZVBvdygpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VVbmFyeSgpO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnKionKSkge1xuICAgICAgdmFyIG5vZGUyID0gdGhpcy5wYXJzZVVuYXJ5KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlBvdyhub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVVuYXJ5ID0gZnVuY3Rpb24gcGFyc2VVbmFyeShub0ZpbHRlcnMpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy0nKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5OZWcodG9rLmxpbmVubywgdG9rLmNvbG5vLCB0aGlzLnBhcnNlVW5hcnkodHJ1ZSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcrJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuUG9zKHRvay5saW5lbm8sIHRvay5jb2xubywgdGhpcy5wYXJzZVVuYXJ5KHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgfVxuXG4gICAgaWYgKCFub0ZpbHRlcnMpIHtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRmlsdGVyKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiBwYXJzZVByaW1hcnkobm9Qb3N0Zml4KSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgdmFyIHZhbDtcbiAgICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgICBpZiAoIXRvaykge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBleHByZXNzaW9uLCBnb3QgZW5kIG9mIGZpbGUnKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9TVFJJTkcpIHtcbiAgICAgIHZhbCA9IHRvay52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9JTlQpIHtcbiAgICAgIHZhbCA9IHBhcnNlSW50KHRvay52YWx1ZSwgMTApO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0ZMT0FUKSB7XG4gICAgICB2YWwgPSBwYXJzZUZsb2F0KHRvay52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQk9PTEVBTikge1xuICAgICAgaWYgKHRvay52YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHZhbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRvay52YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICB2YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFpbCgnaW52YWxpZCBib29sZWFuOiAnICsgdG9rLnZhbHVlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX05PTkUpIHtcbiAgICAgIHZhbCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fUkVHRVgpIHtcbiAgICAgIHZhbCA9IG5ldyBSZWdFeHAodG9rLnZhbHVlLmJvZHksIHRvay52YWx1ZS5mbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkxpdGVyYWwodG9rLmxpbmVubywgdG9rLmNvbG5vLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1NZTUJPTCkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TeW1ib2wodG9rLmxpbmVubywgdG9rLmNvbG5vLCB0b2sudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWUgaWYgaXQncyBhbiBhZ2dyZWdhdGUgdHlwZSwgd2UgbmVlZCB0byBwdXNoIHRoZVxuICAgICAgLy8gY3VycmVudCBkZWxpbWl0ZXIgdG9rZW4gYmFjayBvblxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlQWdncmVnYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFub1Bvc3RmaXgpIHtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlUG9zdGZpeChub2RlKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3IoXCJ1bmV4cGVjdGVkIHRva2VuOiBcIiArIHRvay52YWx1ZSwgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRmlsdGVyTmFtZSA9IGZ1bmN0aW9uIHBhcnNlRmlsdGVyTmFtZSgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5leHBlY3QobGV4ZXIuVE9LRU5fU1lNQk9MKTtcbiAgICB2YXIgbmFtZSA9IHRvay52YWx1ZTtcblxuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy4nKSkge1xuICAgICAgbmFtZSArPSAnLicgKyB0aGlzLmV4cGVjdChsZXhlci5UT0tFTl9TWU1CT0wpLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbm9kZXMuU3ltYm9sKHRvay5saW5lbm8sIHRvay5jb2xubywgbmFtZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlRmlsdGVyQXJncyA9IGZ1bmN0aW9uIHBhcnNlRmlsdGVyQXJncyhub2RlKSB7XG4gICAgaWYgKHRoaXMucGVla1Rva2VuKCkudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgLy8gR2V0IGEgRnVuQ2FsbCBub2RlIGFuZCBhZGQgdGhlIHBhcmFtZXRlcnMgdG8gdGhlXG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIHZhciBjYWxsID0gdGhpcy5wYXJzZVBvc3RmaXgobm9kZSk7XG4gICAgICByZXR1cm4gY2FsbC5hcmdzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGaWx0ZXIgPSBmdW5jdGlvbiBwYXJzZUZpbHRlcihub2RlKSB7XG4gICAgd2hpbGUgKHRoaXMuc2tpcChsZXhlci5UT0tFTl9QSVBFKSkge1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlRmlsdGVyTmFtZSgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5GaWx0ZXIobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIG5hbWUsIG5ldyBub2Rlcy5Ob2RlTGlzdChuYW1lLmxpbmVubywgbmFtZS5jb2xubywgW25vZGVdLmNvbmNhdCh0aGlzLnBhcnNlRmlsdGVyQXJncyhub2RlKSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VGaWx0ZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbiBwYXJzZUZpbHRlclN0YXRlbWVudCgpIHtcbiAgICB2YXIgZmlsdGVyVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdmaWx0ZXInKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZpbHRlclN0YXRlbWVudDogZXhwZWN0ZWQgZmlsdGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSB0aGlzLnBhcnNlRmlsdGVyTmFtZSgpO1xuICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUZpbHRlckFyZ3MobmFtZSk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChmaWx0ZXJUb2sudmFsdWUpO1xuICAgIHZhciBib2R5ID0gbmV3IG5vZGVzLkNhcHR1cmUobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kZmlsdGVyJykpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBub2Rlcy5GaWx0ZXIobmFtZS5saW5lbm8sIG5hbWUuY29sbm8sIG5hbWUsIG5ldyBub2Rlcy5Ob2RlTGlzdChuYW1lLmxpbmVubywgbmFtZS5jb2xubywgW2JvZHldLmNvbmNhdChhcmdzKSkpO1xuICAgIHJldHVybiBuZXcgbm9kZXMuT3V0cHV0KG5hbWUubGluZW5vLCBuYW1lLmNvbG5vLCBbbm9kZV0pO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZUFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIHBhcnNlQWdncmVnYXRlKCkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgIHZhciBub2RlO1xuXG4gICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgY2FzZSBsZXhlci5UT0tFTl9MRUZUX1BBUkVOOlxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkdyb3VwKHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGxleGVyLlRPS0VOX0xFRlRfQlJBQ0tFVDpcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5BcnJheSh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBsZXhlci5UT0tFTl9MRUZUX0NVUkxZOlxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkRpY3QodG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgdmFyIHR5cGUgPSB0aGlzLnBlZWtUb2tlbigpLnR5cGU7XG5cbiAgICAgIGlmICh0eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9QQVJFTiB8fCB0eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9CUkFDS0VUIHx8IHR5cGUgPT09IGxleGVyLlRPS0VOX1JJR0hUX0NVUkxZKSB7XG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VBZ2dyZWdhdGU6IGV4cGVjdGVkIGNvbW1hIGFmdGVyIGV4cHJlc3Npb24nLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRGljdCkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXJyb3JzXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnBhcnNlUHJpbWFyeSgpOyAvLyBXZSBleHBlY3QgYSBrZXkvdmFsdWUgcGFpciBmb3IgZGljdHMsIHNlcGFyYXRlZCBieSBhXG4gICAgICAgIC8vIGNvbG9uXG5cbiAgICAgICAgaWYgKCF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09MT04pKSB7XG4gICAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUFnZ3JlZ2F0ZTogZXhwZWN0ZWQgY29sb24gYWZ0ZXIgZGljdCBrZXknLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICB9IC8vIFRPRE86IGNoZWNrIGZvciBlcnJvcnNcblxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIG5vZGUuYWRkQ2hpbGQobmV3IG5vZGVzLlBhaXIoa2V5LmxpbmVubywga2V5LmNvbG5vLCBrZXksIHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXJyb3JzXG4gICAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgbm9kZS5hZGRDaGlsZChleHByKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VTaWduYXR1cmUgPSBmdW5jdGlvbiBwYXJzZVNpZ25hdHVyZSh0b2xlcmFudCwgbm9QYXJlbnMpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgIGlmICghbm9QYXJlbnMgJiYgdG9rLnR5cGUgIT09IGxleGVyLlRPS0VOX0xFRlRfUEFSRU4pIHtcbiAgICAgIGlmICh0b2xlcmFudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFpbCgnZXhwZWN0ZWQgYXJndW1lbnRzJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0xFRlRfUEFSRU4pIHtcbiAgICAgIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBuZXcgbm9kZXMuTm9kZUxpc3QodG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB2YXIga3dhcmdzID0gbmV3IG5vZGVzLktleXdvcmRBcmdzKHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgdmFyIGNoZWNrQ29tbWEgPSBmYWxzZTtcblxuICAgIHdoaWxlICgxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcblxuICAgICAgaWYgKCFub1BhcmVucyAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fUklHSFRfUEFSRU4pIHtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG5vUGFyZW5zICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19FTkQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NvbW1hICYmICF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VTaWduYXR1cmU6IGV4cGVjdGVkIGNvbW1hIGFmdGVyIGV4cHJlc3Npb24nLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZyA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnPScpKSB7XG4gICAgICAgICAga3dhcmdzLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKGFyZy5saW5lbm8sIGFyZy5jb2xubywgYXJnLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJncy5hZGRDaGlsZChhcmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoZWNrQ29tbWEgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChrd2FyZ3MuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBhcmdzLmFkZENoaWxkKGt3YXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlVW50aWxCbG9ja3MgPSBmdW5jdGlvbiBwYXJzZVVudGlsQmxvY2tzKCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5icmVha09uQmxvY2tzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGJsb2NrTmFtZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBibG9ja05hbWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMuYnJlYWtPbkJsb2NrcyA9IGJsb2NrTmFtZXM7XG4gICAgdmFyIHJldCA9IHRoaXMucGFyc2UoKTtcbiAgICB0aGlzLmJyZWFrT25CbG9ja3MgPSBwcmV2O1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTm9kZXMgPSBmdW5jdGlvbiBwYXJzZU5vZGVzKCkge1xuICAgIHZhciB0b2s7XG4gICAgdmFyIGJ1ZiA9IFtdO1xuXG4gICAgd2hpbGUgKHRvayA9IHRoaXMubmV4dFRva2VuKCkpIHtcbiAgICAgIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fREFUQSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRvay52YWx1ZTtcbiAgICAgICAgdmFyIG5leHRUb2tlbiA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgICAgIHZhciBuZXh0VmFsID0gbmV4dFRva2VuICYmIG5leHRUb2tlbi52YWx1ZTsgLy8gSWYgdGhlIGxhc3QgdG9rZW4gaGFzIFwiLVwiIHdlIG5lZWQgdG8gdHJpbSB0aGVcbiAgICAgICAgLy8gbGVhZGluZyB3aGl0ZXNwYWNlIG9mIHRoZSBkYXRhLiBUaGlzIGlzIG1hcmtlZCB3aXRoXG4gICAgICAgIC8vIHRoZSBgZHJvcExlYWRpbmdXaGl0ZXNwYWNlYCB2YXJpYWJsZS5cblxuICAgICAgICBpZiAodGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGNvdWxkIGJlIG9wdGltaXplZCAoZG9uJ3QgdXNlIHJlZ2V4KVxuICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoL15cXHMqLywgJycpO1xuICAgICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgIH0gLy8gU2FtZSBmb3IgdGhlIHN1Y2NlZWRpbmcgYmxvY2sgc3RhcnQgdG9rZW5cblxuXG4gICAgICAgIGlmIChuZXh0VG9rZW4gJiYgKG5leHRUb2tlbi50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19TVEFSVCAmJiBuZXh0VmFsLmNoYXJBdChuZXh0VmFsLmxlbmd0aCAtIDEpID09PSAnLScgfHwgbmV4dFRva2VuLnR5cGUgPT09IGxleGVyLlRPS0VOX1ZBUklBQkxFX1NUQVJUICYmIG5leHRWYWwuY2hhckF0KHRoaXMudG9rZW5zLnRhZ3MuVkFSSUFCTEVfU1RBUlQubGVuZ3RoKSA9PT0gJy0nIHx8IG5leHRUb2tlbi50eXBlID09PSBsZXhlci5UT0tFTl9DT01NRU5UICYmIG5leHRWYWwuY2hhckF0KHRoaXMudG9rZW5zLnRhZ3MuQ09NTUVOVF9TVEFSVC5sZW5ndGgpID09PSAnLScpKSB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgKGRvbid0IHVzZSByZWdleClcbiAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Zi5wdXNoKG5ldyBub2Rlcy5PdXRwdXQodG9rLmxpbmVubywgdG9rLmNvbG5vLCBbbmV3IG5vZGVzLlRlbXBsYXRlRGF0YSh0b2subGluZW5vLCB0b2suY29sbm8sIGRhdGEpXSkpO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG5cbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBidWYucHVzaChuKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1ZBUklBQkxFX1NUQVJUKSB7XG4gICAgICAgIHZhciBlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJWYXJpYWJsZUVuZCgpO1xuICAgICAgICBidWYucHVzaChuZXcgbm9kZXMuT3V0cHV0KHRvay5saW5lbm8sIHRvay5jb2xubywgW2VdKSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9DT01NRU5UKSB7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdG9rLnZhbHVlLmNoYXJBdCh0b2sudmFsdWUubGVuZ3RoIC0gdGhpcy50b2tlbnMudGFncy5DT01NRU5UX0VORC5sZW5ndGggLSAxKSA9PT0gJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWdub3JlIGNvbW1lbnRzLCBvdGhlcndpc2UgdGhpcyBzaG91bGQgYmUgYW4gZXJyb3JcbiAgICAgICAgdGhpcy5mYWlsKCdVbmV4cGVjdGVkIHRva2VuIGF0IHRvcC1sZXZlbDogJyArIHRvay50eXBlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Ob2RlTGlzdCgwLCAwLCB0aGlzLnBhcnNlTm9kZXMoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQXNSb290ID0gZnVuY3Rpb24gcGFyc2VBc1Jvb3QoKSB7XG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Sb290KDAsIDAsIHRoaXMucGFyc2VOb2RlcygpKTtcbiAgfTtcblxuICByZXR1cm4gUGFyc2VyO1xufShPYmopOyAvLyB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbi8vIHZhciBsID0gbGV4ZXIubGV4KCd7JS0gaWYgeCAtJX1cXG4gaGVsbG8geyUgZW5kaWYgJX0nKTtcbi8vIHZhciB0O1xuLy8gd2hpbGUoKHQgPSBsLm5leHRUb2tlbigpKSkge1xuLy8gICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdCh0KSk7XG4vLyB9XG4vLyB2YXIgcCA9IG5ldyBQYXJzZXIobGV4ZXIubGV4KCdoZWxsbyB7JSBmaWx0ZXIgdGl0bGUgJX0nICtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hlbGxvIG1hZGFtIGhvdyBhcmUgeW91JyArXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7JSBlbmRmaWx0ZXIgJX0nKSk7XG4vLyB2YXIgbiA9IHAucGFyc2VBc1Jvb3QoKTtcbi8vIG5vZGVzLnByaW50Tm9kZXMobik7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShzcmMsIGV4dGVuc2lvbnMsIG9wdHMpIHtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIobGV4ZXIubGV4KHNyYywgb3B0cykpO1xuXG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wYXJzZUFzUm9vdCgpO1xuICB9LFxuICBQYXJzZXI6IFBhcnNlclxufTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgd2hpdGVzcGFjZUNoYXJzID0gXCIgXFxuXFx0XFxyXFx4QTBcIjtcbnZhciBkZWxpbUNoYXJzID0gJygpW117fSUqLSt+LyMsOnwuPD49ISc7XG52YXIgaW50Q2hhcnMgPSAnMDEyMzQ1Njc4OSc7XG52YXIgQkxPQ0tfU1RBUlQgPSAneyUnO1xudmFyIEJMT0NLX0VORCA9ICclfSc7XG52YXIgVkFSSUFCTEVfU1RBUlQgPSAne3snO1xudmFyIFZBUklBQkxFX0VORCA9ICd9fSc7XG52YXIgQ09NTUVOVF9TVEFSVCA9ICd7Iyc7XG52YXIgQ09NTUVOVF9FTkQgPSAnI30nO1xudmFyIFRPS0VOX1NUUklORyA9ICdzdHJpbmcnO1xudmFyIFRPS0VOX1dISVRFU1BBQ0UgPSAnd2hpdGVzcGFjZSc7XG52YXIgVE9LRU5fREFUQSA9ICdkYXRhJztcbnZhciBUT0tFTl9CTE9DS19TVEFSVCA9ICdibG9jay1zdGFydCc7XG52YXIgVE9LRU5fQkxPQ0tfRU5EID0gJ2Jsb2NrLWVuZCc7XG52YXIgVE9LRU5fVkFSSUFCTEVfU1RBUlQgPSAndmFyaWFibGUtc3RhcnQnO1xudmFyIFRPS0VOX1ZBUklBQkxFX0VORCA9ICd2YXJpYWJsZS1lbmQnO1xudmFyIFRPS0VOX0NPTU1FTlQgPSAnY29tbWVudCc7XG52YXIgVE9LRU5fTEVGVF9QQVJFTiA9ICdsZWZ0LXBhcmVuJztcbnZhciBUT0tFTl9SSUdIVF9QQVJFTiA9ICdyaWdodC1wYXJlbic7XG52YXIgVE9LRU5fTEVGVF9CUkFDS0VUID0gJ2xlZnQtYnJhY2tldCc7XG52YXIgVE9LRU5fUklHSFRfQlJBQ0tFVCA9ICdyaWdodC1icmFja2V0JztcbnZhciBUT0tFTl9MRUZUX0NVUkxZID0gJ2xlZnQtY3VybHknO1xudmFyIFRPS0VOX1JJR0hUX0NVUkxZID0gJ3JpZ2h0LWN1cmx5JztcbnZhciBUT0tFTl9PUEVSQVRPUiA9ICdvcGVyYXRvcic7XG52YXIgVE9LRU5fQ09NTUEgPSAnY29tbWEnO1xudmFyIFRPS0VOX0NPTE9OID0gJ2NvbG9uJztcbnZhciBUT0tFTl9USUxERSA9ICd0aWxkZSc7XG52YXIgVE9LRU5fUElQRSA9ICdwaXBlJztcbnZhciBUT0tFTl9JTlQgPSAnaW50JztcbnZhciBUT0tFTl9GTE9BVCA9ICdmbG9hdCc7XG52YXIgVE9LRU5fQk9PTEVBTiA9ICdib29sZWFuJztcbnZhciBUT0tFTl9OT05FID0gJ25vbmUnO1xudmFyIFRPS0VOX1NZTUJPTCA9ICdzeW1ib2wnO1xudmFyIFRPS0VOX1NQRUNJQUwgPSAnc3BlY2lhbCc7XG52YXIgVE9LRU5fUkVHRVggPSAncmVnZXgnO1xuXG5mdW5jdGlvbiB0b2tlbih0eXBlLCB2YWx1ZSwgbGluZW5vLCBjb2xubykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGxpbmVubzogbGluZW5vLFxuICAgIGNvbG5vOiBjb2xub1xuICB9O1xufVxuXG52YXIgVG9rZW5pemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9rZW5pemVyKHN0ciwgb3B0cykge1xuICAgIHRoaXMuc3RyID0gc3RyO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMubGVuID0gc3RyLmxlbmd0aDtcbiAgICB0aGlzLmxpbmVubyA9IDA7XG4gICAgdGhpcy5jb2xubyA9IDA7XG4gICAgdGhpcy5pbl9jb2RlID0gZmFsc2U7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHRhZ3MgPSBvcHRzLnRhZ3MgfHwge307XG4gICAgdGhpcy50YWdzID0ge1xuICAgICAgQkxPQ0tfU1RBUlQ6IHRhZ3MuYmxvY2tTdGFydCB8fCBCTE9DS19TVEFSVCxcbiAgICAgIEJMT0NLX0VORDogdGFncy5ibG9ja0VuZCB8fCBCTE9DS19FTkQsXG4gICAgICBWQVJJQUJMRV9TVEFSVDogdGFncy52YXJpYWJsZVN0YXJ0IHx8IFZBUklBQkxFX1NUQVJULFxuICAgICAgVkFSSUFCTEVfRU5EOiB0YWdzLnZhcmlhYmxlRW5kIHx8IFZBUklBQkxFX0VORCxcbiAgICAgIENPTU1FTlRfU1RBUlQ6IHRhZ3MuY29tbWVudFN0YXJ0IHx8IENPTU1FTlRfU1RBUlQsXG4gICAgICBDT01NRU5UX0VORDogdGFncy5jb21tZW50RW5kIHx8IENPTU1FTlRfRU5EXG4gICAgfTtcbiAgICB0aGlzLnRyaW1CbG9ja3MgPSAhIW9wdHMudHJpbUJsb2NrcztcbiAgICB0aGlzLmxzdHJpcEJsb2NrcyA9ICEhb3B0cy5sc3RyaXBCbG9ja3M7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG9rZW5pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubmV4dFRva2VuID0gZnVuY3Rpb24gbmV4dFRva2VuKCkge1xuICAgIHZhciBsaW5lbm8gPSB0aGlzLmxpbmVubztcbiAgICB2YXIgY29sbm8gPSB0aGlzLmNvbG5vO1xuICAgIHZhciB0b2s7XG5cbiAgICBpZiAodGhpcy5pbl9jb2RlKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGlmIHdlIGFyZSBpbiBhIGJsb2NrIHBhcnNlIGl0IGFzIGNvZGVcbiAgICAgIHZhciBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm90aGluZyBlbHNlIHRvIHBhcnNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdcIicgfHwgY3VyID09PSAnXFwnJykge1xuICAgICAgICAvLyBXZSd2ZSBoaXQgYSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1NUUklORywgdGhpcy5fcGFyc2VTdHJpbmcoY3VyKSwgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKHRvayA9IHRoaXMuX2V4dHJhY3Qod2hpdGVzcGFjZUNoYXJzKSkge1xuICAgICAgICAvLyBXZSBoaXQgc29tZSB3aGl0ZXNwYWNlXG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9XSElURVNQQUNFLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmICgodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQkxPQ0tfRU5EKSkgfHwgKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcoJy0nICsgdGhpcy50YWdzLkJMT0NLX0VORCkpKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2hlY2sgZm9yIHRoZSBibG9jayBlbmQgdGFnXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0IGlzIGEgcmVxdWlyZW1lbnQgdGhhdCBzdGFydCBhbmQgZW5kIHRhZ3MgYXJlIGNvbXBvc2VkIG9mXG4gICAgICAgIC8vIGRlbGltaXRlciBjaGFyYWN0ZXJzICgle31bXSBldGMpLCBhbmQgb3VyIGNvZGUgYWx3YXlzXG4gICAgICAgIC8vIGJyZWFrcyBvbiBkZWxpbWl0ZXJzIHNvIHdlIGNhbiBhc3N1bWUgdGhlIHRva2VuIHBhcnNpbmdcbiAgICAgICAgLy8gZG9lc24ndCBjb25zdW1lIHRoZXNlIGVsc2V3aGVyZVxuICAgICAgICB0aGlzLmluX2NvZGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy50cmltQmxvY2tzKSB7XG4gICAgICAgICAgY3VyID0gdGhpcy5jdXJyZW50KCk7XG5cbiAgICAgICAgICBpZiAoY3VyID09PSAnXFxuJykge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXdsaW5lXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgIC8vIFNraXAgQ1JMRiBuZXdsaW5lXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGN1ciA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgICAgICAgICBpZiAoY3VyID09PSAnXFxuJykge1xuICAgICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdhcyBub3QgYSBDUkxGLCBzbyBnbyBiYWNrXG4gICAgICAgICAgICAgIHRoaXMuYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9CTE9DS19FTkQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5WQVJJQUJMRV9FTkQpKSB8fCAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZygnLScgKyB0aGlzLnRhZ3MuVkFSSUFCTEVfRU5EKSkpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjaGVjayBmb3IgdmFyaWFibGUgZW5kIHRhZyAoc2VlIGFib3ZlKVxuICAgICAgICB0aGlzLmluX2NvZGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1ZBUklBQkxFX0VORCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAncicgJiYgdGhpcy5zdHIuY2hhckF0KHRoaXMuaW5kZXggKyAxKSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIFNraXAgcGFzdCAnci8nLlxuICAgICAgICB0aGlzLmZvcndhcmROKDIpOyAvLyBFeHRyYWN0IHVudGlsIHRoZSBlbmQgb2YgdGhlIHJlZ2V4IC0tIC8gZW5kcyBpdCwgXFwvIGRvZXMgbm90LlxuXG4gICAgICAgIHZhciByZWdleEJvZHkgPSAnJztcblxuICAgICAgICB3aGlsZSAoIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudCgpID09PSAnLycgJiYgdGhpcy5wcmV2aW91cygpICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4Qm9keSArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDaGVjayBmb3IgZmxhZ3MuXG4gICAgICAgIC8vIFRoZSBwb3NzaWJsZSBmbGFncyBhcmUgYWNjb3JkaW5nIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cClcblxuXG4gICAgICAgIHZhciBQT1NTSUJMRV9GTEFHUyA9IFsnZycsICdpJywgJ20nLCAneSddO1xuICAgICAgICB2YXIgcmVnZXhGbGFncyA9ICcnO1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICB2YXIgaXNDdXJyZW50QUZsYWcgPSBQT1NTSUJMRV9GTEFHUy5pbmRleE9mKHRoaXMuY3VycmVudCgpKSAhPT0gLTE7XG5cbiAgICAgICAgICBpZiAoaXNDdXJyZW50QUZsYWcpIHtcbiAgICAgICAgICAgIHJlZ2V4RmxhZ3MgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1JFR0VYLCB7XG4gICAgICAgICAgYm9keTogcmVnZXhCb2R5LFxuICAgICAgICAgIGZsYWdzOiByZWdleEZsYWdzXG4gICAgICAgIH0sIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIGlmIChkZWxpbUNoYXJzLmluZGV4T2YoY3VyKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2UndmUgaGl0IGEgZGVsaW1pdGVyIChhIHNwZWNpYWwgY2hhciBsaWtlIGEgYnJhY2tldClcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHZhciBjb21wbGV4T3BzID0gWyc9PScsICc9PT0nLCAnIT0nLCAnIT09JywgJzw9JywgJz49JywgJy8vJywgJyoqJ107XG4gICAgICAgIHZhciBjdXJDb21wbGV4ID0gY3VyICsgdGhpcy5jdXJyZW50KCk7XG4gICAgICAgIHZhciB0eXBlO1xuXG4gICAgICAgIGlmIChsaWIuaW5kZXhPZihjb21wbGV4T3BzLCBjdXJDb21wbGV4KSAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICBjdXIgPSBjdXJDb21wbGV4OyAvLyBTZWUgaWYgdGhpcyBpcyBhIHN0cmljdCBlcXVhbGl0eS9pbmVxdWFsaXR5IGNvbXBhcmF0b3JcblxuICAgICAgICAgIGlmIChsaWIuaW5kZXhPZihjb21wbGV4T3BzLCBjdXJDb21wbGV4ICsgdGhpcy5jdXJyZW50KCkpICE9PSAtMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyQ29tcGxleCArIHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjdXIpIHtcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9MRUZUX1BBUkVOO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9SSUdIVF9QQVJFTjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fTEVGVF9CUkFDS0VUO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9SSUdIVF9CUkFDS0VUO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9MRUZUX0NVUkxZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9SSUdIVF9DVVJMWTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fQ09NTUE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX0NPTE9OO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9USUxERTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUElQRTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9PUEVSQVRPUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbih0eXBlLCBjdXIsIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgYXJlIG5vdCBhdCB3aGl0ZXNwYWNlIG9yIGEgZGVsaW1pdGVyLCBzbyBleHRyYWN0IHRoZVxuICAgICAgICAvLyB0ZXh0IGFuZCBwYXJzZSBpdFxuICAgICAgICB0b2sgPSB0aGlzLl9leHRyYWN0VW50aWwod2hpdGVzcGFjZUNoYXJzICsgZGVsaW1DaGFycyk7XG5cbiAgICAgICAgaWYgKHRvay5tYXRjaCgvXlstK10/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudCgpID09PSAnLicpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuXG4gICAgICAgICAgICB2YXIgZGVjID0gdGhpcy5fZXh0cmFjdChpbnRDaGFycyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9GTE9BVCwgdG9rICsgJy4nICsgZGVjLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0lOVCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rLm1hdGNoKC9eKHRydWV8ZmFsc2UpJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0JPT0xFQU4sIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rID09PSAnbm9uZScpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fTk9ORSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEFkZGVkIHRvIG1ha2UgdGhlIHRlc3QgYG51bGwgaXMgbnVsbGAgZXZhbHVhdGUgdHJ1dGhpbHkuXG4gICAgICAgICAgICogT3RoZXJ3aXNlLCBOdW5qdWNrcyB3aWxsIGxvb2sgdXAgbnVsbCBpbiB0aGUgY29udGV4dCBhbmRcbiAgICAgICAgICAgKiByZXR1cm4gYHVuZGVmaW5lZGAsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuIFRoaXMgKm1heSogaGF2ZVxuICAgICAgICAgICAqIGNvbnNlcXVlbmNlcyBpcyBzb21lb25lIGlzIHVzaW5nIG51bGwgaW4gdGhlaXIgdGVtcGxhdGVzIGFzIGFcbiAgICAgICAgICAgKiB2YXJpYWJsZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSBlbHNlIGlmICh0b2sgPT09ICdudWxsJykge1xuICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9OT05FLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICB9IGVsc2UgaWYgKHRvaykge1xuICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9TWU1CT0wsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIHdoaWxlIHBhcnNpbmc6ICcgKyB0b2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBhcnNlIG91dCB0aGUgdGVtcGxhdGUgdGV4dCwgYnJlYWtpbmcgb24gdGFnXG4gICAgICAvLyBkZWxpbWl0ZXJzIGJlY2F1c2Ugd2UgbmVlZCB0byBsb29rIGZvciBibG9jay92YXJpYWJsZSBzdGFydFxuICAgICAgLy8gdGFncyAoZG9uJ3QgdXNlIHRoZSBmdWxsIGRlbGltQ2hhcnMgZm9yIG9wdGltaXphdGlvbilcbiAgICAgIHZhciBiZWdpbkNoYXJzID0gdGhpcy50YWdzLkJMT0NLX1NUQVJULmNoYXJBdCgwKSArIHRoaXMudGFncy5WQVJJQUJMRV9TVEFSVC5jaGFyQXQoMCkgKyB0aGlzLnRhZ3MuQ09NTUVOVF9TVEFSVC5jaGFyQXQoMCkgKyB0aGlzLnRhZ3MuQ09NTUVOVF9FTkQuY2hhckF0KDApO1xuXG4gICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19TVEFSVCArICctJykpIHx8ICh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19TVEFSVCkpKSB7XG4gICAgICAgIHRoaXMuaW5fY29kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9CTE9DS19TVEFSVCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLlZBUklBQkxFX1NUQVJUICsgJy0nKSkgfHwgKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLlZBUklBQkxFX1NUQVJUKSkpIHtcbiAgICAgICAgdGhpcy5pbl9jb2RlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1ZBUklBQkxFX1NUQVJULCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rID0gJyc7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICB2YXIgaW5Db21tZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkNPTU1FTlRfU1RBUlQpKSB7XG4gICAgICAgICAgaW5Db21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5DT01NRU5UX1NUQVJUKTtcbiAgICAgICAgfSAvLyBDb250aW51YWxseSBjb25zdW1lIHRleHQsIGJyZWFraW5nIG9uIHRoZSB0YWcgZGVsaW1pdGVyXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgYW5kIGNoZWNraW5nIHRvIHNlZSBpZiBpdCdzIGEgc3RhcnQgdGFnLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBjb3VsZCBoaXQgdGhlIGVuZCBvZiB0aGUgdGVtcGxhdGUgaW4gdGhlIG1pZGRsZSBvZlxuICAgICAgICAvLyBvdXIgbG9vcGluZywgc28gY2hlY2sgZm9yIHRoZSBudWxsIHJldHVybiB2YWx1ZSBmcm9tXG4gICAgICAgIC8vIF9leHRyYWN0VW50aWxcblxuXG4gICAgICAgIHdoaWxlICgoZGF0YSA9IHRoaXMuX2V4dHJhY3RVbnRpbChiZWdpbkNoYXJzKSkgIT09IG51bGwpIHtcbiAgICAgICAgICB0b2sgKz0gZGF0YTtcblxuICAgICAgICAgIGlmICgodGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQpIHx8IHRoaXMuX21hdGNoZXModGhpcy50YWdzLlZBUklBQkxFX1NUQVJUKSB8fCB0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5DT01NRU5UX1NUQVJUKSkgJiYgIWluQ29tbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubHN0cmlwQmxvY2tzICYmIHRoaXMuX21hdGNoZXModGhpcy50YWdzLkJMT0NLX1NUQVJUKSAmJiB0aGlzLmNvbG5vID4gMCAmJiB0aGlzLmNvbG5vIDw9IHRvay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gdG9rLnNsaWNlKC10aGlzLmNvbG5vKTtcblxuICAgICAgICAgICAgICBpZiAoL15cXHMrJC8udGVzdChsYXN0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYmxvY2sgbGVhZGluZyB3aGl0ZXNwYWNlIGZyb20gYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICAgICAgICB0b2sgPSB0b2suc2xpY2UoMCwgLXRoaXMuY29sbm8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0b2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBbGwgZGF0YSByZW1vdmVkLCBjb2xsYXBzZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBub2Rlc1xuICAgICAgICAgICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIG5leHQgdG9rZW4gKGJsb2NrIHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElmIGl0IGlzIGEgc3RhcnQgdGFnLCBzdG9wIGxvb3BpbmdcblxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkNPTU1FTlRfRU5EKSkge1xuICAgICAgICAgICAgaWYgKCFpbkNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBjb21tZW50Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvayArPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5DT01NRU5UX0VORCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXQgZG9lcyBub3QgbWF0Y2ggYW55IHRhZywgc28gYWRkIHRoZSBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAvLyBjYXJyeSBvblxuICAgICAgICAgICAgdG9rICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwgJiYgaW5Db21tZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBlbmQgb2YgY29tbWVudCwgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4oaW5Db21tZW50ID8gVE9LRU5fQ09NTUVOVCA6IFRPS0VOX0RBVEEsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGFyc2VTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VTdHJpbmcoZGVsaW1pdGVyKSB7XG4gICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgd2hpbGUgKCF0aGlzLmlzRmluaXNoZWQoKSAmJiB0aGlzLmN1cnJlbnQoKSAhPT0gZGVsaW1pdGVyKSB7XG4gICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50KCk7XG5cbiAgICAgIGlmIChjdXIgPT09ICdcXFxcJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudCgpKSB7XG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGN1cjtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBfcHJvdG8uX21hdGNoZXMgPSBmdW5jdGlvbiBfbWF0Y2hlcyhzdHIpIHtcbiAgICBpZiAodGhpcy5pbmRleCArIHN0ci5sZW5ndGggPiB0aGlzLmxlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB0aGlzLnN0ci5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgc3RyLmxlbmd0aCk7XG4gICAgcmV0dXJuIG0gPT09IHN0cjtcbiAgfTtcblxuICBfcHJvdG8uX2V4dHJhY3RTdHJpbmcgPSBmdW5jdGlvbiBfZXh0cmFjdFN0cmluZyhzdHIpIHtcbiAgICBpZiAodGhpcy5fbWF0Y2hlcyhzdHIpKSB7XG4gICAgICB0aGlzLmZvcndhcmROKHN0ci5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8uX2V4dHJhY3RVbnRpbCA9IGZ1bmN0aW9uIF9leHRyYWN0VW50aWwoY2hhclN0cmluZykge1xuICAgIC8vIEV4dHJhY3QgYWxsIG5vbi1tYXRjaGluZyBjaGFycywgd2l0aCB0aGUgZGVmYXVsdCBtYXRjaGluZyBzZXRcbiAgICAvLyB0byBldmVyeXRoaW5nXG4gICAgcmV0dXJuIHRoaXMuX2V4dHJhY3RNYXRjaGluZyh0cnVlLCBjaGFyU3RyaW5nIHx8ICcnKTtcbiAgfTtcblxuICBfcHJvdG8uX2V4dHJhY3QgPSBmdW5jdGlvbiBfZXh0cmFjdChjaGFyU3RyaW5nKSB7XG4gICAgLy8gRXh0cmFjdCBhbGwgbWF0Y2hpbmcgY2hhcnMgKG5vIGRlZmF1bHQsIHNvIGNoYXJTdHJpbmcgbXVzdCBiZVxuICAgIC8vIGV4cGxpY2l0KVxuICAgIHJldHVybiB0aGlzLl9leHRyYWN0TWF0Y2hpbmcoZmFsc2UsIGNoYXJTdHJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5fZXh0cmFjdE1hdGNoaW5nID0gZnVuY3Rpb24gX2V4dHJhY3RNYXRjaGluZyhicmVha09uTWF0Y2gsIGNoYXJTdHJpbmcpIHtcbiAgICAvLyBQdWxsIG91dCBjaGFyYWN0ZXJzIHVudGlsIGEgYnJlYWtpbmcgY2hhciBpcyBoaXQuXG4gICAgLy8gSWYgYnJlYWtPbk1hdGNoIGlzIGZhbHNlLCBhIG5vbi1tYXRjaGluZyBjaGFyIHN0b3BzIGl0LlxuICAgIC8vIElmIGJyZWFrT25NYXRjaCBpcyB0cnVlLCBhIG1hdGNoaW5nIGNoYXIgc3RvcHMgaXQuXG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3QgPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpOyAvLyBPbmx5IHByb2NlZWQgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBkb2Vzbid0IG1lZXQgb3VyIGNvbmRpdGlvblxuXG4gICAgaWYgKGJyZWFrT25NYXRjaCAmJiBmaXJzdCA9PT0gLTEgfHwgIWJyZWFrT25NYXRjaCAmJiBmaXJzdCAhPT0gLTEpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTsgLy8gQW5kIHB1bGwgb3V0IGFsbCB0aGUgY2hhcnMgb25lIGF0IGEgdGltZSB1bnRpbCB3ZSBoaXQgYVxuICAgICAgLy8gYnJlYWtpbmcgY2hhclxuXG4gICAgICB2YXIgaWR4ID0gY2hhclN0cmluZy5pbmRleE9mKHRoaXMuY3VycmVudCgpKTtcblxuICAgICAgd2hpbGUgKChicmVha09uTWF0Y2ggJiYgaWR4ID09PSAtMSB8fCAhYnJlYWtPbk1hdGNoICYmIGlkeCAhPT0gLTEpICYmICF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICB0ICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgaWR4ID0gY2hhclN0cmluZy5pbmRleE9mKHRoaXMuY3VycmVudCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIF9wcm90by5fZXh0cmFjdFJlZ2V4ID0gZnVuY3Rpb24gX2V4dHJhY3RSZWdleChyZWdleCkge1xuICAgIHZhciBtYXRjaGVzID0gdGhpcy5jdXJyZW50U3RyKCkubWF0Y2gocmVnZXgpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIE1vdmUgZm9yd2FyZCB3aGF0ZXZlciB3YXMgbWF0Y2hlZFxuXG5cbiAgICB0aGlzLmZvcndhcmROKG1hdGNoZXNbMF0ubGVuZ3RoKTtcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfTtcblxuICBfcHJvdG8uaXNGaW5pc2hlZCA9IGZ1bmN0aW9uIGlzRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy5sZW47XG4gIH07XG5cbiAgX3Byb3RvLmZvcndhcmROID0gZnVuY3Rpb24gZm9yd2FyZE4obikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgIHRoaXMuaW5kZXgrKztcblxuICAgIGlmICh0aGlzLnByZXZpb3VzKCkgPT09ICdcXG4nKSB7XG4gICAgICB0aGlzLmxpbmVubysrO1xuICAgICAgdGhpcy5jb2xubyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29sbm8rKztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmJhY2tOID0gZnVuY3Rpb24gYmFja04obikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB0aGlzLmJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmJhY2sgPSBmdW5jdGlvbiBiYWNrKCkge1xuICAgIHRoaXMuaW5kZXgtLTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJ1xcbicpIHtcbiAgICAgIHRoaXMubGluZW5vLS07XG4gICAgICB2YXIgaWR4ID0gdGhpcy5zcmMubGFzdEluZGV4T2YoJ1xcbicsIHRoaXMuaW5kZXggLSAxKTtcblxuICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jb2xubyA9IHRoaXMuaW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbG5vID0gdGhpcy5pbmRleCAtIGlkeDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xuby0tO1xuICAgIH1cbiAgfSAvLyBjdXJyZW50IHJldHVybnMgY3VycmVudCBjaGFyYWN0ZXJcbiAgO1xuXG4gIF9wcm90by5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICBpZiAoIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHIuY2hhckF0KHRoaXMuaW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSAvLyBjdXJyZW50U3RyIHJldHVybnMgd2hhdCdzIGxlZnQgb2YgdGhlIHVucGFyc2VkIHN0cmluZ1xuICA7XG5cbiAgX3Byb3RvLmN1cnJlbnRTdHIgPSBmdW5jdGlvbiBjdXJyZW50U3RyKCkge1xuICAgIGlmICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ci5zdWJzdHIodGhpcy5pbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9O1xuXG4gIF9wcm90by5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pbmRleCAtIDEpO1xuICB9O1xuXG4gIHJldHVybiBUb2tlbml6ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsZXg6IGZ1bmN0aW9uIGxleChzcmMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuaXplcihzcmMsIG9wdHMpO1xuICB9LFxuICBUT0tFTl9TVFJJTkc6IFRPS0VOX1NUUklORyxcbiAgVE9LRU5fV0hJVEVTUEFDRTogVE9LRU5fV0hJVEVTUEFDRSxcbiAgVE9LRU5fREFUQTogVE9LRU5fREFUQSxcbiAgVE9LRU5fQkxPQ0tfU1RBUlQ6IFRPS0VOX0JMT0NLX1NUQVJULFxuICBUT0tFTl9CTE9DS19FTkQ6IFRPS0VOX0JMT0NLX0VORCxcbiAgVE9LRU5fVkFSSUFCTEVfU1RBUlQ6IFRPS0VOX1ZBUklBQkxFX1NUQVJULFxuICBUT0tFTl9WQVJJQUJMRV9FTkQ6IFRPS0VOX1ZBUklBQkxFX0VORCxcbiAgVE9LRU5fQ09NTUVOVDogVE9LRU5fQ09NTUVOVCxcbiAgVE9LRU5fTEVGVF9QQVJFTjogVE9LRU5fTEVGVF9QQVJFTixcbiAgVE9LRU5fUklHSFRfUEFSRU46IFRPS0VOX1JJR0hUX1BBUkVOLFxuICBUT0tFTl9MRUZUX0JSQUNLRVQ6IFRPS0VOX0xFRlRfQlJBQ0tFVCxcbiAgVE9LRU5fUklHSFRfQlJBQ0tFVDogVE9LRU5fUklHSFRfQlJBQ0tFVCxcbiAgVE9LRU5fTEVGVF9DVVJMWTogVE9LRU5fTEVGVF9DVVJMWSxcbiAgVE9LRU5fUklHSFRfQ1VSTFk6IFRPS0VOX1JJR0hUX0NVUkxZLFxuICBUT0tFTl9PUEVSQVRPUjogVE9LRU5fT1BFUkFUT1IsXG4gIFRPS0VOX0NPTU1BOiBUT0tFTl9DT01NQSxcbiAgVE9LRU5fQ09MT046IFRPS0VOX0NPTE9OLFxuICBUT0tFTl9USUxERTogVE9LRU5fVElMREUsXG4gIFRPS0VOX1BJUEU6IFRPS0VOX1BJUEUsXG4gIFRPS0VOX0lOVDogVE9LRU5fSU5ULFxuICBUT0tFTl9GTE9BVDogVE9LRU5fRkxPQVQsXG4gIFRPS0VOX0JPT0xFQU46IFRPS0VOX0JPT0xFQU4sXG4gIFRPS0VOX05PTkU6IFRPS0VOX05PTkUsXG4gIFRPS0VOX1NZTUJPTDogVE9LRU5fU1lNQk9MLFxuICBUT0tFTl9TUEVDSUFMOiBUT0tFTl9TUEVDSUFMLFxuICBUT0tFTl9SRUdFWDogVE9LRU5fUkVHRVhcbn07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBMb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSxcbiAgICBQcmVjb21waWxlZExvYWRlciA9IF9yZXF1aXJlLlByZWNvbXBpbGVkTG9hZGVyO1xuXG52YXIgV2ViTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFdlYkxvYWRlciwgX0xvYWRlcik7XG5cbiAgZnVuY3Rpb24gV2ViTG9hZGVyKGJhc2VVUkwsIG9wdHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Mb2FkZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmJhc2VVUkwgPSBiYXNlVVJMIHx8ICcuJztcbiAgICBvcHRzID0gb3B0cyB8fCB7fTsgLy8gQnkgZGVmYXVsdCwgdGhlIGNhY2hlIGlzIHR1cm5lZCBvZmYgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAgIC8vIHRvIFwid2F0Y2hcIiB0ZW1wbGF0ZXMgb3ZlciBIVFRQLCBzbyB0aGV5IGFyZSByZS1kb3dubG9hZGVkXG4gICAgLy8gYW5kIGNvbXBpbGVkIGVhY2ggdGltZS4gKFJlbWVtYmVyLCBQUkVDT01QSUxFIFlPVVJcbiAgICAvLyBURU1QTEFURVMgaW4gcHJvZHVjdGlvbiEpXG5cbiAgICBfdGhpcy51c2VDYWNoZSA9ICEhb3B0cy51c2VDYWNoZTsgLy8gV2UgZGVmYXVsdCBgYXN5bmNgIHRvIGZhbHNlIHNvIHRoYXQgdGhlIHNpbXBsZSBzeW5jaHJvbm91c1xuICAgIC8vIEFQSSBjYW4gYmUgdXNlZCB3aGVuIHlvdSBhcmVuJ3QgZG9pbmcgYW55dGhpbmcgYXN5bmMgaW5cbiAgICAvLyB5b3VyIHRlbXBsYXRlcyAod2hpY2ggaXMgbW9zdCBvZiB0aGUgdGltZSkuIFRoaXMgcGVyZm9ybXMgYVxuICAgIC8vIHN5bmMgYWpheCByZXF1ZXN0LCBidXQgdGhhdCdzIG9rIGJlY2F1c2UgaXQgc2hvdWxkICpvbmx5KlxuICAgIC8vIGhhcHBlbiBpbiBkZXZlbG9wbWVudC4gUFJFQ09NUElMRSBZT1VSIFRFTVBMQVRFUy5cblxuICAgIF90aGlzLmFzeW5jID0gISFvcHRzLmFzeW5jO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBXZWJMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmcm9tLCB0bykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVsYXRpdmUgdGVtcGxhdGVzIG5vdCBzdXBwb3J0IGluIHRoZSBicm93c2VyIHlldCcpO1xuICB9O1xuXG4gIF9wcm90by5nZXRTb3VyY2UgPSBmdW5jdGlvbiBnZXRTb3VyY2UobmFtZSwgY2IpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciB1c2VDYWNoZSA9IHRoaXMudXNlQ2FjaGU7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0aGlzLmZldGNoKHRoaXMuYmFzZVVSTCArICcvJyArIG5hbWUsIGZ1bmN0aW9uIChlcnIsIHNyYykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIuY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnIuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIHNyYzogc3JjLFxuICAgICAgICAgIHBhdGg6IG5hbWUsXG4gICAgICAgICAgbm9DYWNoZTogIXVzZUNhY2hlXG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMyLmVtaXQoJ2xvYWQnLCBuYW1lLCByZXN1bHQpO1xuXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gaWYgdGhpcyBXZWJMb2FkZXIgaXNuJ3QgcnVubmluZyBhc3luY2hyb25vdXNseSwgdGhlXG4gICAgLy8gZmV0Y2ggYWJvdmUgd291bGQgYWN0dWFsbHkgcnVuIHN5bmMgYW5kIHdlJ2xsIGhhdmUgYVxuICAgIC8vIHJlc3VsdCBoZXJlXG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5mZXRjaCA9IGZ1bmN0aW9uIGZldGNoKHVybCwgY2IpIHtcbiAgICAvLyBPbmx5IGluIHRoZSBicm93c2VyIHBsZWFzZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJMb2FkZXIgY2FuIG9ubHkgYnkgdXNlZCBpbiBhIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB2YXIgYWpheCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkaW5nID0gdHJ1ZTtcblxuICAgIGFqYXgub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGFqYXgucmVhZHlTdGF0ZSA9PT0gNCAmJiBsb2FkaW5nKSB7XG4gICAgICAgIGxvYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWpheC5zdGF0dXMgPT09IDAgfHwgYWpheC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIGNiKG51bGwsIGFqYXgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYih7XG4gICAgICAgICAgICBzdGF0dXM6IGFqYXguc3RhdHVzLFxuICAgICAgICAgICAgY29udGVudDogYWpheC5yZXNwb25zZVRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICdzPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBhamF4Lm9wZW4oJ0dFVCcsIHVybCwgdGhpcy5hc3luYyk7XG4gICAgYWpheC5zZW5kKCk7XG4gIH07XG5cbiAgcmV0dXJuIFdlYkxvYWRlcjtcbn0oTG9hZGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdlYkxvYWRlcjogV2ViTG9hZGVyLFxuICBQcmVjb21waWxlZExvYWRlcjogUHJlY29tcGlsZWRMb2FkZXJcbn07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxpYiA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyksXG4gICAgRW52aXJvbm1lbnQgPSBfcmVxdWlyZS5FbnZpcm9ubWVudCxcbiAgICBUZW1wbGF0ZSA9IF9yZXF1aXJlLlRlbXBsYXRlO1xuXG52YXIgTG9hZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIGxvYWRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIHByZWNvbXBpbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIGNvbXBpbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIHBhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBsZXhlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBydW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIG5vZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIGluc3RhbGxKaW5qYUNvbXBhdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpOyAvLyBBIHNpbmdsZSBpbnN0YW5jZSBvZiBhbiBlbnZpcm9ubWVudCwgc2luY2UgdGhpcyBpcyBzbyBjb21tb25seSB1c2VkXG5cblxudmFyIGU7XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZSh0ZW1wbGF0ZXNQYXRoLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmIChsaWIuaXNPYmplY3QodGVtcGxhdGVzUGF0aCkpIHtcbiAgICBvcHRzID0gdGVtcGxhdGVzUGF0aDtcbiAgICB0ZW1wbGF0ZXNQYXRoID0gbnVsbDtcbiAgfVxuXG4gIHZhciBUZW1wbGF0ZUxvYWRlcjtcblxuICBpZiAobG9hZGVycy5GaWxlU3lzdGVtTG9hZGVyKSB7XG4gICAgVGVtcGxhdGVMb2FkZXIgPSBuZXcgbG9hZGVycy5GaWxlU3lzdGVtTG9hZGVyKHRlbXBsYXRlc1BhdGgsIHtcbiAgICAgIHdhdGNoOiBvcHRzLndhdGNoLFxuICAgICAgbm9DYWNoZTogb3B0cy5ub0NhY2hlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobG9hZGVycy5XZWJMb2FkZXIpIHtcbiAgICBUZW1wbGF0ZUxvYWRlciA9IG5ldyBsb2FkZXJzLldlYkxvYWRlcih0ZW1wbGF0ZXNQYXRoLCB7XG4gICAgICB1c2VDYWNoZTogb3B0cy53ZWIgJiYgb3B0cy53ZWIudXNlQ2FjaGUsXG4gICAgICBhc3luYzogb3B0cy53ZWIgJiYgb3B0cy53ZWIuYXN5bmNcbiAgICB9KTtcbiAgfVxuXG4gIGUgPSBuZXcgRW52aXJvbm1lbnQoVGVtcGxhdGVMb2FkZXIsIG9wdHMpO1xuXG4gIGlmIChvcHRzICYmIG9wdHMuZXhwcmVzcykge1xuICAgIGUuZXhwcmVzcyhvcHRzLmV4cHJlc3MpO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFbnZpcm9ubWVudDogRW52aXJvbm1lbnQsXG4gIFRlbXBsYXRlOiBUZW1wbGF0ZSxcbiAgTG9hZGVyOiBMb2FkZXIsXG4gIEZpbGVTeXN0ZW1Mb2FkZXI6IGxvYWRlcnMuRmlsZVN5c3RlbUxvYWRlcixcbiAgTm9kZVJlc29sdmVMb2FkZXI6IGxvYWRlcnMuTm9kZVJlc29sdmVMb2FkZXIsXG4gIFByZWNvbXBpbGVkTG9hZGVyOiBsb2FkZXJzLlByZWNvbXBpbGVkTG9hZGVyLFxuICBXZWJMb2FkZXI6IGxvYWRlcnMuV2ViTG9hZGVyLFxuICBjb21waWxlcjogY29tcGlsZXIsXG4gIHBhcnNlcjogcGFyc2VyLFxuICBsZXhlcjogbGV4ZXIsXG4gIHJ1bnRpbWU6IHJ1bnRpbWUsXG4gIGxpYjogbGliLFxuICBub2Rlczogbm9kZXMsXG4gIGluc3RhbGxKaW5qYUNvbXBhdDogaW5zdGFsbEppbmphQ29tcGF0LFxuICBjb25maWd1cmU6IGNvbmZpZ3VyZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGUgPSB1bmRlZmluZWQ7XG4gIH0sXG4gIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoc3JjLCBlbnYsIHBhdGgsIGVhZ2VyQ29tcGlsZSkge1xuICAgIGlmICghZSkge1xuICAgICAgY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIobmFtZSwgY3R4LCBjYikge1xuICAgIGlmICghZSkge1xuICAgICAgY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGUucmVuZGVyKG5hbWUsIGN0eCwgY2IpO1xuICB9LFxuICByZW5kZXJTdHJpbmc6IGZ1bmN0aW9uIHJlbmRlclN0cmluZyhzcmMsIGN0eCwgY2IpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlLnJlbmRlclN0cmluZyhzcmMsIGN0eCwgY2IpO1xuICB9LFxuICBwcmVjb21waWxlOiBwcmVjb21waWxlID8gcHJlY29tcGlsZS5wcmVjb21waWxlIDogdW5kZWZpbmVkLFxuICBwcmVjb21waWxlU3RyaW5nOiBwcmVjb21waWxlID8gcHJlY29tcGlsZS5wcmVjb21waWxlU3RyaW5nIDogdW5kZWZpbmVkXG59O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIHJhd0FzYXAgcHJvdmlkZXMgZXZlcnl0aGluZyB3ZSBuZWVkIGV4Y2VwdCBleGNlcHRpb24gbWFuYWdlbWVudC5cbnZhciByYXdBc2FwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG4vLyBSYXdUYXNrcyBhcmUgcmVjeWNsZWQgdG8gcmVkdWNlIEdDIGNodXJuLlxudmFyIGZyZWVUYXNrcyA9IFtdO1xuLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuLy8gQXJyYXktYXMtcXVldWUgaXMgZ29vZCBlbm91Z2ggaGVyZSwgc2luY2Ugd2UgYXJlIGp1c3QgZGVhbGluZyB3aXRoIGV4Y2VwdGlvbnMuXG52YXIgcGVuZGluZ0Vycm9ycyA9IFtdO1xudmFyIHJlcXVlc3RFcnJvclRocm93ID0gcmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIodGhyb3dGaXJzdEVycm9yKTtcblxuZnVuY3Rpb24gdGhyb3dGaXJzdEVycm9yKCkge1xuICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBwZW5kaW5nRXJyb3JzLnNoaWZ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgdGFzayBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHJldHVybmluZywgaW4gaXRzIG93biBldmVudCwgd2l0aCBwcmlvcml0eVxuICogb3ZlciBvdGhlciBldmVudHMgbGlrZSBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlcGFpbnQuIEFuIGVycm9yIHRocm93biBmcm9tIGFuXG4gKiBldmVudCB3aWxsIG5vdCBpbnRlcnJ1cHQsIG5vciBldmVuIHN1YnN0YW50aWFsbHkgc2xvdyBkb3duIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBvdGhlciBldmVudHMsIGJ1dCB3aWxsIGJlIHJhdGhlciBwb3N0cG9uZWQgdG8gYSBsb3dlciBwcmlvcml0eSBldmVudC5cbiAqIEBwYXJhbSB7e2NhbGx9fSB0YXNrIEEgY2FsbGFibGUgb2JqZWN0LCB0eXBpY2FsbHkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHZhciByYXdUYXNrO1xuICAgIGlmIChmcmVlVGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rhc2sgPSBmcmVlVGFza3MucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VGFzayA9IG5ldyBSYXdUYXNrKCk7XG4gICAgfVxuICAgIHJhd1Rhc2sudGFzayA9IHRhc2s7XG4gICAgcmF3QXNhcChyYXdUYXNrKTtcbn1cblxuLy8gV2Ugd3JhcCB0YXNrcyB3aXRoIHJlY3ljbGFibGUgdGFzayBvYmplY3RzLiAgQSB0YXNrIG9iamVjdCBpbXBsZW1lbnRzXG4vLyBgY2FsbGAsIGp1c3QgbGlrZSBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUmF3VGFzaygpIHtcbiAgICB0aGlzLnRhc2sgPSBudWxsO1xufVxuXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHdyYXBwaW5nIHRoZSB0YXNrIGlzIHRvIGNhdGNoIHRoZSBleGNlcHRpb24gYW5kIHJlY3ljbGVcbi8vIHRoZSB0YXNrIG9iamVjdCBhZnRlciBpdHMgc2luZ2xlIHVzZS5cblJhd1Rhc2sucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy50YXNrLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoYXNhcC5vbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhvb2sgZXhpc3RzIHB1cmVseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgIC8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdFxuICAgICAgICAgICAgLy8gZGVwZW5kcyBvbiBpdHMgZXhpc3RlbmNlLlxuICAgICAgICAgICAgYXNhcC5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNsb3dpbmcgZG93biB0aGUgcXVldWUgb2YgcGVuZGluZyB0YXNrcywgd2UgcmV0aHJvdyB0aGUgZXJyb3IgaW4gYVxuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdHVybi5cbiAgICAgICAgICAgIHBlbmRpbmdFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0RXJyb3JUaHJvdygpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgZnJlZVRhc2tzW2ZyZWVUYXNrcy5sZW5ndGhdID0gdGhpcztcbiAgICB9XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgb3IgYHNlbGZgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG5cbi8qIGdsb2JhbHMgc2VsZiAqL1xudmFyIHNjb3BlID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHNlbGY7XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBzY29wZS5NdXRhdGlvbk9ic2VydmVyIHx8IHNjb3BlLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSkpXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8vIE1JVCBsaWNlbnNlIChieSBFbGFuIFNoYW5rZXIpLlxuKGZ1bmN0aW9uKGdsb2JhbHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBleGVjdXRlU3luYyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICBhcmdzWzBdLmFwcGx5KG51bGwsIGFyZ3Muc3BsaWNlKDEpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGV4ZWN1dGVBc3luYyA9IGZ1bmN0aW9uKGZuKXtcbiAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYWtlSXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgfTtcbiAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gIH07XG4gIFxuICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG1heWJlQXJyYXkpe1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWF5YmVBcnJheSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgdmFyIHdhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2ssIGZvcmNlQXN5bmMpIHtcbiAgICB2YXIgbmV4dFRpY2sgPSBmb3JjZUFzeW5jID8gZXhlY3V0ZUFzeW5jIDogZXhlY3V0ZVN5bmM7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgd3JhcEl0ZXJhdG9yKG1ha2VJdGVyYXRvcih0YXNrcykpKCk7XG4gIH07XG5cbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdhdGVyZmFsbDtcbiAgICB9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpOyAvLyBSZXF1aXJlSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2F0ZXJmYWxsOyAvLyBDb21tb25KU1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsOyAvLyA8c2NyaXB0PlxuICB9XG59KSh0aGlzKTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBldmVudExpc3RlbmVyKCkge1xuICAgICAgaWYgKGVycm9yTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAvLyBBZGRpbmcgYW4gZXJyb3IgbGlzdGVuZXIgaXMgbm90IG9wdGlvbmFsIGJlY2F1c2VcbiAgICAvLyBpZiBhbiBlcnJvciBpcyB0aHJvd24gb24gYW4gZXZlbnQgZW1pdHRlciB3ZSBjYW5ub3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgYWN0dWFsIGV2ZW50IHdlIGFyZSB3YWl0aW5nIHdpbGxcbiAgICAvLyBiZSBmaXJlZC4gVGhlIHJlc3VsdCBjb3VsZCBiZSBhIHNpbGVudCB3YXkgdG8gY3JlYXRlXG4gICAgLy8gbWVtb3J5IG9yIGZpbGUgZGVzY3JpcHRvciBsZWFrcywgd2hpY2ggaXMgc29tZXRoaW5nXG4gICAgLy8gd2Ugc2hvdWxkIGF2b2lkLlxuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBlbWl0dGVyLm9uY2UoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgZW1pdHRlci5vbmNlKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBub2RlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgc3ltID0gMDtcblxuZnVuY3Rpb24gZ2Vuc3ltKCkge1xuICByZXR1cm4gJ2hvbGVfJyArIHN5bSsrO1xufSAvLyBjb3B5LW9uLXdyaXRlIHZlcnNpb24gb2YgbWFwXG5cblxuZnVuY3Rpb24gbWFwQ09XKGFyciwgZnVuYykge1xuICB2YXIgcmVzID0gbnVsbDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gZnVuYyhhcnJbaV0pO1xuXG4gICAgaWYgKGl0ZW0gIT09IGFycltpXSkge1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmVzID0gYXJyLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJlc1tpXSA9IGl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyB8fCBhcnI7XG59XG5cbmZ1bmN0aW9uIHdhbGsoYXN0LCBmdW5jLCBkZXB0aEZpcnN0KSB7XG4gIGlmICghKGFzdCBpbnN0YW5jZW9mIG5vZGVzLk5vZGUpKSB7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIGlmICghZGVwdGhGaXJzdCkge1xuICAgIHZhciBhc3RUID0gZnVuYyhhc3QpO1xuXG4gICAgaWYgKGFzdFQgJiYgYXN0VCAhPT0gYXN0KSB7XG4gICAgICByZXR1cm4gYXN0VDtcbiAgICB9XG4gIH1cblxuICBpZiAoYXN0IGluc3RhbmNlb2Ygbm9kZXMuTm9kZUxpc3QpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBtYXBDT1coYXN0LmNoaWxkcmVuLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIHdhbGsobm9kZSwgZnVuYywgZGVwdGhGaXJzdCk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2hpbGRyZW4gIT09IGFzdC5jaGlsZHJlbikge1xuICAgICAgYXN0ID0gbmV3IG5vZGVzW2FzdC50eXBlbmFtZV0oYXN0LmxpbmVubywgYXN0LmNvbG5vLCBjaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIG5vZGVzLkNhbGxFeHRlbnNpb24pIHtcbiAgICB2YXIgYXJncyA9IHdhbGsoYXN0LmFyZ3MsIGZ1bmMsIGRlcHRoRmlyc3QpO1xuICAgIHZhciBjb250ZW50QXJncyA9IG1hcENPVyhhc3QuY29udGVudEFyZ3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gd2Fsayhub2RlLCBmdW5jLCBkZXB0aEZpcnN0KTtcbiAgICB9KTtcblxuICAgIGlmIChhcmdzICE9PSBhc3QuYXJncyB8fCBjb250ZW50QXJncyAhPT0gYXN0LmNvbnRlbnRBcmdzKSB7XG4gICAgICBhc3QgPSBuZXcgbm9kZXNbYXN0LnR5cGVuYW1lXShhc3QuZXh0TmFtZSwgYXN0LnByb3AsIGFyZ3MsIGNvbnRlbnRBcmdzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHByb3BzID0gYXN0LmZpZWxkcy5tYXAoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICByZXR1cm4gYXN0W2ZpZWxkXTtcbiAgICB9KTtcbiAgICB2YXIgcHJvcHNUID0gbWFwQ09XKHByb3BzLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHdhbGsocHJvcCwgZnVuYywgZGVwdGhGaXJzdCk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcHNUICE9PSBwcm9wcykge1xuICAgICAgYXN0ID0gbmV3IG5vZGVzW2FzdC50eXBlbmFtZV0oYXN0LmxpbmVubywgYXN0LmNvbG5vKTtcbiAgICAgIHByb3BzVC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgIGFzdFthc3QuZmllbGRzW2ldXSA9IHByb3A7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVwdGhGaXJzdCA/IGZ1bmMoYXN0KSB8fCBhc3QgOiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGRlcHRoV2Fsayhhc3QsIGZ1bmMpIHtcbiAgcmV0dXJuIHdhbGsoYXN0LCBmdW5jLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgcHJvcCkge1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgdmFyIHdhbGtlZCA9IGRlcHRoV2Fsayhwcm9wID8gbm9kZVtwcm9wXSA6IG5vZGUsIGZ1bmN0aW9uIChkZXNjTm9kZSkge1xuICAgIHZhciBzeW1ib2w7XG5cbiAgICBpZiAoZGVzY05vZGUgaW5zdGFuY2VvZiBub2Rlcy5CbG9jaykge1xuICAgICAgcmV0dXJuIGRlc2NOb2RlO1xuICAgIH0gZWxzZSBpZiAoZGVzY05vZGUgaW5zdGFuY2VvZiBub2Rlcy5GaWx0ZXIgJiYgbGliLmluZGV4T2YoYXN5bmNGaWx0ZXJzLCBkZXNjTm9kZS5uYW1lLnZhbHVlKSAhPT0gLTEgfHwgZGVzY05vZGUgaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXh0ZW5zaW9uQXN5bmMpIHtcbiAgICAgIHN5bWJvbCA9IG5ldyBub2Rlcy5TeW1ib2woZGVzY05vZGUubGluZW5vLCBkZXNjTm9kZS5jb2xubywgZ2Vuc3ltKCkpO1xuICAgICAgY2hpbGRyZW4ucHVzaChuZXcgbm9kZXMuRmlsdGVyQXN5bmMoZGVzY05vZGUubGluZW5vLCBkZXNjTm9kZS5jb2xubywgZGVzY05vZGUubmFtZSwgZGVzY05vZGUuYXJncywgc3ltYm9sKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfSk7XG5cbiAgaWYgKHByb3ApIHtcbiAgICBub2RlW3Byb3BdID0gd2Fsa2VkO1xuICB9IGVsc2Uge1xuICAgIG5vZGUgPSB3YWxrZWQ7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICByZXR1cm4gbmV3IG5vZGVzLk5vZGVMaXN0KG5vZGUubGluZW5vLCBub2RlLmNvbG5vLCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmdEZpbHRlcnMoYXN0LCBhc3luY0ZpbHRlcnMpIHtcbiAgcmV0dXJuIGRlcHRoV2Fsayhhc3QsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5PdXRwdXQpIHtcbiAgICAgIHJldHVybiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXQpIHtcbiAgICAgIHJldHVybiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzLCAndmFsdWUnKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5Gb3IpIHtcbiAgICAgIHJldHVybiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzLCAnYXJyJyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuSWYpIHtcbiAgICAgIHJldHVybiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzLCAnY29uZCcpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkNhbGxFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBfbGlmdEZpbHRlcnMobm9kZSwgYXN5bmNGaWx0ZXJzLCAnYXJncycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxpZnRTdXBlcihhc3QpIHtcbiAgcmV0dXJuIHdhbGsoYXN0LCBmdW5jdGlvbiAoYmxvY2tOb2RlKSB7XG4gICAgaWYgKCEoYmxvY2tOb2RlIGluc3RhbmNlb2Ygbm9kZXMuQmxvY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhhc1N1cGVyID0gZmFsc2U7XG4gICAgdmFyIHN5bWJvbCA9IGdlbnN5bSgpO1xuICAgIGJsb2NrTm9kZS5ib2R5ID0gd2FsayhibG9ja05vZGUuYm9keSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRnVuQ2FsbCAmJiBub2RlLm5hbWUudmFsdWUgPT09ICdzdXBlcicpIHtcbiAgICAgICAgaGFzU3VwZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLlN5bWJvbChub2RlLmxpbmVubywgbm9kZS5jb2xubywgc3ltYm9sKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChoYXNTdXBlcikge1xuICAgICAgYmxvY2tOb2RlLmJvZHkuY2hpbGRyZW4udW5zaGlmdChuZXcgbm9kZXMuU3VwZXIoMCwgMCwgYmxvY2tOb2RlLm5hbWUsIG5ldyBub2Rlcy5TeW1ib2woMCwgMCwgc3ltYm9sKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTdGF0ZW1lbnRzKGFzdCkge1xuICByZXR1cm4gZGVwdGhXYWxrKGFzdCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuSWYpICYmICEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZvcikpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGFzeW5jID0gZmFsc2U7XG4gICAgd2Fsayhub2RlLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLkZpbHRlckFzeW5jIHx8IGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuSWZBc3luYyB8fCBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLkFzeW5jRWFjaCB8fCBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLkFzeW5jQWxsIHx8IGNoaWxkIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbkFzeW5jKSB7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTsgLy8gU3RvcCBpdGVyYXRpbmcgYnkgcmV0dXJuaW5nIHRoZSBub2RlXG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSB7XG4gICAgICAgIHJldHVybiBuZXcgbm9kZXMuSWZBc3luYyhub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZS5jb25kLCBub2RlLmJvZHksIG5vZGUuZWxzZV8pO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRm9yICYmICEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkFzeW5jQWxsKSkge1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLkFzeW5jRWFjaChub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZS5hcnIsIG5vZGUubmFtZSwgbm9kZS5ib2R5LCBub2RlLmVsc2VfKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3BzKGFzdCwgYXN5bmNGaWx0ZXJzKSB7XG4gIHJldHVybiBjb252ZXJ0U3RhdGVtZW50cyhsaWZ0U3VwZXIobGlmdEZpbHRlcnMoYXN0LCBhc3luY0ZpbHRlcnMpKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShhc3QsIGFzeW5jRmlsdGVycykge1xuICByZXR1cm4gY3BzKGFzdCwgYXN5bmNGaWx0ZXJzIHx8IFtdKTtcbn0gLy8gdmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG4vLyB2YXIgc3JjID0gJ2hlbGxvIHslIGZvbyAlfXslIGVuZGZvbyAlfSBlbmQnO1xuLy8gdmFyIGFzdCA9IHRyYW5zZm9ybShwYXJzZXIucGFyc2Uoc3JjLCBbbmV3IEZvb0V4dGVuc2lvbigpXSksIFsnYmFyJ10pO1xuLy8gbm9kZXMucHJpbnROb2Rlcyhhc3QpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0cmFuc2Zvcm06IHRyYW5zZm9ybVxufTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIHIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydHMuYWJzID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIGlzTmFOKG51bSkge1xuICByZXR1cm4gbnVtICE9PSBudW07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbmZ1bmN0aW9uIGJhdGNoKGFyciwgbGluZWNvdW50LCBmaWxsV2l0aCkge1xuICB2YXIgaTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgdG1wID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpICUgbGluZWNvdW50ID09PSAwICYmIHRtcC5sZW5ndGgpIHtcbiAgICAgIHJlcy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSBbXTtcbiAgICB9XG5cbiAgICB0bXAucHVzaChhcnJbaV0pO1xuICB9XG5cbiAgaWYgKHRtcC5sZW5ndGgpIHtcbiAgICBpZiAoZmlsbFdpdGgpIHtcbiAgICAgIGZvciAoaSA9IHRtcC5sZW5ndGg7IGkgPCBsaW5lY291bnQ7IGkrKykge1xuICAgICAgICB0bXAucHVzaChmaWxsV2l0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzLnB1c2godG1wKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuYmF0Y2ggPSBiYXRjaDtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICB2YXIgcmV0ID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHJldC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJldC5zbGljZSgxKSk7XG59XG5cbmV4cG9ydHMuY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG5cbmZ1bmN0aW9uIGNlbnRlcihzdHIsIHdpZHRoKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgd2lkdGggPSB3aWR0aCB8fCA4MDtcblxuICBpZiAoc3RyLmxlbmd0aCA+PSB3aWR0aCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgc3BhY2VzID0gd2lkdGggLSBzdHIubGVuZ3RoO1xuICB2YXIgcHJlID0gbGliLnJlcGVhdCgnICcsIHNwYWNlcyAvIDIgLSBzcGFjZXMgJSAyKTtcbiAgdmFyIHBvc3QgPSBsaWIucmVwZWF0KCcgJywgc3BhY2VzIC8gMik7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHByZSArIHN0ciArIHBvc3QpO1xufVxuXG5leHBvcnRzLmNlbnRlciA9IGNlbnRlcjtcblxuZnVuY3Rpb24gZGVmYXVsdF8odmFsLCBkZWYsIGJvb2wpIHtcbiAgaWYgKGJvb2wpIHtcbiAgICByZXR1cm4gdmFsIHx8IGRlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkZWY7XG4gIH1cbn0gLy8gVE9ETzogaXQgaXMgY29uZnVzaW5nIHRvIGV4cG9ydCBzb21ldGhpbmcgY2FsbGVkICdkZWZhdWx0J1xuXG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlZmF1bHRfOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuXG5mdW5jdGlvbiBkaWN0c29ydCh2YWwsIGNhc2VTZW5zaXRpdmUsIGJ5KSB7XG4gIGlmICghbGliLmlzT2JqZWN0KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoJ2RpY3Rzb3J0IGZpbHRlcjogdmFsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgYXJyYXkgPSBbXTsgLy8gZGVsaWJlcmF0ZWx5IGluY2x1ZGUgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QncyBwcm90b3R5cGVcblxuICBmb3IgKHZhciBrIGluIHZhbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGFycmF5LnB1c2goW2ssIHZhbFtrXV0pO1xuICB9XG5cbiAgdmFyIHNpO1xuXG4gIGlmIChieSA9PT0gdW5kZWZpbmVkIHx8IGJ5ID09PSAna2V5Jykge1xuICAgIHNpID0gMDtcbiAgfSBlbHNlIGlmIChieSA9PT0gJ3ZhbHVlJykge1xuICAgIHNpID0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoJ2RpY3Rzb3J0IGZpbHRlcjogWW91IGNhbiBvbmx5IHNvcnQgYnkgZWl0aGVyIGtleSBvciB2YWx1ZScpO1xuICB9XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgdmFyIGEgPSB0MVtzaV07XG4gICAgdmFyIGIgPSB0MltzaV07XG5cbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGlmIChsaWIuaXNTdHJpbmcoYSkpIHtcbiAgICAgICAgYSA9IGEudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpYi5pc1N0cmluZyhiKSkge1xuICAgICAgICBiID0gYi50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhID4gYiA/IDEgOiBhID09PSBiID8gMCA6IC0xOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydHMuZGljdHNvcnQgPSBkaWN0c29ydDtcblxuZnVuY3Rpb24gZHVtcChvYmosIHNwYWNlcykge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCBzcGFjZXMpO1xufVxuXG5leHBvcnRzLmR1bXAgPSBkdW1wO1xuXG5mdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gIGlmIChzdHIgaW5zdGFuY2VvZiByLlNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgc3RyID0gc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkID8gJycgOiBzdHI7XG4gIHJldHVybiByLm1hcmtTYWZlKGxpYi5lc2NhcGUoc3RyLnRvU3RyaW5nKCkpKTtcbn1cblxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG5cbmZ1bmN0aW9uIHNhZmUoc3RyKSB7XG4gIGlmIChzdHIgaW5zdGFuY2VvZiByLlNhZmVTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgc3RyID0gc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkID8gJycgOiBzdHI7XG4gIHJldHVybiByLm1hcmtTYWZlKHN0ci50b1N0cmluZygpKTtcbn1cblxuZXhwb3J0cy5zYWZlID0gc2FmZTtcblxuZnVuY3Rpb24gZmlyc3QoYXJyKSB7XG4gIHJldHVybiBhcnJbMF07XG59XG5cbmV4cG9ydHMuZmlyc3QgPSBmaXJzdDtcblxuZnVuY3Rpb24gZm9yY2Vlc2NhcGUoc3RyKSB7XG4gIHN0ciA9IHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShsaWIuZXNjYXBlKHN0ci50b1N0cmluZygpKSk7XG59XG5cbmV4cG9ydHMuZm9yY2Vlc2NhcGUgPSBmb3JjZWVzY2FwZTtcblxuZnVuY3Rpb24gZ3JvdXBieShhcnIsIGF0dHIpIHtcbiAgcmV0dXJuIGxpYi5ncm91cEJ5KGFyciwgYXR0ciwgdGhpcy5lbnYub3B0cy50aHJvd09uVW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0cy5ncm91cGJ5ID0gZ3JvdXBieTtcblxuZnVuY3Rpb24gaW5kZW50KHN0ciwgd2lkdGgsIGluZGVudGZpcnN0KSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcblxuICBpZiAoc3RyID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHdpZHRoID0gd2lkdGggfHwgNDsgLy8gbGV0IHJlcyA9ICcnO1xuXG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBzcCA9IGxpYi5yZXBlYXQoJyAnLCB3aWR0aCk7XG4gIHZhciByZXMgPSBsaW5lcy5tYXAoZnVuY3Rpb24gKGwsIGkpIHtcbiAgICByZXR1cm4gaSA9PT0gMCAmJiAhaW5kZW50Zmlyc3QgPyBsIDogXCJcIiArIHNwICsgbDtcbiAgfSkuam9pbignXFxuJyk7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHJlcyk7XG59XG5cbmV4cG9ydHMuaW5kZW50ID0gaW5kZW50O1xuXG5mdW5jdGlvbiBqb2luKGFyciwgZGVsLCBhdHRyKSB7XG4gIGRlbCA9IGRlbCB8fCAnJztcblxuICBpZiAoYXR0cikge1xuICAgIGFyciA9IGxpYi5tYXAoYXJyLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHZbYXR0cl07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXJyLmpvaW4oZGVsKTtcbn1cblxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG5cbmZ1bmN0aW9uIGxlbmd0aEZpbHRlcih2YWwpIHtcbiAgdmFyIHZhbHVlID0gbm9ybWFsaXplKHZhbCwgJycpO1xuXG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgLy8gRUNNQVNjcmlwdCAyMDE1IE1hcHMgYW5kIFNldHNcbiAgICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICAgIH1cblxuICAgIGlmIChsaWIuaXNPYmplY3QodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiByLlNhZmVTdHJpbmcpKSB7XG4gICAgICAvLyBPYmplY3RzIChiZXNpZGVzIFNhZmVTdHJpbmdzKSwgbm9uLXByaW1hdGl2ZSBBcnJheXNcbiAgICAgIHJldHVybiBsaWIua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGhGaWx0ZXI7XG5cbmZ1bmN0aW9uIGxpc3QodmFsKSB7XG4gIGlmIChsaWIuaXNTdHJpbmcodmFsKSkge1xuICAgIHJldHVybiB2YWwuc3BsaXQoJycpO1xuICB9IGVsc2UgaWYgKGxpYi5pc09iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIGxpYi5fZW50cmllcyh2YWwgfHwge30pLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGtleSA9IF9yZWZbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmWzFdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsaWIuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoJ2xpc3QgZmlsdGVyOiB0eXBlIG5vdCBpdGVyYWJsZScpO1xuICB9XG59XG5cbmV4cG9ydHMubGlzdCA9IGxpc3Q7XG5cbmZ1bmN0aW9uIGxvd2VyKHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0cy5sb3dlciA9IGxvd2VyO1xuXG5mdW5jdGlvbiBubDJicihzdHIpIHtcbiAgaWYgKHN0ciA9PT0gbnVsbCB8fCBzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHN0ci5yZXBsYWNlKC9cXHJcXG58XFxuL2csICc8YnIgLz5cXG4nKSk7XG59XG5cbmV4cG9ydHMubmwyYnIgPSBubDJicjtcblxuZnVuY3Rpb24gcmFuZG9tKGFycikge1xuICByZXR1cm4gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXTtcbn1cblxuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG4vKipcbiAqIENvbnN0cnVjdCBzZWxlY3Qgb3IgcmVqZWN0IGZpbHRlclxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhwZWN0ZWRUZXN0UmVzdWx0XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oYXJyYXksIHN0cmluZywgKik6IGFycmF5fVxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdE9yUmVqZWN0KGV4cGVjdGVkVGVzdFJlc3VsdCkge1xuICBmdW5jdGlvbiBmaWx0ZXIoYXJyLCB0ZXN0TmFtZSwgc2Vjb25kQXJnKSB7XG4gICAgaWYgKHRlc3ROYW1lID09PSB2b2lkIDApIHtcbiAgICAgIHRlc3ROYW1lID0gJ3RydXRoeSc7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgIHZhciB0ZXN0ID0gY29udGV4dC5lbnYuZ2V0VGVzdCh0ZXN0TmFtZSk7XG4gICAgcmV0dXJuIGxpYi50b0FycmF5KGFycikuZmlsdGVyKGZ1bmN0aW9uIGV4YW1pbmVUZXN0UmVzdWx0KGl0ZW0pIHtcbiAgICAgIHJldHVybiB0ZXN0LmNhbGwoY29udGV4dCwgaXRlbSwgc2Vjb25kQXJnKSA9PT0gZXhwZWN0ZWRUZXN0UmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZpbHRlcjtcbn1cblxuZXhwb3J0cy5yZWplY3QgPSBnZXRTZWxlY3RPclJlamVjdChmYWxzZSk7XG5cbmZ1bmN0aW9uIHJlamVjdGF0dHIoYXJyLCBhdHRyKSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuICFpdGVtW2F0dHJdO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yZWplY3RhdHRyID0gcmVqZWN0YXR0cjtcbmV4cG9ydHMuc2VsZWN0ID0gZ2V0U2VsZWN0T3JSZWplY3QodHJ1ZSk7XG5cbmZ1bmN0aW9uIHNlbGVjdGF0dHIoYXJyLCBhdHRyKSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuICEhaXRlbVthdHRyXTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuc2VsZWN0YXR0ciA9IHNlbGVjdGF0dHI7XG5cbmZ1bmN0aW9uIHJlcGxhY2Uoc3RyLCBvbGQsIG5ld18sIG1heENvdW50KSB7XG4gIHZhciBvcmlnaW5hbFN0ciA9IHN0cjtcblxuICBpZiAob2xkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG9sZCwgbmV3Xyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG1heENvdW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIG1heENvdW50ID0gLTE7XG4gIH1cblxuICB2YXIgcmVzID0gJyc7IC8vIE91dHB1dFxuICAvLyBDYXN0IE51bWJlcnMgaW4gdGhlIHNlYXJjaCB0ZXJtIHRvIHN0cmluZ1xuXG4gIGlmICh0eXBlb2Ygb2xkID09PSAnbnVtYmVyJykge1xuICAgIG9sZCA9ICcnICsgb2xkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvbGQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgaXQgaXMgc29tZXRoaW5nIG90aGVyIHRoYW4gbnVtYmVyIG9yIHN0cmluZyxcbiAgICAvLyByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZ1xuICAgIHJldHVybiBzdHI7XG4gIH0gLy8gQ2FzdCBudW1iZXJzIGluIHRoZSByZXBsYWNlbWVudCB0byBzdHJpbmdcblxuXG4gIGlmICh0eXBlb2Ygc3RyID09PSAnbnVtYmVyJykge1xuICAgIHN0ciA9ICcnICsgc3RyO1xuICB9IC8vIElmIGJ5IG5vdywgd2UgZG9uJ3QgaGF2ZSBhIHN0cmluZywgdGhyb3cgaXQgYmFja1xuXG5cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnICYmICEoc3RyIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH0gLy8gU2hvcnRDaXJjdWl0c1xuXG5cbiAgaWYgKG9sZCA9PT0gJycpIHtcbiAgICAvLyBNaW1pYyB0aGUgcHl0aG9uIGJlaGF2aW91cjogZW1wdHkgc3RyaW5nIGlzIHJlcGxhY2VkXG4gICAgLy8gYnkgcmVwbGFjZW1lbnQgZS5nLiBcImFiY1wifHJlcGxhY2UoXCJcIiwgXCIuXCIpIC0+IC5hLmIuYy5cbiAgICByZXMgPSBuZXdfICsgc3RyLnNwbGl0KCcnKS5qb2luKG5ld18pICsgbmV3XztcbiAgICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCByZXMpO1xuICB9XG5cbiAgdmFyIG5leHRJbmRleCA9IHN0ci5pbmRleE9mKG9sZCk7IC8vIGlmICMgb2YgcmVwbGFjZW1lbnRzIHRvIHBlcmZvcm0gaXMgMCwgb3IgdGhlIHN0cmluZyB0byBkb2VzXG4gIC8vIG5vdCBjb250YWluIHRoZSBvbGQgdmFsdWUsIHJldHVybiB0aGUgc3RyaW5nXG5cbiAgaWYgKG1heENvdW50ID09PSAwIHx8IG5leHRJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIHBvcyA9IDA7XG4gIHZhciBjb3VudCA9IDA7IC8vICMgb2YgcmVwbGFjZW1lbnRzIG1hZGVcblxuICB3aGlsZSAobmV4dEluZGV4ID4gLTEgJiYgKG1heENvdW50ID09PSAtMSB8fCBjb3VudCA8IG1heENvdW50KSkge1xuICAgIC8vIEdyYWIgdGhlIG5leHQgY2h1bmsgb2Ygc3JjIHN0cmluZyBhbmQgYWRkIGl0IHdpdGggdGhlXG4gICAgLy8gcmVwbGFjZW1lbnQsIHRvIHRoZSByZXN1bHRcbiAgICByZXMgKz0gc3RyLnN1YnN0cmluZyhwb3MsIG5leHRJbmRleCkgKyBuZXdfOyAvLyBJbmNyZW1lbnQgb3VyIHBvaW50ZXIgaW4gdGhlIHNyYyBzdHJpbmdcblxuICAgIHBvcyA9IG5leHRJbmRleCArIG9sZC5sZW5ndGg7XG4gICAgY291bnQrKzsgLy8gU2VlIGlmIHRoZXJlIGFyZSBhbnkgbW9yZSByZXBsYWNlbWVudHMgdG8gYmUgbWFkZVxuXG4gICAgbmV4dEluZGV4ID0gc3RyLmluZGV4T2Yob2xkLCBwb3MpO1xuICB9IC8vIFdlJ3ZlIGVpdGhlciByZWFjaGVkIHRoZSBlbmQsIG9yIGRvbmUgdGhlIG1heCAjIG9mXG4gIC8vIHJlcGxhY2VtZW50cywgdGFjayBvbiBhbnkgcmVtYWluaW5nIHN0cmluZ1xuXG5cbiAgaWYgKHBvcyA8IHN0ci5sZW5ndGgpIHtcbiAgICByZXMgKz0gc3RyLnN1YnN0cmluZyhwb3MpO1xuICB9XG5cbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKG9yaWdpbmFsU3RyLCByZXMpO1xufVxuXG5leHBvcnRzLnJlcGxhY2UgPSByZXBsYWNlO1xuXG5mdW5jdGlvbiByZXZlcnNlKHZhbCkge1xuICB2YXIgYXJyO1xuXG4gIGlmIChsaWIuaXNTdHJpbmcodmFsKSkge1xuICAgIGFyciA9IGxpc3QodmFsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb3B5IGl0XG4gICAgYXJyID0gbGliLm1hcCh2YWwsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfVxuXG4gIGFyci5yZXZlcnNlKCk7XG5cbiAgaWYgKGxpYi5pc1N0cmluZyh2YWwpKSB7XG4gICAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHZhbCwgYXJyLmpvaW4oJycpKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydHMucmV2ZXJzZSA9IHJldmVyc2U7XG5cbmZ1bmN0aW9uIHJvdW5kKHZhbCwgcHJlY2lzaW9uLCBtZXRob2QpIHtcbiAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDA7XG4gIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgdmFyIHJvdW5kZXI7XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ2NlaWwnKSB7XG4gICAgcm91bmRlciA9IE1hdGguY2VpbDtcbiAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdmbG9vcicpIHtcbiAgICByb3VuZGVyID0gTWF0aC5mbG9vcjtcbiAgfSBlbHNlIHtcbiAgICByb3VuZGVyID0gTWF0aC5yb3VuZDtcbiAgfVxuXG4gIHJldHVybiByb3VuZGVyKHZhbCAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbmV4cG9ydHMucm91bmQgPSByb3VuZDtcblxuZnVuY3Rpb24gc2xpY2UoYXJyLCBzbGljZXMsIGZpbGxXaXRoKSB7XG4gIHZhciBzbGljZUxlbmd0aCA9IE1hdGguZmxvb3IoYXJyLmxlbmd0aCAvIHNsaWNlcyk7XG4gIHZhciBleHRyYSA9IGFyci5sZW5ndGggJSBzbGljZXM7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZXM7IGkrKykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldCArIGkgKiBzbGljZUxlbmd0aDtcblxuICAgIGlmIChpIDwgZXh0cmEpIHtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBvZmZzZXQgKyAoaSArIDEpICogc2xpY2VMZW5ndGg7XG4gICAgdmFyIGN1cnJTbGljZSA9IGFyci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChmaWxsV2l0aCAmJiBpID49IGV4dHJhKSB7XG4gICAgICBjdXJyU2xpY2UucHVzaChmaWxsV2l0aCk7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY3VyclNsaWNlKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcblxuZnVuY3Rpb24gc3VtKGFyciwgYXR0ciwgc3RhcnQpIHtcbiAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoYXR0cikge1xuICAgIGFyciA9IGxpYi5tYXAoYXJyLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHZbYXR0cl07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhcnQgKyBhcnIucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9LCAwKTtcbn1cblxuZXhwb3J0cy5zdW0gPSBzdW07XG5leHBvcnRzLnNvcnQgPSByLm1ha2VNYWNybyhbJ3ZhbHVlJywgJ3JldmVyc2UnLCAnY2FzZV9zZW5zaXRpdmUnLCAnYXR0cmlidXRlJ10sIFtdLCBmdW5jdGlvbiBzb3J0RmlsdGVyKGFyciwgcmV2ZXJzZWQsIGNhc2VTZW5zLCBhdHRyKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgLy8gQ29weSBpdFxuICB2YXIgYXJyYXkgPSBsaWIubWFwKGFyciwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfSk7XG4gIHZhciBnZXRBdHRyaWJ1dGUgPSBsaWIuZ2V0QXR0ckdldHRlcihhdHRyKTtcbiAgYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB4ID0gYXR0ciA/IGdldEF0dHJpYnV0ZShhKSA6IGE7XG4gICAgdmFyIHkgPSBhdHRyID8gZ2V0QXR0cmlidXRlKGIpIDogYjtcblxuICAgIGlmIChfdGhpcy5lbnYub3B0cy50aHJvd09uVW5kZWZpbmVkICYmIGF0dHIgJiYgKHggPT09IHVuZGVmaW5lZCB8fCB5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic29ydDogYXR0cmlidXRlIFxcXCJcIiArIGF0dHIgKyBcIlxcXCIgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIGlmICghY2FzZVNlbnMgJiYgbGliLmlzU3RyaW5nKHgpICYmIGxpYi5pc1N0cmluZyh5KSkge1xuICAgICAgeCA9IHgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHkgPSB5LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gcmV2ZXJzZWQgPyAxIDogLTE7XG4gICAgfSBlbHNlIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIHJldmVyc2VkID8gLTEgOiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59KTtcblxuZnVuY3Rpb24gc3RyaW5nKG9iaikge1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Mob2JqLCBvYmopO1xufVxuXG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcblxuZnVuY3Rpb24gc3RyaXB0YWdzKGlucHV0LCBwcmVzZXJ2ZUxpbmVicmVha3MpIHtcbiAgaW5wdXQgPSBub3JtYWxpemUoaW5wdXQsICcnKTtcbiAgdmFyIHRhZ3MgPSAvPFxcLz8oW2Etel1bYS16MC05XSopXFxiW14+XSo+fDwhLS1bXFxzXFxTXSo/LS0+L2dpO1xuICB2YXIgdHJpbW1lZElucHV0ID0gdHJpbShpbnB1dC5yZXBsYWNlKHRhZ3MsICcnKSk7XG4gIHZhciByZXMgPSAnJztcblxuICBpZiAocHJlc2VydmVMaW5lYnJlYWtzKSB7XG4gICAgcmVzID0gdHJpbW1lZElucHV0LnJlcGxhY2UoL14gK3wgKyQvZ20sICcnKSAvLyByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzXG4gICAgLnJlcGxhY2UoLyArL2csICcgJykgLy8gc3F1YXNoIGFkamFjZW50IHNwYWNlc1xuICAgIC5yZXBsYWNlKC8oXFxyXFxuKS9nLCAnXFxuJykgLy8gbm9ybWFsaXplIGxpbmVicmVha3MgKENSTEYgLT4gTEYpXG4gICAgLnJlcGxhY2UoL1xcblxcblxcbisvZywgJ1xcblxcbicpOyAvLyBzcXVhc2ggYWJub3JtYWwgYWRqYWNlbnQgbGluZWJyZWFrc1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHRyaW1tZWRJbnB1dC5yZXBsYWNlKC9cXHMrL2dpLCAnICcpO1xuICB9XG5cbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKGlucHV0LCByZXMpO1xufVxuXG5leHBvcnRzLnN0cmlwdGFncyA9IHN0cmlwdGFncztcblxuZnVuY3Rpb24gdGl0bGUoc3RyKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgcmV0dXJuIGNhcGl0YWxpemUod29yZCk7XG4gIH0pO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCB3b3Jkcy5qb2luKCcgJykpO1xufVxuXG5leHBvcnRzLnRpdGxlID0gdGl0bGU7XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJykpO1xufVxuXG5leHBvcnRzLnRyaW0gPSB0cmltO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShpbnB1dCwgbGVuZ3RoLCBraWxsd29yZHMsIGVuZCkge1xuICB2YXIgb3JpZyA9IGlucHV0O1xuICBpbnB1dCA9IG5vcm1hbGl6ZShpbnB1dCwgJycpO1xuICBsZW5ndGggPSBsZW5ndGggfHwgMjU1O1xuXG4gIGlmIChpbnB1dC5sZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgaWYgKGtpbGx3b3Jkcykge1xuICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKCcgJywgbGVuZ3RoKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBpZHggPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBpbnB1dC5zdWJzdHJpbmcoMCwgaWR4KTtcbiAgfVxuXG4gIGlucHV0ICs9IGVuZCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gbnVsbCA/IGVuZCA6ICcuLi4nO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Mob3JpZywgaW5wdXQpO1xufVxuXG5leHBvcnRzLnRydW5jYXRlID0gdHJ1bmNhdGU7XG5cbmZ1bmN0aW9uIHVwcGVyKHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0cy51cHBlciA9IHVwcGVyO1xuXG5mdW5jdGlvbiB1cmxlbmNvZGUob2JqKSB7XG4gIHZhciBlbmMgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgaWYgKGxpYi5pc1N0cmluZyhvYmopKSB7XG4gICAgcmV0dXJuIGVuYyhvYmopO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXl2YWxzID0gbGliLmlzQXJyYXkob2JqKSA/IG9iaiA6IGxpYi5fZW50cmllcyhvYmopO1xuICAgIHJldHVybiBrZXl2YWxzLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgIHZhciBrID0gX3JlZjJbMF0sXG4gICAgICAgICAgdiA9IF9yZWYyWzFdO1xuICAgICAgcmV0dXJuIGVuYyhrKSArIFwiPVwiICsgZW5jKHYpO1xuICAgIH0pLmpvaW4oJyYnKTtcbiAgfVxufVxuXG5leHBvcnRzLnVybGVuY29kZSA9IHVybGVuY29kZTsgLy8gRm9yIHRoZSBqaW5qYSByZWdleHAsIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pdHN1aGlrby9qaW5qYTIvYmxvYi9mMTViODE0ZGNiYTZhYTEyYmM3NGQxZjdkMGM4ODFkNTVmNzEyNmJlL2ppbmphMi91dGlscy5weSNMMjAtTDIzXG5cbnZhciBwdW5jUmUgPSAvXig/OlxcKHw8fCZsdDspPyguKj8pKD86XFwufCx8XFwpfFxcbnwmZ3Q7KT8kLzsgLy8gZnJvbSBodHRwOi8vYmxvZy5nZXJ2Lm5ldC8yMDExLzA1L2h0bWw1X2VtYWlsX2FkZHJlc3NfcmVnZXhwL1xuXG52YXIgZW1haWxSZSA9IC9eW1xcdy4hIyQlJicqK1xcLVxcLz0/XFxeYHt8fX5dK0BbYS16XFxkXFwtXSsoXFwuW2EtelxcZFxcLV0rKSskL2k7XG52YXIgaHR0cEh0dHBzUmUgPSAvXmh0dHBzPzpcXC9cXC8uKiQvO1xudmFyIHd3d1JlID0gL153d3dcXC4vO1xudmFyIHRsZFJlID0gL1xcLig/Om9yZ3xuZXR8Y29tKSg/OlxcOnxcXC98JCkvO1xuXG5mdW5jdGlvbiB1cmxpemUoc3RyLCBsZW5ndGgsIG5vZm9sbG93KSB7XG4gIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgbGVuZ3RoID0gSW5maW5pdHk7XG4gIH1cblxuICB2YXIgbm9Gb2xsb3dBdHRyID0gbm9mb2xsb3cgPT09IHRydWUgPyAnIHJlbD1cIm5vZm9sbG93XCInIDogJyc7XG4gIHZhciB3b3JkcyA9IHN0ci5zcGxpdCgvKFxccyspLykuZmlsdGVyKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgLy8gSWYgdGhlIHdvcmQgaGFzIG5vIGxlbmd0aCwgYmFpbC4gVGhpcyBjYW4gaGFwcGVuIGZvciBzdHIgd2l0aFxuICAgIC8vIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgcmV0dXJuIHdvcmQgJiYgd29yZC5sZW5ndGg7XG4gIH0pLm1hcChmdW5jdGlvbiAod29yZCkge1xuICAgIHZhciBtYXRjaGVzID0gd29yZC5tYXRjaChwdW5jUmUpO1xuICAgIHZhciBwb3NzaWJsZVVybCA9IG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogd29yZDtcbiAgICB2YXIgc2hvcnRVcmwgPSBwb3NzaWJsZVVybC5zdWJzdHIoMCwgbGVuZ3RoKTsgLy8gdXJsIHRoYXQgc3RhcnRzIHdpdGggaHR0cCBvciBodHRwc1xuXG4gICAgaWYgKGh0dHBIdHRwc1JlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIiArIHBvc3NpYmxlVXJsICsgXCJcXFwiXCIgKyBub0ZvbGxvd0F0dHIgKyBcIj5cIiArIHNob3J0VXJsICsgXCI8L2E+XCI7XG4gICAgfSAvLyB1cmwgdGhhdCBzdGFydHMgd2l0aCB3d3cuXG5cblxuICAgIGlmICh3d3dSZS50ZXN0KHBvc3NpYmxlVXJsKSkge1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiaHR0cDovL1wiICsgcG9zc2libGVVcmwgKyBcIlxcXCJcIiArIG5vRm9sbG93QXR0ciArIFwiPlwiICsgc2hvcnRVcmwgKyBcIjwvYT5cIjtcbiAgICB9IC8vIGFuIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIGZvcm0gdXNlcm5hbWVAZG9tYWluLnRsZFxuXG5cbiAgICBpZiAoZW1haWxSZS50ZXN0KHBvc3NpYmxlVXJsKSkge1xuICAgICAgcmV0dXJuIFwiPGEgaHJlZj1cXFwibWFpbHRvOlwiICsgcG9zc2libGVVcmwgKyBcIlxcXCI+XCIgKyBwb3NzaWJsZVVybCArIFwiPC9hPlwiO1xuICAgIH0gLy8gdXJsIHRoYXQgZW5kcyBpbiAuY29tLCAub3JnIG9yIC5uZXQgdGhhdCBpcyBub3QgYW4gZW1haWwgYWRkcmVzc1xuXG5cbiAgICBpZiAodGxkUmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcImh0dHA6Ly9cIiArIHBvc3NpYmxlVXJsICsgXCJcXFwiXCIgKyBub0ZvbGxvd0F0dHIgKyBcIj5cIiArIHNob3J0VXJsICsgXCI8L2E+XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmQ7XG4gIH0pO1xuICByZXR1cm4gd29yZHMuam9pbignJyk7XG59XG5cbmV4cG9ydHMudXJsaXplID0gdXJsaXplO1xuXG5mdW5jdGlvbiB3b3JkY291bnQoc3RyKSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcbiAgdmFyIHdvcmRzID0gc3RyID8gc3RyLm1hdGNoKC9cXHcrL2cpIDogbnVsbDtcbiAgcmV0dXJuIHdvcmRzID8gd29yZHMubGVuZ3RoIDogbnVsbDtcbn1cblxuZXhwb3J0cy53b3JkY291bnQgPSB3b3JkY291bnQ7XG5cbmZ1bmN0aW9uIGZsb2F0KHZhbCwgZGVmKSB7XG4gIHZhciByZXMgPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihyZXMpID8gZGVmIDogcmVzO1xufVxuXG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG52YXIgaW50RmlsdGVyID0gci5tYWtlTWFjcm8oWyd2YWx1ZScsICdkZWZhdWx0JywgJ2Jhc2UnXSwgW10sIGZ1bmN0aW9uIGRvSW50KHZhbHVlLCBkZWZhdWx0VmFsdWUsIGJhc2UpIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuXG4gIHZhciByZXMgPSBwYXJzZUludCh2YWx1ZSwgYmFzZSk7XG4gIHJldHVybiBpc05hTihyZXMpID8gZGVmYXVsdFZhbHVlIDogcmVzO1xufSk7XG5leHBvcnRzLmludCA9IGludEZpbHRlcjsgLy8gQWxpYXNlc1xuXG5leHBvcnRzLmQgPSBleHBvcnRzLmRlZmF1bHQ7XG5leHBvcnRzLmUgPSBleHBvcnRzLmVzY2FwZTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIExvYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBQcmVjb21waWxlZExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcikge1xuICBfaW5oZXJpdHNMb29zZShQcmVjb21waWxlZExvYWRlciwgX0xvYWRlcik7XG5cbiAgZnVuY3Rpb24gUHJlY29tcGlsZWRMb2FkZXIoY29tcGlsZWRUZW1wbGF0ZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Mb2FkZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLnByZWNvbXBpbGVkID0gY29tcGlsZWRUZW1wbGF0ZXMgfHwge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFByZWNvbXBpbGVkTG9hZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0U291cmNlID0gZnVuY3Rpb24gZ2V0U291cmNlKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wcmVjb21waWxlZFtuYW1lXSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIG9iajogdGhpcy5wcmVjb21waWxlZFtuYW1lXVxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiBuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcmVjb21waWxlZExvYWRlcjtcbn0oTG9hZGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFByZWNvbXBpbGVkTG9hZGVyOiBQcmVjb21waWxlZExvYWRlclxufTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgU2FmZVN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMikuU2FmZVN0cmluZztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBpcyBhIGZ1bmN0aW9uLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cblxuZnVuY3Rpb24gY2FsbGFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0cy5jYWxsYWJsZSA9IGNhbGxhYmxlO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGlzIHN0cmljdGx5IG5vdCBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMuZGVmaW5lZCA9IGRlZmluZWQ7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGRpdmlzYmxlIGJ5IHRoZSB0ZXN0J3MgYXJndW1lbnRcbiAqICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZGl2aXNpYmxlYnkob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSAlIHR3byA9PT0gMDtcbn1cblxuZXhwb3J0cy5kaXZpc2libGVieSA9IGRpdmlzaWJsZWJ5O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBoYXMgYmVlbiBlc2NhcGVkIChpLmUuLCBpcyBhIFNhZmVTdHJpbmcpLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTYWZlU3RyaW5nO1xufVxuXG5leHBvcnRzLmVzY2FwZWQgPSBlc2NhcGVkO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqIEBwYXJhbSB7IGFueSB9IG9uZVxuICogQHBhcmFtIHsgYW55IH0gdHdvXG4gKi9cblxuZnVuY3Rpb24gZXF1YWx0byhvbmUsIHR3bykge1xuICByZXR1cm4gb25lID09PSB0d287XG59XG5cbmV4cG9ydHMuZXF1YWx0byA9IGVxdWFsdG87IC8vIEFsaWFzZXNcblxuZXhwb3J0cy5lcSA9IGV4cG9ydHMuZXF1YWx0bztcbmV4cG9ydHMuc2FtZWFzID0gZXhwb3J0cy5lcXVhbHRvO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZXZlbmx5IGRpdmlzaWJsZSBieSAyLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gZXZlbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJSAyID09PSAwO1xufVxuXG5leHBvcnRzLmV2ZW4gPSBldmVuO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZmFsc3kgLSBpZiBJIHJlY2FsbCBjb3JyZWN0bHksICcnLCAwLCBmYWxzZSxcbiAqIHVuZGVmaW5lZCwgTmFOIG9yIG51bGwuIEkgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgc3RpY2sgdG8gdGhlIGRlZmF1bHQgSlNcbiAqIGJlaGF2aW9yIG9yIGF0dGVtcHQgdG8gcmVwbGljYXRlIHdoYXQgUHl0aG9uIGJlbGlldmVzIHNob3VsZCBiZSBmYWxzeSAoaS5lLixcbiAqIGVtcHR5IGFycmF5cywgZW1wdHkgZGljdHMsIG5vdCAwLi4uKS5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGZhbHN5KHZhbHVlKSB7XG4gIHJldHVybiAhdmFsdWU7XG59XG5cbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgdGVzdCdzXG4gKiBhcmd1bWVudCAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGdlKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPj0gdHdvO1xufVxuXG5leHBvcnRzLmdlID0gZ2U7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGVzdCdzIGFyZ3VtZW50XG4gKiAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGdyZWF0ZXJ0aGFuKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPiB0d287XG59XG5cbmV4cG9ydHMuZ3JlYXRlcnRoYW4gPSBncmVhdGVydGhhbjsgLy8gYWxpYXNcblxuZXhwb3J0cy5ndCA9IGV4cG9ydHMuZ3JlYXRlcnRoYW47XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdGVzdCdzXG4gKiBhcmd1bWVudCAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIGxlKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPD0gdHdvO1xufVxuXG5leHBvcnRzLmxlID0gbGU7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGxlc3MgdGhhbiB0aGUgdGVzdCdzIHBhc3NlZCBhcmd1bWVudFxuICogKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBsZXNzdGhhbihvbmUsIHR3bykge1xuICByZXR1cm4gb25lIDwgdHdvO1xufVxuXG5leHBvcnRzLmxlc3N0aGFuID0gbGVzc3RoYW47IC8vIGFsaWFzXG5cbmV4cG9ydHMubHQgPSBleHBvcnRzLmxlc3N0aGFuO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyaW5nIGlzIGxvd2VyY2FzZWQuXG4gKiBAcGFyYW0geyBzdHJpbmcgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBsb3dlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWU7XG59XG5cbmV4cG9ydHMubG93ZXIgPSBsb3dlcjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0ZXN0J3NcbiAqIGFyZ3VtZW50ICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbmUob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSAhPT0gdHdvO1xufVxuXG5leHBvcnRzLm5lID0gbmU7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgc3RyaWN0bHkgZXF1YWwgdG8gYG51bGxgLlxuICogQHBhcmFtIHsgYW55IH1cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbnVsbFRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG5leHBvcnRzLm51bGwgPSBudWxsVGVzdDtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHsgYW55IH1cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzICpub3QqIGV2ZW5seSBkaXZpc2libGUgYnkgMi5cbiAqIEBwYXJhbSB7IG51bWJlciB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIG9kZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJSAyID09PSAxO1xufVxuXG5leHBvcnRzLm9kZCA9IG9kZDtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBgZmFsc2VgIGlmIG5vdC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgdGhpbmdzIGNvbnNpZGVyZWQgZmFsc3k6XG4gKiAnJywgbnVsbCwgdW5kZWZpbmVkLCAwLCBOYU4gYW5kIGZhbHNlLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlO1xufVxuXG5leHBvcnRzLnRydXRoeSA9IHRydXRoeTtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5cbmZ1bmN0aW9uIHVuZGVmaW5lZFRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMudW5kZWZpbmVkID0gdW5kZWZpbmVkVGVzdDtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHN0cmluZyBpcyB1cHBlcmNhc2VkLlxuICogQHBhcmFtIHsgc3RyaW5nIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cblxuZnVuY3Rpb24gdXBwZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCkgPT09IHZhbHVlO1xufVxuXG5leHBvcnRzLnVwcGVyID0gdXBwZXI7XG4vKipcbiAqIElmIEVTNiBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlLCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaW1wbGVtZW50cyB0aGVcbiAqIGBTeW1ib2wuaXRlcmF0b3JgIG1ldGhvZC4gSWYgbm90LCBpdCdzIGEgc3RyaW5nIG9yIEFycmF5LlxuICpcbiAqIENvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGlzc3VlcyBpZiBhIGJyb3dzZXIgZXhpc3RzIHRoYXQgaGFzIFNldCBhbmQgTWFwIGJ1dFxuICogbm90IFN5bWJvbC5cbiAqXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBpdGVyYWJsZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gISF2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICB9XG59XG5cbmV4cG9ydHMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbi8qKlxuICogSWYgRVM2IGZlYXR1cmVzIGFyZSBhdmFpbGFibGUsIHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgaGFzaFxuICogb3IgYW4gRVM2IE1hcC4gT3RoZXJ3aXNlIGp1c3QgcmV0dXJuIGlmIGl0J3MgYW4gb2JqZWN0IGhhc2guXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuXG5mdW5jdGlvbiBtYXBwaW5nKHZhbHVlKSB7XG4gIC8vIG9ubHkgbWFwcyBhbmQgb2JqZWN0IGhhc2hlc1xuICB2YXIgYm9vbCA9IHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbiAgaWYgKFNldCkge1xuICAgIHJldHVybiBib29sICYmICEodmFsdWUgaW5zdGFuY2VvZiBTZXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBib29sO1xuICB9XG59XG5cbmV4cG9ydHMubWFwcGluZyA9IG1hcHBpbmc7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2N5Y2xlcihpdGVtcykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGlmIChpbmRleCA+PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnQgPSBpdGVtc1tpbmRleF07XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gX2pvaW5lcihzZXApIHtcbiAgc2VwID0gc2VwIHx8ICcsJztcbiAgdmFyIGZpcnN0ID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsID0gZmlyc3QgPyAnJyA6IHNlcDtcbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG59IC8vIE1ha2luZyB0aGlzIGEgZnVuY3Rpb24gaW5zdGVhZCBzbyBpdCByZXR1cm5zIGEgbmV3IG9iamVjdFxuLy8gZWFjaCB0aW1lIGl0J3MgY2FsbGVkLiBUaGF0IHdheSwgaWYgc29tZXRoaW5nIGxpa2UgYW4gZW52aXJvbm1lbnRcbi8vIHVzZXMgaXQsIHRoZXkgd2lsbCBlYWNoIGhhdmUgdGhlaXIgb3duIGNvcHkuXG5cblxuZnVuY3Rpb24gZ2xvYmFscygpIHtcbiAgcmV0dXJuIHtcbiAgICByYW5nZTogZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIHN0ZXAgPSAxO1xuICAgICAgfSBlbHNlIGlmICghc3RlcCkge1xuICAgICAgICBzdGVwID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgYXJyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gc3RhcnQ7IF9pID4gc3RvcDsgX2kgKz0gc3RlcCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZm9yLWRpcmVjdGlvblxuICAgICAgICAgIGFyci5wdXNoKF9pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgY3ljbGVyOiBmdW5jdGlvbiBjeWNsZXIoKSB7XG4gICAgICByZXR1cm4gX2N5Y2xlcihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIGpvaW5lcjogZnVuY3Rpb24gam9pbmVyKHNlcCkge1xuICAgICAgcmV0dXJuIF9qb2luZXIoc2VwKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFscztcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwcmVzcyhlbnYsIGFwcCkge1xuICBmdW5jdGlvbiBOdW5qdWNrc1ZpZXcobmFtZSwgb3B0cykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wYXRoID0gbmFtZTtcbiAgICB0aGlzLmRlZmF1bHRFbmdpbmUgPSBvcHRzLmRlZmF1bHRFbmdpbmU7XG4gICAgdGhpcy5leHQgPSBwYXRoLmV4dG5hbWUobmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuZXh0ICYmICF0aGlzLmRlZmF1bHRFbmdpbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVmYXVsdCBlbmdpbmUgd2FzIHNwZWNpZmllZCBhbmQgbm8gZXh0ZW5zaW9uIHdhcyBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZXh0KSB7XG4gICAgICB0aGlzLm5hbWUgKz0gdGhpcy5leHQgPSAodGhpcy5kZWZhdWx0RW5naW5lWzBdICE9PSAnLicgPyAnLicgOiAnJykgKyB0aGlzLmRlZmF1bHRFbmdpbmU7XG4gICAgfVxuICB9XG5cbiAgTnVuanVja3NWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIob3B0cywgY2IpIHtcbiAgICBlbnYucmVuZGVyKHRoaXMubmFtZSwgb3B0cywgY2IpO1xuICB9O1xuXG4gIGFwcC5zZXQoJ3ZpZXcnLCBOdW5qdWNrc1ZpZXcpO1xuICBhcHAuc2V0KCdudW5qdWNrc0VudicsIGVudik7XG4gIHJldHVybiBlbnY7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKSxcbiAgICBfcHJldHRpZnlFcnJvciA9IF9yZXF1aXJlLl9wcmV0dGlmeUVycm9yO1xuXG52YXIgY29tcGlsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSxcbiAgICBFbnZpcm9ubWVudCA9IF9yZXF1aXJlMi5FbnZpcm9ubWVudDtcblxudmFyIHByZWNvbXBpbGVHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuZnVuY3Rpb24gbWF0Y2goZmlsZW5hbWUsIHBhdHRlcm5zKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJucykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcGF0dGVybnMuc29tZShmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBmaWxlbmFtZS5tYXRjaChwYXR0ZXJuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGVTdHJpbmcoc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLmlzU3RyaW5nID0gdHJ1ZTtcbiAgdmFyIGVudiA9IG9wdHMuZW52IHx8IG5ldyBFbnZpcm9ubWVudChbXSk7XG4gIHZhciB3cmFwcGVyID0gb3B0cy53cmFwcGVyIHx8IHByZWNvbXBpbGVHbG9iYWw7XG5cbiAgaWYgKCFvcHRzLm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBcIm5hbWVcIiBvcHRpb24gaXMgcmVxdWlyZWQgd2hlbiBjb21waWxpbmcgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyKFtfcHJlY29tcGlsZShzdHIsIG9wdHMubmFtZSwgZW52KV0sIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlKGlucHV0LCBvcHRzKSB7XG4gIC8vIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICAvL1xuICAvLyAqIG5hbWU6IG5hbWUgb2YgdGhlIHRlbXBsYXRlIChhdXRvLWdlbmVyYXRlZCB3aGVuIGNvbXBpbGluZyBhIGRpcmVjdG9yeSlcbiAgLy8gKiBpc1N0cmluZzogaW5wdXQgaXMgYSBzdHJpbmcsIG5vdCBhIGZpbGUgcGF0aFxuICAvLyAqIGFzRnVuY3Rpb246IGdlbmVyYXRlIGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgLy8gKiBmb3JjZToga2VlcCBjb21waWxpbmcgb24gZXJyb3JcbiAgLy8gKiBlbnY6IHRoZSBFbnZpcm9ubWVudCB0byB1c2UgKGdldHMgZXh0ZW5zaW9ucyBhbmQgYXN5bmMgZmlsdGVycyBmcm9tIGl0KVxuICAvLyAqIGluY2x1ZGU6IHdoaWNoIGZpbGUvZm9sZGVycyB0byBpbmNsdWRlIChmb2xkZXJzIGFyZSBhdXRvLWluY2x1ZGVkLCBmaWxlcyBhcmUgYXV0by1leGNsdWRlZClcbiAgLy8gKiBleGNsdWRlOiB3aGljaCBmaWxlL2ZvbGRlcnMgdG8gZXhjbHVkZSAoZm9sZGVycyBhcmUgYXV0by1pbmNsdWRlZCwgZmlsZXMgYXJlIGF1dG8tZXhjbHVkZWQpXG4gIC8vICogd3JhcHBlcjogZnVuY3Rpb24odGVtcGxhdGVzLCBvcHRzKSB7Li4ufVxuICAvLyAgICAgICBDdXN0b21pemUgdGhlIG91dHB1dCBmb3JtYXQgdG8gc3RvcmUgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAvLyAgICAgICBCeSBkZWZhdWx0LCB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGdsb2JhbCB2YXJpYWJsZSB1c2VkIGJ5IHRoZSBydW50aW1lLlxuICAvLyAgICAgICBBIGN1c3RvbSBsb2FkZXIgd2lsbCBiZSBuZWNlc3NhcnkgdG8gbG9hZCB5b3VyIGN1c3RvbSB3cmFwcGVyLlxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIGVudiA9IG9wdHMuZW52IHx8IG5ldyBFbnZpcm9ubWVudChbXSk7XG4gIHZhciB3cmFwcGVyID0gb3B0cy53cmFwcGVyIHx8IHByZWNvbXBpbGVHbG9iYWw7XG5cbiAgaWYgKG9wdHMuaXNTdHJpbmcpIHtcbiAgICByZXR1cm4gcHJlY29tcGlsZVN0cmluZyhpbnB1dCwgb3B0cyk7XG4gIH1cblxuICB2YXIgcGF0aFN0YXRzID0gZnMuZXhpc3RzU3luYyhpbnB1dCkgJiYgZnMuc3RhdFN5bmMoaW5wdXQpO1xuICB2YXIgcHJlY29tcGlsZWQgPSBbXTtcbiAgdmFyIHRlbXBsYXRlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFkZFRlbXBsYXRlcyhkaXIpIHtcbiAgICBmcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgIHZhciBmaWxlcGF0aCA9IHBhdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgdmFyIHN1YnBhdGggPSBmaWxlcGF0aC5zdWJzdHIocGF0aC5qb2luKGlucHV0LCAnLycpLmxlbmd0aCk7XG4gICAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGVwYXRoKTtcblxuICAgICAgaWYgKHN0YXQgJiYgc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIHN1YnBhdGggKz0gJy8nO1xuXG4gICAgICAgIGlmICghbWF0Y2goc3VicGF0aCwgb3B0cy5leGNsdWRlKSkge1xuICAgICAgICAgIGFkZFRlbXBsYXRlcyhmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goc3VicGF0aCwgb3B0cy5pbmNsdWRlKSkge1xuICAgICAgICB0ZW1wbGF0ZXMucHVzaChmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocGF0aFN0YXRzLmlzRmlsZSgpKSB7XG4gICAgcHJlY29tcGlsZWQucHVzaChfcHJlY29tcGlsZShmcy5yZWFkRmlsZVN5bmMoaW5wdXQsICd1dGYtOCcpLCBvcHRzLm5hbWUgfHwgaW5wdXQsIGVudikpO1xuICB9IGVsc2UgaWYgKHBhdGhTdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgYWRkVGVtcGxhdGVzKGlucHV0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHRlbXBsYXRlc1tpXS5yZXBsYWNlKHBhdGguam9pbihpbnB1dCwgJy8nKSwgJycpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBwcmVjb21waWxlZC5wdXNoKF9wcmVjb21waWxlKGZzLnJlYWRGaWxlU3luYyh0ZW1wbGF0ZXNbaV0sICd1dGYtOCcpLCBuYW1lLCBlbnYpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKG9wdHMuZm9yY2UpIHtcbiAgICAgICAgICAvLyBEb24ndCBzdG9wIGdlbmVyYXRpbmcgdGhlIG91dHB1dCBpZiB3ZSdyZVxuICAgICAgICAgIC8vIGZvcmNpbmcgY29tcGlsYXRpb24uXG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyKHByZWNvbXBpbGVkLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gX3ByZWNvbXBpbGUoc3RyLCBuYW1lLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IG5ldyBFbnZpcm9ubWVudChbXSk7XG4gIHZhciBhc3luY0ZpbHRlcnMgPSBlbnYuYXN5bmNGaWx0ZXJzO1xuICB2YXIgZXh0ZW5zaW9ucyA9IGVudi5leHRlbnNpb25zTGlzdDtcbiAgdmFyIHRlbXBsYXRlO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cbiAgdHJ5IHtcbiAgICB0ZW1wbGF0ZSA9IGNvbXBpbGVyLmNvbXBpbGUoc3RyLCBhc3luY0ZpbHRlcnMsIGV4dGVuc2lvbnMsIG5hbWUsIGVudi5vcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgX3ByZXR0aWZ5RXJyb3IobmFtZSwgZmFsc2UsIGVycik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcmVjb21waWxlOiBwcmVjb21waWxlLFxuICBwcmVjb21waWxlU3RyaW5nOiBwcmVjb21waWxlU3RyaW5nXG59O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIHByZWNvbXBpbGVHbG9iYWwodGVtcGxhdGVzLCBvcHRzKSB7XG4gIHZhciBvdXQgPSAnJztcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlc1tpXS5uYW1lKTtcbiAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZXNbaV0udGVtcGxhdGU7XG4gICAgb3V0ICs9ICcoZnVuY3Rpb24oKSB7JyArICcod2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQgPSB3aW5kb3cubnVuanVja3NQcmVjb21waWxlZCB8fCB7fSknICsgJ1snICsgbmFtZSArICddID0gKGZ1bmN0aW9uKCkge1xcbicgKyB0ZW1wbGF0ZSArICdcXG59KSgpO1xcbic7XG5cbiAgICBpZiAob3B0cy5hc0Z1bmN0aW9uKSB7XG4gICAgICBvdXQgKz0gJ3JldHVybiBmdW5jdGlvbihjdHgsIGNiKSB7IHJldHVybiBudW5qdWNrcy5yZW5kZXIoJyArIG5hbWUgKyAnLCBjdHgsIGNiKTsgfVxcbic7XG4gICAgfVxuXG4gICAgb3V0ICs9ICd9KSgpO1xcbic7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByZWNvbXBpbGVHbG9iYWw7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gaW5zdGFsbENvbXBhdCgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBsaWtlIGBudW5qdWNrcy5pbnN0YWxsQ29tcGF0YCBzbyB0aGF0IGB0aGlzYFxuICAvLyByZWZlcmVuY2VzIHRoZSBudW5qdWNrcyBpbnN0YW5jZVxuXG4gIHZhciBydW50aW1lID0gdGhpcy5ydW50aW1lO1xuICB2YXIgbGliID0gdGhpcy5saWI7IC8vIEhhbmRsZSBzbGltIGNhc2Ugd2hlcmUgdGhlc2UgJ21vZHVsZXMnIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBidWlsdCBzb3VyY2VcblxuICB2YXIgQ29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyLkNvbXBpbGVyO1xuICB2YXIgUGFyc2VyID0gdGhpcy5wYXJzZXIuUGFyc2VyO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbGV4ZXIgPSB0aGlzLmxleGVyO1xuICB2YXIgb3JpZ19jb250ZXh0T3JGcmFtZUxvb2t1cCA9IHJ1bnRpbWUuY29udGV4dE9yRnJhbWVMb29rdXA7XG4gIHZhciBvcmlnX21lbWJlckxvb2t1cCA9IHJ1bnRpbWUubWVtYmVyTG9va3VwO1xuICB2YXIgb3JpZ19Db21waWxlcl9hc3NlcnRUeXBlO1xuICB2YXIgb3JpZ19QYXJzZXJfcGFyc2VBZ2dyZWdhdGU7XG5cbiAgaWYgKENvbXBpbGVyKSB7XG4gICAgb3JpZ19Db21waWxlcl9hc3NlcnRUeXBlID0gQ29tcGlsZXIucHJvdG90eXBlLmFzc2VydFR5cGU7XG4gIH1cblxuICBpZiAoUGFyc2VyKSB7XG4gICAgb3JpZ19QYXJzZXJfcGFyc2VBZ2dyZWdhdGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWdncmVnYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5pbnN0YWxsKCkge1xuICAgIHJ1bnRpbWUuY29udGV4dE9yRnJhbWVMb29rdXAgPSBvcmlnX2NvbnRleHRPckZyYW1lTG9va3VwO1xuICAgIHJ1bnRpbWUubWVtYmVyTG9va3VwID0gb3JpZ19tZW1iZXJMb29rdXA7XG5cbiAgICBpZiAoQ29tcGlsZXIpIHtcbiAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5hc3NlcnRUeXBlID0gb3JpZ19Db21waWxlcl9hc3NlcnRUeXBlO1xuICAgIH1cblxuICAgIGlmIChQYXJzZXIpIHtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBZ2dyZWdhdGUgPSBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZTtcbiAgICB9XG4gIH1cblxuICBydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwID0gZnVuY3Rpb24gY29udGV4dE9yRnJhbWVMb29rdXAoY29udGV4dCwgZnJhbWUsIGtleSkge1xuICAgIHZhciB2YWwgPSBvcmlnX2NvbnRleHRPckZyYW1lTG9va3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ1RydWUnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSAnRmFsc2UnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgJ05vbmUnOlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VG9rZW5zU3RhdGUodG9rZW5zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiB0b2tlbnMuaW5kZXgsXG4gICAgICBsaW5lbm86IHRva2Vucy5saW5lbm8sXG4gICAgICBjb2xubzogdG9rZW5zLmNvbG5vXG4gICAgfTtcbiAgfVxuXG4gIGlmIChcIlNURFwiICE9PSAnU0xJTScgJiYgbm9kZXMgJiYgQ29tcGlsZXIgJiYgUGFyc2VyKSB7XG4gICAgLy8gaS5lLiwgbm90IHNsaW0gbW9kZVxuICAgIHZhciBTbGljZSA9IG5vZGVzLk5vZGUuZXh0ZW5kKCdTbGljZScsIHtcbiAgICAgIGZpZWxkczogWydzdGFydCcsICdzdG9wJywgJ3N0ZXAnXSxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQobGluZW5vLCBjb2xubywgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCBuZXcgbm9kZXMuTGl0ZXJhbChsaW5lbm8sIGNvbG5vLCBudWxsKTtcbiAgICAgICAgc3RvcCA9IHN0b3AgfHwgbmV3IG5vZGVzLkxpdGVyYWwobGluZW5vLCBjb2xubywgbnVsbCk7XG4gICAgICAgIHN0ZXAgPSBzdGVwIHx8IG5ldyBub2Rlcy5MaXRlcmFsKGxpbmVubywgY29sbm8sIDEpO1xuICAgICAgICB0aGlzLnBhcmVudChsaW5lbm8sIGNvbG5vLCBzdGFydCwgc3RvcCwgc3RlcCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBDb21waWxlci5wcm90b3R5cGUuYXNzZXJ0VHlwZSA9IGZ1bmN0aW9uIGFzc2VydFR5cGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTbGljZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZVNsaWNlID0gZnVuY3Rpb24gY29tcGlsZVNsaWNlKG5vZGUsIGZyYW1lKSB7XG4gICAgICB0aGlzLl9lbWl0KCcoJyk7XG5cbiAgICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuc3RhcnQsIGZyYW1lKTtcblxuICAgICAgdGhpcy5fZW1pdCgnKSwoJyk7XG5cbiAgICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuc3RvcCwgZnJhbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0KCcpLCgnKTtcblxuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5zdGVwLCBmcmFtZSk7XG5cbiAgICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIHBhcnNlQWdncmVnYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9yaWdTdGF0ZSA9IGdldFRva2Vuc1N0YXRlKHRoaXMudG9rZW5zKTsgLy8gU2V0IGJhY2sgb25lIGFjY291bnRpbmcgZm9yIG9wZW5pbmcgYnJhY2tldC9wYXJlbnNcblxuICAgICAgb3JpZ1N0YXRlLmNvbG5vLS07XG4gICAgICBvcmlnU3RhdGUuaW5kZXgtLTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlLmFwcGx5KHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgZXJyU3RhdGUgPSBnZXRUb2tlbnNTdGF0ZSh0aGlzLnRva2Vucyk7XG5cbiAgICAgICAgdmFyIHJldGhyb3cgPSBmdW5jdGlvbiByZXRocm93KCkge1xuICAgICAgICAgIGxpYi5fYXNzaWduKF90aGlzLnRva2VucywgZXJyU3RhdGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07IC8vIFJlc2V0IHRvIHN0YXRlIGJlZm9yZSBvcmlnaW5hbCBwYXJzZUFnZ3JlZ2F0ZSBjYWxsZWRcblxuXG4gICAgICAgIGxpYi5fYXNzaWduKHRoaXMudG9rZW5zLCBvcmlnU3RhdGUpO1xuXG4gICAgICAgIHRoaXMucGVla2VkID0gZmFsc2U7XG4gICAgICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgICAgIGlmICh0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUKSB7XG4gICAgICAgICAgdGhyb3cgcmV0aHJvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBTbGljZSh0b2subGluZW5vLCB0b2suY29sbm8pOyAvLyBJZiB3ZSBkb24ndCBlbmNvdW50ZXIgYSBjb2xvbiB3aGlsZSBwYXJzaW5nLCB0aGlzIGlzIG5vdCBhIHNsaWNlLFxuICAgICAgICAvLyBzbyByZS1yYWlzZSB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uLlxuXG4gICAgICAgIHZhciBpc1NsaWNlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZS5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5za2lwKGxleGVyLlRPS0VOX1JJR0hUX0JSQUNLRVQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gbm9kZS5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNTbGljZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU2xpY2U6IHRvbyBtYW55IHNsaWNlIGNvbXBvbmVudHMnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc2tpcChsZXhlci5UT0tFTl9DT0xPTikpIHtcbiAgICAgICAgICAgIGlzU2xpY2UgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBub2RlLmZpZWxkc1tpXTtcbiAgICAgICAgICAgIG5vZGVbZmllbGRdID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIGlzU2xpY2UgPSB0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09MT04pIHx8IGlzU2xpY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1NsaWNlKSB7XG4gICAgICAgICAgdGhyb3cgcmV0aHJvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBub2Rlcy5BcnJheSh0b2subGluZW5vLCB0b2suY29sbm8sIFtub2RlXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWNlTG9va3VwKG9iaiwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBvYmogPSBvYmogfHwgW107XG5cbiAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHN0YXJ0ID0gc3RlcCA8IDAgPyBvYmoubGVuZ3RoIC0gMSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKHN0b3AgPT09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGVwIDwgMCA/IC0xIDogb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHN0b3AgPCAwKSB7XG4gICAgICBzdG9wICs9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgKz0gb2JqLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OzsgaSArPSBzdGVwKSB7XG4gICAgICBpZiAoaSA8IDAgfHwgaSA+IG9iai5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwID4gMCAmJiBpID49IHN0b3ApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwIDwgMCAmJiBpIDw9IHN0b3ApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHMucHVzaChydW50aW1lLm1lbWJlckxvb2t1cChvYmosIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfVxuXG4gIHZhciBBUlJBWV9NRU1CRVJTID0ge1xuICAgIHBvcDogZnVuY3Rpb24gcG9wKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleUVycm9yJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSxcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWVFcnJvcicpO1xuICAgIH0sXG4gICAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG4gICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZiAoKGkgPSB0aGlzLmluZGV4T2YoZWxlbWVudCkpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlRXJyb3InKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfSxcbiAgICBmaW5kOiBmdW5jdGlvbiBmaW5kKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfSxcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChpbmRleCwgZWxlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCBlbGVtKTtcbiAgICB9XG4gIH07XG4gIHZhciBPQkpFQ1RfTUVNQkVSUyA9IHtcbiAgICBpdGVtczogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICByZXR1cm4gbGliLl9lbnRyaWVzKHRoaXMpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gbGliLl92YWx1ZXModGhpcyk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIGxpYi5rZXlzKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5LCBkZWYpIHtcbiAgICAgIHZhciBvdXRwdXQgPSB0aGlzW2tleV07XG5cbiAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQgPSBkZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICBoYXNfa2V5OiBmdW5jdGlvbiBoYXNfa2V5KGtleSkge1xuICAgICAgcmV0dXJuIGhhc093blByb3AodGhpcywga2V5KTtcbiAgICB9LFxuICAgIHBvcDogZnVuY3Rpb24gcG9wKGtleSwgZGVmKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpc1trZXldO1xuXG4gICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQgJiYgZGVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0ID0gZGVmO1xuICAgICAgfSBlbHNlIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleUVycm9yJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG4gICAgcG9waXRlbTogZnVuY3Rpb24gcG9waXRlbSgpIHtcbiAgICAgIHZhciBrZXlzID0gbGliLmtleXModGhpcyk7XG5cbiAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgayA9IGtleXNbMF07XG4gICAgICB2YXIgdmFsID0gdGhpc1trXTtcbiAgICAgIGRlbGV0ZSB0aGlzW2tdO1xuICAgICAgcmV0dXJuIFtrLCB2YWxdO1xuICAgIH0sXG4gICAgc2V0ZGVmYXVsdDogZnVuY3Rpb24gc2V0ZGVmYXVsdChrZXksIGRlZikge1xuICAgICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlZiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghKGtleSBpbiB0aGlzKSkge1xuICAgICAgICB0aGlzW2tleV0gPSBkZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShrd2FyZ3MpIHtcbiAgICAgIGxpYi5fYXNzaWduKHRoaXMsIGt3YXJncyk7XG5cbiAgICAgIHJldHVybiBudWxsOyAvLyBBbHdheXMgcmV0dXJucyBOb25lXG4gICAgfVxuICB9O1xuICBPQkpFQ1RfTUVNQkVSUy5pdGVyaXRlbXMgPSBPQkpFQ1RfTUVNQkVSUy5pdGVtcztcbiAgT0JKRUNUX01FTUJFUlMuaXRlcnZhbHVlcyA9IE9CSkVDVF9NRU1CRVJTLnZhbHVlcztcbiAgT0JKRUNUX01FTUJFUlMuaXRlcmtleXMgPSBPQkpFQ1RfTUVNQkVSUy5rZXlzO1xuXG4gIHJ1bnRpbWUubWVtYmVyTG9va3VwID0gZnVuY3Rpb24gbWVtYmVyTG9va3VwKG9iaiwgdmFsLCBhdXRvZXNjYXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBzbGljZUxvb2t1cC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIG9iaiA9IG9iaiB8fCB7fTsgLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBvYmplY3QsIHJldHVybiBhbnkgb2YgdGhlIG1ldGhvZHMgdGhhdCBQeXRob24gd291bGRcbiAgICAvLyBvdGhlcndpc2UgcHJvdmlkZS5cblxuICAgIGlmIChsaWIuaXNBcnJheShvYmopICYmIGhhc093blByb3AoQVJSQVlfTUVNQkVSUywgdmFsKSkge1xuICAgICAgcmV0dXJuIEFSUkFZX01FTUJFUlNbdmFsXS5iaW5kKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKGxpYi5pc09iamVjdChvYmopICYmIGhhc093blByb3AoT0JKRUNUX01FTUJFUlMsIHZhbCkpIHtcbiAgICAgIHJldHVybiBPQkpFQ1RfTUVNQkVSU1t2YWxdLmJpbmQob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ19tZW1iZXJMb29rdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gdW5pbnN0YWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbGxDb21wYXQ7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVuanVja3MuanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IGZhY3RvcnkoKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFJlc29uYW5jZUF1ZGlvIGxpYnJhcnkgY29tbW9uIHV0aWxpdGllcywgbWF0aGVtYXRpY2FsIGNvbnN0YW50cyxcbiAqIGFuZCBkZWZhdWx0IHZhbHVlcy5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8qKlxuICogQGNsYXNzIFV0aWxzXG4gKiBAZGVzY3JpcHRpb24gQSBzZXQgb2YgZGVmYXVsdHMsIGNvbnN0YW50cyBhbmQgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIFV0aWxzKCkge307XG5cblxuLyoqXG4gKiBEZWZhdWx0IGlucHV0IGdhaW4gKGxpbmVhcikuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1NPVVJDRV9HQUlOID0gMTtcblxuXG4vKipcbiAqIE1heGltdW0gb3V0c2lkZS10aGUtcm9vbSBkaXN0YW5jZSB0byBhdHRlbnVhdGUgZmFyLWZpZWxkIGxpc3RlbmVyIGJ5LlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuTElTVEVORVJfTUFYX09VVFNJREVfUk9PTV9ESVNUQU5DRSA9IDE7XG5cblxuLyoqXG4gKiBNYXhpbXVtIG91dHNpZGUtdGhlLXJvb20gZGlzdGFuY2UgdG8gYXR0ZW51YXRlIGZhci1maWVsZCBzb3VyY2VzIGJ5LlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuU09VUkNFX01BWF9PVVRTSURFX1JPT01fRElTVEFOQ0UgPSAxO1xuXG5cbi8qKlxuICogRGVmYXVsdCBkaXN0YW5jZSBmcm9tIGxpc3RlbmVyIHdoZW4gc2V0dGluZyBhbmdsZS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfU09VUkNFX0RJU1RBTkNFID0gMTtcblxuXG4vKiogQHR5cGUge0Zsb2F0MzJBcnJheX0gKi9cblV0aWxzLkRFRkFVTFRfUE9TSVRJT04gPSBbMCwgMCwgMF07XG5cblxuLyoqIEB0eXBlIHtGbG9hdDMyQXJyYXl9ICovXG5VdGlscy5ERUZBVUxUX0ZPUldBUkQgPSBbMCwgMCwgLTFdO1xuXG5cbi8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xuVXRpbHMuREVGQVVMVF9VUCA9IFswLCAxLCAwXTtcblxuXG4vKiogQHR5cGUge0Zsb2F0MzJBcnJheX0gKi9cblV0aWxzLkRFRkFVTFRfUklHSFQgPSBbMSwgMCwgMF07XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EID0gMzQzO1xuXG5cbi8qKiBSb2xsb2ZmIG1vZGVscyAoZS5nLiAnbG9nYXJpdGhtaWMnLCAnbGluZWFyJywgb3IgJ25vbmUnKS5cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgPSBbJ2xvZ2FyaXRobWljJywgJ2xpbmVhcicsICdub25lJ107XG5cblxuLyoqIERlZmF1bHQgcm9sbG9mZiBtb2RlbCAoJ2xvZ2FyaXRobWljJykuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5VdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkYgPSAnbG9nYXJpdGhtaWMnO1xuXG5cbi8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0UgPSAxO1xuXG5cbi8qKiBAdHlwZSB7TnVtYmVyfSAqL1xuVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0UgPSAxMDAwO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgYWxwaGEgKGkuZS4gbWljcm9waG9uZSBwYXR0ZXJuKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEEgPSAwO1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgcGF0dGVybiBzaGFycG5lc3MgKGkuZS4gcGF0dGVybiBleHBvbmVudCkuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX1NIQVJQTkVTUyA9IDE7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGF6aW11dGggKGluIGRlZ3JlZXMpLiBTdWl0YWJsZSByYW5nZSBpcyAwIHRvIDM2MC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfQVpJTVVUSCA9IDA7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGVsZXZhdGlvbiAoaW4gZGVncmVzKS5cbiAqIFN1aXRhYmxlIHJhbmdlIGlzIGZyb20gLTkwIChiZWxvdykgdG8gOTAgKGFib3ZlKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfRUxFVkFUSU9OID0gMDtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFtYmlzb25pYyBvcmRlci5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSID0gMTtcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHNvdXJjZSB3aWR0aC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIID0gMDtcblxuXG4vKipcbiAqIFRoZSBtYXhpbXVtIGRlbGF5IChpbiBzZWNvbmRzKSBvZiBhIHNpbmdsZSB3YWxsIHJlZmxlY3Rpb24uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUFYX0RVUkFUSU9OID0gMC41O1xuXG5cbi8qKlxuICogVGhlIC0xMmRCIGN1dG9mZiBmcmVxdWVuY3kgKGluIEhlcnR6KSBmb3IgdGhlIGxvd3Bhc3MgZmlsdGVyIGFwcGxpZWQgdG9cbiAqIGFsbCByZWZsZWN0aW9ucy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DVVRPRkZfRlJFUVVFTkNZID0gNjQwMDsgLy8gVXNlcyAtMTJkQiBjdXRvZmYuXG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCByZWZsZWN0aW9uIGNvZWZmaWNpZW50cyAod2hlcmUgMCA9IG5vIHJlZmxlY3Rpb24sIDEgPSBwZXJmZWN0XG4gKiByZWZsZWN0aW9uLCAtMSA9IG1pcnJvcmVkIHJlZmxlY3Rpb24gKDE4MC1kZWdyZWVzIG91dCBvZiBwaGFzZSkpLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUyA9IHtcbiAgbGVmdDogMCwgcmlnaHQ6IDAsIGZyb250OiAwLCBiYWNrOiAwLCBkb3duOiAwLCB1cDogMCxcbn07XG5cblxuLyoqXG4gKiBUaGUgbWluaW11bSBkaXN0YW5jZSB3ZSBjb25zaWRlciB0aGUgbGlzdGVuZXIgdG8gYmUgdG8gYW55IGdpdmVuIHdhbGwuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFID0gMTtcblxuXG4vKipcbiAqIERlZmF1bHQgcm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgPSB7XG4gIHdpZHRoOiAwLCBoZWlnaHQ6IDAsIGRlcHRoOiAwLFxufTtcblxuXG4vKipcbiAqIFRoZSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIGRpc3RhbmNlcyBmcm9tIHRoZSBsaXN0ZW5lciB0byBlYWNoIHdhbGwuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiA9IDE7XG5cblxuLyoqIFRoZSBkZWZhdWx0IGJhbmR3aWR0aCAoaW4gb2N0YXZlcykgb2YgdGhlIGNlbnRlciBmcmVxdWVuY2llcy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX0JBTkRXSURUSCA9IDE7XG5cblxuLyoqIFRoZSBkZWZhdWx0IG11bHRpcGxpZXIgYXBwbGllZCB3aGVuIGNvbXB1dGluZyB0YWlsIGxlbmd0aHMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9EVVJBVElPTl9NVUxUSVBMSUVSID0gMTtcblxuXG4vKipcbiAqIFRoZSBsYXRlIHJlZmxlY3Rpb25zIHByZS1kZWxheSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX1BSRURFTEFZID0gMS41O1xuXG5cbi8qKlxuICogVGhlIGxlbmd0aCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbXB1bHNlIHJlc3BvbnNlIHRvIGFwcGx5IGFcbiAqIGhhbGYtSGFubiB3aW5kb3cgdG8uXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9UQUlMX09OU0VUID0gMy44O1xuXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZ2FpbiAobGluZWFyKS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLkRFRkFVTFRfUkVWRVJCX0dBSU4gPSAwLjAxO1xuXG5cbi8qKlxuICogVGhlIG1heGltdW0gaW1wdWxzZSByZXNwb25zZSBsZW5ndGggKGluIHNlY29uZHMpLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfTUFYX0RVUkFUSU9OID0gMztcblxuXG4vKipcbiAqIENlbnRlciBmcmVxdWVuY2llcyBvZiB0aGUgbXVsdGliYW5kIGxhdGUgcmVmbGVjdGlvbnMuXG4gKiBOaW5lIGJhbmRzIGFyZSBjb21wdXRlZCBieTogMzEuMjUgKiAyXigwOjgpLlxuICogQHR5cGUge0FycmF5fVxuICovXG5VdGlscy5ERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMgPSBbXG4gIDMxLjI1LCA2Mi41LCAxMjUsIDI1MCwgNTAwLCAxMDAwLCAyMDAwLCA0MDAwLCA4MDAwLFxuXTtcblxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgZnJlcXVlbmN5IGJhbmRzLlxuICovXG5VdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUyA9XG4gIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUy5sZW5ndGg7XG5cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBtdWx0aWJhbmQgUlQ2MCBkdXJhdGlvbnMgKGluIHNlY29uZHMpLlxuICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAqL1xuVXRpbHMuREVGQVVMVF9SRVZFUkJfRFVSQVRJT05TID1cbiAgbmV3IEZsb2F0MzJBcnJheShVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUyk7XG5cblxuLyoqXG4gKiBQcmUtZGVmaW5lZCBmcmVxdWVuY3ktZGVwZW5kZW50IGFic29ycHRpb24gY29lZmZpY2llbnRzIGZvciBsaXN0ZWQgbWF0ZXJpYWxzLlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCBtYXRlcmlhbHMgYXJlOlxuICogPHVsPlxuICogPGxpPid0cmFuc3BhcmVudCc8L2xpPlxuICogPGxpPidhY291c3RpYy1jZWlsaW5nLXRpbGVzJzwvbGk+XG4gKiA8bGk+J2JyaWNrLWJhcmUnPC9saT5cbiAqIDxsaT4nYnJpY2stcGFpbnRlZCc8L2xpPlxuICogPGxpPidjb25jcmV0ZS1ibG9jay1jb2Fyc2UnPC9saT5cbiAqIDxsaT4nY29uY3JldGUtYmxvY2stcGFpbnRlZCc8L2xpPlxuICogPGxpPidjdXJ0YWluLWhlYXZ5JzwvbGk+XG4gKiA8bGk+J2ZpYmVyLWdsYXNzLWluc3VsYXRpb24nPC9saT5cbiAqIDxsaT4nZ2xhc3MtdGhpbic8L2xpPlxuICogPGxpPidnbGFzcy10aGljayc8L2xpPlxuICogPGxpPidncmFzcyc8L2xpPlxuICogPGxpPidsaW5vbGV1bS1vbi1jb25jcmV0ZSc8L2xpPlxuICogPGxpPidtYXJibGUnPC9saT5cbiAqIDxsaT4nbWV0YWwnPC9saT5cbiAqIDxsaT4ncGFycXVldC1vbi1jb25jcmV0ZSc8L2xpPlxuICogPGxpPidwbGFzdGVyLXNtb290aCc8L2xpPlxuICogPGxpPidwbHl3b29kLXBhbmVsJzwvbGk+XG4gKiA8bGk+J3BvbGlzaGVkLWNvbmNyZXRlLW9yLXRpbGUnPC9saT5cbiAqIDxsaT4nc2hlZXRyb2NrJzwvbGk+XG4gKiA8bGk+J3dhdGVyLW9yLWljZS1zdXJmYWNlJzwvbGk+XG4gKiA8bGk+J3dvb2QtY2VpbGluZyc8L2xpPlxuICogPGxpPid3b29kLXBhbmVsJzwvbGk+XG4gKiA8bGk+J3VuaWZvcm0nPC9saT5cbiAqIDwvdWw+XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlscy5ST09NX01BVEVSSUFMX0NPRUZGSUNJRU5UUyA9IHtcbiAgJ3RyYW5zcGFyZW50JzpcbiAgWzEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDAsIDEuMDAwLCAxLjAwMCwgMS4wMDBdLFxuICAnYWNvdXN0aWMtY2VpbGluZy10aWxlcyc6XG4gIFswLjY3MiwgMC42NzUsIDAuNzAwLCAwLjY2MCwgMC43MjAsIDAuOTIwLCAwLjg4MCwgMC43NTAsIDEuMDAwXSxcbiAgJ2JyaWNrLWJhcmUnOlxuICBbMC4wMzAsIDAuMDMwLCAwLjAzMCwgMC4wMzAsIDAuMDMwLCAwLjA0MCwgMC4wNTAsIDAuMDcwLCAwLjE0MF0sXG4gICdicmljay1wYWludGVkJzpcbiAgWzAuMDA2LCAwLjAwNywgMC4wMTAsIDAuMDEwLCAwLjAyMCwgMC4wMjAsIDAuMDIwLCAwLjAzMCwgMC4wNjBdLFxuICAnY29uY3JldGUtYmxvY2stY29hcnNlJzpcbiAgWzAuMzYwLCAwLjM2MCwgMC4zNjAsIDAuNDQwLCAwLjMxMCwgMC4yOTAsIDAuMzkwLCAwLjI1MCwgMC41MDBdLFxuICAnY29uY3JldGUtYmxvY2stcGFpbnRlZCc6XG4gIFswLjA5MiwgMC4wOTAsIDAuMTAwLCAwLjA1MCwgMC4wNjAsIDAuMDcwLCAwLjA5MCwgMC4wODAsIDAuMTYwXSxcbiAgJ2N1cnRhaW4taGVhdnknOlxuICBbMC4wNzMsIDAuMTA2LCAwLjE0MCwgMC4zNTAsIDAuNTUwLCAwLjcyMCwgMC43MDAsIDAuNjUwLCAxLjAwMF0sXG4gICdmaWJlci1nbGFzcy1pbnN1bGF0aW9uJzpcbiAgWzAuMTkzLCAwLjIyMCwgMC4yMjAsIDAuODIwLCAwLjk5MCwgMC45OTAsIDAuOTkwLCAwLjk5MCwgMS4wMDBdLFxuICAnZ2xhc3MtdGhpbic6XG4gIFswLjE4MCwgMC4xNjksIDAuMTgwLCAwLjA2MCwgMC4wNDAsIDAuMDMwLCAwLjAyMCwgMC4wMjAsIDAuMDQwXSxcbiAgJ2dsYXNzLXRoaWNrJzpcbiAgWzAuMzUwLCAwLjM1MCwgMC4zNTAsIDAuMjUwLCAwLjE4MCwgMC4xMjAsIDAuMDcwLCAwLjA0MCwgMC4wODBdLFxuICAnZ3Jhc3MnOlxuICBbMC4wNTAsIDAuMDUwLCAwLjE1MCwgMC4yNTAsIDAuNDAwLCAwLjU1MCwgMC42MDAsIDAuNjAwLCAwLjYwMF0sXG4gICdsaW5vbGV1bS1vbi1jb25jcmV0ZSc6XG4gIFswLjAyMCwgMC4wMjAsIDAuMDIwLCAwLjAzMCwgMC4wMzAsIDAuMDMwLCAwLjAzMCwgMC4wMjAsIDAuMDQwXSxcbiAgJ21hcmJsZSc6XG4gIFswLjAxMCwgMC4wMTAsIDAuMDEwLCAwLjAxMCwgMC4wMTAsIDAuMDEwLCAwLjAyMCwgMC4wMjAsIDAuMDQwXSxcbiAgJ21ldGFsJzpcbiAgWzAuMDMwLCAwLjAzNSwgMC4wNDAsIDAuMDQwLCAwLjA1MCwgMC4wNTAsIDAuMDUwLCAwLjA3MCwgMC4wOTBdLFxuICAncGFycXVldC1vbi1jb25jcmV0ZSc6XG4gIFswLjAyOCwgMC4wMzAsIDAuMDQwLCAwLjA0MCwgMC4wNzAsIDAuMDYwLCAwLjA2MCwgMC4wNzAsIDAuMTQwXSxcbiAgJ3BsYXN0ZXItcm91Z2gnOlxuICBbMC4wMTcsIDAuMDE4LCAwLjAyMCwgMC4wMzAsIDAuMDQwLCAwLjA1MCwgMC4wNDAsIDAuMDMwLCAwLjA2MF0sXG4gICdwbGFzdGVyLXNtb290aCc6XG4gIFswLjAxMSwgMC4wMTIsIDAuMDEzLCAwLjAxNSwgMC4wMjAsIDAuMDMwLCAwLjA0MCwgMC4wNTAsIDAuMTAwXSxcbiAgJ3BseXdvb2QtcGFuZWwnOlxuICBbMC40MDAsIDAuMzQwLCAwLjI4MCwgMC4yMjAsIDAuMTcwLCAwLjA5MCwgMC4xMDAsIDAuMTEwLCAwLjIyMF0sXG4gICdwb2xpc2hlZC1jb25jcmV0ZS1vci10aWxlJzpcbiAgWzAuMDA4LCAwLjAwOCwgMC4wMTAsIDAuMDEwLCAwLjAxNSwgMC4wMjAsIDAuMDIwLCAwLjAyMCwgMC4wNDBdLFxuICAnc2hlZXQtcm9jayc6XG4gIFswLjI5MCwgMC4yNzksIDAuMjkwLCAwLjEwMCwgMC4wNTAsIDAuMDQwLCAwLjA3MCwgMC4wOTAsIDAuMTgwXSxcbiAgJ3dhdGVyLW9yLWljZS1zdXJmYWNlJzpcbiAgWzAuMDA2LCAwLjAwNiwgMC4wMDgsIDAuMDA4LCAwLjAxMywgMC4wMTUsIDAuMDIwLCAwLjAyNSwgMC4wNTBdLFxuICAnd29vZC1jZWlsaW5nJzpcbiAgWzAuMTUwLCAwLjE0NywgMC4xNTAsIDAuMTEwLCAwLjEwMCwgMC4wNzAsIDAuMDYwLCAwLjA3MCwgMC4xNDBdLFxuICAnd29vZC1wYW5lbCc6XG4gIFswLjI4MCwgMC4yODAsIDAuMjgwLCAwLjIyMCwgMC4xNzAsIDAuMDkwLCAwLjEwMCwgMC4xMTAsIDAuMjIwXSxcbiAgJ3VuaWZvcm0nOlxuICBbMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMCwgMC41MDAsIDAuNTAwLCAwLjUwMF0sXG59O1xuXG5cbi8qKlxuICogRGVmYXVsdCBtYXRlcmlhbHMgdGhhdCB1c2Ugc3RyaW5ncyBmcm9tXG4gKiB7QGxpbmtjb2RlIFV0aWxzLk1BVEVSSUFMX0NPRUZGSUNJRU5UUyBNQVRFUklBTF9DT0VGRklDSUVOVFN9XG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5VdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTID0ge1xuICBsZWZ0OiAndHJhbnNwYXJlbnQnLCByaWdodDogJ3RyYW5zcGFyZW50JywgZnJvbnQ6ICd0cmFuc3BhcmVudCcsXG4gIGJhY2s6ICd0cmFuc3BhcmVudCcsIGRvd246ICd0cmFuc3BhcmVudCcsIHVwOiAndHJhbnNwYXJlbnQnLFxufTtcblxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2YgYmFuZHMgdG8gYXZlcmFnZSBvdmVyIHdoZW4gY29tcHV0aW5nIHJlZmxlY3Rpb24gY29lZmZpY2llbnRzLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuTlVNQkVSX1JFRkxFQ1RJT05fQVZFUkFHSU5HX0JBTkRTID0gMztcblxuXG4vKipcbiAqIFRoZSBzdGFydGluZyBiYW5kIHRvIGF2ZXJhZ2Ugb3ZlciB3aGVuIGNvbXB1dGluZyByZWZsZWN0aW9uIGNvZWZmaWNpZW50cy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblV0aWxzLlJPT01fU1RBUlRJTkdfQVZFUkFHSU5HX0JBTkQgPSA0O1xuXG5cbi8qKlxuICogVGhlIG1pbmltdW0gdGhyZXNob2xkIGZvciByb29tIHZvbHVtZS5cbiAqIFJvb20gbW9kZWwgaXMgZGlzYWJsZWQgaWYgdm9sdW1lIGlzIGJlbG93IHRoaXMgdmFsdWUuXG4gKiBAdHlwZSB7TnVtYmVyfSAqL1xuVXRpbHMuUk9PTV9NSU5fVk9MVU1FID0gMWUtNDtcblxuXG4vKipcbiAqIEFpciBhYnNvcnB0aW9uIGNvZWZmaWNpZW50cyBwZXIgZnJlcXVlbmN5IGJhbmQuXG4gKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICovXG5VdGlscy5ST09NX0FJUl9BQlNPUlBUSU9OX0NPRUZGSUNJRU5UUyA9XG4gIFswLjAwMDYsIDAuMDAwNiwgMC4wMDA3LCAwLjAwMDgsIDAuMDAxMCwgMC4wMDE1LCAwLjAwMjYsIDAuMDA2MCwgMC4wMjA3XTtcblxuXG4vKipcbiAqIEEgc2NhbGFyIGNvcnJlY3Rpb24gdmFsdWUgdG8gZW5zdXJlIFNhYmluZSBhbmQgRXlyaW5nIHByb2R1Y2UgdGhlIHNhbWUgUlQ2MFxuICogdmFsdWUgYXQgdGhlIGNyb3NzLW92ZXIgdGhyZXNob2xkLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuVXRpbHMuUk9PTV9FWVJJTkdfQ09SUkVDVElPTl9DT0VGRklDSUVOVCA9IDEuMzg7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuVFdPX1BJID0gNi4yODMxODUzMDcxNzk1OTtcblxuXG4vKipcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5UV0VOVFlfRk9VUl9MT0cxMCA9IDU1LjI2MjA0MjIzMTg1NzE7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuTE9HMTAwMCA9IDYuOTA3NzU1Mjc4OTgyMTQ7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuTE9HMl9ESVYyID0gMC4zNDY1NzM1OTAyNzk5NzM7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuREVHUkVFU19UT19SQURJQU5TID0gMC4wMTc0NTMyOTI1MTk5NDM7XG5cblxuLyoqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuUkFESUFOU19UT19ERUdSRUVTID0gNTcuMjk1Nzc5NTEzMDgyMzIzO1xuXG5cbi8qKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLkVQU0lMT05fRkxPQVQgPSAxZS04O1xuXG5cbi8qKlxuICogUmVzb25hbmNlQXVkaW8gbGlicmFyeSBsb2dnaW5nIGZ1bmN0aW9uLlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHthbnl9IE1lc3NhZ2UgdG8gYmUgcHJpbnRlZCBvdXQuXG4gKiBAcHJpdmF0ZVxuICovXG5VdGlscy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBbXG4gICAgJyVjW1Jlc29uYW5jZUF1ZGlvXSVjICdcbiAgICAgICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJykgKyAnICVjKEAnXG4gICAgICArIHBlcmZvcm1hbmNlLm5vdygpLnRvRml4ZWQoMikgKyAnbXMpJyxcbiAgICAnYmFja2dyb3VuZDogI0JCREVGQjsgY29sb3I6ICNGRjU3MjI7IGZvbnQtd2VpZ2h0OiA3MDAnLFxuICAgICdmb250LXdlaWdodDogNDAwJyxcbiAgICAnY29sb3I6ICNBQUEnLFxuICBdKTtcbn07XG5cblxuLyoqXG4gKiBOb3JtYWxpemUgYSAzLWQgdmVjdG9yLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHYgMy1lbGVtZW50IHZlY3Rvci5cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gMy1lbGVtZW50IHZlY3Rvci5cbiAqIEBwcml2YXRlXG4gKi9cblV0aWxzLm5vcm1hbGl6ZVZlY3RvciA9IGZ1bmN0aW9uKHYpIHtcbiAgbGV0IG4gPSBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSArIHZbMl0gKiB2WzJdKTtcbiAgaWYgKG4gPiBleHBvcnRzLkVQU0lMT05fRkxPQVQpIHtcbiAgICBuID0gMSAvIG47XG4gICAgdlswXSAqPSBuO1xuICAgIHZbMV0gKj0gbjtcbiAgICB2WzJdICo9IG47XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG5cbi8qKlxuICogQ3Jvc3MtcHJvZHVjdCBiZXR3ZWVuIHR3byAzLWQgdmVjdG9ycy5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhIDMtZWxlbWVudCB2ZWN0b3IuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYiAzLWVsZW1lbnQgdmVjdG9yLlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fVxuICogQHByaXZhdGVcbiAqL1xuVXRpbHMuY3Jvc3NQcm9kdWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gW1xuICAgIGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sXG4gICAgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSxcbiAgICBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdLFxuICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVdGlscztcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgU3BhdGlhbGx5IGVuY29kZXMgaW5wdXQgdXNpbmcgd2VpZ2h0ZWQgc3BoZXJpY2FsIGhhcm1vbmljcy5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBUYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIEVuY29kZXJcbiAqIEBkZXNjcmlwdGlvbiBTcGF0aWFsbHkgZW5jb2RlcyBpbnB1dCB1c2luZyB3ZWlnaHRlZCBzcGhlcmljYWwgaGFybW9uaWNzLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHRcbiAqIEFzc29jaWF0ZWQge0BsaW5rXG5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Db250ZXh0IEF1ZGlvQ29udGV4dH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuYW1iaXNvbmljT3JkZXJcbiAqIERlc2lyZWQgYW1iaXNvbmljIG9yZGVyLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUiBERUZBVUxUX0FNQklTT05JQ19PUkRFUn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hemltdXRoXG4gKiBBemltdXRoIChpbiBkZWdyZWVzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BWklNVVRIIERFRkFVTFRfQVpJTVVUSH0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5lbGV2YXRpb25cbiAqIEVsZXZhdGlvbiAoaW4gZGVncmVlcykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRUxFVkFUSU9OIERFRkFVTFRfRUxFVkFUSU9OfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNvdXJjZVdpZHRoXG4gKiBTb3VyY2Ugd2lkdGggKGluIGRlZ3JlZXMpLiBXaGVyZSAwIGRlZ3JlZXMgaXMgYSBwb2ludCBzb3VyY2UgYW5kIDM2MCBkZWdyZWVzXG4gKiBpcyBhbiBvbW5pZGlyZWN0aW9uYWwgc291cmNlLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSCBERUZBVUxUX1NPVVJDRV9XSURUSH0uXG4gKi9cbmZ1bmN0aW9uIEVuY29kZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBFbmNvZGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIEVuY29kZXJcbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmFtYmlzb25pY09yZGVyID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPSBVdGlscy5ERUZBVUxUX0FNQklTT05JQ19PUkRFUjtcbiAgfVxuICBpZiAob3B0aW9ucy5hemltdXRoID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYXppbXV0aCA9IFV0aWxzLkRFRkFVTFRfQVpJTVVUSDtcbiAgfVxuICBpZiAob3B0aW9ucy5lbGV2YXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5lbGV2YXRpb24gPSBVdGlscy5ERUZBVUxUX0VMRVZBVElPTjtcbiAgfVxuICBpZiAob3B0aW9ucy5zb3VyY2VXaWR0aCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNvdXJjZVdpZHRoID0gVXRpbHMuREVGQVVMVF9TT1VSQ0VfV0lEVEg7XG4gIH1cblxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICAvLyBDcmVhdGUgSS9PIG5vZGVzLlxuICB0aGlzLmlucHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2NoYW5uZWxHYWluID0gW107XG4gIHRoaXMuX21lcmdlciA9IHVuZGVmaW5lZDtcbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBTZXQgaW5pdGlhbCBvcmRlciwgYW5nbGUgYW5kIHNvdXJjZSB3aWR0aC5cbiAgdGhpcy5zZXRBbWJpc29uaWNPcmRlcihvcHRpb25zLmFtYmlzb25pY09yZGVyKTtcbiAgdGhpcy5fYXppbXV0aCA9IG9wdGlvbnMuYXppbXV0aDtcbiAgdGhpcy5fZWxldmF0aW9uID0gb3B0aW9ucy5lbGV2YXRpb247XG4gIHRoaXMuc2V0U291cmNlV2lkdGgob3B0aW9ucy5zb3VyY2VXaWR0aCk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBkZXNpcmVkIGFtYmlzb25pYyBvcmRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhbWJpc29uaWNPcmRlciBEZXNpcmVkIGFtYmlzb25pYyBvcmRlci5cbiAqL1xuRW5jb2Rlci5wcm90b3R5cGUuc2V0QW1iaXNvbmljT3JkZXIgPSBmdW5jdGlvbihhbWJpc29uaWNPcmRlcikge1xuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9IEVuY29kZXIudmFsaWRhdGVBbWJpc29uaWNPcmRlcihhbWJpc29uaWNPcmRlcik7XG5cbiAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2hhbm5lbEdhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9jaGFubmVsR2FpbltpXS5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHRoaXMuX21lcmdlciAhPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9tZXJnZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9jaGFubmVsR2FpbjtcbiAgZGVsZXRlIHRoaXMuX21lcmdlcjtcblxuICAvLyBDcmVhdGUgYXVkaW8gZ3JhcGguXG4gIGxldCBudW1DaGFubmVscyA9ICh0aGlzLl9hbWJpc29uaWNPcmRlciArIDEpICogKHRoaXMuX2FtYmlzb25pY09yZGVyICsgMSk7XG4gIHRoaXMuX21lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcihudW1DaGFubmVscyk7XG4gIHRoaXMuX2NoYW5uZWxHYWluID0gbmV3IEFycmF5KG51bUNoYW5uZWxzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DaGFubmVsczsgaSsrKSB7XG4gICAgdGhpcy5fY2hhbm5lbEdhaW5baV0gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fY2hhbm5lbEdhaW5baV0pO1xuICAgIHRoaXMuX2NoYW5uZWxHYWluW2ldLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCBpKTtcbiAgfVxuICB0aGlzLl9tZXJnZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVuY29kZWQgc291cmNlIHNpZ25hbC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhemltdXRoXG4gKiBBemltdXRoIChpbiBkZWdyZWVzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BWklNVVRIIERFRkFVTFRfQVpJTVVUSH0uXG4gKiBAcGFyYW0ge051bWJlcn0gZWxldmF0aW9uXG4gKiBFbGV2YXRpb24gKGluIGRlZ3JlZXMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0VMRVZBVElPTiBERUZBVUxUX0VMRVZBVElPTn0uXG4gKi9cbkVuY29kZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9IGZ1bmN0aW9uKGF6aW11dGgsIGVsZXZhdGlvbikge1xuICAvLyBGb3JtYXQgaW5wdXQgZGlyZWN0aW9uIHRvIG5lYXJlc3QgaW5kaWNlcy5cbiAgaWYgKGF6aW11dGggPT0gdW5kZWZpbmVkIHx8IGlzTmFOKGF6aW11dGgpKSB7XG4gICAgYXppbXV0aCA9IFV0aWxzLkRFRkFVTFRfQVpJTVVUSDtcbiAgfVxuICBpZiAoZWxldmF0aW9uID09IHVuZGVmaW5lZCB8fCBpc05hTihlbGV2YXRpb24pKSB7XG4gICAgZWxldmF0aW9uID0gVXRpbHMuREVGQVVMVF9FTEVWQVRJT047XG4gIH1cblxuICAvLyBTdG9yZSB0aGUgZm9ybWF0dGVkIGlucHV0IChmb3IgdXBkYXRpbmcgc291cmNlIHdpZHRoKS5cbiAgdGhpcy5fYXppbXV0aCA9IGF6aW11dGg7XG4gIHRoaXMuX2VsZXZhdGlvbiA9IGVsZXZhdGlvbjtcblxuICAvLyBGb3JtYXQgZGlyZWN0aW9uIGZvciBpbmRleCBsb29rdXBzLlxuICBhemltdXRoID0gTWF0aC5yb3VuZChhemltdXRoICUgMzYwKTtcbiAgaWYgKGF6aW11dGggPCAwKSB7XG4gICAgYXppbXV0aCArPSAzNjA7XG4gIH1cbiAgZWxldmF0aW9uID0gTWF0aC5yb3VuZChNYXRoLm1pbig5MCwgTWF0aC5tYXgoLTkwLCBlbGV2YXRpb24pKSkgKyA5MDtcblxuICAvLyBBc3NpZ24gZ2FpbnMgdG8gZWFjaCBvdXRwdXQuXG4gIHRoaXMuX2NoYW5uZWxHYWluWzBdLmdhaW4udmFsdWUgPSBUYWJsZXMuTUFYX1JFX1dFSUdIVFNbdGhpcy5fc3ByZWFkSW5kZXhdWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLl9hbWJpc29uaWNPcmRlcjsgaSsrKSB7XG4gICAgbGV0IGRlZ3JlZVdlaWdodCA9IFRhYmxlcy5NQVhfUkVfV0VJR0hUU1t0aGlzLl9zcHJlYWRJbmRleF1baV07XG4gICAgZm9yIChsZXQgaiA9IC1pOyBqIDw9IGk7IGorKykge1xuICAgICAgbGV0IGFjbkNoYW5uZWwgPSAoaSAqIGkpICsgaSArIGo7XG4gICAgICBsZXQgZWxldmF0aW9uSW5kZXggPSBpICogKGkgKyAxKSAvIDIgKyBNYXRoLmFicyhqKSAtIDE7XG4gICAgICBsZXQgdmFsID0gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NbMV1bZWxldmF0aW9uXVtlbGV2YXRpb25JbmRleF07XG4gICAgICBpZiAoaiAhPSAwKSB7XG4gICAgICAgIGxldCBhemltdXRoSW5kZXggPSBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIgKyBqIC0gMTtcbiAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgICAgYXppbXV0aEluZGV4ID0gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSICsgajtcbiAgICAgICAgfVxuICAgICAgICB2YWwgKj0gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NbMF1bYXppbXV0aF1bYXppbXV0aEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5uZWxHYWluW2FjbkNoYW5uZWxdLmdhaW4udmFsdWUgPSB2YWwgKiBkZWdyZWVXZWlnaHQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2Ugd2lkdGggKGluIGRlZ3JlZXMpLiBXaGVyZSAwIGRlZ3JlZXMgaXMgYSBwb2ludCBzb3VyY2UgYW5kIDM2MFxuICogZGVncmVlcyBpcyBhbiBvbW5pZGlyZWN0aW9uYWwgc291cmNlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIChpbiBkZWdyZWVzKS5cbiAqL1xuRW5jb2Rlci5wcm90b3R5cGUuc2V0U291cmNlV2lkdGggPSBmdW5jdGlvbihzb3VyY2VXaWR0aCkge1xuICAvLyBUaGUgTUFYX1JFX1dFSUdIVFMgaXMgYSAzNjAgeCAoVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSKzEpXG4gIC8vIHNpemUgdGFibGUuXG4gIHRoaXMuX3NwcmVhZEluZGV4ID0gTWF0aC5taW4oMzU5LCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHNvdXJjZVdpZHRoKSkpO1xuICB0aGlzLnNldERpcmVjdGlvbih0aGlzLl9hemltdXRoLCB0aGlzLl9lbGV2YXRpb24pO1xufTtcblxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgRGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFZhbGlkYXRlZC9hZGp1c3RlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5FbmNvZGVyLnZhbGlkYXRlQW1iaXNvbmljT3JkZXIgPSBmdW5jdGlvbihhbWJpc29uaWNPcmRlcikge1xuICBpZiAoaXNOYU4oYW1iaXNvbmljT3JkZXIpIHx8IGFtYmlzb25pY09yZGVyID09IHVuZGVmaW5lZCkge1xuICAgIFV0aWxzLmxvZygnRXJyb3I6IEludmFsaWQgYW1iaXNvbmljIG9yZGVyJyxcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyLCAnXFxuVXNpbmcgYW1iaXNvbmljT3JkZXI9MSBpbnN0ZWFkLicpO1xuICAgIGFtYmlzb25pY09yZGVyID0gMTtcbiAgfSBlbHNlIGlmIChhbWJpc29uaWNPcmRlciA8IDEpIHtcbiAgICBVdGlscy5sb2coJ0Vycm9yOiBVbmFibGUgdG8gcmVuZGVyIGFtYmlzb25pYyBvcmRlcicsXG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciwgJyhNaW4gb3JkZXIgaXMgMSknLFxuICAgICdcXG5Vc2luZyBtaW4gb3JkZXIgaW5zdGVhZC4nKTtcbiAgICBhbWJpc29uaWNPcmRlciA9IDE7XG4gIH0gZWxzZSBpZiAoYW1iaXNvbmljT3JkZXIgPiBUYWJsZXMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIpIHtcbiAgICBVdGlscy5sb2coJ0Vycm9yOiBVbmFibGUgdG8gcmVuZGVyIGFtYmlzb25pYyBvcmRlcicsXG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciwgJyhNYXggb3JkZXIgaXMnLFxuICAgIFRhYmxlcy5TUEhFUklDQUxfSEFSTU9OSUNTX01BWF9PUkRFUiwgJylcXG5Vc2luZyBtYXggb3JkZXIgaW5zdGVhZC4nKTtcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyID0gVGFibGVzLlNQSEVSSUNBTF9IQVJNT05JQ1NfTUFYX09SREVSO1xuICB9XG4gIHJldHVybiBhbWJpc29uaWNPcmRlcjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyO1xuXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBMaXN0ZW5lciBtb2RlbCB0byBzcGF0aWFsaXplIHNvdXJjZXMgaW4gYW4gZW52aXJvbm1lbnQuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBPbW5pdG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuY29uc3QgRW5jb2RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgTGlzdGVuZXJcbiAqIEBkZXNjcmlwdGlvbiBMaXN0ZW5lciBtb2RlbCB0byBzcGF0aWFsaXplIHNvdXJjZXMgaW4gYW4gZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5hbWJpc29uaWNPcmRlclxuICogRGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSIERFRkFVTFRfQU1CSVNPTklDX09SREVSfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnBvc2l0aW9uXG4gKiBJbml0aWFsIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5mb3J3YXJkXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIGZvcndhcmQgdmVjdG9yLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0ZPUldBUkQgREVGQVVMVF9GT1JXQVJEfS5cbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBvcHRpb25zLnVwXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIHVwIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9VUCBERUZBVUxUX1VQfS5cbiAqL1xuZnVuY3Rpb24gTGlzdGVuZXIoY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogUG9zaXRpb24gKGluIG1ldGVycykuXG4gICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX0gcG9zaXRpb25cbiAgICogQG1lbWJlcm9mIExpc3RlbmVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBMaXN0ZW5lclxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBCaW5hdXJhbGx5LXJlbmRlcmVkIHN0ZXJlbyAoMi1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIExpc3RlbmVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBhbWJpc29uaWNPdXRwdXRcbiAgICogQG1lbWJlcm9mIExpc3RlbmVyXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hbWJpc29uaWNPcmRlciA9IFV0aWxzLkRFRkFVTFRfQU1CSVNPTklDX09SREVSO1xuICB9XG4gIGlmIChvcHRpb25zLnBvc2l0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMucG9zaXRpb24gPSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yd2FyZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmZvcndhcmQgPSBVdGlscy5ERUZBVUxUX0ZPUldBUkQuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy51cCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnVwID0gVXRpbHMuREVGQVVMVF9VUC5zbGljZSgpO1xuICB9XG5cbiAgLy8gTWVtYmVyIHZhcmlhYmxlcy5cbiAgdGhpcy5wb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gIHRoaXMuX3RlbXBNYXRyaXgzID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcblxuICAvLyBTZWxlY3QgdGhlIGFwcHJvcHJpYXRlIEhSSVIgZmlsdGVycyB1c2luZyAyLWNoYW5uZWwgY2h1bmtzIHNpbmNlXG4gIC8vIG11bHRpY2hhbm5lbCBhdWRpbyBpcyBub3QgeWV0IHN1cHBvcnRlZCBieSBhIG1ham9yaXR5IG9mIGJyb3dzZXJzLlxuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9XG4gICAgRW5jb2Rlci52YWxpZGF0ZUFtYmlzb25pY09yZGVyKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIpO1xuXG4gICAgLy8gQ3JlYXRlIGF1ZGlvIG5vZGVzLlxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgaWYgKHRoaXMuX2FtYmlzb25pY09yZGVyID09IDEpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IE9tbml0b25lLk9tbml0b25lLmNyZWF0ZUZPQVJlbmRlcmVyKGNvbnRleHQsIHt9KTtcbiAgfSBlbHNlIGlmICh0aGlzLl9hbWJpc29uaWNPcmRlciA+IDEpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IE9tbml0b25lLk9tbml0b25lLmNyZWF0ZUhPQVJlbmRlcmVyKGNvbnRleHQsIHtcbiAgICAgIGFtYmlzb25pY09yZGVyOiB0aGlzLl9hbWJpc29uaWNPcmRlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRoZXNlIG5vZGVzIGFyZSBjcmVhdGVkIGluIG9yZGVyIHRvIHNhZmVseSBhc3luY2hyb25vdXNseSBsb2FkIE9tbml0b25lXG4gIC8vIHdoaWxlIHRoZSByZXN0IG9mIHRoZSBzY2VuZSBpcyBiZWluZyBjcmVhdGVkLlxuICB0aGlzLmlucHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMub3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuYW1iaXNvbmljT3V0cHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBPbW5pdG9uZSAoYXN5bmMpIGFuZCBjb25uZWN0IHRvIGF1ZGlvIGdyYXBoIHdoZW4gY29tcGxldGUuXG4gIGxldCB0aGF0ID0gdGhpcztcbiAgdGhpcy5fcmVuZGVyZXIuaW5pdGlhbGl6ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgLy8gQ29ubmVjdCBwcmUtcm90YXRlZCBzb3VuZGZpZWxkIHRvIHJlbmRlcmVyLlxuICAgIHRoYXQuaW5wdXQuY29ubmVjdCh0aGF0Ll9yZW5kZXJlci5pbnB1dCk7XG5cbiAgICAvLyBDb25uZWN0IHJvdGF0ZWQgc291bmRmaWVsZCB0byBhbWJpc29uaWMgb3V0cHV0LlxuICAgIGlmICh0aGF0Ll9hbWJpc29uaWNPcmRlciA+IDEpIHtcbiAgICAgIHRoYXQuX3JlbmRlcmVyLl9ob2FSb3RhdG9yLm91dHB1dC5jb25uZWN0KHRoYXQuYW1iaXNvbmljT3V0cHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fcmVuZGVyZXIuX2ZvYVJvdGF0b3Iub3V0cHV0LmNvbm5lY3QodGhhdC5hbWJpc29uaWNPdXRwdXQpO1xuICAgIH1cblxuICAgIC8vIENvbm5lY3QgYmluYXVyYWxseS1yZW5kZXJlZCBzb3VuZGZpZWxkIHRvIGJpbmF1cmFsIG91dHB1dC5cbiAgICB0aGF0Ll9yZW5kZXJlci5vdXRwdXQuY29ubmVjdCh0aGF0Lm91dHB1dCk7XG4gIH0pO1xuXG4gIC8vIFNldCBvcmllbnRhdGlvbiBhbmQgdXBkYXRlIHJvdGF0aW9uIG1hdHJpeCBhY2NvcmRpbmdseS5cbiAgdGhpcy5zZXRPcmllbnRhdGlvbihvcHRpb25zLmZvcndhcmRbMF0sIG9wdGlvbnMuZm9yd2FyZFsxXSxcbiAgICBvcHRpb25zLmZvcndhcmRbMl0sIG9wdGlvbnMudXBbMF0sIG9wdGlvbnMudXBbMV0sIG9wdGlvbnMudXBbMl0pO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc291cmNlJ3Mgb3JpZW50YXRpb24gdXNpbmcgZm9yd2FyZCBhbmQgdXAgdmVjdG9ycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWFxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRZXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFpcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFhcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFlcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFpcbiAqL1xuTGlzdGVuZXIucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24oZm9yd2FyZFgsIGZvcndhcmRZLCBmb3J3YXJkWixcbiAgdXBYLCB1cFksIHVwWikge1xuICBsZXQgcmlnaHQgPSBVdGlscy5jcm9zc1Byb2R1Y3QoW2ZvcndhcmRYLCBmb3J3YXJkWSwgZm9yd2FyZFpdLFxuICAgIFt1cFgsIHVwWSwgdXBaXSk7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzBdID0gcmlnaHRbMF07XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzFdID0gcmlnaHRbMV07XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzJdID0gcmlnaHRbMl07XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzNdID0gdXBYO1xuICB0aGlzLl90ZW1wTWF0cml4M1s0XSA9IHVwWTtcbiAgdGhpcy5fdGVtcE1hdHJpeDNbNV0gPSB1cFo7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzZdID0gZm9yd2FyZFg7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzddID0gZm9yd2FyZFk7XG4gIHRoaXMuX3RlbXBNYXRyaXgzWzhdID0gZm9yd2FyZFo7XG4gIHRoaXMuX3JlbmRlcmVyLnNldFJvdGF0aW9uTWF0cml4Myh0aGlzLl90ZW1wTWF0cml4Myk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiB1c2luZyBhIFRocmVlLmpzIE1hdHJpeDQgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG1hdHJpeDRcbiAqIFRoZSBUaHJlZS5qcyBNYXRyaXg0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGxpc3RlbmVyJ3Mgd29ybGQgdHJhbnNmb3JtLlxuICovXG5MaXN0ZW5lci5wcm90b3R5cGUuc2V0RnJvbU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeDQpIHtcbiAgLy8gVXBkYXRlIGFtYmlzb25pYyByb3RhdGlvbiBtYXRyaXggaW50ZXJuYWxseS5cbiAgdGhpcy5fcmVuZGVyZXIuc2V0Um90YXRpb25NYXRyaXg0KG1hdHJpeDQuZWxlbWVudHMpO1xuXG4gIC8vIEV4dHJhY3QgcG9zaXRpb24gZnJvbSBtYXRyaXguXG4gIHRoaXMucG9zaXRpb25bMF0gPSBtYXRyaXg0LmVsZW1lbnRzWzEyXTtcbiAgdGhpcy5wb3NpdGlvblsxXSA9IG1hdHJpeDQuZWxlbWVudHNbMTNdO1xuICB0aGlzLnBvc2l0aW9uWzJdID0gbWF0cml4NC5lbGVtZW50c1sxNF07XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdGVuZXI7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUHJlLWNvbXB1dGVkIGxvb2t1cCB0YWJsZXMgZm9yIGVuY29kaW5nIGFtYmlzb25pYyBzb3VyY2VzLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLyoqXG4gKiBQcmUtY29tcHV0ZWQgU3BoZXJpY2FsIEhhcm1vbmljcyBDb2VmZmljaWVudHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgYW4gZWZmaWNpZW50IGxvb2t1cCB0YWJsZSBvZiBTSCBjb2VmZmljaWVudHMuIEl0XG4gKiBleHBsb2l0cyB0aGUgd2F5IFNIcyBhcmUgZ2VuZXJhdGVkIChpLmUuIFlsbSA9IE5sbSAqIFBsbSAqIEVtKS4gU2luY2UgTmxtXG4gKiAmIFBsbSBjb2VmZmljaWVudHMgb25seSBkZXBlbmQgb24gdGhldGEsIGFuZCBFbSBvbmx5IGRlcGVuZHMgb24gcGhpLCB3ZVxuICogY2FuIHNlcGFyYXRlIHRoZSBlcXVhdGlvbiBhbG9uZyB0aGVzZSBsaW5lcy4gRW0gZG9lcyBub3QgZGVwZW5kIG9uXG4gKiBkZWdyZWUsIHNvIHdlIG9ubHkgbmVlZCB0byBjb21wdXRlICgyICogbCkgcGVyIGF6aW11dGggRW0gdG90YWwgYW5kXG4gKiBObG0gKiBQbG0gaXMgc3ltbWV0cmljYWwgYWNyb3NzIGluZGV4ZXMsIHNvIG9ubHkgcG9zaXRpdmUgaW5kZXhlcyBhcmVcbiAqIGNvbXB1dGVkICgobCArIDEpICogKGwgKyAyKSAvIDIgLSAxKSBwZXIgZWxldmF0aW9uLlxuICogQHR5cGUge0Zsb2F0MzJBcnJheX1cbiAqL1xuZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTID1cbltcbiAgW1xuICAgIFswLjAwMDAwMCwgMC4wMDAwMDAsIDAuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgICBbMC4wNTIzMzYsIDAuMDM0ODk5LCAwLjAxNzQ1MiwgMC45OTk4NDgsIDAuOTk5MzkxLCAwLjk5ODYzMF0sXG4gICAgWzAuMTA0NTI4LCAwLjA2OTc1NiwgMC4wMzQ4OTksIDAuOTk5MzkxLCAwLjk5NzU2NCwgMC45OTQ1MjJdLFxuICAgIFswLjE1NjQzNCwgMC4xMDQ1MjgsIDAuMDUyMzM2LCAwLjk5ODYzMCwgMC45OTQ1MjIsIDAuOTg3Njg4XSxcbiAgICBbMC4yMDc5MTIsIDAuMTM5MTczLCAwLjA2OTc1NiwgMC45OTc1NjQsIDAuOTkwMjY4LCAwLjk3ODE0OF0sXG4gICAgWzAuMjU4ODE5LCAwLjE3MzY0OCwgMC4wODcxNTYsIDAuOTk2MTk1LCAwLjk4NDgwOCwgMC45NjU5MjZdLFxuICAgIFswLjMwOTAxNywgMC4yMDc5MTIsIDAuMTA0NTI4LCAwLjk5NDUyMiwgMC45NzgxNDgsIDAuOTUxMDU3XSxcbiAgICBbMC4zNTgzNjgsIDAuMjQxOTIyLCAwLjEyMTg2OSwgMC45OTI1NDYsIDAuOTcwMjk2LCAwLjkzMzU4MF0sXG4gICAgWzAuNDA2NzM3LCAwLjI3NTYzNywgMC4xMzkxNzMsIDAuOTkwMjY4LCAwLjk2MTI2MiwgMC45MTM1NDVdLFxuICAgIFswLjQ1Mzk5MCwgMC4zMDkwMTcsIDAuMTU2NDM0LCAwLjk4NzY4OCwgMC45NTEwNTcsIDAuODkxMDA3XSxcbiAgICBbMC41MDAwMDAsIDAuMzQyMDIwLCAwLjE3MzY0OCwgMC45ODQ4MDgsIDAuOTM5NjkzLCAwLjg2NjAyNV0sXG4gICAgWzAuNTQ0NjM5LCAwLjM3NDYwNywgMC4xOTA4MDksIDAuOTgxNjI3LCAwLjkyNzE4NCwgMC44Mzg2NzFdLFxuICAgIFswLjU4Nzc4NSwgMC40MDY3MzcsIDAuMjA3OTEyLCAwLjk3ODE0OCwgMC45MTM1NDUsIDAuODA5MDE3XSxcbiAgICBbMC42MjkzMjAsIDAuNDM4MzcxLCAwLjIyNDk1MSwgMC45NzQzNzAsIDAuODk4Nzk0LCAwLjc3NzE0Nl0sXG4gICAgWzAuNjY5MTMxLCAwLjQ2OTQ3MiwgMC4yNDE5MjIsIDAuOTcwMjk2LCAwLjg4Mjk0OCwgMC43NDMxNDVdLFxuICAgIFswLjcwNzEwNywgMC41MDAwMDAsIDAuMjU4ODE5LCAwLjk2NTkyNiwgMC44NjYwMjUsIDAuNzA3MTA3XSxcbiAgICBbMC43NDMxNDUsIDAuNTI5OTE5LCAwLjI3NTYzNywgMC45NjEyNjIsIDAuODQ4MDQ4LCAwLjY2OTEzMV0sXG4gICAgWzAuNzc3MTQ2LCAwLjU1OTE5MywgMC4yOTIzNzIsIDAuOTU2MzA1LCAwLjgyOTAzOCwgMC42MjkzMjBdLFxuICAgIFswLjgwOTAxNywgMC41ODc3ODUsIDAuMzA5MDE3LCAwLjk1MTA1NywgMC44MDkwMTcsIDAuNTg3Nzg1XSxcbiAgICBbMC44Mzg2NzEsIDAuNjE1NjYxLCAwLjMyNTU2OCwgMC45NDU1MTksIDAuNzg4MDExLCAwLjU0NDYzOV0sXG4gICAgWzAuODY2MDI1LCAwLjY0Mjc4OCwgMC4zNDIwMjAsIDAuOTM5NjkzLCAwLjc2NjA0NCwgMC41MDAwMDBdLFxuICAgIFswLjg5MTAwNywgMC42NjkxMzEsIDAuMzU4MzY4LCAwLjkzMzU4MCwgMC43NDMxNDUsIDAuNDUzOTkwXSxcbiAgICBbMC45MTM1NDUsIDAuNjk0NjU4LCAwLjM3NDYwNywgMC45MjcxODQsIDAuNzE5MzQwLCAwLjQwNjczN10sXG4gICAgWzAuOTMzNTgwLCAwLjcxOTM0MCwgMC4zOTA3MzEsIDAuOTIwNTA1LCAwLjY5NDY1OCwgMC4zNTgzNjhdLFxuICAgIFswLjk1MTA1NywgMC43NDMxNDUsIDAuNDA2NzM3LCAwLjkxMzU0NSwgMC42NjkxMzEsIDAuMzA5MDE3XSxcbiAgICBbMC45NjU5MjYsIDAuNzY2MDQ0LCAwLjQyMjYxOCwgMC45MDYzMDgsIDAuNjQyNzg4LCAwLjI1ODgxOV0sXG4gICAgWzAuOTc4MTQ4LCAwLjc4ODAxMSwgMC40MzgzNzEsIDAuODk4Nzk0LCAwLjYxNTY2MSwgMC4yMDc5MTJdLFxuICAgIFswLjk4NzY4OCwgMC44MDkwMTcsIDAuNDUzOTkwLCAwLjg5MTAwNywgMC41ODc3ODUsIDAuMTU2NDM0XSxcbiAgICBbMC45OTQ1MjIsIDAuODI5MDM4LCAwLjQ2OTQ3MiwgMC44ODI5NDgsIDAuNTU5MTkzLCAwLjEwNDUyOF0sXG4gICAgWzAuOTk4NjMwLCAwLjg0ODA0OCwgMC40ODQ4MTAsIDAuODc0NjIwLCAwLjUyOTkxOSwgMC4wNTIzMzZdLFxuICAgIFsxLjAwMDAwMCwgMC44NjYwMjUsIDAuNTAwMDAwLCAwLjg2NjAyNSwgMC41MDAwMDAsIDAuMDAwMDAwXSxcbiAgICBbMC45OTg2MzAsIDAuODgyOTQ4LCAwLjUxNTAzOCwgMC44NTcxNjcsIDAuNDY5NDcyLCAtMC4wNTIzMzZdLFxuICAgIFswLjk5NDUyMiwgMC44OTg3OTQsIDAuNTI5OTE5LCAwLjg0ODA0OCwgMC40MzgzNzEsIC0wLjEwNDUyOF0sXG4gICAgWzAuOTg3Njg4LCAwLjkxMzU0NSwgMC41NDQ2MzksIDAuODM4NjcxLCAwLjQwNjczNywgLTAuMTU2NDM0XSxcbiAgICBbMC45NzgxNDgsIDAuOTI3MTg0LCAwLjU1OTE5MywgMC44MjkwMzgsIDAuMzc0NjA3LCAtMC4yMDc5MTJdLFxuICAgIFswLjk2NTkyNiwgMC45Mzk2OTMsIDAuNTczNTc2LCAwLjgxOTE1MiwgMC4zNDIwMjAsIC0wLjI1ODgxOV0sXG4gICAgWzAuOTUxMDU3LCAwLjk1MTA1NywgMC41ODc3ODUsIDAuODA5MDE3LCAwLjMwOTAxNywgLTAuMzA5MDE3XSxcbiAgICBbMC45MzM1ODAsIDAuOTYxMjYyLCAwLjYwMTgxNSwgMC43OTg2MzYsIDAuMjc1NjM3LCAtMC4zNTgzNjhdLFxuICAgIFswLjkxMzU0NSwgMC45NzAyOTYsIDAuNjE1NjYxLCAwLjc4ODAxMSwgMC4yNDE5MjIsIC0wLjQwNjczN10sXG4gICAgWzAuODkxMDA3LCAwLjk3ODE0OCwgMC42MjkzMjAsIDAuNzc3MTQ2LCAwLjIwNzkxMiwgLTAuNDUzOTkwXSxcbiAgICBbMC44NjYwMjUsIDAuOTg0ODA4LCAwLjY0Mjc4OCwgMC43NjYwNDQsIDAuMTczNjQ4LCAtMC41MDAwMDBdLFxuICAgIFswLjgzODY3MSwgMC45OTAyNjgsIDAuNjU2MDU5LCAwLjc1NDcxMCwgMC4xMzkxNzMsIC0wLjU0NDYzOV0sXG4gICAgWzAuODA5MDE3LCAwLjk5NDUyMiwgMC42NjkxMzEsIDAuNzQzMTQ1LCAwLjEwNDUyOCwgLTAuNTg3Nzg1XSxcbiAgICBbMC43NzcxNDYsIDAuOTk3NTY0LCAwLjY4MTk5OCwgMC43MzEzNTQsIDAuMDY5NzU2LCAtMC42MjkzMjBdLFxuICAgIFswLjc0MzE0NSwgMC45OTkzOTEsIDAuNjk0NjU4LCAwLjcxOTM0MCwgMC4wMzQ4OTksIC0wLjY2OTEzMV0sXG4gICAgWzAuNzA3MTA3LCAxLjAwMDAwMCwgMC43MDcxMDcsIDAuNzA3MTA3LCAwLjAwMDAwMCwgLTAuNzA3MTA3XSxcbiAgICBbMC42NjkxMzEsIDAuOTk5MzkxLCAwLjcxOTM0MCwgMC42OTQ2NTgsIC0wLjAzNDg5OSwgLTAuNzQzMTQ1XSxcbiAgICBbMC42MjkzMjAsIDAuOTk3NTY0LCAwLjczMTM1NCwgMC42ODE5OTgsIC0wLjA2OTc1NiwgLTAuNzc3MTQ2XSxcbiAgICBbMC41ODc3ODUsIDAuOTk0NTIyLCAwLjc0MzE0NSwgMC42NjkxMzEsIC0wLjEwNDUyOCwgLTAuODA5MDE3XSxcbiAgICBbMC41NDQ2MzksIDAuOTkwMjY4LCAwLjc1NDcxMCwgMC42NTYwNTksIC0wLjEzOTE3MywgLTAuODM4NjcxXSxcbiAgICBbMC41MDAwMDAsIDAuOTg0ODA4LCAwLjc2NjA0NCwgMC42NDI3ODgsIC0wLjE3MzY0OCwgLTAuODY2MDI1XSxcbiAgICBbMC40NTM5OTAsIDAuOTc4MTQ4LCAwLjc3NzE0NiwgMC42MjkzMjAsIC0wLjIwNzkxMiwgLTAuODkxMDA3XSxcbiAgICBbMC40MDY3MzcsIDAuOTcwMjk2LCAwLjc4ODAxMSwgMC42MTU2NjEsIC0wLjI0MTkyMiwgLTAuOTEzNTQ1XSxcbiAgICBbMC4zNTgzNjgsIDAuOTYxMjYyLCAwLjc5ODYzNiwgMC42MDE4MTUsIC0wLjI3NTYzNywgLTAuOTMzNTgwXSxcbiAgICBbMC4zMDkwMTcsIDAuOTUxMDU3LCAwLjgwOTAxNywgMC41ODc3ODUsIC0wLjMwOTAxNywgLTAuOTUxMDU3XSxcbiAgICBbMC4yNTg4MTksIDAuOTM5NjkzLCAwLjgxOTE1MiwgMC41NzM1NzYsIC0wLjM0MjAyMCwgLTAuOTY1OTI2XSxcbiAgICBbMC4yMDc5MTIsIDAuOTI3MTg0LCAwLjgyOTAzOCwgMC41NTkxOTMsIC0wLjM3NDYwNywgLTAuOTc4MTQ4XSxcbiAgICBbMC4xNTY0MzQsIDAuOTEzNTQ1LCAwLjgzODY3MSwgMC41NDQ2MzksIC0wLjQwNjczNywgLTAuOTg3Njg4XSxcbiAgICBbMC4xMDQ1MjgsIDAuODk4Nzk0LCAwLjg0ODA0OCwgMC41Mjk5MTksIC0wLjQzODM3MSwgLTAuOTk0NTIyXSxcbiAgICBbMC4wNTIzMzYsIDAuODgyOTQ4LCAwLjg1NzE2NywgMC41MTUwMzgsIC0wLjQ2OTQ3MiwgLTAuOTk4NjMwXSxcbiAgICBbMC4wMDAwMDAsIDAuODY2MDI1LCAwLjg2NjAyNSwgMC41MDAwMDAsIC0wLjUwMDAwMCwgLTEuMDAwMDAwXSxcbiAgICBbLTAuMDUyMzM2LCAwLjg0ODA0OCwgMC44NzQ2MjAsIDAuNDg0ODEwLCAtMC41Mjk5MTksIC0wLjk5ODYzMF0sXG4gICAgWy0wLjEwNDUyOCwgMC44MjkwMzgsIDAuODgyOTQ4LCAwLjQ2OTQ3MiwgLTAuNTU5MTkzLCAtMC45OTQ1MjJdLFxuICAgIFstMC4xNTY0MzQsIDAuODA5MDE3LCAwLjg5MTAwNywgMC40NTM5OTAsIC0wLjU4Nzc4NSwgLTAuOTg3Njg4XSxcbiAgICBbLTAuMjA3OTEyLCAwLjc4ODAxMSwgMC44OTg3OTQsIDAuNDM4MzcxLCAtMC42MTU2NjEsIC0wLjk3ODE0OF0sXG4gICAgWy0wLjI1ODgxOSwgMC43NjYwNDQsIDAuOTA2MzA4LCAwLjQyMjYxOCwgLTAuNjQyNzg4LCAtMC45NjU5MjZdLFxuICAgIFstMC4zMDkwMTcsIDAuNzQzMTQ1LCAwLjkxMzU0NSwgMC40MDY3MzcsIC0wLjY2OTEzMSwgLTAuOTUxMDU3XSxcbiAgICBbLTAuMzU4MzY4LCAwLjcxOTM0MCwgMC45MjA1MDUsIDAuMzkwNzMxLCAtMC42OTQ2NTgsIC0wLjkzMzU4MF0sXG4gICAgWy0wLjQwNjczNywgMC42OTQ2NTgsIDAuOTI3MTg0LCAwLjM3NDYwNywgLTAuNzE5MzQwLCAtMC45MTM1NDVdLFxuICAgIFstMC40NTM5OTAsIDAuNjY5MTMxLCAwLjkzMzU4MCwgMC4zNTgzNjgsIC0wLjc0MzE0NSwgLTAuODkxMDA3XSxcbiAgICBbLTAuNTAwMDAwLCAwLjY0Mjc4OCwgMC45Mzk2OTMsIDAuMzQyMDIwLCAtMC43NjYwNDQsIC0wLjg2NjAyNV0sXG4gICAgWy0wLjU0NDYzOSwgMC42MTU2NjEsIDAuOTQ1NTE5LCAwLjMyNTU2OCwgLTAuNzg4MDExLCAtMC44Mzg2NzFdLFxuICAgIFstMC41ODc3ODUsIDAuNTg3Nzg1LCAwLjk1MTA1NywgMC4zMDkwMTcsIC0wLjgwOTAxNywgLTAuODA5MDE3XSxcbiAgICBbLTAuNjI5MzIwLCAwLjU1OTE5MywgMC45NTYzMDUsIDAuMjkyMzcyLCAtMC44MjkwMzgsIC0wLjc3NzE0Nl0sXG4gICAgWy0wLjY2OTEzMSwgMC41Mjk5MTksIDAuOTYxMjYyLCAwLjI3NTYzNywgLTAuODQ4MDQ4LCAtMC43NDMxNDVdLFxuICAgIFstMC43MDcxMDcsIDAuNTAwMDAwLCAwLjk2NTkyNiwgMC4yNTg4MTksIC0wLjg2NjAyNSwgLTAuNzA3MTA3XSxcbiAgICBbLTAuNzQzMTQ1LCAwLjQ2OTQ3MiwgMC45NzAyOTYsIDAuMjQxOTIyLCAtMC44ODI5NDgsIC0wLjY2OTEzMV0sXG4gICAgWy0wLjc3NzE0NiwgMC40MzgzNzEsIDAuOTc0MzcwLCAwLjIyNDk1MSwgLTAuODk4Nzk0LCAtMC42MjkzMjBdLFxuICAgIFstMC44MDkwMTcsIDAuNDA2NzM3LCAwLjk3ODE0OCwgMC4yMDc5MTIsIC0wLjkxMzU0NSwgLTAuNTg3Nzg1XSxcbiAgICBbLTAuODM4NjcxLCAwLjM3NDYwNywgMC45ODE2MjcsIDAuMTkwODA5LCAtMC45MjcxODQsIC0wLjU0NDYzOV0sXG4gICAgWy0wLjg2NjAyNSwgMC4zNDIwMjAsIDAuOTg0ODA4LCAwLjE3MzY0OCwgLTAuOTM5NjkzLCAtMC41MDAwMDBdLFxuICAgIFstMC44OTEwMDcsIDAuMzA5MDE3LCAwLjk4NzY4OCwgMC4xNTY0MzQsIC0wLjk1MTA1NywgLTAuNDUzOTkwXSxcbiAgICBbLTAuOTEzNTQ1LCAwLjI3NTYzNywgMC45OTAyNjgsIDAuMTM5MTczLCAtMC45NjEyNjIsIC0wLjQwNjczN10sXG4gICAgWy0wLjkzMzU4MCwgMC4yNDE5MjIsIDAuOTkyNTQ2LCAwLjEyMTg2OSwgLTAuOTcwMjk2LCAtMC4zNTgzNjhdLFxuICAgIFstMC45NTEwNTcsIDAuMjA3OTEyLCAwLjk5NDUyMiwgMC4xMDQ1MjgsIC0wLjk3ODE0OCwgLTAuMzA5MDE3XSxcbiAgICBbLTAuOTY1OTI2LCAwLjE3MzY0OCwgMC45OTYxOTUsIDAuMDg3MTU2LCAtMC45ODQ4MDgsIC0wLjI1ODgxOV0sXG4gICAgWy0wLjk3ODE0OCwgMC4xMzkxNzMsIDAuOTk3NTY0LCAwLjA2OTc1NiwgLTAuOTkwMjY4LCAtMC4yMDc5MTJdLFxuICAgIFstMC45ODc2ODgsIDAuMTA0NTI4LCAwLjk5ODYzMCwgMC4wNTIzMzYsIC0wLjk5NDUyMiwgLTAuMTU2NDM0XSxcbiAgICBbLTAuOTk0NTIyLCAwLjA2OTc1NiwgMC45OTkzOTEsIDAuMDM0ODk5LCAtMC45OTc1NjQsIC0wLjEwNDUyOF0sXG4gICAgWy0wLjk5ODYzMCwgMC4wMzQ4OTksIDAuOTk5ODQ4LCAwLjAxNzQ1MiwgLTAuOTk5MzkxLCAtMC4wNTIzMzZdLFxuICAgIFstMS4wMDAwMDAsIDAuMDAwMDAwLCAxLjAwMDAwMCwgMC4wMDAwMDAsIC0xLjAwMDAwMCwgLTAuMDAwMDAwXSxcbiAgICBbLTAuOTk4NjMwLCAtMC4wMzQ4OTksIDAuOTk5ODQ4LCAtMC4wMTc0NTIsIC0wLjk5OTM5MSwgMC4wNTIzMzZdLFxuICAgIFstMC45OTQ1MjIsIC0wLjA2OTc1NiwgMC45OTkzOTEsIC0wLjAzNDg5OSwgLTAuOTk3NTY0LCAwLjEwNDUyOF0sXG4gICAgWy0wLjk4NzY4OCwgLTAuMTA0NTI4LCAwLjk5ODYzMCwgLTAuMDUyMzM2LCAtMC45OTQ1MjIsIDAuMTU2NDM0XSxcbiAgICBbLTAuOTc4MTQ4LCAtMC4xMzkxNzMsIDAuOTk3NTY0LCAtMC4wNjk3NTYsIC0wLjk5MDI2OCwgMC4yMDc5MTJdLFxuICAgIFstMC45NjU5MjYsIC0wLjE3MzY0OCwgMC45OTYxOTUsIC0wLjA4NzE1NiwgLTAuOTg0ODA4LCAwLjI1ODgxOV0sXG4gICAgWy0wLjk1MTA1NywgLTAuMjA3OTEyLCAwLjk5NDUyMiwgLTAuMTA0NTI4LCAtMC45NzgxNDgsIDAuMzA5MDE3XSxcbiAgICBbLTAuOTMzNTgwLCAtMC4yNDE5MjIsIDAuOTkyNTQ2LCAtMC4xMjE4NjksIC0wLjk3MDI5NiwgMC4zNTgzNjhdLFxuICAgIFstMC45MTM1NDUsIC0wLjI3NTYzNywgMC45OTAyNjgsIC0wLjEzOTE3MywgLTAuOTYxMjYyLCAwLjQwNjczN10sXG4gICAgWy0wLjg5MTAwNywgLTAuMzA5MDE3LCAwLjk4NzY4OCwgLTAuMTU2NDM0LCAtMC45NTEwNTcsIDAuNDUzOTkwXSxcbiAgICBbLTAuODY2MDI1LCAtMC4zNDIwMjAsIDAuOTg0ODA4LCAtMC4xNzM2NDgsIC0wLjkzOTY5MywgMC41MDAwMDBdLFxuICAgIFstMC44Mzg2NzEsIC0wLjM3NDYwNywgMC45ODE2MjcsIC0wLjE5MDgwOSwgLTAuOTI3MTg0LCAwLjU0NDYzOV0sXG4gICAgWy0wLjgwOTAxNywgLTAuNDA2NzM3LCAwLjk3ODE0OCwgLTAuMjA3OTEyLCAtMC45MTM1NDUsIDAuNTg3Nzg1XSxcbiAgICBbLTAuNzc3MTQ2LCAtMC40MzgzNzEsIDAuOTc0MzcwLCAtMC4yMjQ5NTEsIC0wLjg5ODc5NCwgMC42MjkzMjBdLFxuICAgIFstMC43NDMxNDUsIC0wLjQ2OTQ3MiwgMC45NzAyOTYsIC0wLjI0MTkyMiwgLTAuODgyOTQ4LCAwLjY2OTEzMV0sXG4gICAgWy0wLjcwNzEwNywgLTAuNTAwMDAwLCAwLjk2NTkyNiwgLTAuMjU4ODE5LCAtMC44NjYwMjUsIDAuNzA3MTA3XSxcbiAgICBbLTAuNjY5MTMxLCAtMC41Mjk5MTksIDAuOTYxMjYyLCAtMC4yNzU2MzcsIC0wLjg0ODA0OCwgMC43NDMxNDVdLFxuICAgIFstMC42MjkzMjAsIC0wLjU1OTE5MywgMC45NTYzMDUsIC0wLjI5MjM3MiwgLTAuODI5MDM4LCAwLjc3NzE0Nl0sXG4gICAgWy0wLjU4Nzc4NSwgLTAuNTg3Nzg1LCAwLjk1MTA1NywgLTAuMzA5MDE3LCAtMC44MDkwMTcsIDAuODA5MDE3XSxcbiAgICBbLTAuNTQ0NjM5LCAtMC42MTU2NjEsIDAuOTQ1NTE5LCAtMC4zMjU1NjgsIC0wLjc4ODAxMSwgMC44Mzg2NzFdLFxuICAgIFstMC41MDAwMDAsIC0wLjY0Mjc4OCwgMC45Mzk2OTMsIC0wLjM0MjAyMCwgLTAuNzY2MDQ0LCAwLjg2NjAyNV0sXG4gICAgWy0wLjQ1Mzk5MCwgLTAuNjY5MTMxLCAwLjkzMzU4MCwgLTAuMzU4MzY4LCAtMC43NDMxNDUsIDAuODkxMDA3XSxcbiAgICBbLTAuNDA2NzM3LCAtMC42OTQ2NTgsIDAuOTI3MTg0LCAtMC4zNzQ2MDcsIC0wLjcxOTM0MCwgMC45MTM1NDVdLFxuICAgIFstMC4zNTgzNjgsIC0wLjcxOTM0MCwgMC45MjA1MDUsIC0wLjM5MDczMSwgLTAuNjk0NjU4LCAwLjkzMzU4MF0sXG4gICAgWy0wLjMwOTAxNywgLTAuNzQzMTQ1LCAwLjkxMzU0NSwgLTAuNDA2NzM3LCAtMC42NjkxMzEsIDAuOTUxMDU3XSxcbiAgICBbLTAuMjU4ODE5LCAtMC43NjYwNDQsIDAuOTA2MzA4LCAtMC40MjI2MTgsIC0wLjY0Mjc4OCwgMC45NjU5MjZdLFxuICAgIFstMC4yMDc5MTIsIC0wLjc4ODAxMSwgMC44OTg3OTQsIC0wLjQzODM3MSwgLTAuNjE1NjYxLCAwLjk3ODE0OF0sXG4gICAgWy0wLjE1NjQzNCwgLTAuODA5MDE3LCAwLjg5MTAwNywgLTAuNDUzOTkwLCAtMC41ODc3ODUsIDAuOTg3Njg4XSxcbiAgICBbLTAuMTA0NTI4LCAtMC44MjkwMzgsIDAuODgyOTQ4LCAtMC40Njk0NzIsIC0wLjU1OTE5MywgMC45OTQ1MjJdLFxuICAgIFstMC4wNTIzMzYsIC0wLjg0ODA0OCwgMC44NzQ2MjAsIC0wLjQ4NDgxMCwgLTAuNTI5OTE5LCAwLjk5ODYzMF0sXG4gICAgWy0wLjAwMDAwMCwgLTAuODY2MDI1LCAwLjg2NjAyNSwgLTAuNTAwMDAwLCAtMC41MDAwMDAsIDEuMDAwMDAwXSxcbiAgICBbMC4wNTIzMzYsIC0wLjg4Mjk0OCwgMC44NTcxNjcsIC0wLjUxNTAzOCwgLTAuNDY5NDcyLCAwLjk5ODYzMF0sXG4gICAgWzAuMTA0NTI4LCAtMC44OTg3OTQsIDAuODQ4MDQ4LCAtMC41Mjk5MTksIC0wLjQzODM3MSwgMC45OTQ1MjJdLFxuICAgIFswLjE1NjQzNCwgLTAuOTEzNTQ1LCAwLjgzODY3MSwgLTAuNTQ0NjM5LCAtMC40MDY3MzcsIDAuOTg3Njg4XSxcbiAgICBbMC4yMDc5MTIsIC0wLjkyNzE4NCwgMC44MjkwMzgsIC0wLjU1OTE5MywgLTAuMzc0NjA3LCAwLjk3ODE0OF0sXG4gICAgWzAuMjU4ODE5LCAtMC45Mzk2OTMsIDAuODE5MTUyLCAtMC41NzM1NzYsIC0wLjM0MjAyMCwgMC45NjU5MjZdLFxuICAgIFswLjMwOTAxNywgLTAuOTUxMDU3LCAwLjgwOTAxNywgLTAuNTg3Nzg1LCAtMC4zMDkwMTcsIDAuOTUxMDU3XSxcbiAgICBbMC4zNTgzNjgsIC0wLjk2MTI2MiwgMC43OTg2MzYsIC0wLjYwMTgxNSwgLTAuMjc1NjM3LCAwLjkzMzU4MF0sXG4gICAgWzAuNDA2NzM3LCAtMC45NzAyOTYsIDAuNzg4MDExLCAtMC42MTU2NjEsIC0wLjI0MTkyMiwgMC45MTM1NDVdLFxuICAgIFswLjQ1Mzk5MCwgLTAuOTc4MTQ4LCAwLjc3NzE0NiwgLTAuNjI5MzIwLCAtMC4yMDc5MTIsIDAuODkxMDA3XSxcbiAgICBbMC41MDAwMDAsIC0wLjk4NDgwOCwgMC43NjYwNDQsIC0wLjY0Mjc4OCwgLTAuMTczNjQ4LCAwLjg2NjAyNV0sXG4gICAgWzAuNTQ0NjM5LCAtMC45OTAyNjgsIDAuNzU0NzEwLCAtMC42NTYwNTksIC0wLjEzOTE3MywgMC44Mzg2NzFdLFxuICAgIFswLjU4Nzc4NSwgLTAuOTk0NTIyLCAwLjc0MzE0NSwgLTAuNjY5MTMxLCAtMC4xMDQ1MjgsIDAuODA5MDE3XSxcbiAgICBbMC42MjkzMjAsIC0wLjk5NzU2NCwgMC43MzEzNTQsIC0wLjY4MTk5OCwgLTAuMDY5NzU2LCAwLjc3NzE0Nl0sXG4gICAgWzAuNjY5MTMxLCAtMC45OTkzOTEsIDAuNzE5MzQwLCAtMC42OTQ2NTgsIC0wLjAzNDg5OSwgMC43NDMxNDVdLFxuICAgIFswLjcwNzEwNywgLTEuMDAwMDAwLCAwLjcwNzEwNywgLTAuNzA3MTA3LCAtMC4wMDAwMDAsIDAuNzA3MTA3XSxcbiAgICBbMC43NDMxNDUsIC0wLjk5OTM5MSwgMC42OTQ2NTgsIC0wLjcxOTM0MCwgMC4wMzQ4OTksIDAuNjY5MTMxXSxcbiAgICBbMC43NzcxNDYsIC0wLjk5NzU2NCwgMC42ODE5OTgsIC0wLjczMTM1NCwgMC4wNjk3NTYsIDAuNjI5MzIwXSxcbiAgICBbMC44MDkwMTcsIC0wLjk5NDUyMiwgMC42NjkxMzEsIC0wLjc0MzE0NSwgMC4xMDQ1MjgsIDAuNTg3Nzg1XSxcbiAgICBbMC44Mzg2NzEsIC0wLjk5MDI2OCwgMC42NTYwNTksIC0wLjc1NDcxMCwgMC4xMzkxNzMsIDAuNTQ0NjM5XSxcbiAgICBbMC44NjYwMjUsIC0wLjk4NDgwOCwgMC42NDI3ODgsIC0wLjc2NjA0NCwgMC4xNzM2NDgsIDAuNTAwMDAwXSxcbiAgICBbMC44OTEwMDcsIC0wLjk3ODE0OCwgMC42MjkzMjAsIC0wLjc3NzE0NiwgMC4yMDc5MTIsIDAuNDUzOTkwXSxcbiAgICBbMC45MTM1NDUsIC0wLjk3MDI5NiwgMC42MTU2NjEsIC0wLjc4ODAxMSwgMC4yNDE5MjIsIDAuNDA2NzM3XSxcbiAgICBbMC45MzM1ODAsIC0wLjk2MTI2MiwgMC42MDE4MTUsIC0wLjc5ODYzNiwgMC4yNzU2MzcsIDAuMzU4MzY4XSxcbiAgICBbMC45NTEwNTcsIC0wLjk1MTA1NywgMC41ODc3ODUsIC0wLjgwOTAxNywgMC4zMDkwMTcsIDAuMzA5MDE3XSxcbiAgICBbMC45NjU5MjYsIC0wLjkzOTY5MywgMC41NzM1NzYsIC0wLjgxOTE1MiwgMC4zNDIwMjAsIDAuMjU4ODE5XSxcbiAgICBbMC45NzgxNDgsIC0wLjkyNzE4NCwgMC41NTkxOTMsIC0wLjgyOTAzOCwgMC4zNzQ2MDcsIDAuMjA3OTEyXSxcbiAgICBbMC45ODc2ODgsIC0wLjkxMzU0NSwgMC41NDQ2MzksIC0wLjgzODY3MSwgMC40MDY3MzcsIDAuMTU2NDM0XSxcbiAgICBbMC45OTQ1MjIsIC0wLjg5ODc5NCwgMC41Mjk5MTksIC0wLjg0ODA0OCwgMC40MzgzNzEsIDAuMTA0NTI4XSxcbiAgICBbMC45OTg2MzAsIC0wLjg4Mjk0OCwgMC41MTUwMzgsIC0wLjg1NzE2NywgMC40Njk0NzIsIDAuMDUyMzM2XSxcbiAgICBbMS4wMDAwMDAsIC0wLjg2NjAyNSwgMC41MDAwMDAsIC0wLjg2NjAyNSwgMC41MDAwMDAsIDAuMDAwMDAwXSxcbiAgICBbMC45OTg2MzAsIC0wLjg0ODA0OCwgMC40ODQ4MTAsIC0wLjg3NDYyMCwgMC41Mjk5MTksIC0wLjA1MjMzNl0sXG4gICAgWzAuOTk0NTIyLCAtMC44MjkwMzgsIDAuNDY5NDcyLCAtMC44ODI5NDgsIDAuNTU5MTkzLCAtMC4xMDQ1MjhdLFxuICAgIFswLjk4NzY4OCwgLTAuODA5MDE3LCAwLjQ1Mzk5MCwgLTAuODkxMDA3LCAwLjU4Nzc4NSwgLTAuMTU2NDM0XSxcbiAgICBbMC45NzgxNDgsIC0wLjc4ODAxMSwgMC40MzgzNzEsIC0wLjg5ODc5NCwgMC42MTU2NjEsIC0wLjIwNzkxMl0sXG4gICAgWzAuOTY1OTI2LCAtMC43NjYwNDQsIDAuNDIyNjE4LCAtMC45MDYzMDgsIDAuNjQyNzg4LCAtMC4yNTg4MTldLFxuICAgIFswLjk1MTA1NywgLTAuNzQzMTQ1LCAwLjQwNjczNywgLTAuOTEzNTQ1LCAwLjY2OTEzMSwgLTAuMzA5MDE3XSxcbiAgICBbMC45MzM1ODAsIC0wLjcxOTM0MCwgMC4zOTA3MzEsIC0wLjkyMDUwNSwgMC42OTQ2NTgsIC0wLjM1ODM2OF0sXG4gICAgWzAuOTEzNTQ1LCAtMC42OTQ2NTgsIDAuMzc0NjA3LCAtMC45MjcxODQsIDAuNzE5MzQwLCAtMC40MDY3MzddLFxuICAgIFswLjg5MTAwNywgLTAuNjY5MTMxLCAwLjM1ODM2OCwgLTAuOTMzNTgwLCAwLjc0MzE0NSwgLTAuNDUzOTkwXSxcbiAgICBbMC44NjYwMjUsIC0wLjY0Mjc4OCwgMC4zNDIwMjAsIC0wLjkzOTY5MywgMC43NjYwNDQsIC0wLjUwMDAwMF0sXG4gICAgWzAuODM4NjcxLCAtMC42MTU2NjEsIDAuMzI1NTY4LCAtMC45NDU1MTksIDAuNzg4MDExLCAtMC41NDQ2MzldLFxuICAgIFswLjgwOTAxNywgLTAuNTg3Nzg1LCAwLjMwOTAxNywgLTAuOTUxMDU3LCAwLjgwOTAxNywgLTAuNTg3Nzg1XSxcbiAgICBbMC43NzcxNDYsIC0wLjU1OTE5MywgMC4yOTIzNzIsIC0wLjk1NjMwNSwgMC44MjkwMzgsIC0wLjYyOTMyMF0sXG4gICAgWzAuNzQzMTQ1LCAtMC41Mjk5MTksIDAuMjc1NjM3LCAtMC45NjEyNjIsIDAuODQ4MDQ4LCAtMC42NjkxMzFdLFxuICAgIFswLjcwNzEwNywgLTAuNTAwMDAwLCAwLjI1ODgxOSwgLTAuOTY1OTI2LCAwLjg2NjAyNSwgLTAuNzA3MTA3XSxcbiAgICBbMC42NjkxMzEsIC0wLjQ2OTQ3MiwgMC4yNDE5MjIsIC0wLjk3MDI5NiwgMC44ODI5NDgsIC0wLjc0MzE0NV0sXG4gICAgWzAuNjI5MzIwLCAtMC40MzgzNzEsIDAuMjI0OTUxLCAtMC45NzQzNzAsIDAuODk4Nzk0LCAtMC43NzcxNDZdLFxuICAgIFswLjU4Nzc4NSwgLTAuNDA2NzM3LCAwLjIwNzkxMiwgLTAuOTc4MTQ4LCAwLjkxMzU0NSwgLTAuODA5MDE3XSxcbiAgICBbMC41NDQ2MzksIC0wLjM3NDYwNywgMC4xOTA4MDksIC0wLjk4MTYyNywgMC45MjcxODQsIC0wLjgzODY3MV0sXG4gICAgWzAuNTAwMDAwLCAtMC4zNDIwMjAsIDAuMTczNjQ4LCAtMC45ODQ4MDgsIDAuOTM5NjkzLCAtMC44NjYwMjVdLFxuICAgIFswLjQ1Mzk5MCwgLTAuMzA5MDE3LCAwLjE1NjQzNCwgLTAuOTg3Njg4LCAwLjk1MTA1NywgLTAuODkxMDA3XSxcbiAgICBbMC40MDY3MzcsIC0wLjI3NTYzNywgMC4xMzkxNzMsIC0wLjk5MDI2OCwgMC45NjEyNjIsIC0wLjkxMzU0NV0sXG4gICAgWzAuMzU4MzY4LCAtMC4yNDE5MjIsIDAuMTIxODY5LCAtMC45OTI1NDYsIDAuOTcwMjk2LCAtMC45MzM1ODBdLFxuICAgIFswLjMwOTAxNywgLTAuMjA3OTEyLCAwLjEwNDUyOCwgLTAuOTk0NTIyLCAwLjk3ODE0OCwgLTAuOTUxMDU3XSxcbiAgICBbMC4yNTg4MTksIC0wLjE3MzY0OCwgMC4wODcxNTYsIC0wLjk5NjE5NSwgMC45ODQ4MDgsIC0wLjk2NTkyNl0sXG4gICAgWzAuMjA3OTEyLCAtMC4xMzkxNzMsIDAuMDY5NzU2LCAtMC45OTc1NjQsIDAuOTkwMjY4LCAtMC45NzgxNDhdLFxuICAgIFswLjE1NjQzNCwgLTAuMTA0NTI4LCAwLjA1MjMzNiwgLTAuOTk4NjMwLCAwLjk5NDUyMiwgLTAuOTg3Njg4XSxcbiAgICBbMC4xMDQ1MjgsIC0wLjA2OTc1NiwgMC4wMzQ4OTksIC0wLjk5OTM5MSwgMC45OTc1NjQsIC0wLjk5NDUyMl0sXG4gICAgWzAuMDUyMzM2LCAtMC4wMzQ4OTksIDAuMDE3NDUyLCAtMC45OTk4NDgsIDAuOTk5MzkxLCAtMC45OTg2MzBdLFxuICAgIFswLjAwMDAwMCwgLTAuMDAwMDAwLCAwLjAwMDAwMCwgLTEuMDAwMDAwLCAxLjAwMDAwMCwgLTEuMDAwMDAwXSxcbiAgICBbLTAuMDUyMzM2LCAwLjAzNDg5OSwgLTAuMDE3NDUyLCAtMC45OTk4NDgsIDAuOTk5MzkxLCAtMC45OTg2MzBdLFxuICAgIFstMC4xMDQ1MjgsIDAuMDY5NzU2LCAtMC4wMzQ4OTksIC0wLjk5OTM5MSwgMC45OTc1NjQsIC0wLjk5NDUyMl0sXG4gICAgWy0wLjE1NjQzNCwgMC4xMDQ1MjgsIC0wLjA1MjMzNiwgLTAuOTk4NjMwLCAwLjk5NDUyMiwgLTAuOTg3Njg4XSxcbiAgICBbLTAuMjA3OTEyLCAwLjEzOTE3MywgLTAuMDY5NzU2LCAtMC45OTc1NjQsIDAuOTkwMjY4LCAtMC45NzgxNDhdLFxuICAgIFstMC4yNTg4MTksIDAuMTczNjQ4LCAtMC4wODcxNTYsIC0wLjk5NjE5NSwgMC45ODQ4MDgsIC0wLjk2NTkyNl0sXG4gICAgWy0wLjMwOTAxNywgMC4yMDc5MTIsIC0wLjEwNDUyOCwgLTAuOTk0NTIyLCAwLjk3ODE0OCwgLTAuOTUxMDU3XSxcbiAgICBbLTAuMzU4MzY4LCAwLjI0MTkyMiwgLTAuMTIxODY5LCAtMC45OTI1NDYsIDAuOTcwMjk2LCAtMC45MzM1ODBdLFxuICAgIFstMC40MDY3MzcsIDAuMjc1NjM3LCAtMC4xMzkxNzMsIC0wLjk5MDI2OCwgMC45NjEyNjIsIC0wLjkxMzU0NV0sXG4gICAgWy0wLjQ1Mzk5MCwgMC4zMDkwMTcsIC0wLjE1NjQzNCwgLTAuOTg3Njg4LCAwLjk1MTA1NywgLTAuODkxMDA3XSxcbiAgICBbLTAuNTAwMDAwLCAwLjM0MjAyMCwgLTAuMTczNjQ4LCAtMC45ODQ4MDgsIDAuOTM5NjkzLCAtMC44NjYwMjVdLFxuICAgIFstMC41NDQ2MzksIDAuMzc0NjA3LCAtMC4xOTA4MDksIC0wLjk4MTYyNywgMC45MjcxODQsIC0wLjgzODY3MV0sXG4gICAgWy0wLjU4Nzc4NSwgMC40MDY3MzcsIC0wLjIwNzkxMiwgLTAuOTc4MTQ4LCAwLjkxMzU0NSwgLTAuODA5MDE3XSxcbiAgICBbLTAuNjI5MzIwLCAwLjQzODM3MSwgLTAuMjI0OTUxLCAtMC45NzQzNzAsIDAuODk4Nzk0LCAtMC43NzcxNDZdLFxuICAgIFstMC42NjkxMzEsIDAuNDY5NDcyLCAtMC4yNDE5MjIsIC0wLjk3MDI5NiwgMC44ODI5NDgsIC0wLjc0MzE0NV0sXG4gICAgWy0wLjcwNzEwNywgMC41MDAwMDAsIC0wLjI1ODgxOSwgLTAuOTY1OTI2LCAwLjg2NjAyNSwgLTAuNzA3MTA3XSxcbiAgICBbLTAuNzQzMTQ1LCAwLjUyOTkxOSwgLTAuMjc1NjM3LCAtMC45NjEyNjIsIDAuODQ4MDQ4LCAtMC42NjkxMzFdLFxuICAgIFstMC43NzcxNDYsIDAuNTU5MTkzLCAtMC4yOTIzNzIsIC0wLjk1NjMwNSwgMC44MjkwMzgsIC0wLjYyOTMyMF0sXG4gICAgWy0wLjgwOTAxNywgMC41ODc3ODUsIC0wLjMwOTAxNywgLTAuOTUxMDU3LCAwLjgwOTAxNywgLTAuNTg3Nzg1XSxcbiAgICBbLTAuODM4NjcxLCAwLjYxNTY2MSwgLTAuMzI1NTY4LCAtMC45NDU1MTksIDAuNzg4MDExLCAtMC41NDQ2MzldLFxuICAgIFstMC44NjYwMjUsIDAuNjQyNzg4LCAtMC4zNDIwMjAsIC0wLjkzOTY5MywgMC43NjYwNDQsIC0wLjUwMDAwMF0sXG4gICAgWy0wLjg5MTAwNywgMC42NjkxMzEsIC0wLjM1ODM2OCwgLTAuOTMzNTgwLCAwLjc0MzE0NSwgLTAuNDUzOTkwXSxcbiAgICBbLTAuOTEzNTQ1LCAwLjY5NDY1OCwgLTAuMzc0NjA3LCAtMC45MjcxODQsIDAuNzE5MzQwLCAtMC40MDY3MzddLFxuICAgIFstMC45MzM1ODAsIDAuNzE5MzQwLCAtMC4zOTA3MzEsIC0wLjkyMDUwNSwgMC42OTQ2NTgsIC0wLjM1ODM2OF0sXG4gICAgWy0wLjk1MTA1NywgMC43NDMxNDUsIC0wLjQwNjczNywgLTAuOTEzNTQ1LCAwLjY2OTEzMSwgLTAuMzA5MDE3XSxcbiAgICBbLTAuOTY1OTI2LCAwLjc2NjA0NCwgLTAuNDIyNjE4LCAtMC45MDYzMDgsIDAuNjQyNzg4LCAtMC4yNTg4MTldLFxuICAgIFstMC45NzgxNDgsIDAuNzg4MDExLCAtMC40MzgzNzEsIC0wLjg5ODc5NCwgMC42MTU2NjEsIC0wLjIwNzkxMl0sXG4gICAgWy0wLjk4NzY4OCwgMC44MDkwMTcsIC0wLjQ1Mzk5MCwgLTAuODkxMDA3LCAwLjU4Nzc4NSwgLTAuMTU2NDM0XSxcbiAgICBbLTAuOTk0NTIyLCAwLjgyOTAzOCwgLTAuNDY5NDcyLCAtMC44ODI5NDgsIDAuNTU5MTkzLCAtMC4xMDQ1MjhdLFxuICAgIFstMC45OTg2MzAsIDAuODQ4MDQ4LCAtMC40ODQ4MTAsIC0wLjg3NDYyMCwgMC41Mjk5MTksIC0wLjA1MjMzNl0sXG4gICAgWy0xLjAwMDAwMCwgMC44NjYwMjUsIC0wLjUwMDAwMCwgLTAuODY2MDI1LCAwLjUwMDAwMCwgMC4wMDAwMDBdLFxuICAgIFstMC45OTg2MzAsIDAuODgyOTQ4LCAtMC41MTUwMzgsIC0wLjg1NzE2NywgMC40Njk0NzIsIDAuMDUyMzM2XSxcbiAgICBbLTAuOTk0NTIyLCAwLjg5ODc5NCwgLTAuNTI5OTE5LCAtMC44NDgwNDgsIDAuNDM4MzcxLCAwLjEwNDUyOF0sXG4gICAgWy0wLjk4NzY4OCwgMC45MTM1NDUsIC0wLjU0NDYzOSwgLTAuODM4NjcxLCAwLjQwNjczNywgMC4xNTY0MzRdLFxuICAgIFstMC45NzgxNDgsIDAuOTI3MTg0LCAtMC41NTkxOTMsIC0wLjgyOTAzOCwgMC4zNzQ2MDcsIDAuMjA3OTEyXSxcbiAgICBbLTAuOTY1OTI2LCAwLjkzOTY5MywgLTAuNTczNTc2LCAtMC44MTkxNTIsIDAuMzQyMDIwLCAwLjI1ODgxOV0sXG4gICAgWy0wLjk1MTA1NywgMC45NTEwNTcsIC0wLjU4Nzc4NSwgLTAuODA5MDE3LCAwLjMwOTAxNywgMC4zMDkwMTddLFxuICAgIFstMC45MzM1ODAsIDAuOTYxMjYyLCAtMC42MDE4MTUsIC0wLjc5ODYzNiwgMC4yNzU2MzcsIDAuMzU4MzY4XSxcbiAgICBbLTAuOTEzNTQ1LCAwLjk3MDI5NiwgLTAuNjE1NjYxLCAtMC43ODgwMTEsIDAuMjQxOTIyLCAwLjQwNjczN10sXG4gICAgWy0wLjg5MTAwNywgMC45NzgxNDgsIC0wLjYyOTMyMCwgLTAuNzc3MTQ2LCAwLjIwNzkxMiwgMC40NTM5OTBdLFxuICAgIFstMC44NjYwMjUsIDAuOTg0ODA4LCAtMC42NDI3ODgsIC0wLjc2NjA0NCwgMC4xNzM2NDgsIDAuNTAwMDAwXSxcbiAgICBbLTAuODM4NjcxLCAwLjk5MDI2OCwgLTAuNjU2MDU5LCAtMC43NTQ3MTAsIDAuMTM5MTczLCAwLjU0NDYzOV0sXG4gICAgWy0wLjgwOTAxNywgMC45OTQ1MjIsIC0wLjY2OTEzMSwgLTAuNzQzMTQ1LCAwLjEwNDUyOCwgMC41ODc3ODVdLFxuICAgIFstMC43NzcxNDYsIDAuOTk3NTY0LCAtMC42ODE5OTgsIC0wLjczMTM1NCwgMC4wNjk3NTYsIDAuNjI5MzIwXSxcbiAgICBbLTAuNzQzMTQ1LCAwLjk5OTM5MSwgLTAuNjk0NjU4LCAtMC43MTkzNDAsIDAuMDM0ODk5LCAwLjY2OTEzMV0sXG4gICAgWy0wLjcwNzEwNywgMS4wMDAwMDAsIC0wLjcwNzEwNywgLTAuNzA3MTA3LCAwLjAwMDAwMCwgMC43MDcxMDddLFxuICAgIFstMC42NjkxMzEsIDAuOTk5MzkxLCAtMC43MTkzNDAsIC0wLjY5NDY1OCwgLTAuMDM0ODk5LCAwLjc0MzE0NV0sXG4gICAgWy0wLjYyOTMyMCwgMC45OTc1NjQsIC0wLjczMTM1NCwgLTAuNjgxOTk4LCAtMC4wNjk3NTYsIDAuNzc3MTQ2XSxcbiAgICBbLTAuNTg3Nzg1LCAwLjk5NDUyMiwgLTAuNzQzMTQ1LCAtMC42NjkxMzEsIC0wLjEwNDUyOCwgMC44MDkwMTddLFxuICAgIFstMC41NDQ2MzksIDAuOTkwMjY4LCAtMC43NTQ3MTAsIC0wLjY1NjA1OSwgLTAuMTM5MTczLCAwLjgzODY3MV0sXG4gICAgWy0wLjUwMDAwMCwgMC45ODQ4MDgsIC0wLjc2NjA0NCwgLTAuNjQyNzg4LCAtMC4xNzM2NDgsIDAuODY2MDI1XSxcbiAgICBbLTAuNDUzOTkwLCAwLjk3ODE0OCwgLTAuNzc3MTQ2LCAtMC42MjkzMjAsIC0wLjIwNzkxMiwgMC44OTEwMDddLFxuICAgIFstMC40MDY3MzcsIDAuOTcwMjk2LCAtMC43ODgwMTEsIC0wLjYxNTY2MSwgLTAuMjQxOTIyLCAwLjkxMzU0NV0sXG4gICAgWy0wLjM1ODM2OCwgMC45NjEyNjIsIC0wLjc5ODYzNiwgLTAuNjAxODE1LCAtMC4yNzU2MzcsIDAuOTMzNTgwXSxcbiAgICBbLTAuMzA5MDE3LCAwLjk1MTA1NywgLTAuODA5MDE3LCAtMC41ODc3ODUsIC0wLjMwOTAxNywgMC45NTEwNTddLFxuICAgIFstMC4yNTg4MTksIDAuOTM5NjkzLCAtMC44MTkxNTIsIC0wLjU3MzU3NiwgLTAuMzQyMDIwLCAwLjk2NTkyNl0sXG4gICAgWy0wLjIwNzkxMiwgMC45MjcxODQsIC0wLjgyOTAzOCwgLTAuNTU5MTkzLCAtMC4zNzQ2MDcsIDAuOTc4MTQ4XSxcbiAgICBbLTAuMTU2NDM0LCAwLjkxMzU0NSwgLTAuODM4NjcxLCAtMC41NDQ2MzksIC0wLjQwNjczNywgMC45ODc2ODhdLFxuICAgIFstMC4xMDQ1MjgsIDAuODk4Nzk0LCAtMC44NDgwNDgsIC0wLjUyOTkxOSwgLTAuNDM4MzcxLCAwLjk5NDUyMl0sXG4gICAgWy0wLjA1MjMzNiwgMC44ODI5NDgsIC0wLjg1NzE2NywgLTAuNTE1MDM4LCAtMC40Njk0NzIsIDAuOTk4NjMwXSxcbiAgICBbLTAuMDAwMDAwLCAwLjg2NjAyNSwgLTAuODY2MDI1LCAtMC41MDAwMDAsIC0wLjUwMDAwMCwgMS4wMDAwMDBdLFxuICAgIFswLjA1MjMzNiwgMC44NDgwNDgsIC0wLjg3NDYyMCwgLTAuNDg0ODEwLCAtMC41Mjk5MTksIDAuOTk4NjMwXSxcbiAgICBbMC4xMDQ1MjgsIDAuODI5MDM4LCAtMC44ODI5NDgsIC0wLjQ2OTQ3MiwgLTAuNTU5MTkzLCAwLjk5NDUyMl0sXG4gICAgWzAuMTU2NDM0LCAwLjgwOTAxNywgLTAuODkxMDA3LCAtMC40NTM5OTAsIC0wLjU4Nzc4NSwgMC45ODc2ODhdLFxuICAgIFswLjIwNzkxMiwgMC43ODgwMTEsIC0wLjg5ODc5NCwgLTAuNDM4MzcxLCAtMC42MTU2NjEsIDAuOTc4MTQ4XSxcbiAgICBbMC4yNTg4MTksIDAuNzY2MDQ0LCAtMC45MDYzMDgsIC0wLjQyMjYxOCwgLTAuNjQyNzg4LCAwLjk2NTkyNl0sXG4gICAgWzAuMzA5MDE3LCAwLjc0MzE0NSwgLTAuOTEzNTQ1LCAtMC40MDY3MzcsIC0wLjY2OTEzMSwgMC45NTEwNTddLFxuICAgIFswLjM1ODM2OCwgMC43MTkzNDAsIC0wLjkyMDUwNSwgLTAuMzkwNzMxLCAtMC42OTQ2NTgsIDAuOTMzNTgwXSxcbiAgICBbMC40MDY3MzcsIDAuNjk0NjU4LCAtMC45MjcxODQsIC0wLjM3NDYwNywgLTAuNzE5MzQwLCAwLjkxMzU0NV0sXG4gICAgWzAuNDUzOTkwLCAwLjY2OTEzMSwgLTAuOTMzNTgwLCAtMC4zNTgzNjgsIC0wLjc0MzE0NSwgMC44OTEwMDddLFxuICAgIFswLjUwMDAwMCwgMC42NDI3ODgsIC0wLjkzOTY5MywgLTAuMzQyMDIwLCAtMC43NjYwNDQsIDAuODY2MDI1XSxcbiAgICBbMC41NDQ2MzksIDAuNjE1NjYxLCAtMC45NDU1MTksIC0wLjMyNTU2OCwgLTAuNzg4MDExLCAwLjgzODY3MV0sXG4gICAgWzAuNTg3Nzg1LCAwLjU4Nzc4NSwgLTAuOTUxMDU3LCAtMC4zMDkwMTcsIC0wLjgwOTAxNywgMC44MDkwMTddLFxuICAgIFswLjYyOTMyMCwgMC41NTkxOTMsIC0wLjk1NjMwNSwgLTAuMjkyMzcyLCAtMC44MjkwMzgsIDAuNzc3MTQ2XSxcbiAgICBbMC42NjkxMzEsIDAuNTI5OTE5LCAtMC45NjEyNjIsIC0wLjI3NTYzNywgLTAuODQ4MDQ4LCAwLjc0MzE0NV0sXG4gICAgWzAuNzA3MTA3LCAwLjUwMDAwMCwgLTAuOTY1OTI2LCAtMC4yNTg4MTksIC0wLjg2NjAyNSwgMC43MDcxMDddLFxuICAgIFswLjc0MzE0NSwgMC40Njk0NzIsIC0wLjk3MDI5NiwgLTAuMjQxOTIyLCAtMC44ODI5NDgsIDAuNjY5MTMxXSxcbiAgICBbMC43NzcxNDYsIDAuNDM4MzcxLCAtMC45NzQzNzAsIC0wLjIyNDk1MSwgLTAuODk4Nzk0LCAwLjYyOTMyMF0sXG4gICAgWzAuODA5MDE3LCAwLjQwNjczNywgLTAuOTc4MTQ4LCAtMC4yMDc5MTIsIC0wLjkxMzU0NSwgMC41ODc3ODVdLFxuICAgIFswLjgzODY3MSwgMC4zNzQ2MDcsIC0wLjk4MTYyNywgLTAuMTkwODA5LCAtMC45MjcxODQsIDAuNTQ0NjM5XSxcbiAgICBbMC44NjYwMjUsIDAuMzQyMDIwLCAtMC45ODQ4MDgsIC0wLjE3MzY0OCwgLTAuOTM5NjkzLCAwLjUwMDAwMF0sXG4gICAgWzAuODkxMDA3LCAwLjMwOTAxNywgLTAuOTg3Njg4LCAtMC4xNTY0MzQsIC0wLjk1MTA1NywgMC40NTM5OTBdLFxuICAgIFswLjkxMzU0NSwgMC4yNzU2MzcsIC0wLjk5MDI2OCwgLTAuMTM5MTczLCAtMC45NjEyNjIsIDAuNDA2NzM3XSxcbiAgICBbMC45MzM1ODAsIDAuMjQxOTIyLCAtMC45OTI1NDYsIC0wLjEyMTg2OSwgLTAuOTcwMjk2LCAwLjM1ODM2OF0sXG4gICAgWzAuOTUxMDU3LCAwLjIwNzkxMiwgLTAuOTk0NTIyLCAtMC4xMDQ1MjgsIC0wLjk3ODE0OCwgMC4zMDkwMTddLFxuICAgIFswLjk2NTkyNiwgMC4xNzM2NDgsIC0wLjk5NjE5NSwgLTAuMDg3MTU2LCAtMC45ODQ4MDgsIDAuMjU4ODE5XSxcbiAgICBbMC45NzgxNDgsIDAuMTM5MTczLCAtMC45OTc1NjQsIC0wLjA2OTc1NiwgLTAuOTkwMjY4LCAwLjIwNzkxMl0sXG4gICAgWzAuOTg3Njg4LCAwLjEwNDUyOCwgLTAuOTk4NjMwLCAtMC4wNTIzMzYsIC0wLjk5NDUyMiwgMC4xNTY0MzRdLFxuICAgIFswLjk5NDUyMiwgMC4wNjk3NTYsIC0wLjk5OTM5MSwgLTAuMDM0ODk5LCAtMC45OTc1NjQsIDAuMTA0NTI4XSxcbiAgICBbMC45OTg2MzAsIDAuMDM0ODk5LCAtMC45OTk4NDgsIC0wLjAxNzQ1MiwgLTAuOTk5MzkxLCAwLjA1MjMzNl0sXG4gICAgWzEuMDAwMDAwLCAwLjAwMDAwMCwgLTEuMDAwMDAwLCAtMC4wMDAwMDAsIC0xLjAwMDAwMCwgMC4wMDAwMDBdLFxuICAgIFswLjk5ODYzMCwgLTAuMDM0ODk5LCAtMC45OTk4NDgsIDAuMDE3NDUyLCAtMC45OTkzOTEsIC0wLjA1MjMzNl0sXG4gICAgWzAuOTk0NTIyLCAtMC4wNjk3NTYsIC0wLjk5OTM5MSwgMC4wMzQ4OTksIC0wLjk5NzU2NCwgLTAuMTA0NTI4XSxcbiAgICBbMC45ODc2ODgsIC0wLjEwNDUyOCwgLTAuOTk4NjMwLCAwLjA1MjMzNiwgLTAuOTk0NTIyLCAtMC4xNTY0MzRdLFxuICAgIFswLjk3ODE0OCwgLTAuMTM5MTczLCAtMC45OTc1NjQsIDAuMDY5NzU2LCAtMC45OTAyNjgsIC0wLjIwNzkxMl0sXG4gICAgWzAuOTY1OTI2LCAtMC4xNzM2NDgsIC0wLjk5NjE5NSwgMC4wODcxNTYsIC0wLjk4NDgwOCwgLTAuMjU4ODE5XSxcbiAgICBbMC45NTEwNTcsIC0wLjIwNzkxMiwgLTAuOTk0NTIyLCAwLjEwNDUyOCwgLTAuOTc4MTQ4LCAtMC4zMDkwMTddLFxuICAgIFswLjkzMzU4MCwgLTAuMjQxOTIyLCAtMC45OTI1NDYsIDAuMTIxODY5LCAtMC45NzAyOTYsIC0wLjM1ODM2OF0sXG4gICAgWzAuOTEzNTQ1LCAtMC4yNzU2MzcsIC0wLjk5MDI2OCwgMC4xMzkxNzMsIC0wLjk2MTI2MiwgLTAuNDA2NzM3XSxcbiAgICBbMC44OTEwMDcsIC0wLjMwOTAxNywgLTAuOTg3Njg4LCAwLjE1NjQzNCwgLTAuOTUxMDU3LCAtMC40NTM5OTBdLFxuICAgIFswLjg2NjAyNSwgLTAuMzQyMDIwLCAtMC45ODQ4MDgsIDAuMTczNjQ4LCAtMC45Mzk2OTMsIC0wLjUwMDAwMF0sXG4gICAgWzAuODM4NjcxLCAtMC4zNzQ2MDcsIC0wLjk4MTYyNywgMC4xOTA4MDksIC0wLjkyNzE4NCwgLTAuNTQ0NjM5XSxcbiAgICBbMC44MDkwMTcsIC0wLjQwNjczNywgLTAuOTc4MTQ4LCAwLjIwNzkxMiwgLTAuOTEzNTQ1LCAtMC41ODc3ODVdLFxuICAgIFswLjc3NzE0NiwgLTAuNDM4MzcxLCAtMC45NzQzNzAsIDAuMjI0OTUxLCAtMC44OTg3OTQsIC0wLjYyOTMyMF0sXG4gICAgWzAuNzQzMTQ1LCAtMC40Njk0NzIsIC0wLjk3MDI5NiwgMC4yNDE5MjIsIC0wLjg4Mjk0OCwgLTAuNjY5MTMxXSxcbiAgICBbMC43MDcxMDcsIC0wLjUwMDAwMCwgLTAuOTY1OTI2LCAwLjI1ODgxOSwgLTAuODY2MDI1LCAtMC43MDcxMDddLFxuICAgIFswLjY2OTEzMSwgLTAuNTI5OTE5LCAtMC45NjEyNjIsIDAuMjc1NjM3LCAtMC44NDgwNDgsIC0wLjc0MzE0NV0sXG4gICAgWzAuNjI5MzIwLCAtMC41NTkxOTMsIC0wLjk1NjMwNSwgMC4yOTIzNzIsIC0wLjgyOTAzOCwgLTAuNzc3MTQ2XSxcbiAgICBbMC41ODc3ODUsIC0wLjU4Nzc4NSwgLTAuOTUxMDU3LCAwLjMwOTAxNywgLTAuODA5MDE3LCAtMC44MDkwMTddLFxuICAgIFswLjU0NDYzOSwgLTAuNjE1NjYxLCAtMC45NDU1MTksIDAuMzI1NTY4LCAtMC43ODgwMTEsIC0wLjgzODY3MV0sXG4gICAgWzAuNTAwMDAwLCAtMC42NDI3ODgsIC0wLjkzOTY5MywgMC4zNDIwMjAsIC0wLjc2NjA0NCwgLTAuODY2MDI1XSxcbiAgICBbMC40NTM5OTAsIC0wLjY2OTEzMSwgLTAuOTMzNTgwLCAwLjM1ODM2OCwgLTAuNzQzMTQ1LCAtMC44OTEwMDddLFxuICAgIFswLjQwNjczNywgLTAuNjk0NjU4LCAtMC45MjcxODQsIDAuMzc0NjA3LCAtMC43MTkzNDAsIC0wLjkxMzU0NV0sXG4gICAgWzAuMzU4MzY4LCAtMC43MTkzNDAsIC0wLjkyMDUwNSwgMC4zOTA3MzEsIC0wLjY5NDY1OCwgLTAuOTMzNTgwXSxcbiAgICBbMC4zMDkwMTcsIC0wLjc0MzE0NSwgLTAuOTEzNTQ1LCAwLjQwNjczNywgLTAuNjY5MTMxLCAtMC45NTEwNTddLFxuICAgIFswLjI1ODgxOSwgLTAuNzY2MDQ0LCAtMC45MDYzMDgsIDAuNDIyNjE4LCAtMC42NDI3ODgsIC0wLjk2NTkyNl0sXG4gICAgWzAuMjA3OTEyLCAtMC43ODgwMTEsIC0wLjg5ODc5NCwgMC40MzgzNzEsIC0wLjYxNTY2MSwgLTAuOTc4MTQ4XSxcbiAgICBbMC4xNTY0MzQsIC0wLjgwOTAxNywgLTAuODkxMDA3LCAwLjQ1Mzk5MCwgLTAuNTg3Nzg1LCAtMC45ODc2ODhdLFxuICAgIFswLjEwNDUyOCwgLTAuODI5MDM4LCAtMC44ODI5NDgsIDAuNDY5NDcyLCAtMC41NTkxOTMsIC0wLjk5NDUyMl0sXG4gICAgWzAuMDUyMzM2LCAtMC44NDgwNDgsIC0wLjg3NDYyMCwgMC40ODQ4MTAsIC0wLjUyOTkxOSwgLTAuOTk4NjMwXSxcbiAgICBbMC4wMDAwMDAsIC0wLjg2NjAyNSwgLTAuODY2MDI1LCAwLjUwMDAwMCwgLTAuNTAwMDAwLCAtMS4wMDAwMDBdLFxuICAgIFstMC4wNTIzMzYsIC0wLjg4Mjk0OCwgLTAuODU3MTY3LCAwLjUxNTAzOCwgLTAuNDY5NDcyLCAtMC45OTg2MzBdLFxuICAgIFstMC4xMDQ1MjgsIC0wLjg5ODc5NCwgLTAuODQ4MDQ4LCAwLjUyOTkxOSwgLTAuNDM4MzcxLCAtMC45OTQ1MjJdLFxuICAgIFstMC4xNTY0MzQsIC0wLjkxMzU0NSwgLTAuODM4NjcxLCAwLjU0NDYzOSwgLTAuNDA2NzM3LCAtMC45ODc2ODhdLFxuICAgIFstMC4yMDc5MTIsIC0wLjkyNzE4NCwgLTAuODI5MDM4LCAwLjU1OTE5MywgLTAuMzc0NjA3LCAtMC45NzgxNDhdLFxuICAgIFstMC4yNTg4MTksIC0wLjkzOTY5MywgLTAuODE5MTUyLCAwLjU3MzU3NiwgLTAuMzQyMDIwLCAtMC45NjU5MjZdLFxuICAgIFstMC4zMDkwMTcsIC0wLjk1MTA1NywgLTAuODA5MDE3LCAwLjU4Nzc4NSwgLTAuMzA5MDE3LCAtMC45NTEwNTddLFxuICAgIFstMC4zNTgzNjgsIC0wLjk2MTI2MiwgLTAuNzk4NjM2LCAwLjYwMTgxNSwgLTAuMjc1NjM3LCAtMC45MzM1ODBdLFxuICAgIFstMC40MDY3MzcsIC0wLjk3MDI5NiwgLTAuNzg4MDExLCAwLjYxNTY2MSwgLTAuMjQxOTIyLCAtMC45MTM1NDVdLFxuICAgIFstMC40NTM5OTAsIC0wLjk3ODE0OCwgLTAuNzc3MTQ2LCAwLjYyOTMyMCwgLTAuMjA3OTEyLCAtMC44OTEwMDddLFxuICAgIFstMC41MDAwMDAsIC0wLjk4NDgwOCwgLTAuNzY2MDQ0LCAwLjY0Mjc4OCwgLTAuMTczNjQ4LCAtMC44NjYwMjVdLFxuICAgIFstMC41NDQ2MzksIC0wLjk5MDI2OCwgLTAuNzU0NzEwLCAwLjY1NjA1OSwgLTAuMTM5MTczLCAtMC44Mzg2NzFdLFxuICAgIFstMC41ODc3ODUsIC0wLjk5NDUyMiwgLTAuNzQzMTQ1LCAwLjY2OTEzMSwgLTAuMTA0NTI4LCAtMC44MDkwMTddLFxuICAgIFstMC42MjkzMjAsIC0wLjk5NzU2NCwgLTAuNzMxMzU0LCAwLjY4MTk5OCwgLTAuMDY5NzU2LCAtMC43NzcxNDZdLFxuICAgIFstMC42NjkxMzEsIC0wLjk5OTM5MSwgLTAuNzE5MzQwLCAwLjY5NDY1OCwgLTAuMDM0ODk5LCAtMC43NDMxNDVdLFxuICAgIFstMC43MDcxMDcsIC0xLjAwMDAwMCwgLTAuNzA3MTA3LCAwLjcwNzEwNywgLTAuMDAwMDAwLCAtMC43MDcxMDddLFxuICAgIFstMC43NDMxNDUsIC0wLjk5OTM5MSwgLTAuNjk0NjU4LCAwLjcxOTM0MCwgMC4wMzQ4OTksIC0wLjY2OTEzMV0sXG4gICAgWy0wLjc3NzE0NiwgLTAuOTk3NTY0LCAtMC42ODE5OTgsIDAuNzMxMzU0LCAwLjA2OTc1NiwgLTAuNjI5MzIwXSxcbiAgICBbLTAuODA5MDE3LCAtMC45OTQ1MjIsIC0wLjY2OTEzMSwgMC43NDMxNDUsIDAuMTA0NTI4LCAtMC41ODc3ODVdLFxuICAgIFstMC44Mzg2NzEsIC0wLjk5MDI2OCwgLTAuNjU2MDU5LCAwLjc1NDcxMCwgMC4xMzkxNzMsIC0wLjU0NDYzOV0sXG4gICAgWy0wLjg2NjAyNSwgLTAuOTg0ODA4LCAtMC42NDI3ODgsIDAuNzY2MDQ0LCAwLjE3MzY0OCwgLTAuNTAwMDAwXSxcbiAgICBbLTAuODkxMDA3LCAtMC45NzgxNDgsIC0wLjYyOTMyMCwgMC43NzcxNDYsIDAuMjA3OTEyLCAtMC40NTM5OTBdLFxuICAgIFstMC45MTM1NDUsIC0wLjk3MDI5NiwgLTAuNjE1NjYxLCAwLjc4ODAxMSwgMC4yNDE5MjIsIC0wLjQwNjczN10sXG4gICAgWy0wLjkzMzU4MCwgLTAuOTYxMjYyLCAtMC42MDE4MTUsIDAuNzk4NjM2LCAwLjI3NTYzNywgLTAuMzU4MzY4XSxcbiAgICBbLTAuOTUxMDU3LCAtMC45NTEwNTcsIC0wLjU4Nzc4NSwgMC44MDkwMTcsIDAuMzA5MDE3LCAtMC4zMDkwMTddLFxuICAgIFstMC45NjU5MjYsIC0wLjkzOTY5MywgLTAuNTczNTc2LCAwLjgxOTE1MiwgMC4zNDIwMjAsIC0wLjI1ODgxOV0sXG4gICAgWy0wLjk3ODE0OCwgLTAuOTI3MTg0LCAtMC41NTkxOTMsIDAuODI5MDM4LCAwLjM3NDYwNywgLTAuMjA3OTEyXSxcbiAgICBbLTAuOTg3Njg4LCAtMC45MTM1NDUsIC0wLjU0NDYzOSwgMC44Mzg2NzEsIDAuNDA2NzM3LCAtMC4xNTY0MzRdLFxuICAgIFstMC45OTQ1MjIsIC0wLjg5ODc5NCwgLTAuNTI5OTE5LCAwLjg0ODA0OCwgMC40MzgzNzEsIC0wLjEwNDUyOF0sXG4gICAgWy0wLjk5ODYzMCwgLTAuODgyOTQ4LCAtMC41MTUwMzgsIDAuODU3MTY3LCAwLjQ2OTQ3MiwgLTAuMDUyMzM2XSxcbiAgICBbLTEuMDAwMDAwLCAtMC44NjYwMjUsIC0wLjUwMDAwMCwgMC44NjYwMjUsIDAuNTAwMDAwLCAtMC4wMDAwMDBdLFxuICAgIFstMC45OTg2MzAsIC0wLjg0ODA0OCwgLTAuNDg0ODEwLCAwLjg3NDYyMCwgMC41Mjk5MTksIDAuMDUyMzM2XSxcbiAgICBbLTAuOTk0NTIyLCAtMC44MjkwMzgsIC0wLjQ2OTQ3MiwgMC44ODI5NDgsIDAuNTU5MTkzLCAwLjEwNDUyOF0sXG4gICAgWy0wLjk4NzY4OCwgLTAuODA5MDE3LCAtMC40NTM5OTAsIDAuODkxMDA3LCAwLjU4Nzc4NSwgMC4xNTY0MzRdLFxuICAgIFstMC45NzgxNDgsIC0wLjc4ODAxMSwgLTAuNDM4MzcxLCAwLjg5ODc5NCwgMC42MTU2NjEsIDAuMjA3OTEyXSxcbiAgICBbLTAuOTY1OTI2LCAtMC43NjYwNDQsIC0wLjQyMjYxOCwgMC45MDYzMDgsIDAuNjQyNzg4LCAwLjI1ODgxOV0sXG4gICAgWy0wLjk1MTA1NywgLTAuNzQzMTQ1LCAtMC40MDY3MzcsIDAuOTEzNTQ1LCAwLjY2OTEzMSwgMC4zMDkwMTddLFxuICAgIFstMC45MzM1ODAsIC0wLjcxOTM0MCwgLTAuMzkwNzMxLCAwLjkyMDUwNSwgMC42OTQ2NTgsIDAuMzU4MzY4XSxcbiAgICBbLTAuOTEzNTQ1LCAtMC42OTQ2NTgsIC0wLjM3NDYwNywgMC45MjcxODQsIDAuNzE5MzQwLCAwLjQwNjczN10sXG4gICAgWy0wLjg5MTAwNywgLTAuNjY5MTMxLCAtMC4zNTgzNjgsIDAuOTMzNTgwLCAwLjc0MzE0NSwgMC40NTM5OTBdLFxuICAgIFstMC44NjYwMjUsIC0wLjY0Mjc4OCwgLTAuMzQyMDIwLCAwLjkzOTY5MywgMC43NjYwNDQsIDAuNTAwMDAwXSxcbiAgICBbLTAuODM4NjcxLCAtMC42MTU2NjEsIC0wLjMyNTU2OCwgMC45NDU1MTksIDAuNzg4MDExLCAwLjU0NDYzOV0sXG4gICAgWy0wLjgwOTAxNywgLTAuNTg3Nzg1LCAtMC4zMDkwMTcsIDAuOTUxMDU3LCAwLjgwOTAxNywgMC41ODc3ODVdLFxuICAgIFstMC43NzcxNDYsIC0wLjU1OTE5MywgLTAuMjkyMzcyLCAwLjk1NjMwNSwgMC44MjkwMzgsIDAuNjI5MzIwXSxcbiAgICBbLTAuNzQzMTQ1LCAtMC41Mjk5MTksIC0wLjI3NTYzNywgMC45NjEyNjIsIDAuODQ4MDQ4LCAwLjY2OTEzMV0sXG4gICAgWy0wLjcwNzEwNywgLTAuNTAwMDAwLCAtMC4yNTg4MTksIDAuOTY1OTI2LCAwLjg2NjAyNSwgMC43MDcxMDddLFxuICAgIFstMC42NjkxMzEsIC0wLjQ2OTQ3MiwgLTAuMjQxOTIyLCAwLjk3MDI5NiwgMC44ODI5NDgsIDAuNzQzMTQ1XSxcbiAgICBbLTAuNjI5MzIwLCAtMC40MzgzNzEsIC0wLjIyNDk1MSwgMC45NzQzNzAsIDAuODk4Nzk0LCAwLjc3NzE0Nl0sXG4gICAgWy0wLjU4Nzc4NSwgLTAuNDA2NzM3LCAtMC4yMDc5MTIsIDAuOTc4MTQ4LCAwLjkxMzU0NSwgMC44MDkwMTddLFxuICAgIFstMC41NDQ2MzksIC0wLjM3NDYwNywgLTAuMTkwODA5LCAwLjk4MTYyNywgMC45MjcxODQsIDAuODM4NjcxXSxcbiAgICBbLTAuNTAwMDAwLCAtMC4zNDIwMjAsIC0wLjE3MzY0OCwgMC45ODQ4MDgsIDAuOTM5NjkzLCAwLjg2NjAyNV0sXG4gICAgWy0wLjQ1Mzk5MCwgLTAuMzA5MDE3LCAtMC4xNTY0MzQsIDAuOTg3Njg4LCAwLjk1MTA1NywgMC44OTEwMDddLFxuICAgIFstMC40MDY3MzcsIC0wLjI3NTYzNywgLTAuMTM5MTczLCAwLjk5MDI2OCwgMC45NjEyNjIsIDAuOTEzNTQ1XSxcbiAgICBbLTAuMzU4MzY4LCAtMC4yNDE5MjIsIC0wLjEyMTg2OSwgMC45OTI1NDYsIDAuOTcwMjk2LCAwLjkzMzU4MF0sXG4gICAgWy0wLjMwOTAxNywgLTAuMjA3OTEyLCAtMC4xMDQ1MjgsIDAuOTk0NTIyLCAwLjk3ODE0OCwgMC45NTEwNTddLFxuICAgIFstMC4yNTg4MTksIC0wLjE3MzY0OCwgLTAuMDg3MTU2LCAwLjk5NjE5NSwgMC45ODQ4MDgsIDAuOTY1OTI2XSxcbiAgICBbLTAuMjA3OTEyLCAtMC4xMzkxNzMsIC0wLjA2OTc1NiwgMC45OTc1NjQsIDAuOTkwMjY4LCAwLjk3ODE0OF0sXG4gICAgWy0wLjE1NjQzNCwgLTAuMTA0NTI4LCAtMC4wNTIzMzYsIDAuOTk4NjMwLCAwLjk5NDUyMiwgMC45ODc2ODhdLFxuICAgIFstMC4xMDQ1MjgsIC0wLjA2OTc1NiwgLTAuMDM0ODk5LCAwLjk5OTM5MSwgMC45OTc1NjQsIDAuOTk0NTIyXSxcbiAgICBbLTAuMDUyMzM2LCAtMC4wMzQ4OTksIC0wLjAxNzQ1MiwgMC45OTk4NDgsIDAuOTk5MzkxLCAwLjk5ODYzMF0sXG4gIF0sXG4gIFtcbiAgICBbLTEuMDAwMDAwLCAtMC4wMDAwMDAsIDEuMDAwMDAwLCAtMC4wMDAwMDAsIDAuMDAwMDAwLFxuICAgICAtMS4wMDAwMDAsIC0wLjAwMDAwMCwgMC4wMDAwMDAsIC0wLjAwMDAwMF0sXG4gICAgWy0wLjk5OTg0OCwgMC4wMTc0NTIsIDAuOTk5NTQzLCAtMC4wMzAyMjQsIDAuMDAwMjY0LFxuICAgICAtMC45OTkwODYsIDAuMDQyNzMzLCAtMC4wMDA1OTAsIDAuMDAwMDA0XSxcbiAgICBbLTAuOTk5MzkxLCAwLjAzNDg5OSwgMC45OTgxNzMsIC0wLjA2MDQxMSwgMC4wMDEwNTUsXG4gICAgIC0wLjk5NjM0OCwgMC4wODUzNTYsIC0wLjAwMjM1NywgMC4wMDAwMzRdLFxuICAgIFstMC45OTg2MzAsIDAuMDUyMzM2LCAwLjk5NTg5MSwgLTAuMDkwNTI0LCAwLjAwMjM3MixcbiAgICAgLTAuOTkxNzkxLCAwLjEyNzc1NywgLTAuMDA1Mjk3LCAwLjAwMDExM10sXG4gICAgWy0wLjk5NzU2NCwgMC4wNjk3NTYsIDAuOTkyNzAxLCAtMC4xMjA1MjcsIDAuMDA0MjE0LFxuICAgICAtMC45ODU0MjksIDAuMTY5ODI4LCAtMC4wMDk0MDAsIDAuMDAwMjY4XSxcbiAgICBbLTAuOTk2MTk1LCAwLjA4NzE1NiwgMC45ODg2MDYsIC0wLjE1MDM4NCwgMC4wMDY1NzgsXG4gICAgIC0wLjk3NzI3NywgMC4yMTE0NjAsIC0wLjAxNDY1NCwgMC4wMDA1MjNdLFxuICAgIFstMC45OTQ1MjIsIDAuMTA0NTI4LCAwLjk4MzYxMSwgLTAuMTgwMDU3LCAwLjAwOTQ2MixcbiAgICAgLTAuOTY3MzU2LCAwLjI1MjU0NCwgLTAuMDIxMDQzLCAwLjAwMDkwM10sXG4gICAgWy0wLjk5MjU0NiwgMC4xMjE4NjksIDAuOTc3NzIyLCAtMC4yMDk1MTEsIDAuMDEyODYyLFxuICAgICAtMC45NTU2OTMsIDAuMjkyOTc2LCAtMC4wMjg1NDcsIDAuMDAxNDMxXSxcbiAgICBbLTAuOTkwMjY4LCAwLjEzOTE3MywgMC45NzA5NDYsIC0wLjIzODcwOSwgMC4wMTY3NzQsXG4gICAgIC0wLjk0MjMxNiwgMC4zMzI2NDksIC0wLjAzNzE0MywgMC4wMDIxMzFdLFxuICAgIFstMC45ODc2ODgsIDAuMTU2NDM0LCAwLjk2MzI5MiwgLTAuMjY3NjE3LCAwLjAyMTE5MyxcbiAgICAgLTAuOTI3MjYyLCAwLjM3MTQ2MywgLTAuMDQ2ODA2LCAwLjAwMzAyNl0sXG4gICAgWy0wLjk4NDgwOCwgMC4xNzM2NDgsIDAuOTU0NzY5LCAtMC4yOTYxOTgsIDAuMDI2MTE0LFxuICAgICAtMC45MTA1NjksIDAuNDA5MzE3LCAtMC4wNTc1MDUsIDAuMDA0MTQwXSxcbiAgICBbLTAuOTgxNjI3LCAwLjE5MDgwOSwgMC45NDUzODgsIC0wLjMyNDQxOSwgMC4wMzE1MzAsXG4gICAgIC0wLjg5MjI3OSwgMC40NDYxMTQsIC0wLjA2OTIwOSwgMC4wMDU0OTJdLFxuICAgIFstMC45NzgxNDgsIDAuMjA3OTEyLCAwLjkzNTE1OSwgLTAuMzUyMjQ0LCAwLjAzNzQzNixcbiAgICAgLTAuODcyNDQxLCAwLjQ4MTc1OSwgLTAuMDgxODgwLCAwLjAwNzEwNV0sXG4gICAgWy0wLjk3NDM3MCwgMC4yMjQ5NTEsIDAuOTI0MDk2LCAtMC4zNzk2NDEsIDAuMDQzODIzLFxuICAgICAtMC44NTExMDUsIDAuNTE2MTYyLCAtMC4wOTU0ODEsIDAuMDA4OTk5XSxcbiAgICBbLTAuOTcwMjk2LCAwLjI0MTkyMiwgMC45MTIyMTEsIC0wLjQwNjU3NCwgMC4wNTA2ODUsXG4gICAgIC0wLjgyODMyNiwgMC41NDkyMzMsIC0wLjEwOTk2OSwgMC4wMTExOTNdLFxuICAgIFstMC45NjU5MjYsIDAuMjU4ODE5LCAwLjg5OTUxOSwgLTAuNDMzMDEzLCAwLjA1ODAxMyxcbiAgICAgLTAuODA0MTY0LCAwLjU4MDg4OSwgLTAuMTI1MzAwLCAwLjAxMzcwN10sXG4gICAgWy0wLjk2MTI2MiwgMC4yNzU2MzcsIDAuODg2MDM2LCAtMC40NTg5MjQsIDAuMDY1Nzk3LFxuICAgICAtMC43Nzg2ODAsIDAuNjExMDUwLCAtMC4xNDE0MjcsIDAuMDE2NTU2XSxcbiAgICBbLTAuOTU2MzA1LCAwLjI5MjM3MiwgMC44NzE3NzgsIC0wLjQ4NDI3NSwgMC4wNzQwMjksXG4gICAgIC0wLjc1MTk0MCwgMC42Mzk2MzksIC0wLjE1ODMwMSwgMC4wMTk3NThdLFxuICAgIFstMC45NTEwNTcsIDAuMzA5MDE3LCAwLjg1Njc2MywgLTAuNTA5MDM3LCAwLjA4MjY5OCxcbiAgICAgLTAuNzI0MDEyLCAwLjY2NjU4MywgLTAuMTc1ODY4LCAwLjAyMzMyOV0sXG4gICAgWy0wLjk0NTUxOSwgMC4zMjU1NjgsIDAuODQxMDA4LCAtMC41MzMxNzgsIDAuMDkxNzk0LFxuICAgICAtMC42OTQ5NjksIDAuNjkxODE2LCAtMC4xOTQwNzUsIDAuMDI3MjgxXSxcbiAgICBbLTAuOTM5NjkzLCAwLjM0MjAyMCwgMC44MjQ1MzMsIC0wLjU1NjY3MCwgMC4xMDEzMDYsXG4gICAgIC0wLjY2NDg4NSwgMC43MTUyNzQsIC0wLjIxMjg2NSwgMC4wMzE2MzBdLFxuICAgIFstMC45MzM1ODAsIDAuMzU4MzY4LCAwLjgwNzM1OSwgLTAuNTc5NDg0LCAwLjExMTIyMixcbiAgICAgLTAuNjMzODM3LCAwLjczNjg5OCwgLTAuMjMyMTgwLCAwLjAzNjM4NV0sXG4gICAgWy0wLjkyNzE4NCwgMC4zNzQ2MDcsIDAuNzg5NTA1LCAtMC42MDE1OTIsIDAuMTIxNTI5LFxuICAgICAtMC42MDE5MDQsIDAuNzU2NjM3LCAtMC4yNTE5NjAsIDAuMDQxNTU5XSxcbiAgICBbLTAuOTIwNTA1LCAwLjM5MDczMSwgMC43NzA5OTQsIC0wLjYyMjk2NywgMC4xMzIyMTcsXG4gICAgIC0wLjU2OTE2OSwgMC43NzQ0NDIsIC0wLjI3MjE0MywgMC4wNDcxNjBdLFxuICAgIFstMC45MTM1NDUsIDAuNDA2NzM3LCAwLjc1MTg0OCwgLTAuNjQzNTgyLCAwLjE0MzI3MSxcbiAgICAgLTAuNTM1NzE1LCAwLjc5MDI3MCwgLTAuMjkyNjY2LCAwLjA1MzE5Nl0sXG4gICAgWy0wLjkwNjMwOCwgMC40MjI2MTgsIDAuNzMyMDkxLCAtMC42NjM0MTQsIDAuMTU0Njc4LFxuICAgICAtMC41MDE2MjcsIDAuODA0MDgzLCAtMC4zMTM0NjQsIDAuMDU5Njc0XSxcbiAgICBbLTAuODk4Nzk0LCAwLjQzODM3MSwgMC43MTE3NDYsIC0wLjY4MjQzNywgMC4xNjY0MjMsXG4gICAgIC0wLjQ2Njk5MywgMC44MTU4NTAsIC0wLjMzNDQ3MiwgMC4wNjY1OTldLFxuICAgIFstMC44OTEwMDcsIDAuNDUzOTkwLCAwLjY5MDgzOSwgLTAuNzAwNjI5LCAwLjE3ODQ5NCxcbiAgICAgLTAuNDMxODk5LCAwLjgyNTU0NCwgLTAuMzU1NjIzLCAwLjA3Mzk3NF0sXG4gICAgWy0wLjg4Mjk0OCwgMC40Njk0NzIsIDAuNjY5Mzk1LCAtMC43MTc5NjgsIDAuMTkwODc1LFxuICAgICAtMC4zOTY0MzYsIDAuODMzMTQ1LCAtMC4zNzY4NTEsIDAuMDgxODAzXSxcbiAgICBbLTAuODc0NjIwLCAwLjQ4NDgxMCwgMC42NDc0MzksIC0wLjczNDQzMSwgMC4yMDM1NTEsXG4gICAgIC0wLjM2MDY5MiwgMC44Mzg2MzgsIC0wLjM5ODA4NiwgMC4wOTAwODVdLFxuICAgIFstMC44NjYwMjUsIDAuNTAwMDAwLCAwLjYyNTAwMCwgLTAuNzUwMDAwLCAwLjIxNjUwNixcbiAgICAgLTAuMzI0NzYwLCAwLjg0MjAxMiwgLTAuNDE5MjYzLCAwLjA5ODgyMV0sXG4gICAgWy0wLjg1NzE2NywgMC41MTUwMzgsIDAuNjAyMTA0LCAtMC43NjQ2NTUsIDAuMjI5NzI2LFxuICAgICAtMC4yODg3MjgsIDAuODQzMjY1LCAtMC40NDAzMTEsIDAuMTA4MDA5XSxcbiAgICBbLTAuODQ4MDQ4LCAwLjUyOTkxOSwgMC41Nzg3NzgsIC0wLjc3ODM3OCwgMC4yNDMxOTIsXG4gICAgIC0wLjI1MjY4OCwgMC44NDIzOTksIC0wLjQ2MTE2NCwgMC4xMTc2NDRdLFxuICAgIFstMC44Mzg2NzEsIDAuNTQ0NjM5LCAwLjU1NTA1MiwgLTAuNzkxMTU0LCAwLjI1Njg5MSxcbiAgICAgLTAuMjE2NzMwLCAwLjgzOTQyMiwgLTAuNDgxNzUzLCAwLjEyNzcyMl0sXG4gICAgWy0wLjgyOTAzOCwgMC41NTkxOTMsIDAuNTMwOTU1LCAtMC44MDI5NjUsIDAuMjcwODAzLFxuICAgICAtMC4xODA5NDQsIDAuODM0MzQ3LCAtMC41MDIwMTEsIDAuMTM4MjM3XSxcbiAgICBbLTAuODE5MTUyLCAwLjU3MzU3NiwgMC41MDY1MTUsIC0wLjgxMzc5OCwgMC4yODQ5MTQsXG4gICAgIC0wLjE0NTQyMCwgMC44MjcxOTQsIC0wLjUyMTg3MSwgMC4xNDkxODFdLFxuICAgIFstMC44MDkwMTcsIDAuNTg3Nzg1LCAwLjQ4MTc2MywgLTAuODIzNjM5LCAwLjI5OTIwNCxcbiAgICAgLTAuMTEwMjQ2LCAwLjgxNzk4NywgLTAuNTQxMjY2LCAwLjE2MDU0NV0sXG4gICAgWy0wLjc5ODYzNiwgMC42MDE4MTUsIDAuNDU2NzI4LCAtMC44MzI0NzcsIDAuMzEzNjU4LFxuICAgICAtMC4wNzU1MDgsIDAuODA2NzU3LCAtMC41NjAxMzIsIDAuMTcyMzE3XSxcbiAgICBbLTAuNzg4MDExLCAwLjYxNTY2MSwgMC40MzE0NDEsIC0wLjg0MDMwMSwgMC4zMjgyNTcsXG4gICAgIC0wLjA0MTI5NCwgMC43OTM1NDEsIC0wLjU3ODQwNSwgMC4xODQ0ODddLFxuICAgIFstMC43NzcxNDYsIDAuNjI5MzIwLCAwLjQwNTkzNCwgLTAuODQ3MTAxLCAwLjM0Mjk4NCxcbiAgICAgLTAuMDA3Njg2LCAwLjc3ODM3OSwgLTAuNTk2MDIxLCAwLjE5NzA0MF0sXG4gICAgWy0wLjc2NjA0NCwgMC42NDI3ODgsIDAuMzgwMjM2LCAtMC44NTI4NjksIDAuMzU3ODIxLFxuICAgICAwLjAyNTIzMywgMC43NjEzMTksIC0wLjYxMjkyMSwgMC4yMDk5NjNdLFxuICAgIFstMC43NTQ3MTAsIDAuNjU2MDU5LCAwLjM1NDM4MCwgLTAuODU3NTk3LCAwLjM3Mjc0OSxcbiAgICAgMC4wNTczODMsIDAuNzQyNDEyLCAtMC42MjkwNDQsIDAuMjIzMjM4XSxcbiAgICBbLTAuNzQzMTQ1LCAwLjY2OTEzMSwgMC4zMjgzOTYsIC0wLjg2MTI4MSwgMC4zODc3NTEsXG4gICAgIDAuMDg4Njg2LCAwLjcyMTcxNCwgLTAuNjQ0MzM0LCAwLjIzNjg1MF0sXG4gICAgWy0wLjczMTM1NCwgMC42ODE5OTgsIDAuMzAyMzE3LCAtMC44NjM5MTYsIDAuNDAyODA3LFxuICAgICAwLjExOTA2OCwgMC42OTkyODgsIC0wLjY1ODczNCwgMC4yNTA3NzhdLFxuICAgIFstMC43MTkzNDAsIDAuNjk0NjU4LCAwLjI3NjE3NSwgLTAuODY1NDk4LCAwLjQxNzkwMSxcbiAgICAgMC4xNDg0NTQsIDAuNjc1MTk5LCAtMC42NzIxOTAsIDAuMjY1MDA1XSxcbiAgICBbLTAuNzA3MTA3LCAwLjcwNzEwNywgMC4yNTAwMDAsIC0wLjg2NjAyNSwgMC40MzMwMTMsXG4gICAgIDAuMTc2Nzc3LCAwLjY0OTUxOSwgLTAuNjg0NjUzLCAwLjI3OTUwOF0sXG4gICAgWy0wLjY5NDY1OCwgMC43MTkzNDAsIDAuMjIzODI1LCAtMC44NjU0OTgsIDAuNDQ4MTI1LFxuICAgICAwLjIwMzk2OSwgMC42MjIzMjIsIC0wLjY5NjA3MywgMC4yOTQyNjddLFxuICAgIFstMC42ODE5OTgsIDAuNzMxMzU0LCAwLjE5NzY4MywgLTAuODYzOTE2LCAwLjQ2MzIxOCxcbiAgICAgMC4yMjk5NjcsIDAuNTkzNjg4LCAtMC43MDY0MDUsIDAuMzA5MjU5XSxcbiAgICBbLTAuNjY5MTMxLCAwLjc0MzE0NSwgMC4xNzE2MDQsIC0wLjg2MTI4MSwgMC40NzgyNzUsXG4gICAgIDAuMjU0NzEyLCAwLjU2MzcwMCwgLTAuNzE1NjA1LCAwLjMyNDQ1OV0sXG4gICAgWy0wLjY1NjA1OSwgMC43NTQ3MTAsIDAuMTQ1NjIwLCAtMC44NTc1OTcsIDAuNDkzMjc2LFxuICAgICAwLjI3ODE0NywgMC41MzI0NDMsIC0wLjcyMzYzMywgMC4zMzk4NDRdLFxuICAgIFstMC42NDI3ODgsIDAuNzY2MDQ0LCAwLjExOTc2NCwgLTAuODUyODY5LCAwLjUwODIwNSxcbiAgICAgMC4zMDAyMjEsIDAuNTAwMDA5LCAtMC43MzA0NTEsIDAuMzU1Mzg3XSxcbiAgICBbLTAuNjI5MzIwLCAwLjc3NzE0NiwgMC4wOTQwNjYsIC0wLjg0NzEwMSwgMC41MjMwNDEsXG4gICAgIDAuMzIwODg0LCAwLjQ2NjQ5MCwgLTAuNzM2MDI1LCAwLjM3MTA2M10sXG4gICAgWy0wLjYxNTY2MSwgMC43ODgwMTEsIDAuMDY4NTU5LCAtMC44NDAzMDEsIDAuNTM3NzY4LFxuICAgICAwLjM0MDA5MywgMC40MzE5ODIsIC0wLjc0MDMyNCwgMC4zODY4NDVdLFxuICAgIFstMC42MDE4MTUsIDAuNzk4NjM2LCAwLjA0MzI3MiwgLTAuODMyNDc3LCAwLjU1MjM2NyxcbiAgICAgMC4zNTc4MDcsIDAuMzk2NTg0LCAtMC43NDMzMjAsIDAuNDAyNzA0XSxcbiAgICBbLTAuNTg3Nzg1LCAwLjgwOTAxNywgMC4wMTgyMzcsIC0wLjgyMzYzOSwgMC41NjY4MjEsXG4gICAgIDAuMzczOTkxLCAwLjM2MDM5NywgLTAuNzQ0OTg5LCAwLjQxODYxM10sXG4gICAgWy0wLjU3MzU3NiwgMC44MTkxNTIsIC0wLjAwNjUxNSwgLTAuODEzNzk4LCAwLjU4MTExMixcbiAgICAgMC4zODg2MTIsIDAuMzIzNTI0LCAtMC43NDUzMDgsIDAuNDM0NTQ0XSxcbiAgICBbLTAuNTU5MTkzLCAwLjgyOTAzOCwgLTAuMDMwOTU1LCAtMC44MDI5NjUsIDAuNTk1MjIyLFxuICAgICAwLjQwMTY0NSwgMC4yODYwNjksIC0wLjc0NDI2MiwgMC40NTA0NjddLFxuICAgIFstMC41NDQ2MzksIDAuODM4NjcxLCAtMC4wNTUwNTIsIC0wLjc5MTE1NCwgMC42MDkxMzUsXG4gICAgIDAuNDEzMDY2LCAwLjI0ODE0MCwgLTAuNzQxODM1LCAwLjQ2NjM1Ml0sXG4gICAgWy0wLjUyOTkxOSwgMC44NDgwNDgsIC0wLjA3ODc3OCwgLTAuNzc4Mzc4LCAwLjYyMjgzMyxcbiAgICAgMC40MjI4NTYsIDAuMjA5ODQzLCAtMC43MzgwMTcsIDAuNDgyMTcxXSxcbiAgICBbLTAuNTE1MDM4LCAwLjg1NzE2NywgLTAuMTAyMTA0LCAtMC43NjQ2NTUsIDAuNjM2MzAwLFxuICAgICAwLjQzMTAwNCwgMC4xNzEyODgsIC0wLjczMjgwMSwgMC40OTc4OTRdLFxuICAgIFstMC41MDAwMDAsIDAuODY2MDI1LCAtMC4xMjUwMDAsIC0wLjc1MDAwMCwgMC42NDk1MTksXG4gICAgIDAuNDM3NTAwLCAwLjEzMjU4MywgLTAuNzI2MTg0LCAwLjUxMzQ5MF0sXG4gICAgWy0wLjQ4NDgxMCwgMC44NzQ2MjAsIC0wLjE0NzQzOSwgLTAuNzM0NDMxLCAwLjY2MjQ3NCxcbiAgICAgMC40NDIzNDAsIDAuMDkzODM3LCAtMC43MTgxNjcsIDAuNTI4OTI5XSxcbiAgICBbLTAuNDY5NDcyLCAwLjg4Mjk0OCwgLTAuMTY5Mzk1LCAtMC43MTc5NjgsIDAuNjc1MTUwLFxuICAgICAwLjQ0NTUyNCwgMC4wNTUxNjAsIC0wLjcwODc1MywgMC41NDQxODNdLFxuICAgIFstMC40NTM5OTAsIDAuODkxMDA3LCAtMC4xOTA4MzksIC0wLjcwMDYyOSwgMC42ODc1MzEsXG4gICAgIDAuNDQ3MDU5LCAwLjAxNjY2MiwgLTAuNjk3OTUwLCAwLjU1OTIyMF0sXG4gICAgWy0wLjQzODM3MSwgMC44OTg3OTQsIC0wLjIxMTc0NiwgLTAuNjgyNDM3LCAwLjY5OTYwMixcbiAgICAgMC40NDY5NTMsIC0wLjAyMTU1MCwgLTAuNjg1NzY5LCAwLjU3NDAxMV0sXG4gICAgWy0wLjQyMjYxOCwgMC45MDYzMDgsIC0wLjIzMjA5MSwgLTAuNjYzNDE0LCAwLjcxMTM0OCxcbiAgICAgMC40NDUyMjIsIC0wLjA1OTM2OCwgLTAuNjcyMjI2LCAwLjU4ODUyOF0sXG4gICAgWy0wLjQwNjczNywgMC45MTM1NDUsIC0wLjI1MTg0OCwgLTAuNjQzNTgyLCAwLjcyMjc1NSxcbiAgICAgMC40NDE4ODQsIC0wLjA5NjY4NCwgLTAuNjU3MzM5LCAwLjYwMjc0MV0sXG4gICAgWy0wLjM5MDczMSwgMC45MjA1MDUsIC0wLjI3MDk5NCwgLTAuNjIyOTY3LCAwLjczMzgwOSxcbiAgICAgMC40MzY5NjQsIC0wLjEzMzM5NSwgLTAuNjQxMTMwLCAwLjYxNjYyMV0sXG4gICAgWy0wLjM3NDYwNywgMC45MjcxODQsIC0wLjI4OTUwNSwgLTAuNjAxNTkyLCAwLjc0NDQ5NixcbiAgICAgMC40MzA0ODgsIC0wLjE2OTM5NywgLTAuNjIzNjI0LCAwLjYzMDE0MV0sXG4gICAgWy0wLjM1ODM2OCwgMC45MzM1ODAsIC0wLjMwNzM1OSwgLTAuNTc5NDg0LCAwLjc1NDgwNCxcbiAgICAgMC40MjI0OTEsIC0wLjIwNDU4OSwgLTAuNjA0ODUxLCAwLjY0MzI3M10sXG4gICAgWy0wLjM0MjAyMCwgMC45Mzk2OTMsIC0wLjMyNDUzMywgLTAuNTU2NjcwLCAwLjc2NDcyMCxcbiAgICAgMC40MTMwMDgsIC0wLjIzODg3MiwgLTAuNTg0ODQzLCAwLjY1NTk5MF0sXG4gICAgWy0wLjMyNTU2OCwgMC45NDU1MTksIC0wLjM0MTAwOCwgLTAuNTMzMTc4LCAwLjc3NDIzMSxcbiAgICAgMC40MDIwODEsIC0wLjI3MjE1MCwgLTAuNTYzNjM1LCAwLjY2ODI2N10sXG4gICAgWy0wLjMwOTAxNywgMC45NTEwNTcsIC0wLjM1Njc2MywgLTAuNTA5MDM3LCAwLjc4MzMyNyxcbiAgICAgMC4zODk3NTQsIC0wLjMwNDMyOSwgLTAuNTQxMjY2LCAwLjY4MDA3OF0sXG4gICAgWy0wLjI5MjM3MiwgMC45NTYzMDUsIC0wLjM3MTc3OCwgLTAuNDg0Mjc1LCAwLjc5MTk5NyxcbiAgICAgMC4zNzYwNzcsIC0wLjMzNTMxOSwgLTAuNTE3Nzc4LCAwLjY5MTM5OV0sXG4gICAgWy0wLjI3NTYzNywgMC45NjEyNjIsIC0wLjM4NjAzNiwgLTAuNDU4OTI0LCAwLjgwMDIyOCxcbiAgICAgMC4zNjExMDIsIC0wLjM2NTAzNCwgLTAuNDkzMjE2LCAwLjcwMjIwN10sXG4gICAgWy0wLjI1ODgxOSwgMC45NjU5MjYsIC0wLjM5OTUxOSwgLTAuNDMzMDEzLCAwLjgwODAxMyxcbiAgICAgMC4zNDQ4ODUsIC0wLjM5MzM4OSwgLTAuNDY3NjI3LCAwLjcxMjQ3OF0sXG4gICAgWy0wLjI0MTkyMiwgMC45NzAyOTYsIC0wLjQxMjIxMSwgLTAuNDA2NTc0LCAwLjgxNTM0MCxcbiAgICAgMC4zMjc0ODYsIC0wLjQyMDMwNiwgLTAuNDQxMDYxLCAwLjcyMjE5MV0sXG4gICAgWy0wLjIyNDk1MSwgMC45NzQzNzAsIC0wLjQyNDA5NiwgLTAuMzc5NjQxLCAwLjgyMjIwMixcbiAgICAgMC4zMDg5NjksIC0wLjQ0NTcwOSwgLTAuNDEzNTcyLCAwLjczMTMyN10sXG4gICAgWy0wLjIwNzkxMiwgMC45NzgxNDgsIC0wLjQzNTE1OSwgLTAuMzUyMjQ0LCAwLjgyODU4OSxcbiAgICAgMC4yODkzOTksIC0wLjQ2OTUyNywgLTAuMzg1MjE1LCAwLjczOTg2Nl0sXG4gICAgWy0wLjE5MDgwOSwgMC45ODE2MjcsIC0wLjQ0NTM4OCwgLTAuMzI0NDE5LCAwLjgzNDQ5NSxcbiAgICAgMC4yNjg4NDYsIC0wLjQ5MTY5MywgLTAuMzU2MDQ3LCAwLjc0Nzc5MF0sXG4gICAgWy0wLjE3MzY0OCwgMC45ODQ4MDgsIC0wLjQ1NDc2OSwgLTAuMjk2MTk4LCAwLjgzOTkxMixcbiAgICAgMC4yNDczODIsIC0wLjUxMjE0NSwgLTAuMzI2MTI5LCAwLjc1NTA4Ml0sXG4gICAgWy0wLjE1NjQzNCwgMC45ODc2ODgsIC0wLjQ2MzI5MiwgLTAuMjY3NjE3LCAwLjg0NDgzMixcbiAgICAgMC4yMjUwODEsIC0wLjUzMDgyNywgLTAuMjk1NTIxLCAwLjc2MTcyOF0sXG4gICAgWy0wLjEzOTE3MywgMC45OTAyNjgsIC0wLjQ3MDk0NiwgLTAuMjM4NzA5LCAwLjg0OTI1MSxcbiAgICAgMC4yMDIwMjAsIC0wLjU0NzY4NCwgLTAuMjY0Mjg3LCAwLjc2NzcxMl0sXG4gICAgWy0wLjEyMTg2OSwgMC45OTI1NDYsIC0wLjQ3NzcyMiwgLTAuMjA5NTExLCAwLjg1MzE2MyxcbiAgICAgMC4xNzgyNzksIC0wLjU2MjY3MiwgLTAuMjMyNDk0LCAwLjc3MzAyM10sXG4gICAgWy0wLjEwNDUyOCwgMC45OTQ1MjIsIC0wLjQ4MzYxMSwgLTAuMTgwMDU3LCAwLjg1NjU2MyxcbiAgICAgMC4xNTM5MzcsIC0wLjU3NTc0NywgLTAuMjAwMjA3LCAwLjc3NzY0OF0sXG4gICAgWy0wLjA4NzE1NiwgMC45OTYxOTUsIC0wLjQ4ODYwNiwgLTAuMTUwMzg0LCAwLjg1OTQ0NyxcbiAgICAgMC4xMjkwNzgsIC0wLjU4Njg3MiwgLTAuMTY3NDk0LCAwLjc4MTU3OV0sXG4gICAgWy0wLjA2OTc1NiwgMC45OTc1NjQsIC0wLjQ5MjcwMSwgLTAuMTIwNTI3LCAwLjg2MTgxMSxcbiAgICAgMC4xMDM3ODYsIC0wLjU5NjAxOCwgLTAuMTM0NDI2LCAwLjc4NDgwNl0sXG4gICAgWy0wLjA1MjMzNiwgMC45OTg2MzAsIC0wLjQ5NTg5MSwgLTAuMDkwNTI0LCAwLjg2MzY1MyxcbiAgICAgMC4wNzgxNDYsIC0wLjYwMzE1OCwgLTAuMTAxMDcxLCAwLjc4NzMyNF0sXG4gICAgWy0wLjAzNDg5OSwgMC45OTkzOTEsIC0wLjQ5ODE3MywgLTAuMDYwNDExLCAwLjg2NDk3MSxcbiAgICAgMC4wNTIyNDMsIC0wLjYwODI3MiwgLTAuMDY3NTAwLCAwLjc4OTEyNl0sXG4gICAgWy0wLjAxNzQ1MiwgMC45OTk4NDgsIC0wLjQ5OTU0MywgLTAuMDMwMjI0LCAwLjg2NTc2MixcbiAgICAgMC4wMjYxNjUsIC0wLjYxMTM0NywgLTAuMDMzNzg2LCAwLjc5MDIwOF0sXG4gICAgWzAuMDAwMDAwLCAxLjAwMDAwMCwgLTAuNTAwMDAwLCAwLjAwMDAwMCwgMC44NjYwMjUsXG4gICAgIC0wLjAwMDAwMCwgLTAuNjEyMzcyLCAwLjAwMDAwMCwgMC43OTA1NjldLFxuICAgIFswLjAxNzQ1MiwgMC45OTk4NDgsIC0wLjQ5OTU0MywgMC4wMzAyMjQsIDAuODY1NzYyLFxuICAgICAtMC4wMjYxNjUsIC0wLjYxMTM0NywgMC4wMzM3ODYsIDAuNzkwMjA4XSxcbiAgICBbMC4wMzQ4OTksIDAuOTk5MzkxLCAtMC40OTgxNzMsIDAuMDYwNDExLCAwLjg2NDk3MSxcbiAgICAgLTAuMDUyMjQzLCAtMC42MDgyNzIsIDAuMDY3NTAwLCAwLjc4OTEyNl0sXG4gICAgWzAuMDUyMzM2LCAwLjk5ODYzMCwgLTAuNDk1ODkxLCAwLjA5MDUyNCwgMC44NjM2NTMsXG4gICAgIC0wLjA3ODE0NiwgLTAuNjAzMTU4LCAwLjEwMTA3MSwgMC43ODczMjRdLFxuICAgIFswLjA2OTc1NiwgMC45OTc1NjQsIC0wLjQ5MjcwMSwgMC4xMjA1MjcsIDAuODYxODExLFxuICAgICAtMC4xMDM3ODYsIC0wLjU5NjAxOCwgMC4xMzQ0MjYsIDAuNzg0ODA2XSxcbiAgICBbMC4wODcxNTYsIDAuOTk2MTk1LCAtMC40ODg2MDYsIDAuMTUwMzg0LCAwLjg1OTQ0NyxcbiAgICAgLTAuMTI5MDc4LCAtMC41ODY4NzIsIDAuMTY3NDk0LCAwLjc4MTU3OV0sXG4gICAgWzAuMTA0NTI4LCAwLjk5NDUyMiwgLTAuNDgzNjExLCAwLjE4MDA1NywgMC44NTY1NjMsXG4gICAgIC0wLjE1MzkzNywgLTAuNTc1NzQ3LCAwLjIwMDIwNywgMC43Nzc2NDhdLFxuICAgIFswLjEyMTg2OSwgMC45OTI1NDYsIC0wLjQ3NzcyMiwgMC4yMDk1MTEsIDAuODUzMTYzLFxuICAgICAtMC4xNzgyNzksIC0wLjU2MjY3MiwgMC4yMzI0OTQsIDAuNzczMDIzXSxcbiAgICBbMC4xMzkxNzMsIDAuOTkwMjY4LCAtMC40NzA5NDYsIDAuMjM4NzA5LCAwLjg0OTI1MSxcbiAgICAgLTAuMjAyMDIwLCAtMC41NDc2ODQsIDAuMjY0Mjg3LCAwLjc2NzcxMl0sXG4gICAgWzAuMTU2NDM0LCAwLjk4NzY4OCwgLTAuNDYzMjkyLCAwLjI2NzYxNywgMC44NDQ4MzIsXG4gICAgIC0wLjIyNTA4MSwgLTAuNTMwODI3LCAwLjI5NTUyMSwgMC43NjE3MjhdLFxuICAgIFswLjE3MzY0OCwgMC45ODQ4MDgsIC0wLjQ1NDc2OSwgMC4yOTYxOTgsIDAuODM5OTEyLFxuICAgICAtMC4yNDczODIsIC0wLjUxMjE0NSwgMC4zMjYxMjksIDAuNzU1MDgyXSxcbiAgICBbMC4xOTA4MDksIDAuOTgxNjI3LCAtMC40NDUzODgsIDAuMzI0NDE5LCAwLjgzNDQ5NSxcbiAgICAgLTAuMjY4ODQ2LCAtMC40OTE2OTMsIDAuMzU2MDQ3LCAwLjc0Nzc5MF0sXG4gICAgWzAuMjA3OTEyLCAwLjk3ODE0OCwgLTAuNDM1MTU5LCAwLjM1MjI0NCwgMC44Mjg1ODksXG4gICAgIC0wLjI4OTM5OSwgLTAuNDY5NTI3LCAwLjM4NTIxNSwgMC43Mzk4NjZdLFxuICAgIFswLjIyNDk1MSwgMC45NzQzNzAsIC0wLjQyNDA5NiwgMC4zNzk2NDEsIDAuODIyMjAyLFxuICAgICAtMC4zMDg5NjksIC0wLjQ0NTcwOSwgMC40MTM1NzIsIDAuNzMxMzI3XSxcbiAgICBbMC4yNDE5MjIsIDAuOTcwMjk2LCAtMC40MTIyMTEsIDAuNDA2NTc0LCAwLjgxNTM0MCxcbiAgICAgLTAuMzI3NDg2LCAtMC40MjAzMDYsIDAuNDQxMDYxLCAwLjcyMjE5MV0sXG4gICAgWzAuMjU4ODE5LCAwLjk2NTkyNiwgLTAuMzk5NTE5LCAwLjQzMzAxMywgMC44MDgwMTMsXG4gICAgIC0wLjM0NDg4NSwgLTAuMzkzMzg5LCAwLjQ2NzYyNywgMC43MTI0NzhdLFxuICAgIFswLjI3NTYzNywgMC45NjEyNjIsIC0wLjM4NjAzNiwgMC40NTg5MjQsIDAuODAwMjI4LFxuICAgICAtMC4zNjExMDIsIC0wLjM2NTAzNCwgMC40OTMyMTYsIDAuNzAyMjA3XSxcbiAgICBbMC4yOTIzNzIsIDAuOTU2MzA1LCAtMC4zNzE3NzgsIDAuNDg0Mjc1LCAwLjc5MTk5NyxcbiAgICAgLTAuMzc2MDc3LCAtMC4zMzUzMTksIDAuNTE3Nzc4LCAwLjY5MTM5OV0sXG4gICAgWzAuMzA5MDE3LCAwLjk1MTA1NywgLTAuMzU2NzYzLCAwLjUwOTAzNywgMC43ODMzMjcsXG4gICAgIC0wLjM4OTc1NCwgLTAuMzA0MzI5LCAwLjU0MTI2NiwgMC42ODAwNzhdLFxuICAgIFswLjMyNTU2OCwgMC45NDU1MTksIC0wLjM0MTAwOCwgMC41MzMxNzgsIDAuNzc0MjMxLFxuICAgICAtMC40MDIwODEsIC0wLjI3MjE1MCwgMC41NjM2MzUsIDAuNjY4MjY3XSxcbiAgICBbMC4zNDIwMjAsIDAuOTM5NjkzLCAtMC4zMjQ1MzMsIDAuNTU2NjcwLCAwLjc2NDcyMCxcbiAgICAgLTAuNDEzMDA4LCAtMC4yMzg4NzIsIDAuNTg0ODQzLCAwLjY1NTk5MF0sXG4gICAgWzAuMzU4MzY4LCAwLjkzMzU4MCwgLTAuMzA3MzU5LCAwLjU3OTQ4NCwgMC43NTQ4MDQsXG4gICAgIC0wLjQyMjQ5MSwgLTAuMjA0NTg5LCAwLjYwNDg1MSwgMC42NDMyNzNdLFxuICAgIFswLjM3NDYwNywgMC45MjcxODQsIC0wLjI4OTUwNSwgMC42MDE1OTIsIDAuNzQ0NDk2LFxuICAgICAtMC40MzA0ODgsIC0wLjE2OTM5NywgMC42MjM2MjQsIDAuNjMwMTQxXSxcbiAgICBbMC4zOTA3MzEsIDAuOTIwNTA1LCAtMC4yNzA5OTQsIDAuNjIyOTY3LCAwLjczMzgwOSxcbiAgICAgLTAuNDM2OTY0LCAtMC4xMzMzOTUsIDAuNjQxMTMwLCAwLjYxNjYyMV0sXG4gICAgWzAuNDA2NzM3LCAwLjkxMzU0NSwgLTAuMjUxODQ4LCAwLjY0MzU4MiwgMC43MjI3NTUsXG4gICAgIC0wLjQ0MTg4NCwgLTAuMDk2Njg0LCAwLjY1NzMzOSwgMC42MDI3NDFdLFxuICAgIFswLjQyMjYxOCwgMC45MDYzMDgsIC0wLjIzMjA5MSwgMC42NjM0MTQsIDAuNzExMzQ4LFxuICAgICAtMC40NDUyMjIsIC0wLjA1OTM2OCwgMC42NzIyMjYsIDAuNTg4NTI4XSxcbiAgICBbMC40MzgzNzEsIDAuODk4Nzk0LCAtMC4yMTE3NDYsIDAuNjgyNDM3LCAwLjY5OTYwMixcbiAgICAgLTAuNDQ2OTUzLCAtMC4wMjE1NTAsIDAuNjg1NzY5LCAwLjU3NDAxMV0sXG4gICAgWzAuNDUzOTkwLCAwLjg5MTAwNywgLTAuMTkwODM5LCAwLjcwMDYyOSwgMC42ODc1MzEsXG4gICAgIC0wLjQ0NzA1OSwgMC4wMTY2NjIsIDAuNjk3OTUwLCAwLjU1OTIyMF0sXG4gICAgWzAuNDY5NDcyLCAwLjg4Mjk0OCwgLTAuMTY5Mzk1LCAwLjcxNzk2OCwgMC42NzUxNTAsXG4gICAgIC0wLjQ0NTUyNCwgMC4wNTUxNjAsIDAuNzA4NzUzLCAwLjU0NDE4M10sXG4gICAgWzAuNDg0ODEwLCAwLjg3NDYyMCwgLTAuMTQ3NDM5LCAwLjczNDQzMSwgMC42NjI0NzQsXG4gICAgIC0wLjQ0MjM0MCwgMC4wOTM4MzcsIDAuNzE4MTY3LCAwLjUyODkyOV0sXG4gICAgWzAuNTAwMDAwLCAwLjg2NjAyNSwgLTAuMTI1MDAwLCAwLjc1MDAwMCwgMC42NDk1MTksXG4gICAgIC0wLjQzNzUwMCwgMC4xMzI1ODMsIDAuNzI2MTg0LCAwLjUxMzQ5MF0sXG4gICAgWzAuNTE1MDM4LCAwLjg1NzE2NywgLTAuMTAyMTA0LCAwLjc2NDY1NSwgMC42MzYzMDAsXG4gICAgIC0wLjQzMTAwNCwgMC4xNzEyODgsIDAuNzMyODAxLCAwLjQ5Nzg5NF0sXG4gICAgWzAuNTI5OTE5LCAwLjg0ODA0OCwgLTAuMDc4Nzc4LCAwLjc3ODM3OCwgMC42MjI4MzMsXG4gICAgIC0wLjQyMjg1NiwgMC4yMDk4NDMsIDAuNzM4MDE3LCAwLjQ4MjE3MV0sXG4gICAgWzAuNTQ0NjM5LCAwLjgzODY3MSwgLTAuMDU1MDUyLCAwLjc5MTE1NCwgMC42MDkxMzUsXG4gICAgIC0wLjQxMzA2NiwgMC4yNDgxNDAsIDAuNzQxODM1LCAwLjQ2NjM1Ml0sXG4gICAgWzAuNTU5MTkzLCAwLjgyOTAzOCwgLTAuMDMwOTU1LCAwLjgwMjk2NSwgMC41OTUyMjIsXG4gICAgIC0wLjQwMTY0NSwgMC4yODYwNjksIDAuNzQ0MjYyLCAwLjQ1MDQ2N10sXG4gICAgWzAuNTczNTc2LCAwLjgxOTE1MiwgLTAuMDA2NTE1LCAwLjgxMzc5OCwgMC41ODExMTIsXG4gICAgIC0wLjM4ODYxMiwgMC4zMjM1MjQsIDAuNzQ1MzA4LCAwLjQzNDU0NF0sXG4gICAgWzAuNTg3Nzg1LCAwLjgwOTAxNywgMC4wMTgyMzcsIDAuODIzNjM5LCAwLjU2NjgyMSxcbiAgICAgLTAuMzczOTkxLCAwLjM2MDM5NywgMC43NDQ5ODksIDAuNDE4NjEzXSxcbiAgICBbMC42MDE4MTUsIDAuNzk4NjM2LCAwLjA0MzI3MiwgMC44MzI0NzcsIDAuNTUyMzY3LFxuICAgICAtMC4zNTc4MDcsIDAuMzk2NTg0LCAwLjc0MzMyMCwgMC40MDI3MDRdLFxuICAgIFswLjYxNTY2MSwgMC43ODgwMTEsIDAuMDY4NTU5LCAwLjg0MDMwMSwgMC41Mzc3NjgsXG4gICAgIC0wLjM0MDA5MywgMC40MzE5ODIsIDAuNzQwMzI0LCAwLjM4Njg0NV0sXG4gICAgWzAuNjI5MzIwLCAwLjc3NzE0NiwgMC4wOTQwNjYsIDAuODQ3MTAxLCAwLjUyMzA0MSxcbiAgICAgLTAuMzIwODg0LCAwLjQ2NjQ5MCwgMC43MzYwMjUsIDAuMzcxMDYzXSxcbiAgICBbMC42NDI3ODgsIDAuNzY2MDQ0LCAwLjExOTc2NCwgMC44NTI4NjksIDAuNTA4MjA1LFxuICAgICAtMC4zMDAyMjEsIDAuNTAwMDA5LCAwLjczMDQ1MSwgMC4zNTUzODddLFxuICAgIFswLjY1NjA1OSwgMC43NTQ3MTAsIDAuMTQ1NjIwLCAwLjg1NzU5NywgMC40OTMyNzYsXG4gICAgIC0wLjI3ODE0NywgMC41MzI0NDMsIDAuNzIzNjMzLCAwLjMzOTg0NF0sXG4gICAgWzAuNjY5MTMxLCAwLjc0MzE0NSwgMC4xNzE2MDQsIDAuODYxMjgxLCAwLjQ3ODI3NSxcbiAgICAgLTAuMjU0NzEyLCAwLjU2MzcwMCwgMC43MTU2MDUsIDAuMzI0NDU5XSxcbiAgICBbMC42ODE5OTgsIDAuNzMxMzU0LCAwLjE5NzY4MywgMC44NjM5MTYsIDAuNDYzMjE4LFxuICAgICAtMC4yMjk5NjcsIDAuNTkzNjg4LCAwLjcwNjQwNSwgMC4zMDkyNTldLFxuICAgIFswLjY5NDY1OCwgMC43MTkzNDAsIDAuMjIzODI1LCAwLjg2NTQ5OCwgMC40NDgxMjUsXG4gICAgIC0wLjIwMzk2OSwgMC42MjIzMjIsIDAuNjk2MDczLCAwLjI5NDI2N10sXG4gICAgWzAuNzA3MTA3LCAwLjcwNzEwNywgMC4yNTAwMDAsIDAuODY2MDI1LCAwLjQzMzAxMyxcbiAgICAgLTAuMTc2Nzc3LCAwLjY0OTUxOSwgMC42ODQ2NTMsIDAuMjc5NTA4XSxcbiAgICBbMC43MTkzNDAsIDAuNjk0NjU4LCAwLjI3NjE3NSwgMC44NjU0OTgsIDAuNDE3OTAxLFxuICAgICAtMC4xNDg0NTQsIDAuNjc1MTk5LCAwLjY3MjE5MCwgMC4yNjUwMDVdLFxuICAgIFswLjczMTM1NCwgMC42ODE5OTgsIDAuMzAyMzE3LCAwLjg2MzkxNiwgMC40MDI4MDcsXG4gICAgIC0wLjExOTA2OCwgMC42OTkyODgsIDAuNjU4NzM0LCAwLjI1MDc3OF0sXG4gICAgWzAuNzQzMTQ1LCAwLjY2OTEzMSwgMC4zMjgzOTYsIDAuODYxMjgxLCAwLjM4Nzc1MSxcbiAgICAgLTAuMDg4Njg2LCAwLjcyMTcxNCwgMC42NDQzMzQsIDAuMjM2ODUwXSxcbiAgICBbMC43NTQ3MTAsIDAuNjU2MDU5LCAwLjM1NDM4MCwgMC44NTc1OTcsIDAuMzcyNzQ5LFxuICAgICAtMC4wNTczODMsIDAuNzQyNDEyLCAwLjYyOTA0NCwgMC4yMjMyMzhdLFxuICAgIFswLjc2NjA0NCwgMC42NDI3ODgsIDAuMzgwMjM2LCAwLjg1Mjg2OSwgMC4zNTc4MjEsXG4gICAgIC0wLjAyNTIzMywgMC43NjEzMTksIDAuNjEyOTIxLCAwLjIwOTk2M10sXG4gICAgWzAuNzc3MTQ2LCAwLjYyOTMyMCwgMC40MDU5MzQsIDAuODQ3MTAxLCAwLjM0Mjk4NCxcbiAgICAgMC4wMDc2ODYsIDAuNzc4Mzc5LCAwLjU5NjAyMSwgMC4xOTcwNDBdLFxuICAgIFswLjc4ODAxMSwgMC42MTU2NjEsIDAuNDMxNDQxLCAwLjg0MDMwMSwgMC4zMjgyNTcsXG4gICAgIDAuMDQxMjk0LCAwLjc5MzU0MSwgMC41Nzg0MDUsIDAuMTg0NDg3XSxcbiAgICBbMC43OTg2MzYsIDAuNjAxODE1LCAwLjQ1NjcyOCwgMC44MzI0NzcsIDAuMzEzNjU4LFxuICAgICAwLjA3NTUwOCwgMC44MDY3NTcsIDAuNTYwMTMyLCAwLjE3MjMxN10sXG4gICAgWzAuODA5MDE3LCAwLjU4Nzc4NSwgMC40ODE3NjMsIDAuODIzNjM5LCAwLjI5OTIwNCxcbiAgICAgMC4xMTAyNDYsIDAuODE3OTg3LCAwLjU0MTI2NiwgMC4xNjA1NDVdLFxuICAgIFswLjgxOTE1MiwgMC41NzM1NzYsIDAuNTA2NTE1LCAwLjgxMzc5OCwgMC4yODQ5MTQsXG4gICAgIDAuMTQ1NDIwLCAwLjgyNzE5NCwgMC41MjE4NzEsIDAuMTQ5MTgxXSxcbiAgICBbMC44MjkwMzgsIDAuNTU5MTkzLCAwLjUzMDk1NSwgMC44MDI5NjUsIDAuMjcwODAzLFxuICAgICAwLjE4MDk0NCwgMC44MzQzNDcsIDAuNTAyMDExLCAwLjEzODIzN10sXG4gICAgWzAuODM4NjcxLCAwLjU0NDYzOSwgMC41NTUwNTIsIDAuNzkxMTU0LCAwLjI1Njg5MSxcbiAgICAgMC4yMTY3MzAsIDAuODM5NDIyLCAwLjQ4MTc1MywgMC4xMjc3MjJdLFxuICAgIFswLjg0ODA0OCwgMC41Mjk5MTksIDAuNTc4Nzc4LCAwLjc3ODM3OCwgMC4yNDMxOTIsXG4gICAgIDAuMjUyNjg4LCAwLjg0MjM5OSwgMC40NjExNjQsIDAuMTE3NjQ0XSxcbiAgICBbMC44NTcxNjcsIDAuNTE1MDM4LCAwLjYwMjEwNCwgMC43NjQ2NTUsIDAuMjI5NzI2LFxuICAgICAwLjI4ODcyOCwgMC44NDMyNjUsIDAuNDQwMzExLCAwLjEwODAwOV0sXG4gICAgWzAuODY2MDI1LCAwLjUwMDAwMCwgMC42MjUwMDAsIDAuNzUwMDAwLCAwLjIxNjUwNixcbiAgICAgMC4zMjQ3NjAsIDAuODQyMDEyLCAwLjQxOTI2MywgMC4wOTg4MjFdLFxuICAgIFswLjg3NDYyMCwgMC40ODQ4MTAsIDAuNjQ3NDM5LCAwLjczNDQzMSwgMC4yMDM1NTEsXG4gICAgIDAuMzYwNjkyLCAwLjgzODYzOCwgMC4zOTgwODYsIDAuMDkwMDg1XSxcbiAgICBbMC44ODI5NDgsIDAuNDY5NDcyLCAwLjY2OTM5NSwgMC43MTc5NjgsIDAuMTkwODc1LFxuICAgICAwLjM5NjQzNiwgMC44MzMxNDUsIDAuMzc2ODUxLCAwLjA4MTgwM10sXG4gICAgWzAuODkxMDA3LCAwLjQ1Mzk5MCwgMC42OTA4MzksIDAuNzAwNjI5LCAwLjE3ODQ5NCxcbiAgICAgMC40MzE4OTksIDAuODI1NTQ0LCAwLjM1NTYyMywgMC4wNzM5NzRdLFxuICAgIFswLjg5ODc5NCwgMC40MzgzNzEsIDAuNzExNzQ2LCAwLjY4MjQzNywgMC4xNjY0MjMsXG4gICAgIDAuNDY2OTkzLCAwLjgxNTg1MCwgMC4zMzQ0NzIsIDAuMDY2NTk5XSxcbiAgICBbMC45MDYzMDgsIDAuNDIyNjE4LCAwLjczMjA5MSwgMC42NjM0MTQsIDAuMTU0Njc4LFxuICAgICAwLjUwMTYyNywgMC44MDQwODMsIDAuMzEzNDY0LCAwLjA1OTY3NF0sXG4gICAgWzAuOTEzNTQ1LCAwLjQwNjczNywgMC43NTE4NDgsIDAuNjQzNTgyLCAwLjE0MzI3MSxcbiAgICAgMC41MzU3MTUsIDAuNzkwMjcwLCAwLjI5MjY2NiwgMC4wNTMxOTZdLFxuICAgIFswLjkyMDUwNSwgMC4zOTA3MzEsIDAuNzcwOTk0LCAwLjYyMjk2NywgMC4xMzIyMTcsXG4gICAgIDAuNTY5MTY5LCAwLjc3NDQ0MiwgMC4yNzIxNDMsIDAuMDQ3MTYwXSxcbiAgICBbMC45MjcxODQsIDAuMzc0NjA3LCAwLjc4OTUwNSwgMC42MDE1OTIsIDAuMTIxNTI5LFxuICAgICAwLjYwMTkwNCwgMC43NTY2MzcsIDAuMjUxOTYwLCAwLjA0MTU1OV0sXG4gICAgWzAuOTMzNTgwLCAwLjM1ODM2OCwgMC44MDczNTksIDAuNTc5NDg0LCAwLjExMTIyMixcbiAgICAgMC42MzM4MzcsIDAuNzM2ODk4LCAwLjIzMjE4MCwgMC4wMzYzODVdLFxuICAgIFswLjkzOTY5MywgMC4zNDIwMjAsIDAuODI0NTMzLCAwLjU1NjY3MCwgMC4xMDEzMDYsXG4gICAgIDAuNjY0ODg1LCAwLjcxNTI3NCwgMC4yMTI4NjUsIDAuMDMxNjMwXSxcbiAgICBbMC45NDU1MTksIDAuMzI1NTY4LCAwLjg0MTAwOCwgMC41MzMxNzgsIDAuMDkxNzk0LFxuICAgICAwLjY5NDk2OSwgMC42OTE4MTYsIDAuMTk0MDc1LCAwLjAyNzI4MV0sXG4gICAgWzAuOTUxMDU3LCAwLjMwOTAxNywgMC44NTY3NjMsIDAuNTA5MDM3LCAwLjA4MjY5OCxcbiAgICAgMC43MjQwMTIsIDAuNjY2NTgzLCAwLjE3NTg2OCwgMC4wMjMzMjldLFxuICAgIFswLjk1NjMwNSwgMC4yOTIzNzIsIDAuODcxNzc4LCAwLjQ4NDI3NSwgMC4wNzQwMjksXG4gICAgIDAuNzUxOTQwLCAwLjYzOTYzOSwgMC4xNTgzMDEsIDAuMDE5NzU4XSxcbiAgICBbMC45NjEyNjIsIDAuMjc1NjM3LCAwLjg4NjAzNiwgMC40NTg5MjQsIDAuMDY1Nzk3LFxuICAgICAwLjc3ODY4MCwgMC42MTEwNTAsIDAuMTQxNDI3LCAwLjAxNjU1Nl0sXG4gICAgWzAuOTY1OTI2LCAwLjI1ODgxOSwgMC44OTk1MTksIDAuNDMzMDEzLCAwLjA1ODAxMyxcbiAgICAgMC44MDQxNjQsIDAuNTgwODg5LCAwLjEyNTMwMCwgMC4wMTM3MDddLFxuICAgIFswLjk3MDI5NiwgMC4yNDE5MjIsIDAuOTEyMjExLCAwLjQwNjU3NCwgMC4wNTA2ODUsXG4gICAgIDAuODI4MzI2LCAwLjU0OTIzMywgMC4xMDk5NjksIDAuMDExMTkzXSxcbiAgICBbMC45NzQzNzAsIDAuMjI0OTUxLCAwLjkyNDA5NiwgMC4zNzk2NDEsIDAuMDQzODIzLFxuICAgICAwLjg1MTEwNSwgMC41MTYxNjIsIDAuMDk1NDgxLCAwLjAwODk5OV0sXG4gICAgWzAuOTc4MTQ4LCAwLjIwNzkxMiwgMC45MzUxNTksIDAuMzUyMjQ0LCAwLjAzNzQzNixcbiAgICAgMC44NzI0NDEsIDAuNDgxNzU5LCAwLjA4MTg4MCwgMC4wMDcxMDVdLFxuICAgIFswLjk4MTYyNywgMC4xOTA4MDksIDAuOTQ1Mzg4LCAwLjMyNDQxOSwgMC4wMzE1MzAsXG4gICAgIDAuODkyMjc5LCAwLjQ0NjExNCwgMC4wNjkyMDksIDAuMDA1NDkyXSxcbiAgICBbMC45ODQ4MDgsIDAuMTczNjQ4LCAwLjk1NDc2OSwgMC4yOTYxOTgsIDAuMDI2MTE0LFxuICAgICAwLjkxMDU2OSwgMC40MDkzMTcsIDAuMDU3NTA1LCAwLjAwNDE0MF0sXG4gICAgWzAuOTg3Njg4LCAwLjE1NjQzNCwgMC45NjMyOTIsIDAuMjY3NjE3LCAwLjAyMTE5MyxcbiAgICAgMC45MjcyNjIsIDAuMzcxNDYzLCAwLjA0NjgwNiwgMC4wMDMwMjZdLFxuICAgIFswLjk5MDI2OCwgMC4xMzkxNzMsIDAuOTcwOTQ2LCAwLjIzODcwOSwgMC4wMTY3NzQsXG4gICAgIDAuOTQyMzE2LCAwLjMzMjY0OSwgMC4wMzcxNDMsIDAuMDAyMTMxXSxcbiAgICBbMC45OTI1NDYsIDAuMTIxODY5LCAwLjk3NzcyMiwgMC4yMDk1MTEsIDAuMDEyODYyLFxuICAgICAwLjk1NTY5MywgMC4yOTI5NzYsIDAuMDI4NTQ3LCAwLjAwMTQzMV0sXG4gICAgWzAuOTk0NTIyLCAwLjEwNDUyOCwgMC45ODM2MTEsIDAuMTgwMDU3LCAwLjAwOTQ2MixcbiAgICAgMC45NjczNTYsIDAuMjUyNTQ0LCAwLjAyMTA0MywgMC4wMDA5MDNdLFxuICAgIFswLjk5NjE5NSwgMC4wODcxNTYsIDAuOTg4NjA2LCAwLjE1MDM4NCwgMC4wMDY1NzgsXG4gICAgIDAuOTc3Mjc3LCAwLjIxMTQ2MCwgMC4wMTQ2NTQsIDAuMDAwNTIzXSxcbiAgICBbMC45OTc1NjQsIDAuMDY5NzU2LCAwLjk5MjcwMSwgMC4xMjA1MjcsIDAuMDA0MjE0LFxuICAgICAwLjk4NTQyOSwgMC4xNjk4MjgsIDAuMDA5NDAwLCAwLjAwMDI2OF0sXG4gICAgWzAuOTk4NjMwLCAwLjA1MjMzNiwgMC45OTU4OTEsIDAuMDkwNTI0LCAwLjAwMjM3MixcbiAgICAgMC45OTE3OTEsIDAuMTI3NzU3LCAwLjAwNTI5NywgMC4wMDAxMTNdLFxuICAgIFswLjk5OTM5MSwgMC4wMzQ4OTksIDAuOTk4MTczLCAwLjA2MDQxMSwgMC4wMDEwNTUsXG4gICAgIDAuOTk2MzQ4LCAwLjA4NTM1NiwgMC4wMDIzNTcsIDAuMDAwMDM0XSxcbiAgICBbMC45OTk4NDgsIDAuMDE3NDUyLCAwLjk5OTU0MywgMC4wMzAyMjQsIDAuMDAwMjY0LFxuICAgICAwLjk5OTA4NiwgMC4wNDI3MzMsIDAuMDAwNTkwLCAwLjAwMDAwNF0sXG4gICAgWzEuMDAwMDAwLCAtMC4wMDAwMDAsIDEuMDAwMDAwLCAtMC4wMDAwMDAsIDAuMDAwMDAwLFxuICAgICAxLjAwMDAwMCwgLTAuMDAwMDAwLCAwLjAwMDAwMCwgLTAuMDAwMDAwXSxcbiAgXSxcbl07XG5cblxuLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG5leHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NfQVpJTVVUSF9SRVNPTFVUSU9OID1cbiAgZXhwb3J0cy5TUEhFUklDQUxfSEFSTU9OSUNTWzBdLmxlbmd0aDtcblxuXG4vKiogQHR5cGUge051bWJlcn0gKi9cbmV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU19FTEVWQVRJT05fUkVTT0xVVElPTiA9XG4gIGV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU1sxXS5sZW5ndGg7XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBhbGxvd2VkIGFtYmlzb25pYyBvcmRlci5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydHMuU1BIRVJJQ0FMX0hBUk1PTklDU19NQVhfT1JERVIgPVxuICBleHBvcnRzLlNQSEVSSUNBTF9IQVJNT05JQ1NbMF1bMF0ubGVuZ3RoIC8gMjtcblxuXG4vKipcbiAqIFByZS1jb21wdXRlZCBwZXItYmFuZCB3ZWlnaHRpbmcgY29lZmZpY2llbnRzIGZvciBwcm9kdWNpbmcgZW5lcmd5LXByZXNlcnZpbmdcbiAqIE1heC1SZSBzb3VyY2VzLlxuICovXG5leHBvcnRzLk1BWF9SRV9XRUlHSFRTID1cbltcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAwMDAwLCAxLjAwMDAwMCwgMS4wMDAwMDAsIDEuMDAwMDAwXSxcbiAgWzEuMDAzMjM2LCAxLjAwMjE1NiwgMC45OTkxNTIsIDAuOTkwMDM4XSxcbiAgWzEuMDMyMzcwLCAxLjAyMTE5NCwgMC45OTA0MzMsIDAuODk4NTcyXSxcbiAgWzEuMDYyNjk0LCAxLjA0MDIzMSwgMC45NzkxNjEsIDAuNzk5ODA2XSxcbiAgWzEuMDkzOTk5LCAxLjA1ODk1NCwgMC45NjQ5NzYsIDAuNjkzNjAzXSxcbiAgWzEuMTI2MDAzLCAxLjA3NzAwNiwgMC45NDc1MjYsIDAuNTc5ODkwXSxcbiAgWzEuMTU4MzQ1LCAxLjA5Mzk4MiwgMC45MjY0NzQsIDAuNDU4NjkwXSxcbiAgWzEuMTkwNTkwLCAxLjEwOTQzNywgMC45MDE1MTIsIDAuMzMwMTU4XSxcbiAgWzEuMjIyMjI4LCAxLjEyMjg5MCwgMC44NzIzNzAsIDAuMTk0NjIxXSxcbiAgWzEuMjUyNjg0LCAxLjEzMzgzNywgMC44Mzg4MzksIDAuMDUyNjE0XSxcbiAgWzEuMjgxOTg3LCAxLjE0MjM1OCwgMC44MDExOTksIDAuMDAwMDAwXSxcbiAgWzEuMzEyMDczLCAxLjE1MDIwNywgMC43NjA4MzksIDAuMDAwMDAwXSxcbiAgWzEuMzQzMDExLCAxLjE1NzQyNCwgMC43MTc3OTksIDAuMDAwMDAwXSxcbiAgWzEuMzc0NjQ5LCAxLjE2Mzg1OSwgMC42NzE5OTksIDAuMDAwMDAwXSxcbiAgWzEuNDA2ODA5LCAxLjE2OTM1NCwgMC42MjMzNzEsIDAuMDAwMDAwXSxcbiAgWzEuNDM5Mjg2LCAxLjE3MzczOSwgMC41NzE4NjgsIDAuMDAwMDAwXSxcbiAgWzEuNDcxODQ2LCAxLjE3NjgzNywgMC41MTc0NjUsIDAuMDAwMDAwXSxcbiAgWzEuNTA0MjI2LCAxLjE3ODQ2NSwgMC40NjAxNzQsIDAuMDAwMDAwXSxcbiAgWzEuNTM2MTMzLCAxLjE3ODQzOCwgMC40MDAwNDMsIDAuMDAwMDAwXSxcbiAgWzEuNTY3MjUzLCAxLjE3NjU3MywgMC4zMzcxNjUsIDAuMDAwMDAwXSxcbiAgWzEuNTk3MjQ3LCAxLjE3MjY5NSwgMC4yNzE2ODgsIDAuMDAwMDAwXSxcbiAgWzEuNjI1NzY2LCAxLjE2NjY0NSwgMC4yMDM4MTUsIDAuMDAwMDAwXSxcbiAgWzEuNjUyNDU1LCAxLjE1ODI4NSwgMC4xMzM4MDYsIDAuMDAwMDAwXSxcbiAgWzEuNjc2OTY2LCAxLjE0NzUwNiwgMC4wNjE5ODMsIDAuMDAwMDAwXSxcbiAgWzEuNjk5MDA2LCAxLjEzNDI2MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuNzIwMjI0LCAxLjExOTc4OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuNzQxNjMxLCAxLjEwNDgxMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuNzYzMTgzLCAxLjA4OTMzMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuNzg0ODM3LCAxLjA3MzM1NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuODA2NTQ4LCAxLjA1Njg5OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuODI4MjY5LCAxLjAzOTk2OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuODQ5OTUyLCAxLjAyMjU4MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuODcxNTUyLCAxLjAwNDc1MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuODkzMDE4LCAwLjk4NjUwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuOTE0MzA1LCAwLjk2Nzg1NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuOTM1MzY2LCAwLjk0ODgzNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuOTU2MTU0LCAwLjkyOTQ3MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuOTc2NjI1LCAwLjkwOTc5MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzEuOTk2NzM2LCAwLjg4OTgyMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMDE2NDQ4LCAwLjg2OTYwNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMDM1NzIxLCAwLjg0OTE3NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMDU0NTIyLCAwLjgyODU2NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMDcyODE4LCAwLjgwNzgxNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMDkwNTgxLCAwLjc4Njk2NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTA3Nzg1LCAwLjc2NjA1MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTI0NDExLCAwLjc0NTExNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTQwNDM5LCAwLjcyNDE5NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTU1ODU2LCAwLjcwMzMzMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTcwNjUzLCAwLjY4MjU2MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTg0ODIzLCAwLjY2MTkyMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMTk4MzY0LCAwLjY0MTQ0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjExMjc1LCAwLjYyMTE2OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjIzNTYyLCAwLjYwMTEyNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjM1MjMwLCAwLjU4MTM0MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjQ2Mjg5LCAwLjU2MTg0NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjU2NzUxLCAwLjU0MjY2NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjY2NjMxLCAwLjUyMzgyNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjc1OTQzLCAwLjUwNTM0NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjg0NzA3LCAwLjQ4NzIzOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMjkyOTM5LCAwLjQ2OTUyOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzAwNjYxLCAwLjQ1MjIyNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzA3ODkyLCAwLjQzNTM0MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzE0NjU0LCAwLjQxODg4OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzIwOTY5LCAwLjQwMjg3MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzI2ODU4LCAwLjM4NzI5NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzMyMzQzLCAwLjM3MjE2NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzM3NDQ1LCAwLjM1NzQ4MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzQyMTg2LCAwLjM0MzI0NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzQ2NTg1LCAwLjMyOTQ1OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzUwNjY0LCAwLjMxNjExMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzU0NDQyLCAwLjMwMzIwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzU3OTM3LCAwLjI5MDczOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzYxMTY4LCAwLjI3ODY5OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzY0MTUyLCAwLjI2NzA4MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzY2OTA2LCAwLjI1NTg3OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzY5NDQ2LCAwLjI0NTA4MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzcxNzg2LCAwLjIzNDY4NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzczOTQwLCAwLjIyNDY3NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzc1OTIzLCAwLjIxNTA0OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzc3NzQ1LCAwLjIwNTc5MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzc5NDIxLCAwLjE5Njg5MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzgwOTU5LCAwLjE4ODM0MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzgyMzcyLCAwLjE4MDEzMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzgzNjY3LCAwLjE3MjI1MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg0ODU2LCAwLjE2NDY4OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg1OTQ1LCAwLjE1NzQzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg2OTQzLCAwLjE1MDQ3OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg3ODU3LCAwLjE0MzgxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg4Njk0LCAwLjEzNzQyMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzg5NDYwLCAwLjEzMTI5OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkwMTYwLCAwLjEyNTQzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkwODAxLCAwLjExOTgyMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkxMzg2LCAwLjExNDQ0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkxOTIxLCAwLjEwOTMwMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkyNDEwLCAwLjEwNDM3NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkyODU3LCAwLjA5OTY2NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkzMjY1LCAwLjA5NTE2MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkzNjM3LCAwLjA5MDg1MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzkzOTc3LCAwLjA4NjczMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk0Mjg4LCAwLjA4Mjc5MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk0NTcxLCAwLjA3OTAyNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk0ODI5LCAwLjA3NTQyNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1MDY0LCAwLjA3MTk4NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1Mjc5LCAwLjA2ODY5OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1NDc1LCAwLjA2NTU1OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1NjUzLCAwLjA2MjU1OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1ODE2LCAwLjA1OTY5MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk1OTY0LCAwLjA1Njk1NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2MDk5LCAwLjA1NDM0MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2MjIyLCAwLjA1MTg0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2MzM0LCAwLjA0OTQ2MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2NDM2LCAwLjA0NzE4NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2NTI5LCAwLjA0NTAxMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2NjEzLCAwLjA0MjkzOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2NjkxLCAwLjA0MDk1OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2NzYxLCAwLjAzOTA2OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2ODI1LCAwLjAzNzI2NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2ODgzLCAwLjAzNTU0NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2OTM2LCAwLjAzMzkwMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk2OTg0LCAwLjAzMjMzNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MDI4LCAwLjAzMDgzOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MDY4LCAwLjAyOTQxMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MTA0LCAwLjAyODA0OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MTM3LCAwLjAyNjc0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MTY3LCAwLjAyNTUwOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MTk0LCAwLjAyNDMyNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MjE5LCAwLjAyMzE5OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MjQyLCAwLjAyMjEyMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MjYyLCAwLjAyMTA5NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MjgxLCAwLjAyMDExNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3Mjk4LCAwLjAxOTE4MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzE0LCAwLjAxODI5MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzI4LCAwLjAxNzQ0MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzQxLCAwLjAxNjYzMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzUyLCAwLjAxNTg1NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzYzLCAwLjAxNTExOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzcyLCAwLjAxNDQxNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3MzgxLCAwLjAxMzc0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3Mzg5LCAwLjAxMzEwNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3Mzk2LCAwLjAxMjQ5NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDAzLCAwLjAxMTkxNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDA5LCAwLjAxMTM2MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDE0LCAwLjAxMDgzMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDE5LCAwLjAxMDMyNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDI0LCAwLjAwOTg0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDI4LCAwLjAwOTM4NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDMyLCAwLjAwODk0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDM1LCAwLjAwODUzMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDM4LCAwLjAwODEzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDQxLCAwLjAwNzc1NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDQzLCAwLjAwNzM5NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDQ2LCAwLjAwNzA0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDQ4LCAwLjAwNjcyMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDUwLCAwLjAwNjQwNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDUxLCAwLjAwNjEwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDUzLCAwLjAwNTgyNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDU0LCAwLjAwNTU1MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDU2LCAwLjAwNTI5MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDU3LCAwLjAwNTA0NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDU4LCAwLjAwNDgxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDU5LCAwLjAwNDU4NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYwLCAwLjAwNDM3MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYxLCAwLjAwNDE2OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYxLCAwLjAwMzk3NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYyLCAwLjAwMzc4OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYzLCAwLjAwMzYxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDYzLCAwLjAwMzQ0MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY0LCAwLjAwMzI4MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY0LCAwLjAwMzEyOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY1LCAwLjAwMjk4MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY1LCAwLjAwMjg0NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY1LCAwLjAwMjcxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY2LCAwLjAwMjU4NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY2LCAwLjAwMjQ2NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY2LCAwLjAwMjM0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY2LCAwLjAwMjIzOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMjEzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMjAzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMTk0MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMTg0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMTc2MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY3LCAwLjAwMTY4MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTYwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTUyNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTQ1NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTM4OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTMyMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTI2MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTIwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTE0NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTA5MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMTA0MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMDk5MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMDk0NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMDkwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMDg2MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY4LCAwLjAwMDgyMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDc4MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDc0NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDcxMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDY3NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDY0NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDYxNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDU4NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDU1OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDUzMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDUwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDQ4NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDQ2MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDQ0MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDQyMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDQwMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDM4MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDM2NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDM0NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDMzMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDMxNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDMwMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDI4NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDI3MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDI2MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDI0OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDIzNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDIyNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDIxNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDIwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE5NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE4NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE3NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE2OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE2MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE1NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE0NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDE0MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDEzMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDEyNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDEyMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDExNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDExMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDEwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDEwMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA5NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA5MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA4NywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA4MywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA3OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA3NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA3MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA2OCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA2NSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA2MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA1OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA1NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA1NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA1MSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA0OSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA0NiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA0NCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA0MiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDA0MCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAzMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAyMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAxMCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwOSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwOCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwNCwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMywgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMiwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbiAgWzIuMzk3NDY5LCAwLjAwMDAwMSwgMC4wMDAwMDAsIDAuMDAwMDAwXSxcbl07XG5cblxuLyoqIEB0eXBlIHtOdW1iZXJ9ICovXG5leHBvcnRzLk1BWF9SRV9XRUlHSFRTX1JFU09MVVRJT04gPSBleHBvcnRzLk1BWF9SRV9XRUlHSFRTLmxlbmd0aDtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgU291cmNlIG1vZGVsIHRvIHNwYXRpYWxpemUgYW4gYXVkaW8gYnVmZmVyLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgRGlyZWN0aXZpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuY29uc3QgQXR0ZW51YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuY29uc3QgRW5jb2RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgU291cmNlXG4gKiBAZGVzY3JpcHRpb24gU291cmNlIG1vZGVsIHRvIHNwYXRpYWxpemUgYW4gYXVkaW8gYnVmZmVyLlxuICogQHBhcmFtIHtSZXNvbmFuY2VBdWRpb30gc2NlbmUgQXNzb2NpYXRlZCB7QGxpbmsgUmVzb25hbmNlQXVkaW9cbiAqIFJlc29uYW5jZUF1ZGlvfSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5wb3NpdGlvblxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS4gRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMuZm9yd2FyZFxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgZm9yd2FyZCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRk9SV0FSRCBERUZBVUxUX0ZPUldBUkR9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMudXBcbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIHVwIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9VUCBERUZBVUxUX1VQfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1pbkRpc3RhbmNlXG4gKiBNaW4uIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRSBERUZBVUxUX01JTl9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhEaXN0YW5jZVxuICogTWF4LiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0UgREVGQVVMVF9NQVhfRElTVEFOQ0V9LlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucm9sbG9mZlxuICogUm9sbG9mZiBtb2RlbCB0byB1c2UsIGNob3NlbiBmcm9tIG9wdGlvbnMgaW5cbiAqIHtAbGlua2NvZGUgVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgQVRURU5VQVRJT05fUk9MTE9GRlN9LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkYgREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmdhaW4gSW5wdXQgZ2FpbiAobGluZWFyKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TT1VSQ0VfR0FJTiBERUZBVUxUX1NPVVJDRV9HQUlOfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFscGhhIERpcmVjdGl2aXR5IGFscGhhLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBIERFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEF9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2hhcnBuZXNzIERpcmVjdGl2aXR5IHNoYXJwbmVzcy4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1NcbiAqIERFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNvdXJjZVdpZHRoXG4gKiBTb3VyY2Ugd2lkdGggKGluIGRlZ3JlZXMpLiBXaGVyZSAwIGRlZ3JlZXMgaXMgYSBwb2ludCBzb3VyY2UgYW5kIDM2MCBkZWdyZWVzXG4gKiBpcyBhbiBvbW5pZGlyZWN0aW9uYWwgc291cmNlLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSCBERUZBVUxUX1NPVVJDRV9XSURUSH0uXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZShzY2VuZSwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBTb3VyY2VcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICpcbiAgICovXG5cbiAgLy8gVXNlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgYXJndW1lbnRzLlxuICBpZiAob3B0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5wb3NpdGlvbiA9IFV0aWxzLkRFRkFVTFRfUE9TSVRJT04uc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3J3YXJkID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZm9yd2FyZCA9IFV0aWxzLkRFRkFVTFRfRk9SV0FSRC5zbGljZSgpO1xuICB9XG4gIGlmIChvcHRpb25zLnVwID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMudXAgPSBVdGlscy5ERUZBVUxUX1VQLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWluRGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5taW5EaXN0YW5jZSA9IFV0aWxzLkRFRkFVTFRfTUlOX0RJU1RBTkNFO1xuICB9XG4gIGlmIChvcHRpb25zLm1heERpc3RhbmNlID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWF4RGlzdGFuY2UgPSBVdGlscy5ERUZBVUxUX01BWF9ESVNUQU5DRTtcbiAgfVxuICBpZiAob3B0aW9ucy5yb2xsb2ZmID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMucm9sbG9mZiA9IFV0aWxzLkRFRkFVTFRfUk9MTE9GRjtcbiAgfVxuICBpZiAob3B0aW9ucy5nYWluID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZ2FpbiA9IFV0aWxzLkRFRkFVTFRfU09VUkNFX0dBSU47XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxwaGEgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5hbHBoYSA9IFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEE7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc2hhcnBuZXNzID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc2hhcnBuZXNzID0gVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1M7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGggPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IFV0aWxzLkRFRkFVTFRfU09VUkNFX1dJRFRIO1xuICB9XG5cbiAgLy8gTWVtYmVyIHZhcmlhYmxlcy5cbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgdGhpcy5fcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuICB0aGlzLl9mb3J3YXJkID0gb3B0aW9ucy5mb3J3YXJkO1xuICB0aGlzLl91cCA9IG9wdGlvbnMudXA7XG4gIHRoaXMuX2R4ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgdGhpcy5fcmlnaHQgPSBVdGlscy5jcm9zc1Byb2R1Y3QodGhpcy5fZm9yd2FyZCwgdGhpcy5fdXApO1xuXG4gIC8vIENyZWF0ZSBhdWRpbyBub2Rlcy5cbiAgbGV0IGNvbnRleHQgPSBzY2VuZS5fY29udGV4dDtcbiAgdGhpcy5pbnB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9kaXJlY3Rpdml0eSA9IG5ldyBEaXJlY3Rpdml0eShjb250ZXh0LCB7XG4gICAgYWxwaGE6IG9wdGlvbnMuYWxwaGEsXG4gICAgc2hhcnBuZXNzOiBvcHRpb25zLnNoYXJwbmVzcyxcbiAgfSk7XG4gIHRoaXMuX3RvRWFybHkgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fdG9MYXRlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2F0dGVudWF0aW9uID0gbmV3IEF0dGVudWF0aW9uKGNvbnRleHQsIHtcbiAgICBtaW5EaXN0YW5jZTogb3B0aW9ucy5taW5EaXN0YW5jZSxcbiAgICBtYXhEaXN0YW5jZTogb3B0aW9ucy5tYXhEaXN0YW5jZSxcbiAgICByb2xsb2ZmOiBvcHRpb25zLnJvbGxvZmYsXG4gIH0pO1xuICB0aGlzLl9lbmNvZGVyID0gbmV3IEVuY29kZXIoY29udGV4dCwge1xuICAgIGFtYmlzb25pY09yZGVyOiBzY2VuZS5fYW1iaXNvbmljT3JkZXIsXG4gICAgc291cmNlV2lkdGg6IG9wdGlvbnMuc291cmNlV2lkdGgsXG4gIH0pO1xuXG4gIC8vIENvbm5lY3Qgbm9kZXMuXG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl90b0xhdGUpO1xuICB0aGlzLl90b0xhdGUuY29ubmVjdChzY2VuZS5fcm9vbS5sYXRlLmlucHV0KTtcblxuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fYXR0ZW51YXRpb24uaW5wdXQpO1xuICB0aGlzLl9hdHRlbnVhdGlvbi5vdXRwdXQuY29ubmVjdCh0aGlzLl90b0Vhcmx5KTtcbiAgdGhpcy5fdG9FYXJseS5jb25uZWN0KHNjZW5lLl9yb29tLmVhcmx5LmlucHV0KTtcblxuICB0aGlzLl9hdHRlbnVhdGlvbi5vdXRwdXQuY29ubmVjdCh0aGlzLl9kaXJlY3Rpdml0eS5pbnB1dCk7XG4gIHRoaXMuX2RpcmVjdGl2aXR5Lm91dHB1dC5jb25uZWN0KHRoaXMuX2VuY29kZXIuaW5wdXQpO1xuXG4gIHRoaXMuX2VuY29kZXIub3V0cHV0LmNvbm5lY3Qoc2NlbmUuX2xpc3RlbmVyLmlucHV0KTtcblxuICAvLyBBc3NpZ24gaW5pdGlhbCBjb25kaXRpb25zLlxuICB0aGlzLnNldFBvc2l0aW9uKFxuICAgIG9wdGlvbnMucG9zaXRpb25bMF0sIG9wdGlvbnMucG9zaXRpb25bMV0sIG9wdGlvbnMucG9zaXRpb25bMl0pO1xuICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSBvcHRpb25zLmdhaW47XG59O1xuXG5cbi8qKlxuICogU2V0IHNvdXJjZSdzIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIC8vIEFzc2lnbiBuZXcgcG9zaXRpb24uXG4gIHRoaXMuX3Bvc2l0aW9uWzBdID0geDtcbiAgdGhpcy5fcG9zaXRpb25bMV0gPSB5O1xuICB0aGlzLl9wb3NpdGlvblsyXSA9IHo7XG5cbiAgLy8gSGFuZGxlIGZhci1maWVsZCBlZmZlY3QuXG4gIGxldCBkaXN0YW5jZSA9IHRoaXMuX3NjZW5lLl9yb29tLmdldERpc3RhbmNlT3V0c2lkZVJvb20oXG4gICAgdGhpcy5fcG9zaXRpb25bMF0sIHRoaXMuX3Bvc2l0aW9uWzFdLCB0aGlzLl9wb3NpdGlvblsyXSk7XG4gICAgbGV0IGdhaW4gPSBfY29tcHV0ZURpc3RhbmNlT3V0c2lkZVJvb20oZGlzdGFuY2UpO1xuICB0aGlzLl90b0xhdGUuZ2Fpbi52YWx1ZSA9IGdhaW47XG4gIHRoaXMuX3RvRWFybHkuZ2Fpbi52YWx1ZSA9IGdhaW47XG5cbiAgdGhpcy5fdXBkYXRlKCk7XG59O1xuXG5cbi8vIFVwZGF0ZSB0aGUgc291cmNlIHdoZW4gY2hhbmdpbmcgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24uXG5Tb3VyY2UucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB0byBsaXN0ZW5lci5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0aGlzLl9keFtpXSA9IHRoaXMuX3Bvc2l0aW9uW2ldIC0gdGhpcy5fc2NlbmUuX2xpc3RlbmVyLnBvc2l0aW9uW2ldO1xuICB9XG4gIGxldCBkaXN0YW5jZSA9IE1hdGguc3FydCh0aGlzLl9keFswXSAqIHRoaXMuX2R4WzBdICtcbiAgICB0aGlzLl9keFsxXSAqIHRoaXMuX2R4WzFdICsgdGhpcy5fZHhbMl0gKiB0aGlzLl9keFsyXSk7XG4gIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAvLyBOb3JtYWxpemUgZGlyZWN0aW9uIHZlY3Rvci5cbiAgICB0aGlzLl9keFswXSAvPSBkaXN0YW5jZTtcbiAgICB0aGlzLl9keFsxXSAvPSBkaXN0YW5jZTtcbiAgICB0aGlzLl9keFsyXSAvPSBkaXN0YW5jZTtcbiAgfVxuXG4gIC8vIENvbXB1ZXRlIGFuZ2xlIG9mIGRpcmVjdGlvbiB2ZWN0b3IuXG4gIGxldCBhemltdXRoID0gTWF0aC5hdGFuMigtdGhpcy5fZHhbMF0sIHRoaXMuX2R4WzJdKSAqXG4gICAgVXRpbHMuUkFESUFOU19UT19ERUdSRUVTO1xuICBsZXQgZWxldmF0aW9uID0gTWF0aC5hdGFuMih0aGlzLl9keFsxXSwgTWF0aC5zcXJ0KHRoaXMuX2R4WzBdICogdGhpcy5fZHhbMF0gK1xuICAgIHRoaXMuX2R4WzJdICogdGhpcy5fZHhbMl0pKSAqIFV0aWxzLlJBRElBTlNfVE9fREVHUkVFUztcblxuICAvLyBTZXQgZGlzdGFuY2UvZGlyZWN0aXZpdHkvZGlyZWN0aW9uIHZhbHVlcy5cbiAgdGhpcy5fYXR0ZW51YXRpb24uc2V0RGlzdGFuY2UoZGlzdGFuY2UpO1xuICB0aGlzLl9kaXJlY3Rpdml0eS5jb21wdXRlQW5nbGUodGhpcy5fZm9yd2FyZCwgdGhpcy5fZHgpO1xuICB0aGlzLl9lbmNvZGVyLnNldERpcmVjdGlvbihhemltdXRoLCBlbGV2YXRpb24pO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyByb2xsb2ZmLlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGxvZmZcbiAqIFJvbGxvZmYgbW9kZWwgdG8gdXNlLCBjaG9zZW4gZnJvbSBvcHRpb25zIGluXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTIEFUVEVOVUFUSU9OX1JPTExPRkZTfS5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRSb2xsb2ZmID0gZnVuY3Rpb24ocm9sbG9mZikge1xuICB0aGlzLl9hdHRlbnVhdGlvbi5zZXRSb2xsb2ZmKHJvbGxvZmYpO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBtaW5pbXVtIGRpc3RhbmNlIChpbiBtZXRlcnMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkRpc3RhbmNlXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0TWluRGlzdGFuY2UgPSBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuICB0aGlzLl9hdHRlbnVhdGlvbi5taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBtYXhpbXVtIGRpc3RhbmNlIChpbiBtZXRlcnMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RhbmNlXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0TWF4RGlzdGFuY2UgPSBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuICB0aGlzLl9hdHRlbnVhdGlvbi5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xufTtcblxuXG4vKipcbiAqIFNldCBzb3VyY2UncyBnYWluIChsaW5lYXIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IGdhaW5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRHYWluID0gZnVuY3Rpb24oZ2Fpbikge1xuICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSBnYWluO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc291cmNlJ3Mgb3JpZW50YXRpb24gdXNpbmcgZm9yd2FyZCBhbmQgdXAgdmVjdG9ycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWFxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRZXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFpcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFhcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFlcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFpcbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKGZvcndhcmRYLCBmb3J3YXJkWSwgZm9yd2FyZFosXG4gICAgdXBYLCB1cFksIHVwWikge1xuICB0aGlzLl9mb3J3YXJkWzBdID0gZm9yd2FyZFg7XG4gIHRoaXMuX2ZvcndhcmRbMV0gPSBmb3J3YXJkWTtcbiAgdGhpcy5fZm9yd2FyZFsyXSA9IGZvcndhcmRaO1xuICB0aGlzLl91cFswXSA9IHVwWDtcbiAgdGhpcy5fdXBbMV0gPSB1cFk7XG4gIHRoaXMuX3VwWzJdID0gdXBaO1xuICB0aGlzLl9yaWdodCA9IFV0aWxzLmNyb3NzUHJvZHVjdCh0aGlzLl9mb3J3YXJkLCB0aGlzLl91cCk7XG59O1xuXG5cbi8vIFRPRE8oYml0bGxhbWEpOiBNYWtlIHN1cmUgdGhpcyB3b3JrcyB3aXRoIFRocmVlLmpzIGFzIGludGVuZGVkLlxuLyoqXG4gKiBTZXQgc291cmNlJ3MgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIHVzaW5nIGFcbiAqIFRocmVlLmpzIG1vZGVsVmlld01hdHJpeCBvYmplY3QuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gbWF0cml4NFxuICogVGhlIE1hdHJpeDQgcmVwcmVzZW50aW5nIHRoZSBvYmplY3QgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGluIHdvcmxkIHNwYWNlLlxuICovXG5Tb3VyY2UucHJvdG90eXBlLnNldEZyb21NYXRyaXggPSBmdW5jdGlvbihtYXRyaXg0KSB7XG4gIHRoaXMuX3JpZ2h0WzBdID0gbWF0cml4NC5lbGVtZW50c1swXTtcbiAgdGhpcy5fcmlnaHRbMV0gPSBtYXRyaXg0LmVsZW1lbnRzWzFdO1xuICB0aGlzLl9yaWdodFsyXSA9IG1hdHJpeDQuZWxlbWVudHNbMl07XG4gIHRoaXMuX3VwWzBdID0gbWF0cml4NC5lbGVtZW50c1s0XTtcbiAgdGhpcy5fdXBbMV0gPSBtYXRyaXg0LmVsZW1lbnRzWzVdO1xuICB0aGlzLl91cFsyXSA9IG1hdHJpeDQuZWxlbWVudHNbNl07XG4gIHRoaXMuX2ZvcndhcmRbMF0gPSBtYXRyaXg0LmVsZW1lbnRzWzhdO1xuICB0aGlzLl9mb3J3YXJkWzFdID0gbWF0cml4NC5lbGVtZW50c1s5XTtcbiAgdGhpcy5fZm9yd2FyZFsyXSA9IG1hdHJpeDQuZWxlbWVudHNbMTBdO1xuXG4gIC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgc2NhbGluZy5cbiAgdGhpcy5fcmlnaHQgPSBVdGlscy5ub3JtYWxpemVWZWN0b3IodGhpcy5fcmlnaHQpO1xuICB0aGlzLl91cCA9IFV0aWxzLm5vcm1hbGl6ZVZlY3Rvcih0aGlzLl91cCk7XG4gIHRoaXMuX2ZvcndhcmQgPSBVdGlscy5ub3JtYWxpemVWZWN0b3IodGhpcy5fZm9yd2FyZCk7XG5cbiAgLy8gVXBkYXRlIHBvc2l0aW9uLlxuICB0aGlzLnNldFBvc2l0aW9uKFxuICAgIG1hdHJpeDQuZWxlbWVudHNbMTJdLCBtYXRyaXg0LmVsZW1lbnRzWzEzXSwgbWF0cml4NC5lbGVtZW50c1sxNF0pO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIHdpZHRoIChpbiBkZWdyZWVzKS4gV2hlcmUgMCBkZWdyZWVzIGlzIGEgcG9pbnQgc291cmNlIGFuZCAzNjBcbiAqIGRlZ3JlZXMgaXMgYW4gb21uaWRpcmVjdGlvbmFsIHNvdXJjZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VXaWR0aCAoaW4gZGVncmVlcykuXG4gKi9cblNvdXJjZS5wcm90b3R5cGUuc2V0U291cmNlV2lkdGggPSBmdW5jdGlvbihzb3VyY2VXaWR0aCkge1xuICB0aGlzLl9lbmNvZGVyLnNldFNvdXJjZVdpZHRoKHNvdXJjZVdpZHRoKTtcbiAgdGhpcy5zZXRQb3NpdGlvbih0aGlzLl9wb3NpdGlvblswXSwgdGhpcy5fcG9zaXRpb25bMV0sIHRoaXMuX3Bvc2l0aW9uWzJdKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgZGlyZWN0aXZpdHkgcGF0dGVybiAoZGVmaW5lZCBieSBhbHBoYSksIHdoZXJlIDAgaXMgYW5cbiAqIG9tbmlkaXJlY3Rpb25hbCBwYXR0ZXJuLCAxIGlzIGEgYmlkaXJlY3Rpb25hbCBwYXR0ZXJuLCAwLjUgaXMgYSBjYXJkaW9kXG4gKiBwYXR0ZXJuLiBUaGUgc2hhcnBuZXNzIG9mIHRoZSBwYXR0ZXJuIGlzIGluY3JlYXNlZCBleHBvbmVudGlhbGx5LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhXG4gKiBEZXRlcm1pbmVzIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDAgdG8gMSkuXG4gKiBAcGFyYW0ge051bWJlcn0gc2hhcnBuZXNzXG4gKiBEZXRlcm1pbmVzIHRoZSBzaGFycG5lc3Mgb2YgdGhlIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDEgdG8gSW5mKS5cbiAqL1xuU291cmNlLnByb3RvdHlwZS5zZXREaXJlY3Rpdml0eVBhdHRlcm4gPSBmdW5jdGlvbihhbHBoYSwgc2hhcnBuZXNzKSB7XG4gIHRoaXMuX2RpcmVjdGl2aXR5LnNldFBhdHRlcm4oYWxwaGEsIHNoYXJwbmVzcyk7XG4gIHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcG9zaXRpb25bMF0sIHRoaXMuX3Bvc2l0aW9uWzFdLCB0aGlzLl9wb3NpdGlvblsyXSk7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBhIHNvdXJjZSBpcyBvdXRzaWRlIG9mIGEgcm9vbS4gQXR0ZW51YXRlIGdhaW4gZ29pbmdcbiAqIHRvIHRoZSByZWZsZWN0aW9ucyBhbmQgcmV2ZXJiIHdoZW4gdGhlIHNvdXJjZSBpcyBvdXRzaWRlIG9mIHRoZSByb29tLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIERpc3RhbmNlIGluIG1ldGVycy5cbiAqIEByZXR1cm4ge051bWJlcn0gR2FpbiAobGluZWFyKSBvZiBzb3VyY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfY29tcHV0ZURpc3RhbmNlT3V0c2lkZVJvb20oZGlzdGFuY2UpIHtcbiAgLy8gV2UgYXBwbHkgYSBsaW5lYXIgcmFtcCBmcm9tIDEgdG8gMCBhcyB0aGUgc291cmNlIGlzIHVwIHRvIDFtIG91dHNpZGUuXG4gIGxldCBnYWluID0gMTtcbiAgaWYgKGRpc3RhbmNlID4gVXRpbHMuRVBTSUxPTl9GTE9BVCkge1xuICAgIGdhaW4gPSAxIC0gZGlzdGFuY2UgLyBVdGlscy5TT1VSQ0VfTUFYX09VVFNJREVfUk9PTV9ESVNUQU5DRTtcblxuICAgIC8vIENsYW1wIGdhaW4gYmV0d2VlbiAwIGFuZCAxLlxuICAgIGdhaW4gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBnYWluKSk7XG4gIH1cbiAgcmV0dXJuIGdhaW47XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2U7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIERpcmVjdGl2aXR5L29jY2x1c2lvbiBmaWx0ZXIuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuLy8gSW50ZXJuYWwgZGVwZW5kZW5jaWVzLlxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQGNsYXNzIERpcmVjdGl2aXR5XG4gKiBAZGVzY3JpcHRpb24gRGlyZWN0aXZpdHkvb2NjbHVzaW9uIGZpbHRlci5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFscGhhXG4gKiBEZXRlcm1pbmVzIGRpcmVjdGl2aXR5IHBhdHRlcm4gKDAgdG8gMSkuIFNlZVxuICoge0BsaW5rIERpcmVjdGl2aXR5I3NldFBhdHRlcm4gc2V0UGF0dGVybn0gZm9yIG1vcmUgZGV0YWlscy4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9BTFBIQSBERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNoYXJwbmVzc1xuICogRGV0ZXJtaW5lcyB0aGUgc2hhcnBuZXNzIG9mIHRoZSBkaXJlY3Rpdml0eSBwYXR0ZXJuICgxIHRvIEluZikuIFNlZVxuICoge0BsaW5rIERpcmVjdGl2aXR5I3NldFBhdHRlcm4gc2V0UGF0dGVybn0gZm9yIG1vcmUgZGV0YWlscy4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1NcbiAqIERFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTfS5cbiAqL1xuZnVuY3Rpb24gRGlyZWN0aXZpdHkoY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBEaXJlY3Rpdml0eVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgRGlyZWN0aXZpdHlcbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLmFscGhhID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuYWxwaGEgPSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBO1xuICB9XG4gIGlmIChvcHRpb25zLnNoYXJwbmVzcyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNoYXJwbmVzcyA9IFV0aWxzLkRFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGF1ZGlvIG5vZGUuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9sb3dwYXNzID0gY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblxuICAvLyBJbml0aWFsaXplIGZpbHRlciBjb2VmZmljaWVudHMuXG4gIHRoaXMuX2xvd3Bhc3MudHlwZSA9ICdsb3dwYXNzJztcbiAgdGhpcy5fbG93cGFzcy5RLnZhbHVlID0gMDtcbiAgdGhpcy5fbG93cGFzcy5mcmVxdWVuY3kudmFsdWUgPSBjb250ZXh0LnNhbXBsZVJhdGUgKiAwLjU7XG5cbiAgdGhpcy5fY29zVGhldGEgPSAwO1xuICB0aGlzLnNldFBhdHRlcm4ob3B0aW9ucy5hbHBoYSwgb3B0aW9ucy5zaGFycG5lc3MpO1xuXG4gIC8vIElucHV0L091dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2xvd3Bhc3M7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fbG93cGFzcztcbn1cblxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGZpbHRlciB1c2luZyB0aGUgc291cmNlJ3MgZm9yd2FyZCBvcmllbnRhdGlvbiBhbmQgdGhlIGxpc3RlbmVyJ3NcbiAqIHBvc2l0aW9uLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGZvcndhcmQgVGhlIHNvdXJjZSdzIGZvcndhcmQgdmVjdG9yLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uIGZyb20gdGhlIHNvdXJjZSB0byB0aGVcbiAqIGxpc3RlbmVyLlxuICovXG5EaXJlY3Rpdml0eS5wcm90b3R5cGUuY29tcHV0ZUFuZ2xlID0gZnVuY3Rpb24oZm9yd2FyZCwgZGlyZWN0aW9uKSB7XG4gIGxldCBmb3J3YXJkTm9ybSA9IFV0aWxzLm5vcm1hbGl6ZVZlY3Rvcihmb3J3YXJkKTtcbiAgbGV0IGRpcmVjdGlvbk5vcm0gPSBVdGlscy5ub3JtYWxpemVWZWN0b3IoZGlyZWN0aW9uKTtcbiAgbGV0IGNvZWZmID0gMTtcbiAgaWYgKHRoaXMuX2FscGhhID4gVXRpbHMuRVBTSUxPTl9GTE9BVCkge1xuICAgIGxldCBjb3NUaGV0YSA9IGZvcndhcmROb3JtWzBdICogZGlyZWN0aW9uTm9ybVswXSArXG4gICAgICBmb3J3YXJkTm9ybVsxXSAqIGRpcmVjdGlvbk5vcm1bMV0gKyBmb3J3YXJkTm9ybVsyXSAqIGRpcmVjdGlvbk5vcm1bMl07XG4gICAgY29lZmYgPSAoMSAtIHRoaXMuX2FscGhhKSArIHRoaXMuX2FscGhhICogY29zVGhldGE7XG4gICAgY29lZmYgPSBNYXRoLnBvdyhNYXRoLmFicyhjb2VmZiksIHRoaXMuX3NoYXJwbmVzcyk7XG4gIH1cbiAgdGhpcy5fbG93cGFzcy5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLl9jb250ZXh0LnNhbXBsZVJhdGUgKiAwLjUgKiBjb2VmZjtcbn07XG5cblxuLyoqXG4gKiBTZXQgc291cmNlJ3MgZGlyZWN0aXZpdHkgcGF0dGVybiAoZGVmaW5lZCBieSBhbHBoYSksIHdoZXJlIDAgaXMgYW5cbiAqIG9tbmlkaXJlY3Rpb25hbCBwYXR0ZXJuLCAxIGlzIGEgYmlkaXJlY3Rpb25hbCBwYXR0ZXJuLCAwLjUgaXMgYSBjYXJkaW9kXG4gKiBwYXR0ZXJuLiBUaGUgc2hhcnBuZXNzIG9mIHRoZSBwYXR0ZXJuIGlzIGluY3JlYXNlZCBleHBvbmVuZW50aWFsbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcbiAqIERldGVybWluZXMgZGlyZWN0aXZpdHkgcGF0dGVybiAoMCB0byAxKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzaGFycG5lc3NcbiAqIERldGVybWluZXMgdGhlIHNoYXJwbmVzcyBvZiB0aGUgZGlyZWN0aXZpdHkgcGF0dGVybiAoMSB0byBJbmYpLlxuICogREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1N9LlxuICovXG5EaXJlY3Rpdml0eS5wcm90b3R5cGUuc2V0UGF0dGVybiA9IGZ1bmN0aW9uKGFscGhhLCBzaGFycG5lc3MpIHtcbiAgLy8gQ2xhbXAgYW5kIHNldCB2YWx1ZXMuXG4gIHRoaXMuX2FscGhhID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgYWxwaGEpKTtcbiAgdGhpcy5fc2hhcnBuZXNzID0gTWF0aC5tYXgoMSwgc2hhcnBuZXNzKTtcblxuICAvLyBVcGRhdGUgYW5nbGUgY2FsY3VsYXRpb24gdXNpbmcgbmV3IHZhbHVlcy5cbiAgdGhpcy5jb21wdXRlQW5nbGUoW3RoaXMuX2Nvc1RoZXRhICogdGhpcy5fY29zVGhldGEsIDAsIDBdLCBbMSwgMCwgMF0pO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdGl2aXR5O1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBEaXN0YW5jZS1iYXNlZCBhdHRlbnVhdGlvbiBmaWx0ZXIuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgQXR0ZW51YXRpb25cbiAqIEBkZXNjcmlwdGlvbiBEaXN0YW5jZS1iYXNlZCBhdHRlbnVhdGlvbiBmaWx0ZXIuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5taW5EaXN0YW5jZVxuICogTWluLiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0UgREVGQVVMVF9NSU5fRElTVEFOQ0V9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMubWF4RGlzdGFuY2VcbiAqIE1heC4gZGlzdGFuY2UgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFIERFRkFVTFRfTUFYX0RJU1RBTkNFfS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnJvbGxvZmZcbiAqIFJvbGxvZmYgbW9kZWwgdG8gdXNlLCBjaG9zZW4gZnJvbSBvcHRpb25zIGluXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTIEFUVEVOVUFUSU9OX1JPTExPRkZTfS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGIERFRkFVTFRfQVRURU5VQVRJT05fUk9MTE9GRn0uXG4gKi9cbmZ1bmN0aW9uIEF0dGVudWF0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgLy8gUHVibGljIHZhcmlhYmxlcy5cbiAgLyoqXG4gICAqIE1pbi4gZGlzdGFuY2UgKGluIG1ldGVycykuXG4gICAqIEBtZW1iZXIge051bWJlcn0gbWluRGlzdGFuY2VcbiAgICogQG1lbWJlcm9mIEF0dGVudWF0aW9uXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1heC4gZGlzdGFuY2UgKGluIG1ldGVycykuXG4gICAqIEBtZW1iZXIge051bWJlcn0gbWF4RGlzdGFuY2VcbiAgICogQG1lbWJlcm9mIEF0dGVudWF0aW9uXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIE1vbm8gKDEtY2hhbm5lbCkgaW5wdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBpbnB1dFxuICAgKiBAbWVtYmVyb2YgQXR0ZW51YXRpb25cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIEF0dGVudWF0aW9uXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5taW5EaXN0YW5jZSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1pbkRpc3RhbmNlID0gVXRpbHMuREVGQVVMVF9NSU5fRElTVEFOQ0U7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4RGlzdGFuY2UgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5tYXhEaXN0YW5jZSA9IFV0aWxzLkRFRkFVTFRfTUFYX0RJU1RBTkNFO1xuICB9XG4gIGlmIChvcHRpb25zLnJvbGxvZmYgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5yb2xsb2ZmID0gVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGO1xuICB9XG5cbiAgLy8gQXNzaWduIHZhbHVlcy5cbiAgdGhpcy5taW5EaXN0YW5jZSA9IG9wdGlvbnMubWluRGlzdGFuY2U7XG4gIHRoaXMubWF4RGlzdGFuY2UgPSBvcHRpb25zLm1heERpc3RhbmNlO1xuICB0aGlzLnNldFJvbGxvZmYob3B0aW9ucy5yb2xsb2ZmKTtcblxuICAvLyBDcmVhdGUgbm9kZS5cbiAgdGhpcy5fZ2Fpbk5vZGUgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIHRvIG1heCBkaXN0YW5jZS5cbiAgdGhpcy5zZXREaXN0YW5jZShvcHRpb25zLm1heERpc3RhbmNlKTtcblxuICAvLyBJbnB1dC9PdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9nYWluTm9kZTtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9nYWluTm9kZTtcbn1cblxuXG4vKipcbiAqIFNldCBkaXN0YW5jZSBmcm9tIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBEaXN0YW5jZSAoaW4gbWV0ZXJzKS5cbiAqL1xuQXR0ZW51YXRpb24ucHJvdG90eXBlLnNldERpc3RhbmNlID0gZnVuY3Rpb24oZGlzdGFuY2UpIHtcbiAgbGV0IGdhaW4gPSAxO1xuICBpZiAodGhpcy5fcm9sbG9mZiA9PSAnbG9nYXJpdGhtaWMnKSB7XG4gICAgaWYgKGRpc3RhbmNlID4gdGhpcy5tYXhEaXN0YW5jZSkge1xuICAgICAgZ2FpbiA9IDA7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA+IHRoaXMubWluRGlzdGFuY2UpIHtcbiAgICAgIGxldCByYW5nZSA9IHRoaXMubWF4RGlzdGFuY2UgLSB0aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgaWYgKHJhbmdlID4gVXRpbHMuRVBTSUxPTl9GTE9BVCkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBkaXN0YW5jZSBhdHRlbnVhdGlvbiB2YWx1ZSBieSB0aGUgbG9nYXJpdGhtaWMgY3VydmVcbiAgICAgICAgLy8gXCIxIC8gKGQgKyAxKVwiIHdpdGggYW4gb2Zmc2V0IG9mIHxtaW5EaXN0YW5jZXwuXG4gICAgICAgIGxldCByZWxhdGl2ZURpc3RhbmNlID0gZGlzdGFuY2UgLSB0aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgICBsZXQgYXR0ZW51YXRpb24gPSAxIC8gKHJlbGF0aXZlRGlzdGFuY2UgKyAxKTtcbiAgICAgICAgbGV0IGF0dGVudWF0aW9uTWF4ID0gMSAvIChyYW5nZSArIDEpO1xuICAgICAgICBnYWluID0gKGF0dGVudWF0aW9uIC0gYXR0ZW51YXRpb25NYXgpIC8gKDEgLSBhdHRlbnVhdGlvbk1heCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuX3JvbGxvZmYgPT0gJ2xpbmVhcicpIHtcbiAgICBpZiAoZGlzdGFuY2UgPiB0aGlzLm1heERpc3RhbmNlKSB7XG4gICAgICBnYWluID0gMDtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID4gdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgbGV0IHJhbmdlID0gdGhpcy5tYXhEaXN0YW5jZSAtIHRoaXMubWluRGlzdGFuY2U7XG4gICAgICBpZiAocmFuZ2UgPiBVdGlscy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgICAgIGdhaW4gPSAodGhpcy5tYXhEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHJhbmdlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLl9nYWluTm9kZS5nYWluLnZhbHVlID0gZ2Fpbjtcbn07XG5cblxuLyoqXG4gKiBTZXQgcm9sbG9mZi5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb2xsb2ZmXG4gKiBSb2xsb2ZmIG1vZGVsIHRvIHVzZSwgY2hvc2VuIGZyb20gb3B0aW9ucyBpblxuICoge0BsaW5rY29kZSBVdGlscy5BVFRFTlVBVElPTl9ST0xMT0ZGUyBBVFRFTlVBVElPTl9ST0xMT0ZGU30uXG4gKi9cbkF0dGVudWF0aW9uLnByb3RvdHlwZS5zZXRSb2xsb2ZmID0gZnVuY3Rpb24ocm9sbG9mZikge1xuICBsZXQgaXNWYWxpZE1vZGVsID0gflV0aWxzLkFUVEVOVUFUSU9OX1JPTExPRkZTLmluZGV4T2Yocm9sbG9mZik7XG4gIGlmIChyb2xsb2ZmID09IHVuZGVmaW5lZCB8fCAhaXNWYWxpZE1vZGVsKSB7XG4gICAgaWYgKCFpc1ZhbGlkTW9kZWwpIHtcbiAgICAgIFV0aWxzLmxvZygnSW52YWxpZCByb2xsb2ZmIG1vZGVsIChcXFwiJyArIHJvbGxvZmYgK1xuICAgICAgICAnXFxcIikuIFVzaW5nIGRlZmF1bHQ6IFxcXCInICsgVXRpbHMuREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGICsgJ1xcXCIuJyk7XG4gICAgfVxuICAgIHJvbGxvZmYgPSBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkY7XG4gIH0gZWxzZSB7XG4gICAgcm9sbG9mZiA9IHJvbGxvZmYudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIHRoaXMuX3JvbGxvZmYgPSByb2xsb2ZmO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dGVudWF0aW9uO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBDb21wbGV0ZSByb29tIG1vZGVsIHdpdGggZWFybHkgYW5kIGxhdGUgcmVmbGVjdGlvbnMuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBMYXRlUmVmbGVjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuY29uc3QgRWFybHlSZWZsZWN0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhYnNvcnB0aW9uIGNvZWZmaWNpZW50cyBmcm9tIG1hdGVyaWFsIG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IG1hdGVyaWFsc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZ2V0Q29lZmZpY2llbnRzRnJvbU1hdGVyaWFscyhtYXRlcmlhbHMpIHtcbiAgLy8gSW5pdGlhbGl6ZSBjb2VmZmljaWVudHMgdG8gdXNlIGRlZmF1bHRzLlxuICBsZXQgY29lZmZpY2llbnRzID0ge307XG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIGNvZWZmaWNpZW50c1twcm9wZXJ0eV0gPSBVdGlscy5ST09NX01BVEVSSUFMX0NPRUZGSUNJRU5UU1tcbiAgICAgICAgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMU1twcm9wZXJ0eV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhbml0aXplIG1hdGVyaWFscy5cbiAgaWYgKG1hdGVyaWFscyA9PSB1bmRlZmluZWQpIHtcbiAgICBtYXRlcmlhbHMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG1hdGVyaWFscywgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyk7XG4gIH1cblxuICAvLyBBc3NpZ24gY29lZmZpY2llbnRzIHVzaW5nIHByb3ZpZGVkIG1hdGVyaWFscy5cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJlxuICAgICAgICBtYXRlcmlhbHMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICBpZiAobWF0ZXJpYWxzW3Byb3BlcnR5XSBpbiBVdGlscy5ST09NX01BVEVSSUFMX0NPRUZGSUNJRU5UUykge1xuICAgICAgICBjb2VmZmljaWVudHNbcHJvcGVydHldID1cbiAgICAgICAgICBVdGlscy5ST09NX01BVEVSSUFMX0NPRUZGSUNJRU5UU1ttYXRlcmlhbHNbcHJvcGVydHldXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLmxvZygnTWF0ZXJpYWwgXFxcIicgKyBtYXRlcmlhbHNbcHJvcGVydHldICsgJ1xcXCIgb24gd2FsbCBcXFwiJyArXG4gICAgICAgICAgcHJvcGVydHkgKyAnXFxcIiBub3QgZm91bmQuIFVzaW5nIFxcXCInICtcbiAgICAgICAgICBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTW3Byb3BlcnR5XSArICdcXFwiLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy5sb2coJ1dhbGwgXFxcIicgKyBwcm9wZXJ0eSArICdcXFwiIGlzIG5vdCBkZWZpbmVkLiBEZWZhdWx0IHVzZWQuJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb2VmZmljaWVudHM7XG59XG5cbi8qKlxuICogU2FuaXRpemUgY29lZmZpY2llbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvZWZmaWNpZW50c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfc2FuaXRpemVDb2VmZmljaWVudHMoY29lZmZpY2llbnRzKSB7XG4gIGlmIChjb2VmZmljaWVudHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgY29lZmZpY2llbnRzID0ge307XG4gIH1cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUykge1xuICAgIGlmICghKGNvZWZmaWNpZW50cy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpKSB7XG4gICAgICAvLyBJZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50LCB1c2UgZGVmYXVsdCBjb2VmZmljaWVudHMuXG4gICAgICBjb2VmZmljaWVudHNbcHJvcGVydHldID0gVXRpbHMuUk9PTV9NQVRFUklBTF9DT0VGRklDSUVOVFNbXG4gICAgICAgIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFNbcHJvcGVydHldXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZWZmaWNpZW50cztcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBkaW1lbnNpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplRGltZW5zaW9ucyhkaW1lbnNpb25zKSB7XG4gIGlmIChkaW1lbnNpb25zID09IHVuZGVmaW5lZCkge1xuICAgIGRpbWVuc2lvbnMgPSB7fTtcbiAgfVxuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUykge1xuICAgIGlmICghKGRpbWVuc2lvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSkge1xuICAgICAgZGltZW5zaW9uc1twcm9wZXJ0eV0gPSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OU1twcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIHJldHVybiBkaW1lbnNpb25zO1xufVxuXG4vKipcbiAqIENvbXB1dGUgZnJlcXVlbmN5LWRlcGVuZGVudCByZXZlcmIgZHVyYXRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2VmZmljaWVudHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZE9mU291bmRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBfZ2V0RHVyYXRpb25zRnJvbVByb3BlcnRpZXMoZGltZW5zaW9ucywgY29lZmZpY2llbnRzLCBzcGVlZE9mU291bmQpIHtcbiAgbGV0IGR1cmF0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMpO1xuXG4gIC8vIFNhbml0aXplIGlucHV0cy5cbiAgZGltZW5zaW9ucyA9IF9zYW5pdGl6ZURpbWVuc2lvbnMoZGltZW5zaW9ucyk7XG4gIGNvZWZmaWNpZW50cyA9IF9zYW5pdGl6ZUNvZWZmaWNpZW50cyhjb2VmZmljaWVudHMpO1xuICBpZiAoc3BlZWRPZlNvdW5kID09IHVuZGVmaW5lZCkge1xuICAgIHNwZWVkT2ZTb3VuZCA9IFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQ7XG4gIH1cblxuICAvLyBBY291c3RpYyBjb25zdGFudC5cbiAgbGV0IGsgPSBVdGlscy5UV0VOVFlfRk9VUl9MT0cxMCAvIHNwZWVkT2ZTb3VuZDtcblxuICAvLyBDb21wdXRlIHZvbHVtZSwgc2tpcCBpZiByb29tIGlzIG5vdCBwcmVzZW50LlxuICBsZXQgdm9sdW1lID0gZGltZW5zaW9ucy53aWR0aCAqIGRpbWVuc2lvbnMuaGVpZ2h0ICogZGltZW5zaW9ucy5kZXB0aDtcbiAgaWYgKHZvbHVtZSA8IFV0aWxzLlJPT01fTUlOX1ZPTFVNRSkge1xuICAgIHJldHVybiBkdXJhdGlvbnM7XG4gIH1cblxuICAvLyBSb29tIHN1cmZhY2UgYXJlYS5cbiAgbGV0IGxlZnRSaWdodEFyZWEgPSBkaW1lbnNpb25zLndpZHRoICogZGltZW5zaW9ucy5oZWlnaHQ7XG4gIGxldCBmbG9vckNlaWxpbmdBcmVhID0gZGltZW5zaW9ucy53aWR0aCAqIGRpbWVuc2lvbnMuZGVwdGg7XG4gIGxldCBmcm9udEJhY2tBcmVhID0gZGltZW5zaW9ucy5kZXB0aCAqIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICBsZXQgdG90YWxBcmVhID0gMiAqIChsZWZ0UmlnaHRBcmVhICsgZmxvb3JDZWlsaW5nQXJlYSArIGZyb250QmFja0FyZWEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IFV0aWxzLk5VTUJFUl9SRVZFUkJfRlJFUVVFTkNZX0JBTkRTOyBpKyspIHtcbiAgICAvLyBFZmZlY3RpdmUgYWJzb3JwdGl2ZSBhcmVhLlxuICAgIGxldCBhYnNvcmJ0aW9uQXJlYSA9XG4gICAgICAoY29lZmZpY2llbnRzLmxlZnRbaV0gKyBjb2VmZmljaWVudHMucmlnaHRbaV0pICogbGVmdFJpZ2h0QXJlYSArXG4gICAgICAoY29lZmZpY2llbnRzLmRvd25baV0gKyBjb2VmZmljaWVudHMudXBbaV0pICogZmxvb3JDZWlsaW5nQXJlYSArXG4gICAgICAoY29lZmZpY2llbnRzLmZyb250W2ldICsgY29lZmZpY2llbnRzLmJhY2tbaV0pICogZnJvbnRCYWNrQXJlYTtcbiAgICBsZXQgbWVhbkFic29yYnRpb25BcmVhID0gYWJzb3JidGlvbkFyZWEgLyB0b3RhbEFyZWE7XG5cbiAgICAvLyBDb21wdXRlIHJldmVyYmVyYXRpb24gdXNpbmcgRXlyaW5nIGVxdWF0aW9uIFsxXS5cbiAgICAvLyBbMV0gQmVyYW5laywgTGVvIEwuIFwiQW5hbHlzaXMgb2YgU2FiaW5lIGFuZCBFeXJpbmcgZXF1YXRpb25zIGFuZCB0aGVpclxuICAgIC8vICAgICBhcHBsaWNhdGlvbiB0byBjb25jZXJ0IGhhbGwgYXVkaWVuY2UgYW5kIGNoYWlyIGFic29ycHRpb24uXCIgVGhlXG4gICAgLy8gICAgIEpvdXJuYWwgb2YgdGhlIEFjb3VzdGljYWwgU29jaWV0eSBvZiBBbWVyaWNhLCBWb2wuIDEyMCwgTm8uIDMuXG4gICAgLy8gICAgICgyMDA2KSwgcHAuIDEzOTktMTM5OS5cbiAgICBkdXJhdGlvbnNbaV0gPSBVdGlscy5ST09NX0VZUklOR19DT1JSRUNUSU9OX0NPRUZGSUNJRU5UICogayAqIHZvbHVtZSAvXG4gICAgICAoLXRvdGFsQXJlYSAqIE1hdGgubG9nKDEgLSBtZWFuQWJzb3JidGlvbkFyZWEpICsgNCAqXG4gICAgICBVdGlscy5ST09NX0FJUl9BQlNPUlBUSU9OX0NPRUZGSUNJRU5UU1tpXSAqIHZvbHVtZSk7XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9ucztcbn1cblxuXG4vKipcbiAqIENvbXB1dGUgcmVmbGVjdGlvbiBjb2VmZmljaWVudHMgZnJvbSBhYnNvcnB0aW9uIGNvZWZmaWNpZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhYnNvcnB0aW9uQ29lZmZpY2llbnRzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIF9jb21wdXRlUmVmbGVjdGlvbkNvZWZmaWNpZW50cyhhYnNvcnB0aW9uQ29lZmZpY2llbnRzKSB7XG4gIGxldCByZWZsZWN0aW9uQ29lZmZpY2llbnRzID0gW107XG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICAgICAgICAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAvLyBDb21wdXRlIGF2ZXJhZ2UgYWJzb3JwdGlvbiBjb2VmZmljaWVudCAocGVyIHdhbGwpLlxuICAgICAgcmVmbGVjdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV0gPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBVdGlscy5OVU1CRVJfUkVGTEVDVElPTl9BVkVSQUdJTkdfQkFORFM7IGorKykge1xuICAgICAgICBsZXQgYmFuZEluZGV4ID0gaiArIFV0aWxzLlJPT01fU1RBUlRJTkdfQVZFUkFHSU5HX0JBTkQ7XG4gICAgICAgIHJlZmxlY3Rpb25Db2VmZmljaWVudHNbcHJvcGVydHldICs9XG4gICAgICAgICAgYWJzb3JwdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV1bYmFuZEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHJlZmxlY3Rpb25Db2VmZmljaWVudHNbcHJvcGVydHldIC89XG4gICAgICAgIFV0aWxzLk5VTUJFUl9SRUZMRUNUSU9OX0FWRVJBR0lOR19CQU5EUztcblxuICAgICAgLy8gQ29udmVydCBhYnNvcnB0aW9uIGNvZWZmaWNpZW50IHRvIHJlZmxlY3Rpb24gY29lZmZpY2llbnQuXG4gICAgICByZWZsZWN0aW9uQ29lZmZpY2llbnRzW3Byb3BlcnR5XSA9XG4gICAgICAgIE1hdGguc3FydCgxIC0gcmVmbGVjdGlvbkNvZWZmaWNpZW50c1twcm9wZXJ0eV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmbGVjdGlvbkNvZWZmaWNpZW50cztcbn1cblxuXG4vKipcbiAqIEBjbGFzcyBSb29tXG4gKiBAZGVzY3JpcHRpb24gTW9kZWwgdGhhdCBtYW5hZ2VzIGVhcmx5IGFuZCBsYXRlIHJlZmxlY3Rpb25zIHVzaW5nIGFjb3VzdGljXG4gKiBwcm9wZXJ0aWVzIGFuZCBsaXN0ZW5lciBwb3NpdGlvbiByZWxhdGl2ZSB0byBhIHJlY3Rhbmd1bGFyIHJvb20uXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uXG4gKiBUaGUgbGlzdGVuZXIncyBpbml0aWFsIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRpbWVuc2lvbnMgUm9vbSBkaW1lbnNpb25zIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyBERUZBVUxUX1JPT01fRElNRU5TSU9OU30uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5tYXRlcmlhbHMgTmFtZWQgYWNvdXN0aWMgbWF0ZXJpYWxzIHBlciB3YWxsLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTIERFRkFVTFRfUk9PTV9NQVRFUklBTFN9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc3BlZWRPZlNvdW5kXG4gKiAoaW4gbWV0ZXJzL3NlY29uZCkuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQgREVGQVVMVF9TUEVFRF9PRl9TT1VORH0uXG4gKi9cbmZ1bmN0aW9uIFJvb20oY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBQdWJsaWMgdmFyaWFibGVzLlxuICAvKipcbiAgICogRWFybHlSZWZsZWN0aW9ucyB7QGxpbmsgRWFybHlSZWZsZWN0aW9ucyBFYXJseVJlZmxlY3Rpb25zfSBzdWJtb2R1bGUuXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gZWFybHlcbiAgICogQG1lbWJlcm9mIFJvb21cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTGF0ZVJlZmxlY3Rpb25zIHtAbGluayBMYXRlUmVmbGVjdGlvbnMgTGF0ZVJlZmxlY3Rpb25zfSBzdWJtb2R1bGUuXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gbGF0ZVxuICAgKiBAbWVtYmVyb2YgUm9vbVxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBBbWJpc29uaWMgKG11bHRpY2hhbm5lbCkgb3V0cHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gb3V0cHV0XG4gICAqIEBtZW1iZXJvZiBSb29tXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9IFV0aWxzLkRFRkFVTFRfUE9TSVRJT04uc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5kaW1lbnNpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuZGltZW5zaW9ucyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5kaW1lbnNpb25zLCBVdGlscy5ERUZBVUxUX1JPT01fRElNRU5TSU9OUyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF0ZXJpYWxzID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubWF0ZXJpYWxzID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLm1hdGVyaWFscywgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3BlZWRPZlNvdW5kID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuc3BlZWRPZlNvdW5kID0gVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORDtcbiAgfVxuXG4gIC8vIFNhbml0aXplIHJvb20tcHJvcGVydGllcy1yZWxhdGVkIGFyZ3VtZW50cy5cbiAgb3B0aW9ucy5kaW1lbnNpb25zID0gX3Nhbml0aXplRGltZW5zaW9ucyhvcHRpb25zLmRpbWVuc2lvbnMpO1xuICBsZXQgYWJzb3JwdGlvbkNvZWZmaWNpZW50cyA9IF9nZXRDb2VmZmljaWVudHNGcm9tTWF0ZXJpYWxzKG9wdGlvbnMubWF0ZXJpYWxzKTtcbiAgbGV0IHJlZmxlY3Rpb25Db2VmZmljaWVudHMgPVxuICAgIF9jb21wdXRlUmVmbGVjdGlvbkNvZWZmaWNpZW50cyhhYnNvcnB0aW9uQ29lZmZpY2llbnRzKTtcbiAgbGV0IGR1cmF0aW9ucyA9IF9nZXREdXJhdGlvbnNGcm9tUHJvcGVydGllcyhvcHRpb25zLmRpbWVuc2lvbnMsXG4gICAgYWJzb3JwdGlvbkNvZWZmaWNpZW50cywgb3B0aW9ucy5zcGVlZE9mU291bmQpO1xuXG4gIC8vIENvbnN0cnVjdCBzdWJtb2R1bGVzIGZvciBlYXJseSBhbmQgbGF0ZSByZWZsZWN0aW9ucy5cbiAgdGhpcy5lYXJseSA9IG5ldyBFYXJseVJlZmxlY3Rpb25zKGNvbnRleHQsIHtcbiAgICBkaW1lbnNpb25zOiBvcHRpb25zLmRpbWVuc2lvbnMsXG4gICAgY29lZmZpY2llbnRzOiByZWZsZWN0aW9uQ29lZmZpY2llbnRzLFxuICAgIHNwZWVkT2ZTb3VuZDogb3B0aW9ucy5zcGVlZE9mU291bmQsXG4gICAgbGlzdGVuZXJQb3NpdGlvbjogb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uLFxuICB9KTtcbiAgdGhpcy5sYXRlID0gbmV3IExhdGVSZWZsZWN0aW9ucyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25zOiBkdXJhdGlvbnMsXG4gIH0pO1xuXG4gIHRoaXMuc3BlZWRPZlNvdW5kID0gb3B0aW9ucy5zcGVlZE9mU291bmQ7XG5cbiAgLy8gQ29uc3RydWN0IGF1eGlsbGFyeSBhdWRpbyBub2Rlcy5cbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5lYXJseS5vdXRwdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gIHRoaXMuX21lcmdlciA9IGNvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcig0KTtcblxuICB0aGlzLmxhdGUub3V0cHV0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcbiAgdGhpcy5fbWVyZ2VyLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xufVxuXG5cbi8qKlxuICogU2V0IHRoZSByb29tJ3MgZGltZW5zaW9ucyBhbmQgd2FsbCBtYXRlcmlhbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9ucyBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TIERFRkFVTFRfUk9PTV9ESU1FTlNJT05TfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbHMgTmFtZWQgYWNvdXN0aWMgbWF0ZXJpYWxzIHBlciB3YWxsLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JPT01fTUFURVJJQUxTIERFRkFVTFRfUk9PTV9NQVRFUklBTFN9LlxuICovXG5Sb29tLnByb3RvdHlwZS5zZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZGltZW5zaW9ucywgbWF0ZXJpYWxzKSB7XG4gIC8vIENvbXB1dGUgbGF0ZSByZXNwb25zZS5cbiAgbGV0IGFic29ycHRpb25Db2VmZmljaWVudHMgPSBfZ2V0Q29lZmZpY2llbnRzRnJvbU1hdGVyaWFscyhtYXRlcmlhbHMpO1xuICBsZXQgZHVyYXRpb25zID0gX2dldER1cmF0aW9uc0Zyb21Qcm9wZXJ0aWVzKGRpbWVuc2lvbnMsXG4gICAgYWJzb3JwdGlvbkNvZWZmaWNpZW50cywgdGhpcy5zcGVlZE9mU291bmQpO1xuICB0aGlzLmxhdGUuc2V0RHVyYXRpb25zKGR1cmF0aW9ucyk7XG5cbiAgLy8gQ29tcHV0ZSBlYXJseSByZXNwb25zZS5cbiAgdGhpcy5lYXJseS5zcGVlZE9mU291bmQgPSB0aGlzLnNwZWVkT2ZTb3VuZDtcbiAgbGV0IHJlZmxlY3Rpb25Db2VmZmljaWVudHMgPVxuICAgIF9jb21wdXRlUmVmbGVjdGlvbkNvZWZmaWNpZW50cyhhYnNvcnB0aW9uQ29lZmZpY2llbnRzKTtcbiAgdGhpcy5lYXJseS5zZXRSb29tUHJvcGVydGllcyhkaW1lbnNpb25zLCByZWZsZWN0aW9uQ29lZmZpY2llbnRzKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGxpc3RlbmVyJ3MgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuUm9vbS5wcm90b3R5cGUuc2V0TGlzdGVuZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgdGhpcy5lYXJseS5zcGVlZE9mU291bmQgPSB0aGlzLnNwZWVkT2ZTb3VuZDtcbiAgdGhpcy5lYXJseS5zZXRMaXN0ZW5lclBvc2l0aW9uKHgsIHksIHopO1xuXG4gIC8vIERpc2FibGUgcm9vbSBlZmZlY3RzIGlmIHRoZSBsaXN0ZW5lciBpcyBvdXRzaWRlIHRoZSByb29tIGJvdW5kYXJpZXMuXG4gIGxldCBkaXN0YW5jZSA9IHRoaXMuZ2V0RGlzdGFuY2VPdXRzaWRlUm9vbSh4LCB5LCB6KTtcbiAgbGV0IGdhaW4gPSAxO1xuICBpZiAoZGlzdGFuY2UgPiBVdGlscy5FUFNJTE9OX0ZMT0FUKSB7XG4gICAgZ2FpbiA9IDEgLSBkaXN0YW5jZSAvIFV0aWxzLkxJU1RFTkVSX01BWF9PVVRTSURFX1JPT01fRElTVEFOQ0U7XG5cbiAgICAvLyBDbGFtcCBnYWluIGJldHdlZW4gMCBhbmQgMS5cbiAgICBnYWluID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZ2FpbikpO1xuICB9XG4gIHRoaXMub3V0cHV0LmdhaW4udmFsdWUgPSBnYWluO1xufTtcblxuXG4vKipcbiAqIENvbXB1dGUgZGlzdGFuY2Ugb3V0c2lkZSByb29tIG9mIHByb3ZpZGVkIHBvc2l0aW9uIChpbiBtZXRlcnMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQHJldHVybiB7TnVtYmVyfVxuICogRGlzdGFuY2Ugb3V0c2lkZSByb29tIChpbiBtZXRlcnMpLiBSZXR1cm5zIDAgaWYgaW5zaWRlIHJvb20uXG4gKi9cblJvb20ucHJvdG90eXBlLmdldERpc3RhbmNlT3V0c2lkZVJvb20gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIGxldCBkeCA9IE1hdGgubWF4KDAsIC10aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy53aWR0aCAtIHgsXG4gICAgeCAtIHRoaXMuZWFybHkuX2hhbGZEaW1lbnNpb25zLndpZHRoKTtcbiAgICBsZXQgZHkgPSBNYXRoLm1heCgwLCAtdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMuaGVpZ2h0IC0geSxcbiAgICB5IC0gdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICBsZXQgZHogPSBNYXRoLm1heCgwLCAtdGhpcy5lYXJseS5faGFsZkRpbWVuc2lvbnMuZGVwdGggLSB6LFxuICAgIHogLSB0aGlzLmVhcmx5Ll9oYWxmRGltZW5zaW9ucy5kZXB0aCk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSb29tO1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBMYXRlIHJldmVyYmVyYXRpb24gZmlsdGVyIGZvciBBbWJpc29uaWMgY29udGVudC5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqXG4gKiBAY2xhc3MgTGF0ZVJlZmxlY3Rpb25zXG4gKiBAZGVzY3JpcHRpb24gTGF0ZS1yZWZsZWN0aW9ucyByZXZlcmJlcmF0aW9uIGZpbHRlciBmb3IgQW1iaXNvbmljIGNvbnRlbnQuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLmR1cmF0aW9uc1xuICogTXVsdGliYW5kIFJUNjAgZHVyYXRpb25zIChpbiBzZWNvbmRzKSBmb3IgZWFjaCBmcmVxdWVuY3kgYmFuZCwgbGlzdGVkIGFzXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EU1xuICogRlJFUVVERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFNFTkNZX0JBTkRTfS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9SRVZFUkJfRFVSQVRJT05TIERFRkFVTFRfUkVWRVJCX0RVUkFUSU9OU30uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wcmVkZWxheSBQcmUtZGVsYXkgKGluIG1pbGxpc2Vjb25kcykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX1BSRURFTEFZIERFRkFVTFRfUkVWRVJCX1BSRURFTEFZfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmdhaW4gT3V0cHV0IGdhaW4gKGxpbmVhcikuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0dBSU4gREVGQVVMVF9SRVZFUkJfR0FJTn0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5iYW5kd2lkdGggQmFuZHdpZHRoIChpbiBvY3RhdmVzKSBmb3IgZWFjaCBmcmVxdWVuY3lcbiAqIGJhbmQuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0JBTkRXSURUSCBERUZBVUxUX1JFVkVSQl9CQU5EV0lEVEh9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMudGFpbG9uc2V0IExlbmd0aCAoaW4gbWlsbGlzZWNvbmRzKSBvZiBpbXB1bHNlXG4gKiByZXNwb25zZSB0byBhcHBseSBhIGhhbGYtSGFubiB3aW5kb3cuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUkVWRVJCX1RBSUxfT05TRVQgREVGQVVMVF9SRVZFUkJfVEFJTF9PTlNFVH0uXG4gKi9cbmZ1bmN0aW9uIExhdGVSZWZsZWN0aW9ucyhjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIGlucHV0IHtAbGlua1xuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9Ob2RlIEF1ZGlvTm9kZX0uXG4gICAqIEBtZW1iZXIge0F1ZGlvTm9kZX0gaW5wdXRcbiAgICogQG1lbWJlcm9mIExhdGVSZWZsZWN0aW9uc1xuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIC8qKlxuICAgKiBNb25vICgxLWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IG91dHB1dFxuICAgKiBAbWVtYmVyb2YgTGF0ZVJlZmxlY3Rpb25zXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5kdXJhdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5kdXJhdGlvbnMgPSBVdGlscy5ERUZBVUxUX1JFVkVSQl9EVVJBVElPTlMuc2xpY2UoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVkZWxheSA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnByZWRlbGF5ID0gVXRpbHMuREVGQVVMVF9SRVZFUkJfUFJFREVMQVk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZ2FpbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmdhaW4gPSBVdGlscy5ERUZBVUxUX1JFVkVSQl9HQUlOO1xuICB9XG4gIGlmIChvcHRpb25zLmJhbmR3aWR0aCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmJhbmR3aWR0aCA9IFV0aWxzLkRFRkFVTFRfUkVWRVJCX0JBTkRXSURUSDtcbiAgfVxuICBpZiAob3B0aW9ucy50YWlsb25zZXQgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy50YWlsb25zZXQgPSBVdGlscy5ERUZBVUxUX1JFVkVSQl9UQUlMX09OU0VUO1xuICB9XG5cbiAgLy8gQXNzaWduIHByZS1jb21wdXRlZCB2YXJpYWJsZXMuXG4gIGxldCBkZWxheVNlY3MgPSBvcHRpb25zLnByZWRlbGF5IC8gMTAwMDtcbiAgdGhpcy5fYmFuZHdpZHRoQ29lZmYgPSBvcHRpb25zLmJhbmR3aWR0aCAqIFV0aWxzLkxPRzJfRElWMjtcbiAgdGhpcy5fdGFpbG9uc2V0U2FtcGxlcyA9IG9wdGlvbnMudGFpbG9uc2V0IC8gMTAwMDtcblxuICAvLyBDcmVhdGUgbm9kZXMuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmlucHV0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX3ByZWRlbGF5ID0gY29udGV4dC5jcmVhdGVEZWxheShkZWxheVNlY3MpO1xuICB0aGlzLl9jb252b2x2ZXIgPSBjb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIFNldCByZXZlcmIgYXR0ZW51YXRpb24uXG4gIHRoaXMub3V0cHV0LmdhaW4udmFsdWUgPSBvcHRpb25zLmdhaW47XG5cbiAgLy8gRGlzYWJsZSBub3JtYWxpemF0aW9uLlxuICB0aGlzLl9jb252b2x2ZXIubm9ybWFsaXplID0gZmFsc2U7XG5cbiAgLy8gQ29ubmVjdCBub2Rlcy5cbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX3ByZWRlbGF5KTtcbiAgdGhpcy5fcHJlZGVsYXkuY29ubmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuICB0aGlzLl9jb252b2x2ZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgLy8gQ29tcHV0ZSBJUiB1c2luZyBSVDYwIHZhbHVlcy5cbiAgdGhpcy5zZXREdXJhdGlvbnMob3B0aW9ucy5kdXJhdGlvbnMpO1xufVxuXG5cbi8qKlxuICogUmUtY29tcHV0ZSBhIG5ldyBpbXB1bHNlIHJlc3BvbnNlIGJ5IHByb3ZpZGluZyBNdWx0aWJhbmQgUlQ2MCBkdXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBkdXJhdGlvbnNcbiAqIE11bHRpYmFuZCBSVDYwIGR1cmF0aW9ucyAoaW4gc2Vjb25kcykgZm9yIGVhY2ggZnJlcXVlbmN5IGJhbmQsIGxpc3RlZCBhc1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFNcbiAqIERFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EU30uXG4gKi9cbkxhdGVSZWZsZWN0aW9ucy5wcm90b3R5cGUuc2V0RHVyYXRpb25zID0gZnVuY3Rpb24oZHVyYXRpb25zKSB7XG4gIGlmIChkdXJhdGlvbnMubGVuZ3RoICE9PSBVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUykge1xuICAgIFV0aWxzLmxvZygnV2FybmluZzogaW52YWxpZCBudW1iZXIgb2YgUlQ2MCB2YWx1ZXMgcHJvdmlkZWQgdG8gcmV2ZXJiLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENvbXB1dGUgaW1wdWxzZSByZXNwb25zZS5cbiAgbGV0IGR1cmF0aW9uc1NhbXBsZXMgPVxuICAgIG5ldyBGbG9hdDMyQXJyYXkoVXRpbHMuTlVNQkVSX1JFVkVSQl9GUkVRVUVOQ1lfQkFORFMpO1xuICAgIGxldCBzYW1wbGVSYXRlID0gdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gQ2xhbXAgd2l0aGluIHN1aXRhYmxlIHJhbmdlLlxuICAgIGR1cmF0aW9uc1tpXSA9XG4gICAgICBNYXRoLm1heCgwLCBNYXRoLm1pbihVdGlscy5ERUZBVUxUX1JFVkVSQl9NQVhfRFVSQVRJT04sIGR1cmF0aW9uc1tpXSkpO1xuXG4gICAgLy8gQ29udmVydCBzZWNvbmRzIHRvIHNhbXBsZXMuXG4gICAgZHVyYXRpb25zU2FtcGxlc1tpXSA9IE1hdGgucm91bmQoZHVyYXRpb25zW2ldICogc2FtcGxlUmF0ZSAqXG4gICAgICBVdGlscy5ERUZBVUxUX1JFVkVSQl9EVVJBVElPTl9NVUxUSVBMSUVSKTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgbWF4IFJUNjAgbGVuZ3RoIGluIHNhbXBsZXMuXG4gIGxldCBkdXJhdGlvbnNTYW1wbGVzTWF4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkdXJhdGlvbnNTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGR1cmF0aW9uc1NhbXBsZXNbaV0gPiBkdXJhdGlvbnNTYW1wbGVzTWF4KSB7XG4gICAgICBkdXJhdGlvbnNTYW1wbGVzTWF4ID0gZHVyYXRpb25zU2FtcGxlc1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyBTa2lwIHRoaXMgc3RlcCBpZiB0aGVyZSBpcyBubyByZXZlcmJlcmF0aW9uIHRvIGNvbXB1dGUuXG4gIGlmIChkdXJhdGlvbnNTYW1wbGVzTWF4IDwgMSkge1xuICAgIGR1cmF0aW9uc1NhbXBsZXNNYXggPSAxO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGltcHVsc2UgcmVzcG9uc2UgYnVmZmVyLlxuICBsZXQgYnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVCdWZmZXIoMSwgZHVyYXRpb25zU2FtcGxlc01heCwgc2FtcGxlUmF0ZSk7XG4gIGxldCBidWZmZXJEYXRhID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXG4gIC8vIENyZWF0ZSBub2lzZSBzaWduYWwgKGNvbXB1dGVkIG9uY2UsIHJlZmVyZW5jZWQgaW4gZWFjaCBiYW5kJ3Mgcm91dGluZSkuXG4gIGxldCBub2lzZVNpZ25hbCA9IG5ldyBGbG9hdDMyQXJyYXkoZHVyYXRpb25zU2FtcGxlc01heCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZHVyYXRpb25zU2FtcGxlc01heDsgaSsrKSB7XG4gICAgbm9pc2VTaWduYWxbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBkZWNheSByYXRlIHBlci1iYW5kIGFuZCBmaWx0ZXIgdGhlIGRlY2F5aW5nIG5vaXNlIHNpZ25hbC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBVdGlscy5OVU1CRVJfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EUzsgaSsrKSB7XG4gICAgLy8gQ29tcHV0ZSBkZWNheSByYXRlLlxuICAgIGxldCBkZWNheVJhdGUgPSAtVXRpbHMuTE9HMTAwMCAvIGR1cmF0aW9uc1NhbXBsZXNbaV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgYSBzdGFuZGFyZCBvbmUtemVybywgdHdvLXBvbGUgYmFuZHBhc3MgZmlsdGVyOlxuICAgIC8vIEgoeikgPSAoYjAgKiB6XjAgKyBiMSAqIHpeLTEgKyBiMiAqIHpeLTIpIC8gKDEgKyBhMSAqIHpeLTEgKyBhMiAqIHpeLTIpXG4gICAgbGV0IG9tZWdhID0gVXRpbHMuVFdPX1BJICpcbiAgICAgIFV0aWxzLkRFRkFVTFRfUkVWRVJCX0ZSRVFVRU5DWV9CQU5EU1tpXSAvIHNhbXBsZVJhdGU7XG4gICAgbGV0IHNpbk9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgIGxldCBhbHBoYSA9IHNpbk9tZWdhICogTWF0aC5zaW5oKHRoaXMuX2JhbmR3aWR0aENvZWZmICogb21lZ2EgLyBzaW5PbWVnYSk7XG4gICAgbGV0IGEwQ29lZmZSZWNpcHJvY2FsID0gMSAvICgxICsgYWxwaGEpO1xuICAgIGxldCBiMENvZWZmID0gYWxwaGEgKiBhMENvZWZmUmVjaXByb2NhbDtcbiAgICBsZXQgYTFDb2VmZiA9IC0yICogTWF0aC5jb3Mob21lZ2EpICogYTBDb2VmZlJlY2lwcm9jYWw7XG4gICAgbGV0IGEyQ29lZmYgPSAoMSAtIGFscGhhKSAqIGEwQ29lZmZSZWNpcHJvY2FsO1xuXG4gICAgLy8gV2Ugb3B0aW1pemUgc2luY2UgYjIgPSAtYjAsIGIxID0gMC5cbiAgICAvLyBVcGRhdGUgZXF1YXRpb24gZm9yIHR3by1wb2xlIGJhbmRwYXNzIGZpbHRlcjpcbiAgICAvLyAgIHVbbl0gPSB4W25dIC0gYTEgKiB4W24tMV0gLSBhMiAqIHhbbi0yXVxuICAgIC8vICAgeVtuXSA9IGIwICogKHVbbl0gLSB1W24tMl0pXG4gICAgbGV0IHVtMSA9IDA7XG4gICAgbGV0IHVtMiA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBkdXJhdGlvbnNTYW1wbGVzW2ldOyBqKyspIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHktZGVjYXlpbmcgd2hpdGUgbm9pc2UuXG4gICAgICBsZXQgeCA9IG5vaXNlU2lnbmFsW2pdICogTWF0aC5leHAoZGVjYXlSYXRlICogaik7XG5cbiAgICAgIC8vIEZpbHRlciBzaWduYWwgd2l0aCBiYW5kcGFzcyBmaWx0ZXIgYW5kIGFkZCB0byBvdXRwdXQuXG4gICAgICBsZXQgdSA9IHggLSBhMUNvZWZmICogdW0xIC0gYTJDb2VmZiAqIHVtMjtcbiAgICAgIGJ1ZmZlckRhdGFbal0gKz0gYjBDb2VmZiAqICh1IC0gdW0yKTtcblxuICAgICAgLy8gVXBkYXRlIGNvZWZmaWNpZW50cy5cbiAgICAgIHVtMiA9IHVtMTtcbiAgICAgIHVtMSA9IHU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCBhcHBseSBoYWxmIG9mIGEgSGFubiB3aW5kb3cgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gaW1wdWxzZSByZXNwb25zZS5cbiAgbGV0IGhhbGZIYW5uTGVuZ3RoID1cbiAgICBNYXRoLnJvdW5kKHRoaXMuX3RhaWxvbnNldFNhbXBsZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlckRhdGEubGVuZ3RoLCBoYWxmSGFubkxlbmd0aCk7IGkrKykge1xuICAgIGxldCBoYWxmSGFubiA9XG4gICAgICAwLjUgKiAoMSAtIE1hdGguY29zKFV0aWxzLlRXT19QSSAqIGkgLyAoMiAqIGhhbGZIYW5uTGVuZ3RoIC0gMSkpKTtcbiAgICAgIGJ1ZmZlckRhdGFbaV0gKj0gaGFsZkhhbm47XG4gIH1cbiAgdGhpcy5fY29udm9sdmVyLmJ1ZmZlciA9IGJ1ZmZlcjtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMYXRlUmVmbGVjdGlvbnM7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFJheS10cmFjaW5nLWJhc2VkIGVhcmx5IHJlZmxlY3Rpb25zIG1vZGVsLlxuICogQGF1dGhvciBBbmRyZXcgQWxsZW4gPGJpdGxsYW1hQGdvb2dsZS5jb20+XG4gKi9cblxuXG5cbi8vIEludGVybmFsIGRlcGVuZGVuY2llcy5cbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBFYXJseVJlZmxlY3Rpb25zXG4gKiBAZGVzY3JpcHRpb24gUmF5LXRyYWNpbmctYmFzZWQgZWFybHkgcmVmbGVjdGlvbnMgbW9kZWwuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dFxuICogQXNzb2NpYXRlZCB7QGxpbmtcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb0NvbnRleHQgQXVkaW9Db250ZXh0fS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kaW1lbnNpb25zXG4gKiBSb29tIGRpbWVuc2lvbnMgKGluIG1ldGVycykuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUk9PTV9ESU1FTlNJT05TIERFRkFVTFRfUk9PTV9ESU1FTlNJT05TfS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmNvZWZmaWNpZW50c1xuICogRnJlcXVlbmN5LWluZGVwZW5kZW50IHJlZmxlY3Rpb24gY29lZmZzIHBlciB3YWxsLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gKiBERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkT2ZTb3VuZFxuICogKGluIG1ldGVycyAvIHNlY29uZCkuIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TUEVFRF9PRl9TT1VORFxuICogREVGQVVMVF9TUEVFRF9PRl9TT1VORH0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uXG4gKiAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9QT1NJVElPTiBERUZBVUxUX1BPU0lUSU9OfS5cbiAqL1xuZnVuY3Rpb24gRWFybHlSZWZsZWN0aW9ucyhjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBUaGUgcm9vbSdzIHNwZWVkIG9mIHNvdW5kIChpbiBtZXRlcnMvc2Vjb25kKS5cbiAgICogQG1lbWJlciB7TnVtYmVyfSBzcGVlZE9mU291bmRcbiAgICogQG1lbWJlcm9mIEVhcmx5UmVmbGVjdGlvbnNcbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogTW9ubyAoMS1jaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9LlxuICAgKiBAbWVtYmVyIHtBdWRpb05vZGV9IGlucHV0XG4gICAqIEBtZW1iZXJvZiBFYXJseVJlZmxlY3Rpb25zXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEZpcnN0LW9yZGVyIGFtYmlzb25pYyAoNC1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIEVhcmx5UmVmbGVjdGlvbnNcbiAgICogQGluc3RhbmNlXG4gICAqL1xuXG4gIC8vIFVzZSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGFyZ3VtZW50cy5cbiAgaWYgKG9wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmIChvcHRpb25zLnNwZWVkT2ZTb3VuZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNwZWVkT2ZTb3VuZCA9IFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQ7XG4gIH1cbiAgaWYgKG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY29lZmZpY2llbnRzID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMuY29lZmZpY2llbnRzID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmNvZWZmaWNpZW50cywgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUyk7XG4gIH1cblxuICAvLyBBc3NpZ24gcm9vbSdzIHNwZWVkIG9mIHNvdW5kLlxuICB0aGlzLnNwZWVkT2ZTb3VuZCA9IG9wdGlvbnMuc3BlZWRPZlNvdW5kO1xuXG4gIC8vIENyZWF0ZSBub2Rlcy5cbiAgdGhpcy5pbnB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLm91dHB1dCA9IGNvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9sb3dwYXNzID0gY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgdGhpcy5fZGVsYXlzID0ge307XG4gIHRoaXMuX2dhaW5zID0ge307IC8vIGdhaW5QZXJXYWxsID0gKFJlZmxlY3Rpb25Db2VmZiAvIEF0dGVudWF0aW9uKVxuICB0aGlzLl9pbnZlcnRlcnMgPSB7fTsgLy8gMyBvZiB0aGVzZSBhcmUgbmVlZGVkIGZvciByaWdodC9iYWNrL2Rvd24gd2FsbHMuXG4gIHRoaXMuX21lcmdlciA9IGNvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcig0KTsgLy8gRmlyc3Qtb3JkZXIgZW5jb2Rpbmcgb25seS5cblxuICAvLyBDb25uZWN0IGF1ZGlvIGdyYXBoIGZvciBlYWNoIHdhbGwgcmVmbGVjdGlvbi5cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gICAgICAgIC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIHRoaXMuX2RlbGF5c1twcm9wZXJ0eV0gPVxuICAgICAgICBjb250ZXh0LmNyZWF0ZURlbGF5KFV0aWxzLk1BWF9EVVJBVElPTik7XG4gICAgICB0aGlzLl9nYWluc1twcm9wZXJ0eV0gPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5faW52ZXJ0ZXJzLnJpZ2h0ID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2ludmVydGVycy5kb3duID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2ludmVydGVycy5iYWNrID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsb3dwYXNzIGZpbHRlci5cbiAgdGhpcy5fbG93cGFzcy50eXBlID0gJ2xvd3Bhc3MnO1xuICB0aGlzLl9sb3dwYXNzLmZyZXF1ZW5jeS52YWx1ZSA9IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DVVRPRkZfRlJFUVVFTkNZO1xuICB0aGlzLl9sb3dwYXNzLlEudmFsdWUgPSAwO1xuXG4gIC8vIEluaXRpYWxpemUgZW5jb2RlciBkaXJlY3Rpb25zLCBzZXQgZGVsYXkgdGltZXMgYW5kIGdhaW5zIHRvIDAuXG4gIGZvciAobGV0IHByb3BlcnR5IGluIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpIHtcbiAgICBpZiAoVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UU1xuICAgICAgICAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICB0aGlzLl9kZWxheXNbcHJvcGVydHldLmRlbGF5VGltZS52YWx1ZSA9IDA7XG4gICAgICB0aGlzLl9nYWluc1twcm9wZXJ0eV0uZ2Fpbi52YWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBpbnZlcnRlcnMgZm9yIG9wcG9zaXRlIHdhbGxzICgncmlnaHQnLCAnZG93bicsICdiYWNrJyBvbmx5KS5cbiAgdGhpcy5faW52ZXJ0ZXJzLnJpZ2h0LmdhaW4udmFsdWUgPSAtMTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmRvd24uZ2Fpbi52YWx1ZSA9IC0xO1xuICB0aGlzLl9pbnZlcnRlcnMuYmFjay5nYWluLnZhbHVlID0gLTE7XG5cbiAgLy8gQ29ubmVjdCBub2Rlcy5cbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2xvd3Bhc3MpO1xuICBmb3IgKGxldCBwcm9wZXJ0eSBpbiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTKSB7XG4gICAgaWYgKFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFNcbiAgICAgICAgLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgdGhpcy5fbG93cGFzcy5jb25uZWN0KHRoaXMuX2RlbGF5c1twcm9wZXJ0eV0pO1xuICAgICAgdGhpcy5fZGVsYXlzW3Byb3BlcnR5XS5jb25uZWN0KHRoaXMuX2dhaW5zW3Byb3BlcnR5XSk7XG4gICAgICB0aGlzLl9nYWluc1twcm9wZXJ0eV0uY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbm5lY3QgZ2FpbnMgdG8gYW1iaXNvbmljIGNoYW5uZWwgb3V0cHV0LlxuICAvLyBMZWZ0OiBbMSAxIDAgMF1cbiAgLy8gUmlnaHQ6IFsxIC0xIDAgMF1cbiAgLy8gVXA6IFsxIDAgMSAwXVxuICAvLyBEb3duOiBbMSAwIC0xIDBdXG4gIC8vIEZyb250OiBbMSAwIDAgMV1cbiAgLy8gQmFjazogWzEgMCAwIC0xXVxuICB0aGlzLl9nYWlucy5sZWZ0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblxuICB0aGlzLl9nYWlucy5yaWdodC5jb25uZWN0KHRoaXMuX2ludmVydGVycy5yaWdodCk7XG4gIHRoaXMuX2ludmVydGVycy5yaWdodC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMSk7XG5cbiAgdGhpcy5fZ2FpbnMudXAuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDIpO1xuXG4gIHRoaXMuX2dhaW5zLmRvd24uY29ubmVjdCh0aGlzLl9pbnZlcnRlcnMuZG93bik7XG4gIHRoaXMuX2ludmVydGVycy5kb3duLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAyKTtcblxuICB0aGlzLl9nYWlucy5mcm9udC5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMyk7XG5cbiAgdGhpcy5fZ2FpbnMuYmFjay5jb25uZWN0KHRoaXMuX2ludmVydGVycy5iYWNrKTtcbiAgdGhpcy5faW52ZXJ0ZXJzLmJhY2suY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDMpO1xuICB0aGlzLl9tZXJnZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgLy8gSW5pdGlhbGl6ZS5cbiAgdGhpcy5fbGlzdGVuZXJQb3NpdGlvbiA9IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbjtcbiAgdGhpcy5zZXRSb29tUHJvcGVydGllcyhvcHRpb25zLmRpbWVuc2lvbnMsIG9wdGlvbnMuY29lZmZpY2llbnRzKTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbiAoaW4gbWV0ZXJzKSxcbiAqIHdoZXJlIFswLDAsMF0gaXMgdGhlIGNlbnRlciBvZiB0aGUgcm9vbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqL1xuRWFybHlSZWZsZWN0aW9ucy5wcm90b3R5cGUuc2V0TGlzdGVuZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgLy8gQXNzaWduIGxpc3RlbmVyIHBvc2l0aW9uLlxuICB0aGlzLl9saXN0ZW5lclBvc2l0aW9uID0gW3gsIHksIHpdO1xuXG4gIC8vIERldGVybWluZSBkaXN0YW5jZXMgdG8gZWFjaCB3YWxsLlxuICBsZXQgZGlzdGFuY2VzID0ge1xuICAgIGxlZnQ6IFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NVUxUSVBMSUVSICogTWF0aC5tYXgoMCxcbiAgICAgIHRoaXMuX2hhbGZEaW1lbnNpb25zLndpZHRoICsgeCkgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICAgIHJpZ2h0OiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy53aWR0aCAtIHgpICsgVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01JTl9ESVNUQU5DRSxcbiAgICBmcm9udDogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMuZGVwdGggKyB6KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gICAgYmFjazogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMuZGVwdGggLSB6KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gICAgZG93bjogVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX01VTFRJUExJRVIgKiBNYXRoLm1heCgwLFxuICAgICAgdGhpcy5faGFsZkRpbWVuc2lvbnMuaGVpZ2h0ICsgeSkgKyBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTUlOX0RJU1RBTkNFLFxuICAgIHVwOiBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fTVVMVElQTElFUiAqIE1hdGgubWF4KDAsXG4gICAgICB0aGlzLl9oYWxmRGltZW5zaW9ucy5oZWlnaHQgLSB5KSArIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9NSU5fRElTVEFOQ0UsXG4gIH07XG5cbiAgLy8gQXNzaWduIGRlbGF5ICYgYXR0ZW51YXRpb24gdmFsdWVzIHVzaW5nIGRpc3RhbmNlcy5cbiAgZm9yIChsZXQgcHJvcGVydHkgaW4gVXRpbHMuREVGQVVMVF9SRUZMRUNUSU9OX0NPRUZGSUNJRU5UUykge1xuICAgIGlmIChVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gICAgICAgIC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgIC8vIENvbXB1dGUgYW5kIGFzc2lnbiBkZWxheSAoaW4gc2Vjb25kcykuXG4gICAgICBsZXQgZGVsYXlJblNlY3MgPSBkaXN0YW5jZXNbcHJvcGVydHldIC8gdGhpcy5zcGVlZE9mU291bmQ7XG4gICAgICB0aGlzLl9kZWxheXNbcHJvcGVydHldLmRlbGF5VGltZS52YWx1ZSA9IGRlbGF5SW5TZWNzO1xuXG4gICAgICAvLyBDb21wdXRlIGFuZCBhc3NpZ24gZ2FpbiwgdXNlcyBsb2dhcml0aG1pYyByb2xsb2ZmOiBcImcgPSBSIC8gKGQgKyAxKVwiXG4gICAgICBsZXQgYXR0ZW51YXRpb24gPSB0aGlzLl9jb2VmZmljaWVudHNbcHJvcGVydHldIC8gZGlzdGFuY2VzW3Byb3BlcnR5XTtcbiAgICAgIHRoaXMuX2dhaW5zW3Byb3BlcnR5XS5nYWluLnZhbHVlID0gYXR0ZW51YXRpb247XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSByb29tJ3MgcHJvcGVydGllcyB3aGljaCBkZXRlcm1pbmVzIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2ZcbiAqIHJlZmxlY3Rpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IGRpbWVuc2lvbnNcbiAqIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgREVGQVVMVF9ST09NX0RJTUVOU0lPTlN9LlxuICogQHBhcmFtIHtPYmplY3R9IGNvZWZmaWNpZW50c1xuICogRnJlcXVlbmN5LWluZGVwZW5kZW50IHJlZmxlY3Rpb24gY29lZmZzIHBlciB3YWxsLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTXG4gKiBERUZBVUxUX1JFRkxFQ1RJT05fQ09FRkZJQ0lFTlRTfS5cbiAqL1xuRWFybHlSZWZsZWN0aW9ucy5wcm90b3R5cGUuc2V0Um9vbVByb3BlcnRpZXMgPSBmdW5jdGlvbihkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZmljaWVudHMpIHtcbiAgaWYgKGRpbWVuc2lvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgZGltZW5zaW9ucyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24oZGltZW5zaW9ucywgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMpO1xuICB9XG4gIGlmIChjb2VmZmljaWVudHMgPT0gdW5kZWZpbmVkKSB7XG4gICAgY29lZmZpY2llbnRzID0ge307XG4gICAgT2JqZWN0LmFzc2lnbihjb2VmZmljaWVudHMsIFV0aWxzLkRFRkFVTFRfUkVGTEVDVElPTl9DT0VGRklDSUVOVFMpO1xuICB9XG4gIHRoaXMuX2NvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcblxuICAvLyBTYW5pdGl6ZSBkaW1lbnNpb25zIGFuZCBzdG9yZSBoYWxmLWRpbWVuc2lvbnMuXG4gIHRoaXMuX2hhbGZEaW1lbnNpb25zID0ge307XG4gIHRoaXMuX2hhbGZEaW1lbnNpb25zLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCAqIDAuNTtcbiAgdGhpcy5faGFsZkRpbWVuc2lvbnMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKiAwLjU7XG4gIHRoaXMuX2hhbGZEaW1lbnNpb25zLmRlcHRoID0gZGltZW5zaW9ucy5kZXB0aCAqIDAuNTtcblxuICAvLyBVcGRhdGUgbGlzdGVuZXIgcG9zaXRpb24gd2l0aCBuZXcgcm9vbSBwcm9wZXJ0aWVzLlxuICB0aGlzLnNldExpc3RlbmVyUG9zaXRpb24odGhpcy5fbGlzdGVuZXJQb3NpdGlvblswXSxcbiAgICB0aGlzLl9saXN0ZW5lclBvc2l0aW9uWzFdLCB0aGlzLl9saXN0ZW5lclBvc2l0aW9uWzJdKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBFYXJseVJlZmxlY3Rpb25zO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUHJpbWFyeSBuYW1lc3BhY2UgZm9yIFJlc29uYW5jZUF1ZGlvIGxpYnJhcnkuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG4gXG5cblxuLy8gTWFpbiBtb2R1bGUuXG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblxuLy8gVGVzdGFibGUgU3VibW9kdWxlcy5cbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uQXR0ZW51YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5EaXJlY3Rpdml0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5leHBvcnRzLlJlc29uYW5jZUF1ZGlvLkVhcmx5UmVmbGVjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5FbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uTGF0ZVJlZmxlY3Rpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uTGlzdGVuZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5Sb29tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uVGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmV4cG9ydHMuUmVzb25hbmNlQXVkaW8uVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuZXhwb3J0cy5SZXNvbmFuY2VBdWRpby5WZXJzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBSZXNvbmFuY2VBdWRpbyBsaWJyYXJ5IG5hbWUgc3BhY2UgYW5kIGNvbW1vbiB1dGlsaXRpZXMuXG4gKiBAYXV0aG9yIEFuZHJldyBBbGxlbiA8Yml0bGxhbWFAZ29vZ2xlLmNvbT5cbiAqL1xuXG5cblxuXG4vLyBJbnRlcm5hbCBkZXBlbmRlbmNpZXMuXG5jb25zdCBMaXN0ZW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5jb25zdCBTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29uc3QgUm9vbSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5jb25zdCBFbmNvZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEBjbGFzcyBSZXNvbmFuY2VBdWRpb1xuICogQGRlc2NyaXB0aW9uIE1haW4gY2xhc3MgZm9yIG1hbmFnaW5nIHNvdXJjZXMsIHJvb20gYW5kIGxpc3RlbmVyIG1vZGVscy5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0XG4gKiBBc3NvY2lhdGVkIHtAbGlua1xuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvQ29udGV4dCBBdWRpb0NvbnRleHR9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFtYmlzb25pY09yZGVyXG4gKiBEZXNpcmVkIGFtYmlzb25pYyBPcmRlci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVIgREVGQVVMVF9BTUJJU09OSUNfT1JERVJ9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvblxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCBwb3NpdGlvbiAoaW4gbWV0ZXJzKSwgd2hlcmUgb3JpZ2luIGlzIHRoZSBjZW50ZXIgb2ZcbiAqIHRoZSByb29tLiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfUE9TSVRJT04gREVGQVVMVF9QT1NJVElPTn0uXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5saXN0ZW5lckZvcndhcmRcbiAqIFRoZSBsaXN0ZW5lcidzIGluaXRpYWwgZm9yd2FyZCB2ZWN0b3IuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRk9SV0FSRCBERUZBVUxUX0ZPUldBUkR9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMubGlzdGVuZXJVcFxuICogVGhlIGxpc3RlbmVyJ3MgaW5pdGlhbCB1cCB2ZWN0b3IuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfVVAgREVGQVVMVF9VUH0uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kaW1lbnNpb25zIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMgREVGQVVMVF9ST09NX0RJTUVOU0lPTlN9LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMubWF0ZXJpYWxzIE5hbWVkIGFjb3VzdGljIG1hdGVyaWFscyBwZXIgd2FsbC5cbiAqIERlZmF1bHRzIHRvIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ST09NX01BVEVSSUFMUyBERUZBVUxUX1JPT01fTUFURVJJQUxTfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNwZWVkT2ZTb3VuZFxuICogKGluIG1ldGVycy9zZWNvbmQpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NQRUVEX09GX1NPVU5EIERFRkFVTFRfU1BFRURfT0ZfU09VTkR9LlxuICovXG5mdW5jdGlvbiBSZXNvbmFuY2VBdWRpbyhjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFB1YmxpYyB2YXJpYWJsZXMuXG4gIC8qKlxuICAgKiBCaW5hdXJhbGx5LXJlbmRlcmVkIHN0ZXJlbyAoMi1jaGFubmVsKSBvdXRwdXQge0BsaW5rXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BdWRpb05vZGUgQXVkaW9Ob2RlfS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBvdXRwdXRcbiAgICogQG1lbWJlcm9mIFJlc29uYW5jZUF1ZGlvXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cbiAgLyoqXG4gICAqIEFtYmlzb25pYyAobXVsdGljaGFubmVsKSBpbnB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9XG4gICAqIChGb3IgcmVuZGVyaW5nIGlucHV0IHNvdW5kZmllbGRzKS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBhbWJpc29uaWNJbnB1dFxuICAgKiBAbWVtYmVyb2YgUmVzb25hbmNlQXVkaW9cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICAvKipcbiAgICogQW1iaXNvbmljIChtdWx0aWNoYW5uZWwpIG91dHB1dCB7QGxpbmtcbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvTm9kZSBBdWRpb05vZGV9XG4gICAqIChGb3IgYWxsb3dpbmcgZXh0ZXJuYWwgcmVuZGVyaW5nIC8gcG9zdC1wcm9jZXNzaW5nKS5cbiAgICogQG1lbWJlciB7QXVkaW9Ob2RlfSBhbWJpc29uaWNPdXRwdXRcbiAgICogQG1lbWJlcm9mIFJlc29uYW5jZUF1ZGlvXG4gICAqIEBpbnN0YW5jZVxuICAgKi9cblxuICAvLyBVc2UgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBhcmd1bWVudHMuXG4gIGlmIChvcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5hbWJpc29uaWNPcmRlciA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmFtYmlzb25pY09yZGVyID0gVXRpbHMuREVGQVVMVF9BTUJJU09OSUNfT1JERVI7XG4gIH1cbiAgaWYgKG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbiA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmxpc3RlbmVyUG9zaXRpb24gPSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubGlzdGVuZXJGb3J3YXJkID09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMubGlzdGVuZXJGb3J3YXJkID0gVXRpbHMuREVGQVVMVF9GT1JXQVJELnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubGlzdGVuZXJVcCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmxpc3RlbmVyVXAgPSBVdGlscy5ERUZBVUxUX1VQLnNsaWNlKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZGltZW5zaW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLmRpbWVuc2lvbnMgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuZGltZW5zaW9ucywgVXRpbHMuREVGQVVMVF9ST09NX0RJTUVOU0lPTlMpO1xuICB9XG4gIGlmIChvcHRpb25zLm1hdGVyaWFscyA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLm1hdGVyaWFscyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5tYXRlcmlhbHMsIFV0aWxzLkRFRkFVTFRfUk9PTV9NQVRFUklBTFMpO1xuICB9XG4gIGlmIChvcHRpb25zLnNwZWVkT2ZTb3VuZCA9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zLnNwZWVkT2ZTb3VuZCA9IFV0aWxzLkRFRkFVTFRfU1BFRURfT0ZfU09VTkQ7XG4gIH1cblxuICAvLyBDcmVhdGUgbWVtYmVyIHN1Ym1vZHVsZXMuXG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID0gRW5jb2Rlci52YWxpZGF0ZUFtYmlzb25pY09yZGVyKG9wdGlvbnMuYW1iaXNvbmljT3JkZXIpO1xuICB0aGlzLl9zb3VyY2VzID0gW107XG4gIHRoaXMuX3Jvb20gPSBuZXcgUm9vbShjb250ZXh0LCB7XG4gICAgbGlzdGVuZXJQb3NpdGlvbjogb3B0aW9ucy5saXN0ZW5lclBvc2l0aW9uLFxuICAgIGRpbWVuc2lvbnM6IG9wdGlvbnMuZGltZW5zaW9ucyxcbiAgICBtYXRlcmlhbHM6IG9wdGlvbnMubWF0ZXJpYWxzLFxuICAgIHNwZWVkT2ZTb3VuZDogb3B0aW9ucy5zcGVlZE9mU291bmQsXG4gIH0pO1xuICB0aGlzLl9saXN0ZW5lciA9IG5ldyBMaXN0ZW5lcihjb250ZXh0LCB7XG4gICAgYW1iaXNvbmljT3JkZXI6IG9wdGlvbnMuYW1iaXNvbmljT3JkZXIsXG4gICAgcG9zaXRpb246IG9wdGlvbnMubGlzdGVuZXJQb3NpdGlvbixcbiAgICBmb3J3YXJkOiBvcHRpb25zLmxpc3RlbmVyRm9yd2FyZCxcbiAgICB1cDogb3B0aW9ucy5saXN0ZW5lclVwLFxuICB9KTtcblxuICAvLyBDcmVhdGUgYXV4aWxsYXJ5IGF1ZGlvIG5vZGVzLlxuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5hbWJpc29uaWNPdXRwdXQgPSBjb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5hbWJpc29uaWNJbnB1dCA9IHRoaXMuX2xpc3RlbmVyLmlucHV0O1xuXG4gIC8vIENvbm5lY3QgYXVkaW8gZ3JhcGguXG4gIHRoaXMuX3Jvb20ub3V0cHV0LmNvbm5lY3QodGhpcy5fbGlzdGVuZXIuaW5wdXQpO1xuICB0aGlzLl9saXN0ZW5lci5vdXRwdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gIHRoaXMuX2xpc3RlbmVyLmFtYmlzb25pY091dHB1dC5jb25uZWN0KHRoaXMuYW1iaXNvbmljT3V0cHV0KTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzb3VyY2UgZm9yIHRoZSBzY2VuZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gb3B0aW9ucy5wb3NpdGlvblxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgcG9zaXRpb24gKGluIG1ldGVycyksIHdoZXJlIG9yaWdpbiBpcyB0aGUgY2VudGVyIG9mXG4gKiB0aGUgcm9vbS4gRGVmYXVsdHMgdG8ge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1BPU0lUSU9OIERFRkFVTFRfUE9TSVRJT059LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMuZm9yd2FyZFxuICogVGhlIHNvdXJjZSdzIGluaXRpYWwgZm9yd2FyZCB2ZWN0b3IuIERlZmF1bHRzIHRvXG4gKiB7QGxpbmtjb2RlIFV0aWxzLkRFRkFVTFRfRk9SV0FSRCBERUZBVUxUX0ZPUldBUkR9LlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG9wdGlvbnMudXBcbiAqIFRoZSBzb3VyY2UncyBpbml0aWFsIHVwIHZlY3Rvci4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9VUCBERUZBVUxUX1VQfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm1pbkRpc3RhbmNlXG4gKiBNaW4uIGRpc3RhbmNlIChpbiBtZXRlcnMpLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX01JTl9ESVNUQU5DRSBERUZBVUxUX01JTl9ESVNUQU5DRX0uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5tYXhEaXN0YW5jZVxuICogTWF4LiBkaXN0YW5jZSAoaW4gbWV0ZXJzKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9NQVhfRElTVEFOQ0UgREVGQVVMVF9NQVhfRElTVEFOQ0V9LlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMucm9sbG9mZlxuICogUm9sbG9mZiBtb2RlbCB0byB1c2UsIGNob3NlbiBmcm9tIG9wdGlvbnMgaW5cbiAqIHtAbGlua2NvZGUgVXRpbHMuQVRURU5VQVRJT05fUk9MTE9GRlMgQVRURU5VQVRJT05fUk9MTE9GRlN9LiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0FUVEVOVUFUSU9OX1JPTExPRkYgREVGQVVMVF9BVFRFTlVBVElPTl9ST0xMT0ZGfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmdhaW4gSW5wdXQgZ2FpbiAobGluZWFyKS4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9TT1VSQ0VfR0FJTiBERUZBVUxUX1NPVVJDRV9HQUlOfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmFscGhhIERpcmVjdGl2aXR5IGFscGhhLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX0RJUkVDVElWSVRZX0FMUEhBIERFRkFVTFRfRElSRUNUSVZJVFlfQUxQSEF9LlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2hhcnBuZXNzIERpcmVjdGl2aXR5IHNoYXJwbmVzcy4gRGVmYXVsdHMgdG9cbiAqIHtAbGlua2NvZGUgVXRpbHMuREVGQVVMVF9ESVJFQ1RJVklUWV9TSEFSUE5FU1NcbiAqIERFRkFVTFRfRElSRUNUSVZJVFlfU0hBUlBORVNTfS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNvdXJjZVdpZHRoXG4gKiBTb3VyY2Ugd2lkdGggKGluIGRlZ3JlZXMpLiBXaGVyZSAwIGRlZ3JlZXMgaXMgYSBwb2ludCBzb3VyY2UgYW5kIDM2MCBkZWdyZWVzXG4gKiBpcyBhbiBvbW5pZGlyZWN0aW9uYWwgc291cmNlLiBEZWZhdWx0cyB0b1xuICoge0BsaW5rY29kZSBVdGlscy5ERUZBVUxUX1NPVVJDRV9XSURUSCBERUZBVUxUX1NPVVJDRV9XSURUSH0uXG4gKiBAcmV0dXJuIHtTb3VyY2V9XG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5jcmVhdGVTb3VyY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBhIHNvdXJjZSBhbmQgcHVzaCBpdCB0byB0aGUgaW50ZXJuYWwgc291cmNlcyBhcnJheSwgcmV0dXJuaW5nXG4gIC8vIHRoZSBvYmplY3QncyByZWZlcmVuY2UgdG8gdGhlIHVzZXIuXG4gIGxldCBzb3VyY2UgPSBuZXcgU291cmNlKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl9zb3VyY2VzW3RoaXMuX3NvdXJjZXMubGVuZ3RoXSA9IHNvdXJjZTtcbiAgcmV0dXJuIHNvdXJjZTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNjZW5lJ3MgZGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgRGVzaXJlZCBhbWJpc29uaWMgb3JkZXIuXG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRBbWJpc29uaWNPcmRlciA9IGZ1bmN0aW9uKGFtYmlzb25pY09yZGVyKSB7XG4gIHRoaXMuX2FtYmlzb25pY09yZGVyID0gRW5jb2Rlci52YWxpZGF0ZUFtYmlzb25pY09yZGVyKGFtYmlzb25pY09yZGVyKTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIHJvb20ncyBkaW1lbnNpb25zIGFuZCB3YWxsIG1hdGVyaWFscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb25zIFJvb20gZGltZW5zaW9ucyAoaW4gbWV0ZXJzKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbHMgTmFtZWQgYWNvdXN0aWMgbWF0ZXJpYWxzIHBlciB3YWxsLlxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0Um9vbVByb3BlcnRpZXMgPSBmdW5jdGlvbihkaW1lbnNpb25zLCBtYXRlcmlhbHMpIHtcbiAgdGhpcy5fcm9vbS5zZXRQcm9wZXJ0aWVzKGRpbWVuc2lvbnMsIG1hdGVyaWFscyk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBsaXN0ZW5lcidzIHBvc2l0aW9uIChpbiBtZXRlcnMpLCB3aGVyZSBvcmlnaW4gaXMgdGhlIGNlbnRlciBvZlxuICogdGhlIHJvb20uXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKi9cblJlc29uYW5jZUF1ZGlvLnByb3RvdHlwZS5zZXRMaXN0ZW5lclBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAvLyBVcGRhdGUgbGlzdGVuZXIgcG9zaXRpb24uXG4gIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzBdID0geDtcbiAgdGhpcy5fbGlzdGVuZXIucG9zaXRpb25bMV0gPSB5O1xuICB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblsyXSA9IHo7XG4gIHRoaXMuX3Jvb20uc2V0TGlzdGVuZXJQb3NpdGlvbih4LCB5LCB6KTtcblxuICAvLyBVcGRhdGUgc291cmNlcyB3aXRoIG5ldyBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgdGhpcy5fc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgZWxlbWVudC5fdXBkYXRlKCk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc291cmNlJ3Mgb3JpZW50YXRpb24gdXNpbmcgZm9yd2FyZCBhbmQgdXAgdmVjdG9ycy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmb3J3YXJkWFxuICogQHBhcmFtIHtOdW1iZXJ9IGZvcndhcmRZXG4gKiBAcGFyYW0ge051bWJlcn0gZm9yd2FyZFpcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFhcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFlcbiAqIEBwYXJhbSB7TnVtYmVyfSB1cFpcbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldExpc3RlbmVyT3JpZW50YXRpb24gPSBmdW5jdGlvbihmb3J3YXJkWCwgZm9yd2FyZFksXG4gIGZvcndhcmRaLCB1cFgsIHVwWSwgdXBaKSB7XG4gIHRoaXMuX2xpc3RlbmVyLnNldE9yaWVudGF0aW9uKGZvcndhcmRYLCBmb3J3YXJkWSwgZm9yd2FyZFosIHVwWCwgdXBZLCB1cFopO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgbGlzdGVuZXIncyBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gdXNpbmcgYSBUaHJlZS5qcyBNYXRyaXg0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRyaXhcbiAqIFRoZSBUaHJlZS5qcyBNYXRyaXg0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGxpc3RlbmVyJ3Mgd29ybGQgdHJhbnNmb3JtLlxuICovXG5SZXNvbmFuY2VBdWRpby5wcm90b3R5cGUuc2V0TGlzdGVuZXJGcm9tTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG4gIHRoaXMuX2xpc3RlbmVyLnNldEZyb21NYXRyaXgobWF0cml4KTtcblxuICAvLyBVcGRhdGUgdGhlIHJlc3Qgb2YgdGhlIHNjZW5lIHVzaW5nIG5ldyBsaXN0ZW5lciBwb3NpdGlvbi5cbiAgdGhpcy5zZXRMaXN0ZW5lclBvc2l0aW9uKHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzBdLFxuICAgIHRoaXMuX2xpc3RlbmVyLnBvc2l0aW9uWzFdLCB0aGlzLl9saXN0ZW5lci5wb3NpdGlvblsyXSk7XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBzcGVlZCBvZiBzb3VuZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZE9mU291bmRcbiAqL1xuUmVzb25hbmNlQXVkaW8ucHJvdG90eXBlLnNldFNwZWVkT2ZTb3VuZCA9IGZ1bmN0aW9uKHNwZWVkT2ZTb3VuZCkge1xuICB0aGlzLl9yb29tLnNwZWVkT2ZTb3VuZCA9IHNwZWVkT2ZTb3VuZDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNvbmFuY2VBdWRpbztcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHRydWUpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gZmFjdG9yeSgpO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgbGlicmFyeSBjb21tb24gdXRpbGl0aWVzLlxuICovXG5cblxuLyoqXG4gKiBPbW5pdG9uZSBsaWJyYXJ5IGxvZ2dpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2FueX0gTWVzc2FnZSB0byBiZSBwcmludGVkIG91dC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBbXG4gICAgJyVjW09tbml0b25lXSVjICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKSArXG4gICAgICAgICcgJWMoQCcgKyBwZXJmb3JtYW5jZS5ub3coKS50b0ZpeGVkKDIpICsgJ21zKScsXG4gICAgJ2JhY2tncm91bmQ6ICNCQkRFRkI7IGNvbG9yOiAjRkY1NzIyOyBmb250LXdlaWdodDogNTAwJywgJ2ZvbnQtd2VpZ2h0OiAzMDAnLFxuICAgICdjb2xvcjogI0FBQScsXG4gIF0pO1xufTtcblxuXG4vKipcbiAqIE9tbml0b25lIGxpYnJhcnkgZXJyb3ItdGhyb3dpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2FueX0gTWVzc2FnZSB0byBiZSBwcmludGVkIG91dC5cbiAqL1xuZXhwb3J0cy50aHJvdyA9IGZ1bmN0aW9uKCkge1xuICB3aW5kb3cuY29uc29sZS5lcnJvci5hcHBseSh3aW5kb3cuY29uc29sZSwgW1xuICAgICclY1tPbW5pdG9uZV0lYyAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJykgK1xuICAgICAgICAnICVjKEAnICsgcGVyZm9ybWFuY2Uubm93KCkudG9GaXhlZCgyKSArICdtcyknLFxuICAgICdiYWNrZ3JvdW5kOiAjQzYyODI4OyBjb2xvcjogI0ZGRUJFRTsgZm9udC13ZWlnaHQ6IDgwMCcsICdmb250LXdlaWdodDogNDAwJyxcbiAgICAnY29sb3I6ICNBQUEnLFxuICBdKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UpO1xufTtcblxuXG4vLyBTdGF0aWMgdGVtcCBzdG9yYWdlIGZvciBtYXRyaXggaW52ZXJzaW9uLlxubGV0IGEwMDtcbmxldCBhMDE7XG5sZXQgYTAyO1xubGV0IGEwMztcbmxldCBhMTA7XG5sZXQgYTExO1xubGV0IGExMjtcbmxldCBhMTM7XG5sZXQgYTIwO1xubGV0IGEyMTtcbmxldCBhMjI7XG5sZXQgYTIzO1xubGV0IGEzMDtcbmxldCBhMzE7XG5sZXQgYTMyO1xubGV0IGEzMztcbmxldCBiMDA7XG5sZXQgYjAxO1xubGV0IGIwMjtcbmxldCBiMDM7XG5sZXQgYjA0O1xubGV0IGIwNTtcbmxldCBiMDY7XG5sZXQgYjA3O1xubGV0IGIwODtcbmxldCBiMDk7XG5sZXQgYjEwO1xubGV0IGIxMTtcbmxldCBkZXQ7XG5cblxuLyoqXG4gKiBBIDR4NCBtYXRyaXggaW52ZXJzaW9uIHV0aWxpdHkuIFRoaXMgZG9lcyBub3QgaGFuZGxlIHRoZSBjYXNlIHdoZW4gdGhlXG4gKiBhcmd1bWVudHMgYXJlIG5vdCBwcm9wZXIgNHg0IG1hdHJpY2VzLlxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IG91dCAgIFRoZSBpbnZlcnRlZCByZXN1bHQuXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gYSAgICAgVGhlIHNvdXJjZSBtYXRyaXguXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IG91dFxuICovXG5leHBvcnRzLmludmVydE1hdHJpeDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgYTAwID0gYVswXTtcbiAgYTAxID0gYVsxXTtcbiAgYTAyID0gYVsyXTtcbiAgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTtcbiAgYTExID0gYVs1XTtcbiAgYTEyID0gYVs2XTtcbiAgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTtcbiAgYTIxID0gYVs5XTtcbiAgYTIyID0gYVsxMF07XG4gIGEyMyA9IGFbMTFdO1xuICBhMzAgPSBhWzEyXTtcbiAgYTMxID0gYVsxM107XG4gIGEzMiA9IGFbMTRdO1xuICBhMzMgPSBhWzE1XTtcbiAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcbiAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBkZWZpbmVkIGluIHRoZSBFTlVNIGRpY3Rpb25hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gZW51bURpY3Rpb25hcnkgLSBFTlVNIGRpY3Rpb25hcnkuXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGVudHJ5VmFsdWUgLSBhIHZhbHVlIHRvIHByb2JlLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0RlZmluZWRFTlVNRW50cnkgPSBmdW5jdGlvbihlbnVtRGljdGlvbmFyeSwgZW50cnlWYWx1ZSkge1xuICBmb3IgKGxldCBlbnVtS2V5IGluIGVudW1EaWN0aW9uYXJ5KSB7XG4gICAgaWYgKGVudHJ5VmFsdWUgPT09IGVudW1EaWN0aW9uYXJ5W2VudW1LZXldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQSBjb250ZXh0IG9iamVjdCB0byBiZSBjaGVja2VkLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0F1ZGlvQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgLy8gVE9ETyhob2NoKTogVXBkYXRlIHRoaXMgd2hlbiBCYXNlQXVkaW9Db250ZXh0IGlzIGF2YWlsYWJsZSBmb3IgYWxsXG4gIC8vIGJyb3dzZXJzLlxuICByZXR1cm4gY29udGV4dCBpbnN0YW5jZW9mIEF1ZGlvQ29udGV4dCB8fFxuICAgIGNvbnRleHQgaW5zdGFuY2VvZiBPZmZsaW5lQXVkaW9Db250ZXh0O1xufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWxpZCBBdWRpb0J1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0J1ZmZlciBBbiBBdWRpb0J1ZmZlciBvYmplY3QgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBdWRpb0J1ZmZlciA9IGZ1bmN0aW9uKGF1ZGlvQnVmZmVyKSB7XG4gIHJldHVybiBhdWRpb0J1ZmZlciBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyO1xufTtcblxuXG4vKipcbiAqIFBlcmZvcm0gY2hhbm5lbC13aXNlIG1lcmdlIG9uIG11bHRpcGxlIEF1ZGlvQnVmZmVycy4gVGhlIHNhbXBsZSByYXRlIGFuZFxuICogdGhlIGxlbmd0aCBvZiBidWZmZXJzIHRvIGJlIG1lcmdlZCBtdXN0IGJlIGlkZW50aWNhbC5cbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gYnVmZmVyTGlzdCAtIEFuIGFycmF5IG9mIEF1ZGlvQnVmZmVycyB0byBiZSBtZXJnZWRcbiAqIGNoYW5uZWwtd2lzZS5cbiAqIEByZXR1cm4ge0F1ZGlvQnVmZmVyfSAtIEEgc2luZ2xlIG1lcmdlZCBBdWRpb0J1ZmZlci5cbiAqL1xuZXhwb3J0cy5tZXJnZUJ1ZmZlckxpc3RCeUNoYW5uZWwgPSBmdW5jdGlvbihjb250ZXh0LCBidWZmZXJMaXN0KSB7XG4gIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGJ1ZmZlckxpc3RbMF0ubGVuZ3RoO1xuICBjb25zdCBidWZmZXJTYW1wbGVSYXRlID0gYnVmZmVyTGlzdFswXS5zYW1wbGVSYXRlO1xuICBsZXQgYnVmZmVyTnVtYmVyT2ZDaGFubmVsID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYnVmZmVyTnVtYmVyT2ZDaGFubmVsID4gMzIpIHtcbiAgICAgIGV4cG9ydHMudGhyb3coJ1V0aWxzLm1lcmdlQnVmZmVyOiBOdW1iZXIgb2YgY2hhbm5lbHMgY2Fubm90IGV4Y2VlZCAzMi4nICtcbiAgICAgICAgICAnKGdvdCAnICsgYnVmZmVyTnVtYmVyT2ZDaGFubmVsICsgJyknKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckxlbmd0aCAhPT0gYnVmZmVyTGlzdFtpXS5sZW5ndGgpIHtcbiAgICAgIGV4cG9ydHMudGhyb3coJ1V0aWxzLm1lcmdlQnVmZmVyOiBBdWRpb0J1ZmZlciBsZW5ndGhzIGFyZSAnICtcbiAgICAgICAgICAnaW5jb25zaXN0ZW50LiAoZXhwZWN0ZWQgJyArIGJ1ZmZlckxlbmd0aCArICcgYnV0IGdvdCAnICtcbiAgICAgICAgICBidWZmZXJMaXN0W2ldLmxlbmd0aCArICcpJyk7XG4gICAgfVxuICAgIGlmIChidWZmZXJTYW1wbGVSYXRlICE9PSBidWZmZXJMaXN0W2ldLnNhbXBsZVJhdGUpIHtcbiAgICAgIGV4cG9ydHMudGhyb3coJ1V0aWxzLm1lcmdlQnVmZmVyOiBBdWRpb0J1ZmZlciBzYW1wbGUgcmF0ZXMgYXJlICcgK1xuICAgICAgICAgICdpbmNvbnNpc3RlbnQuIChleHBlY3RlZCAnICsgYnVmZmVyU2FtcGxlUmF0ZSArICcgYnV0IGdvdCAnICtcbiAgICAgICAgICBidWZmZXJMaXN0W2ldLnNhbXBsZVJhdGUgKyAnKScpO1xuICAgIH1cbiAgICBidWZmZXJOdW1iZXJPZkNoYW5uZWwgKz0gYnVmZmVyTGlzdFtpXS5udW1iZXJPZkNoYW5uZWxzO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIoYnVmZmVyTnVtYmVyT2ZDaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclNhbXBsZVJhdGUpO1xuICBsZXQgZGVzdGluYXRpb25DaGFubmVsSW5kZXggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ1ZmZlckxpc3RbaV0ubnVtYmVyT2ZDaGFubmVsczsgKytqKSB7XG4gICAgICBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoZGVzdGluYXRpb25DaGFubmVsSW5kZXgrKykuc2V0KFxuICAgICAgICAgIGJ1ZmZlckxpc3RbaV0uZ2V0Q2hhbm5lbERhdGEoaikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybSBjaGFubmVsLXdpc2Ugc3BsaXQgYnkgdGhlIGdpdmVuIGNoYW5uZWwgY291bnQuIEZvciBleGFtcGxlLFxuICogMSB4IEF1ZGlvQnVmZmVyKDgpIC0+IHNwbGl0QnVmZmVyKGNvbnRleHQsIGJ1ZmZlciwgMikgLT4gNCB4IEF1ZGlvQnVmZmVyKDIpLlxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYXVkaW9CdWZmZXIgLSBBbiBBdWRpb0J1ZmZlciB0byBiZSBzcGxpdHRlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGxpdEJ5IC0gTnVtYmVyIG9mIGNoYW5uZWxzIHRvIGJlIHNwbGl0dGVkLlxuICogQHJldHVybiB7QXVkaW9CdWZmZXJbXX0gLSBBbiBhcnJheSBvZiBzcGxpdHRlZCBBdWRpb0J1ZmZlcnMuXG4gKi9cbmV4cG9ydHMuc3BsaXRCdWZmZXJieUNoYW5uZWwgPSBmdW5jdGlvbihjb250ZXh0LCBhdWRpb0J1ZmZlciwgc3BsaXRCeSkge1xuICBpZiAoYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyA8PSBzcGxpdEJ5KSB7XG4gICAgZXhwb3J0cy50aHJvdygnVXRpbHMuc3BsaXRCdWZmZXI6IEluc3VmZmljaWVudCBudW1iZXIgb2YgY2hhbm5lbHMuICgnICtcbiAgICAgICAgYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscyArICcgc3BsaXR0ZWQgYnkgJyArIHNwbGl0QnkgKyAnKScpO1xuICB9XG5cbiAgbGV0IGJ1ZmZsZXJMaXN0ID0gW107XG4gIGxldCBzb3VyY2VDaGFubmVsSW5kZXggPSAwO1xuICBjb25zdCBudW1iZXJPZlNwbGl0dGVkQnVmZmVyID1cbiAgICAgIE1hdGguY2VpbChhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzIC8gc3BsaXRCeSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTcGxpdHRlZEJ1ZmZlcjsgKytpKSB7XG4gICAgbGV0IGJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyKHNwbGl0QnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvQnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9CdWZmZXIuc2FtcGxlUmF0ZSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGxpdEJ5OyArK2opIHtcbiAgICAgIGlmIChzb3VyY2VDaGFubmVsSW5kZXggPCBhdWRpb0J1ZmZlci5udW1iZXJPZkNoYW5uZWxzKSB7XG4gICAgICAgIGJ1ZmZlci5nZXRDaGFubmVsRGF0YShqKS5zZXQoXG4gICAgICAgICAgYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoc291cmNlQ2hhbm5lbEluZGV4KyspKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmZmxlckxpc3QucHVzaChidWZmZXIpO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlckxpc3Q7XG59O1xuXG5cbi8qKlxuICogQ29udmVydHMgQmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIEFycmF5QnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0cmluZyAtIEJhc2U2NC1lbmNkb2VkIHN0cmluZy5cbiAqIEByZXR1cm4ge0FycmF5Qnl1ZmZlcn0gQ29udmVydGVkIEFycmF5QnVmZmVyIG9iamVjdC5cbiAqL1xuZXhwb3J0cy5nZXRBcnJheUJ1ZmZlckZyb21CYXNlNjRTdHJpbmcgPSBmdW5jdGlvbihiYXNlNjRTdHJpbmcpIHtcbiAgbGV0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKGJhc2U2NFN0cmluZyk7XG4gIGxldCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgYnl0ZUFycmF5LmZvckVhY2goXG4gICAgKHZhbHVlLCBpbmRleCkgPT4gYnl0ZUFycmF5W2luZGV4XSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSk7XG4gIHJldHVybiBieXRlQXJyYXkuYnVmZmVyO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBTdHJlYW1saW5lZCBBdWRpb0J1ZmZlciBsb2FkZXIuXG4gKi9cblxuXG5cblxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEJ1ZmZlckRhdGFUeXBlXG4gKi9cblxuLyoqXG4gKiBCdWZmZXIgZGF0YSB0eXBlIGZvciBFTlVNLlxuICogQGVudW0ge0J1ZmZlckRhdGFUeXBlfVxuICovXG5jb25zdCBCdWZmZXJEYXRhVHlwZSA9IHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBkYXRhIGNvbnRhaW5zIEJhc2U2NC1lbmNvZGVkIHN0cmluZy4uICovXG4gIEJBU0U2NDogJ2Jhc2U2NCcsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBUaGUgZGF0YSBpcyBhIFVSTCBmb3IgYXVkaW8gZmlsZS4gKi9cbiAgVVJMOiAndXJsJyxcbn07XG5cblxuLyoqXG4gKiBCdWZmZXJMaXN0IG9iamVjdCBtYW5hbmdlcyB0aGUgYXN5bmMgbG9hZGluZy9kZWNvZGluZyBvZiBtdWx0aXBsZVxuICogQXVkaW9CdWZmZXJzIGZyb20gbXVsdGlwbGUgVVJMcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gYnVmZmVyRGF0YSAtIEFuIG9yZGVyZWQgbGlzdCBvZiBVUkxzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGF0YVR5cGU9J2Jhc2U2NCddIC0gQnVmZmVyRGF0YVR5cGUgc3BlY2lmaWVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52ZXJib3NlPWZhbHNlXSAtIExvZyB2ZXJib3NpdHkuIHx0cnVlfCBwcmludHMgdGhlXG4gKiBpbmRpdmlkdWFsIG1lc3NhZ2UgZnJvbSBlYWNoIFVSTCBhbmQgQXVkaW9CdWZmZXIuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QoY29udGV4dCwgYnVmZmVyRGF0YSwgb3B0aW9ucykge1xuICB0aGlzLl9jb250ZXh0ID0gVXRpbHMuaXNBdWRpb0NvbnRleHQoY29udGV4dCkgP1xuICAgICAgY29udGV4dCA6XG4gICAgICBVdGlscy50aHJvdygnQnVmZmVyTGlzdDogSW52YWxpZCBCYXNlQXVkaW9Db250ZXh0LicpO1xuXG4gIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgZGF0YVR5cGU6IEJ1ZmZlckRhdGFUeXBlLkJBU0U2NCxcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgfTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRhdGFUeXBlICYmXG4gICAgICAgIFV0aWxzLmlzRGVmaW5lZEVOVU1FbnRyeShCdWZmZXJEYXRhVHlwZSwgb3B0aW9ucy5kYXRhVHlwZSkpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMuZGF0YVR5cGUgPSBvcHRpb25zLmRhdGFUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnZlcmJvc2UgPSBCb29sZWFuKG9wdGlvbnMudmVyYm9zZSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYnVmZmVyTGlzdCA9IFtdO1xuICB0aGlzLl9idWZmZXJEYXRhID0gdGhpcy5fb3B0aW9ucy5kYXRhVHlwZSA9PT0gQnVmZmVyRGF0YVR5cGUuQkFTRTY0XG4gICAgICA/IGJ1ZmZlckRhdGFcbiAgICAgIDogYnVmZmVyRGF0YS5zbGljZSgwKTtcbiAgdGhpcy5fbnVtYmVyT2ZUYXNrcyA9IHRoaXMuX2J1ZmZlckRhdGEubGVuZ3RoO1xuXG4gIHRoaXMuX3Jlc29sdmVIYW5kbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVqZWN0SGFuZGxlciA9IG5ldyBGdW5jdGlvbigpO1xufVxuXG5cbi8qKlxuICogU3RhcnRzIEF1ZGlvQnVmZmVyIGxvYWRpbmcgdGFza3MuXG4gKiBAcmV0dXJuIHtQcm9taXNlPEF1ZGlvQnVmZmVyW10+fSBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mXG4gKiBBdWRpb0J1ZmZlci5cbiAqL1xuQnVmZmVyTGlzdC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UodGhpcy5fcHJvbWlzZUdlbmVyYXRvci5iaW5kKHRoaXMpKTtcbn07XG5cblxuLyoqXG4gKiBQcm9taXNlIGFyZ3VtZW50IGdlbmVyYXRvci4gSW50ZXJuYWxseSBzdGFydHMgbXVsdGlwbGUgYXN5bmMgbG9hZGluZyB0YXNrcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlIFByb21pc2UgcmVzb2x2ZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWplY3QgUHJvbWlzZSByZWplY3QuXG4gKi9cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9wcm9taXNlR2VuZXJhdG9yID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIFV0aWxzLnRocm93KCdCdWZmZXJMaXN0OiBJbnZhbGlkIFByb21pc2UgcmVzb2x2ZXIuJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcmVzb2x2ZUhhbmRsZXIgPSByZXNvbHZlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9yZWplY3RIYW5kbGVyID0gcmVqZWN0O1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZmZXJEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5kYXRhVHlwZSA9PT0gQnVmZmVyRGF0YVR5cGUuQkFTRTY0XG4gICAgICAgID8gdGhpcy5fbGF1bmNoQXN5bmNMb2FkVGFzayhpKVxuICAgICAgICA6IHRoaXMuX2xhdW5jaEFzeW5jTG9hZFRhc2tYSFIoaSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSdW4gYXN5bmMgbG9hZGluZyB0YXNrIGZvciBCYXNlNjQtZW5jb2RlZCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRhc2tJZCBUYXNrIElEIG51bWJlciBmcm9tIHRoZSBvcmRlcmVkIGxpc3QgfGJ1ZmZlckRhdGF8LlxuICovXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fbGF1bmNoQXN5bmNMb2FkVGFzayA9IGZ1bmN0aW9uKHRhc2tJZCkge1xuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgdGhpcy5fY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICBVdGlscy5nZXRBcnJheUJ1ZmZlckZyb21CYXNlNjRTdHJpbmcodGhpcy5fYnVmZmVyRGF0YVt0YXNrSWRdKSxcbiAgICAgIGZ1bmN0aW9uKGF1ZGlvQnVmZmVyKSB7XG4gICAgICAgIHRoYXQuX3VwZGF0ZVByb2dyZXNzKHRhc2tJZCwgYXVkaW9CdWZmZXIpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKGVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aGF0Ll91cGRhdGVQcm9ncmVzcyh0YXNrSWQsIG51bGwpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0J1ZmZlckxpc3Q6IGRlY29kaW5nIEFycmF5QnlmZmVyKFwiJyArIHRhc2tJZCArXG4gICAgICAgICAgICAnXCIgZnJvbSBCYXNlNjQtZW5jb2RlZCBkYXRhIGZhaWxlZC4gKCcgKyBlcnJvck1lc3NhZ2UgKyAnKSc7XG4gICAgICAgIFV0aWxzLnRocm93KG1lc3NhZ2UpO1xuICAgICAgICB0aGF0Ll9yZWplY3RIYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgfSk7XG59O1xuXG5cbi8qKlxuICogUnVuIGFzeW5jIGxvYWRpbmcgdGFzayB2aWEgWEhSIGZvciBhdWRpbyBmaWxlIFVSTHMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHRhc2tJZCBUYXNrIElEIG51bWJlciBmcm9tIHRoZSBvcmRlcmVkIGxpc3QgfGJ1ZmZlckRhdGF8LlxuICovXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fbGF1bmNoQXN5bmNMb2FkVGFza1hIUiA9IGZ1bmN0aW9uKHRhc2tJZCkge1xuICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMuX2J1ZmZlckRhdGFbdGFza0lkXSk7XG4gIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gIGNvbnN0IHRoYXQgPSB0aGlzO1xuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgdGhhdC5fY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoXG4gICAgICAgICAgeGhyLnJlc3BvbnNlLFxuICAgICAgICAgIGZ1bmN0aW9uKGF1ZGlvQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGF0Ll91cGRhdGVQcm9ncmVzcyh0YXNrSWQsIGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhhdC5fdXBkYXRlUHJvZ3Jlc3ModGFza0lkLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQnVmZmVyTGlzdDogZGVjb2RpbmcgXCInICtcbiAgICAgICAgICAgICAgICB0aGF0Ll9idWZmZXJEYXRhW3Rhc2tJZF0gKyAnXCIgZmFpbGVkLiAoJyArIGVycm9yTWVzc2FnZSArICcpJztcbiAgICAgICAgICAgIFV0aWxzLnRocm93KG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhhdC5fcmVqZWN0SGFuZGxlcihtZXNzYWdlKTtcbiAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdCdWZmZXJMaXN0OiBYSFIgZXJyb3Igd2hpbGUgbG9hZGluZyBcIicgK1xuICAgICAgICAgIHRoYXQuX2J1ZmZlckRhdGFbdGFza0lkXSArICcoJyArIHhoci5zdGF0dXNUZXh0ICsgJyknO1xuICAgICAgVXRpbHMudGhyb3cobWVzc2FnZSk7XG4gICAgICB0aGF0Ll9yZWplY3RIYW5kbGVyKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgVXRpbHMudGhyb3coXG4gICAgICAgICdCdWZmZXJMaXN0OiBYSFIgbmV0d29yayBmYWlsZWQgb24gbG9hZGluZyBcIicgK1xuICAgICAgICB0aGF0Ll9idWZmZXJEYXRhW3Rhc2tJZF0gKyAnXCIuJyk7XG4gICAgdGhhdC5fdXBkYXRlUHJvZ3Jlc3ModGFza0lkLCBudWxsKTtcbiAgICB0aGF0Ll9yZWplY3RIYW5kbGVyKCk7XG4gIH07XG5cbiAgeGhyLnNlbmQoKTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBvdmVyYWxsIHByb2dyZXNzIG9uIGxvYWRpbmcgdGFza3MuXG4gKiBAcGFyYW0ge051bWJlcn0gdGFza0lkIFRhc2sgSUQgbnVtYmVyLlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYXVkaW9CdWZmZXIgRGVjb2RlZCBBdWRpb0J1ZmZlciBvYmplY3QuXG4gKi9cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl91cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uKHRhc2tJZCwgYXVkaW9CdWZmZXIpIHtcbiAgdGhpcy5fYnVmZmVyTGlzdFt0YXNrSWRdID0gYXVkaW9CdWZmZXI7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudmVyYm9zZSkge1xuICAgIGxldCBtZXNzYWdlU3RyaW5nID0gdGhpcy5fb3B0aW9ucy5kYXRhVHlwZSA9PT0gQnVmZmVyRGF0YVR5cGUuQkFTRTY0XG4gICAgICAgID8gJ0FycmF5QnVmZmVyKCcgKyB0YXNrSWQgKyAnKSBmcm9tIEJhc2U2NC1lbmNvZGVkIEhSSVInXG4gICAgICAgIDogJ1wiJyArIHRoaXMuX2J1ZmZlckRhdGFbdGFza0lkXSArICdcIic7XG4gICAgVXRpbHMubG9nKCdCdWZmZXJMaXN0OiAnICsgbWVzc2FnZVN0cmluZyArICcgc3VjY2Vzc2Z1bGx5IGxvYWRlZC4nKTtcbiAgfVxuXG4gIGlmICgtLXRoaXMuX251bWJlck9mVGFza3MgPT09IDApIHtcbiAgICBsZXQgbWVzc2FnZVN0cmluZyA9IHRoaXMuX29wdGlvbnMuZGF0YVR5cGUgPT09IEJ1ZmZlckRhdGFUeXBlLkJBU0U2NFxuICAgICAgICA/IHRoaXMuX2J1ZmZlckRhdGEubGVuZ3RoICsgJyBBdWRpb0J1ZmZlcnMgZnJvbSBCYXNlNjQtZW5jb2RlZCBIUklScydcbiAgICAgICAgOiB0aGlzLl9idWZmZXJEYXRhLmxlbmd0aCArICcgZmlsZXMgdmlhIFhIUic7XG4gICAgVXRpbHMubG9nKCdCdWZmZXJMaXN0OiAnICsgbWVzc2FnZVN0cmluZyArICcgbG9hZGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICB0aGlzLl9yZXNvbHZlSGFuZGxlcih0aGlzLl9idWZmZXJMaXN0KTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgQW4gYXVkaW8gY2hhbm5lbCByb3V0ZXIgdG8gcmVzb2x2ZSBkaWZmZXJlbnQgY2hhbm5lbCBsYXlvdXRzIGJldHdlZW5cbiAqIGJyb3dzZXJzLlxuICovXG5cblxuXG5cbi8qKlxuICogQHR5cGVkZWYge051bWJlcltdfSBDaGFubmVsTWFwXG4gKi9cblxuLyoqXG4gKiBDaGFubmVsIG1hcCBkaWN0aW9uYXJ5IEVOVU0uXG4gKiBAZW51bSB7Q2hhbm5lbE1hcH1cbiAqL1xuY29uc3QgQ2hhbm5lbE1hcCA9IHtcbiAgLyoqIEB0eXBlIHtOdW1iZXJbXX0gLSBBQ04gY2hhbm5lbCBtYXAgZm9yIENocm9tZSBhbmQgRmlyZUZveC4gKEZGTVBFRykgKi9cbiAgREVGQVVMVDogWzAsIDEsIDIsIDNdLFxuICAvKiogQHR5cGUge051bWJlcltdfSAtIFNhZmFyaSdzIDQtY2hhbm5lbCBtYXAgZm9yIEFBQyBjb2RlYy4gKi9cbiAgU0FGQVJJOiBbMiwgMCwgMSwgM10sXG4gIC8qKiBAdHlwZSB7TnVtYmVyW119IC0gQUNOID4gRnVNYSBjb252ZXJzaW9uIG1hcC4gKi9cbiAgRlVNQTogWzAsIDMsIDEsIDJdLFxufTtcblxuXG4vKipcbiAqIENoYW5uZWwgcm91dGVyIGZvciBGT0Egc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY2hhbm5lbE1hcCAtIFJvdXRpbmcgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIEZPQVJvdXRlcihjb250ZXh0LCBjaGFubmVsTWFwKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX21lcmdlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcig0KTtcblxuICAvLyBpbnB1dC9vdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9zcGxpdHRlcjtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9tZXJnZXI7XG5cbiAgdGhpcy5zZXRDaGFubmVsTWFwKGNoYW5uZWxNYXAgfHwgQ2hhbm5lbE1hcC5ERUZBVUxUKTtcbn1cblxuXG4vKipcbiAqIFNldHMgY2hhbm5lbCBtYXAuXG4gKiBAcGFyYW0ge051bWJlcltdfSBjaGFubmVsTWFwIC0gQSBuZXcgY2hhbm5lbCBtYXAgZm9yIEZPQSBzdHJlYW0uXG4gKi9cbkZPQVJvdXRlci5wcm90b3R5cGUuc2V0Q2hhbm5lbE1hcCA9IGZ1bmN0aW9uKGNoYW5uZWxNYXApIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5uZWxNYXApKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY2hhbm5lbE1hcCA9IGNoYW5uZWxNYXA7XG4gIHRoaXMuX3NwbGl0dGVyLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIHRoaXMuX2NoYW5uZWxNYXBbMF0pO1xuICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX21lcmdlciwgMSwgdGhpcy5fY2hhbm5lbE1hcFsxXSk7XG4gIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAyLCB0aGlzLl9jaGFubmVsTWFwWzJdKTtcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDMsIHRoaXMuX2NoYW5uZWxNYXBbM10pO1xufTtcblxuXG4vKipcbiAqIFN0YXRpYyBjaGFubmVsIG1hcCBFTlVNLlxuICogQHN0YXRpY1xuICogQHR5cGUge0NoYW5uZWxNYXB9XG4gKi9cbkZPQVJvdXRlci5DaGFubmVsTWFwID0gQ2hhbm5lbE1hcDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVJvdXRlcjtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBTb3VuZCBmaWVsZCByb3RhdG9yIGZvciBmaXJzdC1vcmRlci1hbWJpc29uaWNzIGRlY29kaW5nLlxuICovXG5cblxuXG5cbi8qKlxuICogRmlyc3Qtb3JkZXItYW1iaXNvbmljIGRlY29kZXIgYmFzZWQgb24gZ2FpbiBub2RlIG5ldHdvcmsuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIEZPQVJvdGF0b3IoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcblxuICB0aGlzLl9zcGxpdHRlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDQpO1xuICB0aGlzLl9pblkgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faW5aID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2luWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tMCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tMSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tMiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tMyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tNCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tNSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tNiA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tNyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tOCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9vdXRZID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX291dFogPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fb3V0WCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoNCk7XG5cbiAgLy8gQUNOIGNoYW5uZWwgb3JkZXJpbmc6IFsxLCAyLCAzXSA9PiBbLVksIFosIC1YXVxuICAvLyBZIChmcm9tIGNoYW5uZWwgMSlcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9pblksIDEpO1xuICAvLyBaIChmcm9tIGNoYW5uZWwgMilcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9pblosIDIpO1xuICAvLyBYIChmcm9tIGNoYW5uZWwgMylcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9pblgsIDMpO1xuICB0aGlzLl9pblkuZ2Fpbi52YWx1ZSA9IC0xO1xuICB0aGlzLl9pblguZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gIC8vIEFwcGx5IHRoZSByb3RhdGlvbiBpbiB0aGUgd29ybGQgc3BhY2UuXG4gIC8vIHxZfCAgIHwgbTAgIG0zICBtNiB8ICAgfCBZICogbTAgKyBaICogbTMgKyBYICogbTYgfCAgIHwgWXIgfFxuICAvLyB8WnwgKiB8IG0xICBtNCAgbTcgfCA9IHwgWSAqIG0xICsgWiAqIG00ICsgWCAqIG03IHwgPSB8IFpyIHxcbiAgLy8gfFh8ICAgfCBtMiAgbTUgIG04IHwgICB8IFkgKiBtMiArIFogKiBtNSArIFggKiBtOCB8ICAgfCBYciB8XG4gIHRoaXMuX2luWS5jb25uZWN0KHRoaXMuX20wKTtcbiAgdGhpcy5faW5ZLmNvbm5lY3QodGhpcy5fbTEpO1xuICB0aGlzLl9pblkuY29ubmVjdCh0aGlzLl9tMik7XG4gIHRoaXMuX2luWi5jb25uZWN0KHRoaXMuX20zKTtcbiAgdGhpcy5faW5aLmNvbm5lY3QodGhpcy5fbTQpO1xuICB0aGlzLl9pblouY29ubmVjdCh0aGlzLl9tNSk7XG4gIHRoaXMuX2luWC5jb25uZWN0KHRoaXMuX202KTtcbiAgdGhpcy5faW5YLmNvbm5lY3QodGhpcy5fbTcpO1xuICB0aGlzLl9pblguY29ubmVjdCh0aGlzLl9tOCk7XG4gIHRoaXMuX20wLmNvbm5lY3QodGhpcy5fb3V0WSk7XG4gIHRoaXMuX20xLmNvbm5lY3QodGhpcy5fb3V0Wik7XG4gIHRoaXMuX20yLmNvbm5lY3QodGhpcy5fb3V0WCk7XG4gIHRoaXMuX20zLmNvbm5lY3QodGhpcy5fb3V0WSk7XG4gIHRoaXMuX200LmNvbm5lY3QodGhpcy5fb3V0Wik7XG4gIHRoaXMuX201LmNvbm5lY3QodGhpcy5fb3V0WCk7XG4gIHRoaXMuX202LmNvbm5lY3QodGhpcy5fb3V0WSk7XG4gIHRoaXMuX203LmNvbm5lY3QodGhpcy5fb3V0Wik7XG4gIHRoaXMuX204LmNvbm5lY3QodGhpcy5fb3V0WCk7XG5cbiAgLy8gVHJhbnNmb3JtIDM6IHdvcmxkIHNwYWNlIHRvIGF1ZGlvIHNwYWNlLlxuICAvLyBXIC0+IFcgKHRvIGNoYW5uZWwgMClcbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuICAvLyBZICh0byBjaGFubmVsIDEpXG4gIHRoaXMuX291dFkuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuICAvLyBaICh0byBjaGFubmVsIDIpXG4gIHRoaXMuX291dFouY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDIpO1xuICAvLyBYICh0byBjaGFubmVsIDMpXG4gIHRoaXMuX291dFguY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDMpO1xuICB0aGlzLl9vdXRZLmdhaW4udmFsdWUgPSAtMTtcbiAgdGhpcy5fb3V0WC5nYWluLnZhbHVlID0gLTE7XG5cbiAgdGhpcy5zZXRSb3RhdGlvbk1hdHJpeDMobmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pKTtcblxuICAvLyBpbnB1dC9vdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9zcGxpdHRlcjtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9tZXJnZXI7XG59XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCAzeDMgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXgzIC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSb3RhdG9yLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDMpIHtcbiAgdGhpcy5fbTAuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1swXTtcbiAgdGhpcy5fbTEuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1sxXTtcbiAgdGhpcy5fbTIuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1syXTtcbiAgdGhpcy5fbTMuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1szXTtcbiAgdGhpcy5fbTQuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1s0XTtcbiAgdGhpcy5fbTUuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1s1XTtcbiAgdGhpcy5fbTYuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1s2XTtcbiAgdGhpcy5fbTcuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1s3XTtcbiAgdGhpcy5fbTguZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4M1s4XTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCA0eDQgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXg0IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSb3RhdG9yLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDQpIHtcbiAgdGhpcy5fbTAuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFswXTtcbiAgdGhpcy5fbTEuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsxXTtcbiAgdGhpcy5fbTIuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsyXTtcbiAgdGhpcy5fbTMuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs0XTtcbiAgdGhpcy5fbTQuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs1XTtcbiAgdGhpcy5fbTUuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs2XTtcbiAgdGhpcy5fbTYuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs4XTtcbiAgdGhpcy5fbTcuZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs5XTtcbiAgdGhpcy5fbTguZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsxMF07XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCAzeDMgcm90YXRpb24gbWF0cml4LlxuICogQHJldHVybiB7TnVtYmVyW119IC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5GT0FSb3RhdG9yLnByb3RvdHlwZS5nZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB0aGlzLl9tMC5nYWluLnZhbHVlLCB0aGlzLl9tMS5nYWluLnZhbHVlLCB0aGlzLl9tMi5nYWluLnZhbHVlLFxuICAgIHRoaXMuX20zLmdhaW4udmFsdWUsIHRoaXMuX200LmdhaW4udmFsdWUsIHRoaXMuX201LmdhaW4udmFsdWUsXG4gICAgdGhpcy5fbTYuZ2Fpbi52YWx1ZSwgdGhpcy5fbTcuZ2Fpbi52YWx1ZSwgdGhpcy5fbTguZ2Fpbi52YWx1ZSxcbiAgXTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IDR4NCByb3RhdGlvbiBtYXRyaXguXG4gKiBAcmV0dXJuIHtOdW1iZXJbXX0gLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJvdGF0b3IucHJvdG90eXBlLmdldFJvdGF0aW9uTWF0cml4NCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgcm90YXRpb25NYXRyaXg0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gIHJvdGF0aW9uTWF0cml4NFswXSA9IHRoaXMuX20wLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsxXSA9IHRoaXMuX20xLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsyXSA9IHRoaXMuX20yLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs0XSA9IHRoaXMuX20zLmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs1XSA9IHRoaXMuX200LmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs2XSA9IHRoaXMuX201LmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs4XSA9IHRoaXMuX202LmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFs5XSA9IHRoaXMuX203LmdhaW4udmFsdWU7XG4gIHJvdGF0aW9uTWF0cml4NFsxMF0gPSB0aGlzLl9tOC5nYWluLnZhbHVlO1xuICByZXR1cm4gcm90YXRpb25NYXRyaXg0O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVJvdGF0b3I7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBBIGNvbGxlY3Rpb24gb2YgY29udm9sdmVycy4gQ2FuIGJlIHVzZWQgZm9yIHRoZSBvcHRpbWl6ZWQgRk9BIGJpbmF1cmFsXG4gKiByZW5kZXJpbmcuIChlLmcuIFNILU1heFJlIEhSVEZzKVxuICovXG5cblxuXG5cbi8qKlxuICogRk9BQ29udm9sdmVyLiBBIGNvbGxlY3Rpb24gb2YgMiBzdGVyZW8gY29udm9sdmVycyBmb3IgNC1jaGFubmVsIEZPQSBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCBUaGUgYXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IFtocmlyQnVmZmVyTGlzdF0gLSBBbiBvcmRlcmVkLWxpc3Qgb2Ygc3RlcmVvXG4gKiBBdWRpb0J1ZmZlcnMgZm9yIGNvbnZvbHV0aW9uLiAoaS5lLiAyIHN0ZXJlbyBBdWRpb0J1ZmZlcnMgZm9yIEZPQSlcbiAqL1xuZnVuY3Rpb24gRk9BQ29udm9sdmVyKGNvbnRleHQsIGhyaXJCdWZmZXJMaXN0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICB0aGlzLl9pc0J1ZmZlckxvYWRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuX2J1aWxkQXVkaW9HcmFwaCgpO1xuXG4gIGlmIChocmlyQnVmZmVyTGlzdCkge1xuICAgIHRoaXMuc2V0SFJJUkJ1ZmZlckxpc3QoaHJpckJ1ZmZlckxpc3QpO1xuICB9XG5cbiAgdGhpcy5lbmFibGUoKTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkIHRoZSBpbnRlcm5hbCBhdWRpbyBncmFwaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5GT0FDb252b2x2ZXIucHJvdG90eXBlLl9idWlsZEF1ZGlvR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3BsaXR0ZXJXWVpYID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX21lcmdlcldZID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKDIpO1xuICB0aGlzLl9tZXJnZXJaWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiAgdGhpcy5fY29udm9sdmVyV1kgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuICB0aGlzLl9jb252b2x2ZXJaWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gIHRoaXMuX3NwbGl0dGVyV1kgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiAgdGhpcy5fc3BsaXR0ZXJaWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbFNwbGl0dGVyKDIpO1xuICB0aGlzLl9pbnZlcnRlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tZXJnZXJCaW5hdXJhbCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcbiAgdGhpcy5fc3VtbWluZ0J1cyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuXG4gIC8vIEdyb3VwIFcgYW5kIFksIHRoZW4gWiBhbmQgWC5cbiAgdGhpcy5fc3BsaXR0ZXJXWVpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyV1ksIDAsIDApO1xuICB0aGlzLl9zcGxpdHRlcldZWlguY29ubmVjdCh0aGlzLl9tZXJnZXJXWSwgMSwgMSk7XG4gIHRoaXMuX3NwbGl0dGVyV1laWC5jb25uZWN0KHRoaXMuX21lcmdlclpYLCAyLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWVpYLmNvbm5lY3QodGhpcy5fbWVyZ2VyWlgsIDMsIDEpO1xuXG4gIC8vIENyZWF0ZSBhIG5ldHdvcmsgb2YgY29udm9sdmVycyB1c2luZyBzcGxpdHRlci9tZXJnZXIuXG4gIHRoaXMuX21lcmdlcldZLmNvbm5lY3QodGhpcy5fY29udm9sdmVyV1kpO1xuICB0aGlzLl9tZXJnZXJaWC5jb25uZWN0KHRoaXMuX2NvbnZvbHZlclpYKTtcbiAgdGhpcy5fY29udm9sdmVyV1kuY29ubmVjdCh0aGlzLl9zcGxpdHRlcldZKTtcbiAgdGhpcy5fY29udm9sdmVyWlguY29ubmVjdCh0aGlzLl9zcGxpdHRlclpYKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWS5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAwLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWS5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAwLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWS5jb25uZWN0KHRoaXMuX21lcmdlckJpbmF1cmFsLCAxLCAwKTtcbiAgdGhpcy5fc3BsaXR0ZXJXWS5jb25uZWN0KHRoaXMuX2ludmVydGVyLCAxLCAwKTtcbiAgdGhpcy5faW52ZXJ0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMCwgMSk7XG4gIHRoaXMuX3NwbGl0dGVyWlguY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMCwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyWlguY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMCwgMSk7XG4gIHRoaXMuX3NwbGl0dGVyWlguY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMSwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyWlguY29ubmVjdCh0aGlzLl9tZXJnZXJCaW5hdXJhbCwgMSwgMSk7XG5cbiAgLy8gQnkgZGVmYXVsdCwgV2ViQXVkaW8ncyBjb252b2x2ZXIgZG9lcyB0aGUgbm9ybWFsaXphdGlvbiBiYXNlZCBvbiBJUidzXG4gIC8vIGVuZXJneS4gRm9yIHRoZSBwcmVjaXNlIGNvbnZvbHV0aW9uLCBpdCBtdXN0IGJlIGRpc2FibGVkIGJlZm9yZSB0aGUgYnVmZmVyXG4gIC8vIGFzc2lnbm1lbnQuXG4gIHRoaXMuX2NvbnZvbHZlcldZLm5vcm1hbGl6ZSA9IGZhbHNlO1xuICB0aGlzLl9jb252b2x2ZXJaWC5ub3JtYWxpemUgPSBmYWxzZTtcblxuICAvLyBGb3IgYXN5bW1ldHJpYyBkZWdyZWUuXG4gIHRoaXMuX2ludmVydGVyLmdhaW4udmFsdWUgPSAtMTtcblxuICAvLyBJbnB1dC9vdXRwdXQgcHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9zcGxpdHRlcldZWlg7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fc3VtbWluZ0J1cztcbn07XG5cblxuLyoqXG4gKiBBc3NpZ25zIDIgSFJJUiBBdWRpb0J1ZmZlcnMgdG8gMiBjb252b2x2ZXJzOiBOb3RlIHRoYXQgd2UgdXNlIDIgc3RlcmVvXG4gKiBjb252b2x1dGlvbnMgZm9yIDQtY2hhbm5lbCBkaXJlY3QgY29udm9sdXRpb24uIFVzaW5nIG1vbm8gY29udm9sdmVyIG9yXG4gKiA0LWNoYW5uZWwgY29udm9sdmVyIGlzIG5vdCB2aWFibGUgYmVjYXVzZSBtb25vIGNvbnZvbHV0aW9uIHdhc3RlZnVsbHlcbiAqIHByb2R1Y2VzIHRoZSBzdGVyZW8gb3V0cHV0cywgYW5kIHRoZSA0LWNoIGNvbnZvbHZlciBkb2VzIGNyb3NzLWNoYW5uZWxcbiAqIGNvbnZvbHV0aW9uLiAoU2VlIFdlYiBBdWRpbyBBUEkgc3BlYylcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gaHJpckJ1ZmZlckxpc3QgLSBBbiBhcnJheSBvZiBzdGVyZW8gQXVkaW9CdWZmZXJzIGZvclxuICogY29udm9sdmVycy5cbiAqL1xuRk9BQ29udm9sdmVyLnByb3RvdHlwZS5zZXRIUklSQnVmZmVyTGlzdCA9IGZ1bmN0aW9uKGhyaXJCdWZmZXJMaXN0KSB7XG4gIC8vIEFmdGVyIHRoZXNlIGFzc2lnbm1lbnRzLCB0aGUgY2hhbm5lbCBkYXRhIGluIHRoZSBidWZmZXIgaXMgaW1tdXRhYmxlIGluXG4gIC8vIEZpcmVGb3guIChpLmUuIG5ldXRlcmVkKSBTbyB3ZSBzaG91bGQgYXZvaWQgcmUtYXNzaWduaW5nIGJ1ZmZlcnMsIG90aGVyd2lzZVxuICAvLyBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gIGlmICh0aGlzLl9pc0J1ZmZlckxvYWRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2NvbnZvbHZlcldZLmJ1ZmZlciA9IGhyaXJCdWZmZXJMaXN0WzBdO1xuICB0aGlzLl9jb252b2x2ZXJaWC5idWZmZXIgPSBocmlyQnVmZmVyTGlzdFsxXTtcbiAgdGhpcy5faXNCdWZmZXJMb2FkZWQgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIEVuYWJsZSBGT0FDb252b2x2ZXIgaW5zdGFuY2UuIFRoZSBhdWRpbyBncmFwaCB3aWxsIGJlIGFjdGl2YXRlZCBhbmQgcHVsbGVkIGJ5XG4gKiB0aGUgV2ViQXVkaW8gZW5naW5lLiAoaS5lLiBjb25zdW1lIENQVSBjeWNsZSlcbiAqL1xuRk9BQ29udm9sdmVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbWVyZ2VyQmluYXVyYWwuY29ubmVjdCh0aGlzLl9zdW1taW5nQnVzKTtcbiAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEaXNhYmxlIEZPQUNvbnZvbHZlciBpbnN0YW5jZS4gVGhlIGlubmVyIGdyYXBoIHdpbGwgYmUgZGlzY29ubmVjdGVkIGZyb20gdGhlXG4gKiBhdWRpbyBkZXN0aW5hdGlvbiwgdGh1cyBubyBDUFUgY3ljbGUgd2lsbCBiZSBjb25zdW1lZC5cbiAqL1xuRk9BQ29udm9sdmVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX21lcmdlckJpbmF1cmFsLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRk9BQ29udm9sdmVyO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgREVQUkVDQVRFRCBhdCBWMS4gQXVkaW8gYnVmZmVyIGxvYWRpbmcgdXRpbGl0eS5cbiAqL1xuXG5cblxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vKipcbiAqIFN0cmVhbWxpbmVkIGF1ZGlvIGZpbGUgbG9hZGVyIHN1cHBvcnRzIFByb21pc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAgICAgICAgICBBdWRpb0NvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpb0ZpbGVEYXRhICAgIEF1ZGlvIGZpbGUgaW5mbyBhcyBbe25hbWUsIHVybH1dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlICAgICAgICBSZXNvbHV0aW9uIGhhbmRsZXIgZm9yIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgICAgICAgICBSZWplY3Rpb24gaGFuZGxlciBmb3IgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2dyZXNzICAgICAgIFByb2dyZXNzIGV2ZW50IGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIEF1ZGlvQnVmZmVyTWFuYWdlcihjb250ZXh0LCBhdWRpb0ZpbGVEYXRhLCByZXNvbHZlLCByZWplY3QsIHByb2dyZXNzKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX2J1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuX2xvYWRpbmdUYXNrcyA9IHt9O1xuXG4gIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gIHRoaXMuX3Byb2dyZXNzID0gcHJvZ3Jlc3M7XG5cbiAgLy8gSXRlcmF0aW5nIGZpbGUgbG9hZGluZy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb0ZpbGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZmlsZUluZm8gPSBhdWRpb0ZpbGVEYXRhW2ldO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXMgZmlsZW5hbWUgYW5kIHF1aXQgaWYgaXQgaGFwcGVucy5cbiAgICBpZiAodGhpcy5fbG9hZGluZ1Rhc2tzLmhhc093blByb3BlcnR5KGZpbGVJbmZvLm5hbWUpKSB7XG4gICAgICBVdGlscy5sb2coJ0R1cGxpY2F0ZWQgZmlsZW5hbWUgd2hlbiBsb2FkaW5nOiAnICsgZmlsZUluZm8ubmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFyayBpdCBhcyBwZW5kaW5nICgwKVxuICAgIHRoaXMuX2xvYWRpbmdUYXNrc1tmaWxlSW5mby5uYW1lXSA9IDA7XG4gICAgdGhpcy5fbG9hZEF1ZGlvRmlsZShmaWxlSW5mbyk7XG4gIH1cbn1cblxuQXVkaW9CdWZmZXJNYW5hZ2VyLnByb3RvdHlwZS5fbG9hZEF1ZGlvRmlsZSA9IGZ1bmN0aW9uKGZpbGVJbmZvKSB7XG4gIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB4aHIub3BlbignR0VUJywgZmlsZUluZm8udXJsKTtcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICB0aGF0Ll9jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSh4aHIucmVzcG9uc2UsXG4gICAgICAgIGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICAgIC8vIFV0aWxzLmxvZygnRmlsZSBsb2FkZWQ6ICcgKyBmaWxlSW5mby51cmwpO1xuICAgICAgICAgIHRoYXQuX2RvbmUoZmlsZUluZm8ubmFtZSwgYnVmZmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgIFV0aWxzLmxvZygnRGVjb2RpbmcgZmFpbHVyZTogJ1xuICAgICAgICAgICAgKyBmaWxlSW5mby51cmwgKyAnICgnICsgbWVzc2FnZSArICcpJyk7XG4gICAgICAgICAgdGhhdC5fZG9uZShmaWxlSW5mby5uYW1lLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLmxvZygnWEhSIEVycm9yOiAnICsgZmlsZUluZm8udXJsICsgJyAoJyArIHhoci5zdGF0dXNUZXh0XG4gICAgICAgICsgJyknKTtcbiAgICAgIHRoYXQuX2RvbmUoZmlsZUluZm8ubmFtZSwgbnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IGZldGNoIGxvY2FsIHJlc291cmNlcyBpZiBYSFIgZmFpbHMuXG4gIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBVdGlscy5sb2coJ1hIUiBOZXR3b3JrIGZhaWx1cmU6ICcgKyBmaWxlSW5mby51cmwpO1xuICAgIHRoYXQuX2RvbmUoZmlsZUluZm8ubmFtZSwgbnVsbCk7XG4gIH07XG5cbiAgeGhyLnNlbmQoKTtcbn07XG5cbkF1ZGlvQnVmZmVyTWFuYWdlci5wcm90b3R5cGUuX2RvbmUgPSBmdW5jdGlvbihmaWxlbmFtZSwgYnVmZmVyKSB7XG4gIC8vIExhYmVsIHRoZSBsb2FkaW5nIHRhc2suXG4gIHRoaXMuX2xvYWRpbmdUYXNrc1tmaWxlbmFtZV0gPSBidWZmZXIgIT09IG51bGwgPyAnbG9hZGVkJyA6ICdmYWlsZWQnO1xuXG4gIC8vIEEgZmFpbGVkIHRhc2sgd2lsbCBiZSBhIG51bGwgYnVmZmVyLlxuICB0aGlzLl9idWZmZXJzLnNldChmaWxlbmFtZSwgYnVmZmVyKTtcblxuICB0aGlzLl91cGRhdGVQcm9ncmVzcyhmaWxlbmFtZSk7XG59O1xuXG5BdWRpb0J1ZmZlck1hbmFnZXIucHJvdG90eXBlLl91cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIGxldCBudW1iZXJPZkZpbmlzaGVkVGFza3MgPSAwO1xuICBsZXQgbnVtYmVyT2ZGYWlsZWRUYXNrID0gMDtcbiAgbGV0IG51bWJlck9mVGFza3MgPSAwO1xuXG4gIGZvciAoY29uc3QgdGFzayBpbiB0aGlzLl9sb2FkaW5nVGFza3MpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2xvYWRpbmdUYXNrcywgdGFzaykpIHtcbiAgICAgIG51bWJlck9mVGFza3MrKztcbiAgICAgIGlmICh0aGlzLl9sb2FkaW5nVGFza3NbdGFza10gPT09ICdsb2FkZWQnKSB7XG4gICAgICAgIG51bWJlck9mRmluaXNoZWRUYXNrcysrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sb2FkaW5nVGFza3NbdGFza10gPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIG51bWJlck9mRmFpbGVkVGFzaysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdGhpcy5fcHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9wcm9ncmVzcyhmaWxlbmFtZSwgbnVtYmVyT2ZGaW5pc2hlZFRhc2tzLCBudW1iZXJPZlRhc2tzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobnVtYmVyT2ZGaW5pc2hlZFRhc2tzID09PSBudW1iZXJPZlRhc2tzKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl9idWZmZXJzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobnVtYmVyT2ZGaW5pc2hlZFRhc2tzICsgbnVtYmVyT2ZGYWlsZWRUYXNrID09PSBudW1iZXJPZlRhc2tzKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2J1ZmZlcnMpO1xuICAgIHJldHVybjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdWRpb0J1ZmZlck1hbmFnZXI7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBQaGFzZSBtYXRjaGVkIGZpbHRlciBmb3IgZmlyc3Qtb3JkZXItYW1iaXNvbmljcyBkZWNvZGluZy5cbiAqL1xuXG5cblxuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8vIFN0YXRpYyBwYXJhbWV0ZXJzLlxuY29uc3QgQ1JPU1NPVkVSX0ZSRVFVRU5DWSA9IDY5MDtcbmNvbnN0IEdBSU5fQ09FRkZJQ0lFTlRTID0gWzEuNDE0MiwgMC44MTY2LCAwLjgxNjYsIDAuODE2Nl07XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgY29lZmZpY2llbnRzIGZvciBkdWFsIGJhbmQgZmlsdGVyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyb3Nzb3ZlckZyZXF1ZW5jeVxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gRmlsdGVyIGNvZWZmaWNpZW50cy5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVEdWFsQmFuZENvZWZmaWNpZW50cyhjcm9zc292ZXJGcmVxdWVuY3ksIHNhbXBsZVJhdGUpIHtcbiAgY29uc3QgayA9IE1hdGgudGFuKE1hdGguUEkgKiBjcm9zc292ZXJGcmVxdWVuY3kgLyBzYW1wbGVSYXRlKTtcbiAgY29uc3QgazIgPSBrICogaztcbiAgY29uc3QgZGVub21pbmF0b3IgPSBrMiArIDIgKiBrICsgMTtcblxuICByZXR1cm4ge1xuICAgIGxvd3Bhc3NBOiBbMSwgMiAqIChrMiAtIDEpIC8gZGVub21pbmF0b3IsIChrMiAtIDIgKiBrICsgMSkgLyBkZW5vbWluYXRvcl0sXG4gICAgbG93cGFzc0I6IFtrMiAvIGRlbm9taW5hdG9yLCAyICogazIgLyBkZW5vbWluYXRvciwgazIgLyBkZW5vbWluYXRvcl0sXG4gICAgaGlwYXNzQTogWzEsIDIgKiAoazIgLSAxKSAvIGRlbm9taW5hdG9yLCAoazIgLSAyICogayArIDEpIC8gZGVub21pbmF0b3JdLFxuICAgIGhpcGFzc0I6IFsxIC8gZGVub21pbmF0b3IsIC0yICogMSAvIGRlbm9taW5hdG9yLCAxIC8gZGVub21pbmF0b3JdLFxuICB9O1xufVxuXG5cbi8qKlxuICogRk9BUGhhc2VNYXRjaGVkRmlsdGVyOiBBIHNldCBvZiBmaWx0ZXJzIChMUC9IUCkgd2l0aCBhIGNyb3Nzb3ZlciBmcmVxdWVuY3kgdG9cbiAqIGNvbXBlbnNhdGUgdGhlIGdhaW4gb2YgaGlnaCBmcmVxdWVuY3kgY29udGVudHMgd2l0aG91dCBhIHBoYXNlIGRpZmZlcmVuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIEZPQVBoYXNlTWF0Y2hlZEZpbHRlcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX2lucHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG5cbiAgaWYgKCF0aGlzLl9jb250ZXh0LmNyZWF0ZUlJUkZpbHRlcikge1xuICAgIFV0aWxzLmxvZygnSUlSIGZpbHRlciBpcyBtaXNzaW5nLiBVc2luZyBCaXF1YWQgZmlsdGVyIGluc3RlYWQuJyk7XG4gICAgdGhpcy5fbHBmID0gdGhpcy5fY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcbiAgICB0aGlzLl9ocGYgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgIHRoaXMuX2xwZi5mcmVxdWVuY3kudmFsdWUgPSBDUk9TU09WRVJfRlJFUVVFTkNZO1xuICAgIHRoaXMuX2hwZi5mcmVxdWVuY3kudmFsdWUgPSBDUk9TU09WRVJfRlJFUVVFTkNZO1xuICAgIHRoaXMuX2hwZi50eXBlID0gJ2hpZ2hwYXNzJztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb2VmID0gZ2VuZXJhdGVEdWFsQmFuZENvZWZmaWNpZW50cyhDUk9TU09WRVJfRlJFUVVFTkNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gICAgdGhpcy5fbHBmID0gdGhpcy5fY29udGV4dC5jcmVhdGVJSVJGaWx0ZXIoY29lZi5sb3dwYXNzQiwgY29lZi5sb3dwYXNzQSk7XG4gICAgdGhpcy5faHBmID0gdGhpcy5fY29udGV4dC5jcmVhdGVJSVJGaWx0ZXIoY29lZi5oaXBhc3NCLCBjb2VmLmhpcGFzc0EpO1xuICB9XG5cbiAgdGhpcy5fc3BsaXR0ZXJMb3cgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcig0KTtcbiAgdGhpcy5fc3BsaXR0ZXJIaWdoID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX2dhaW5IaWdoVyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9nYWluSGlnaFkgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fZ2FpbkhpZ2haID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2dhaW5IaWdoWCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9tZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoNCk7XG5cbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9ocGYpO1xuICB0aGlzLl9ocGYuY29ubmVjdCh0aGlzLl9zcGxpdHRlckhpZ2gpO1xuICB0aGlzLl9zcGxpdHRlckhpZ2guY29ubmVjdCh0aGlzLl9nYWluSGlnaFcsIDApO1xuICB0aGlzLl9zcGxpdHRlckhpZ2guY29ubmVjdCh0aGlzLl9nYWluSGlnaFksIDEpO1xuICB0aGlzLl9zcGxpdHRlckhpZ2guY29ubmVjdCh0aGlzLl9nYWluSGlnaFosIDIpO1xuICB0aGlzLl9zcGxpdHRlckhpZ2guY29ubmVjdCh0aGlzLl9nYWluSGlnaFgsIDMpO1xuICB0aGlzLl9nYWluSGlnaFcuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuICB0aGlzLl9nYWluSGlnaFkuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDEpO1xuICB0aGlzLl9nYWluSGlnaFouY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDIpO1xuICB0aGlzLl9nYWluSGlnaFguY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDMpO1xuXG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5fbHBmKTtcbiAgdGhpcy5fbHBmLmNvbm5lY3QodGhpcy5fc3BsaXR0ZXJMb3cpO1xuICB0aGlzLl9zcGxpdHRlckxvdy5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG4gIHRoaXMuX3NwbGl0dGVyTG93LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAxLCAxKTtcbiAgdGhpcy5fc3BsaXR0ZXJMb3cuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDIsIDIpO1xuICB0aGlzLl9zcGxpdHRlckxvdy5jb25uZWN0KHRoaXMuX21lcmdlciwgMywgMyk7XG5cbiAgLy8gQXBwbHkgZ2FpbiBjb3JyZWN0aW9uIHRvIGhpLXBhc3NlZCBwcmVzc3VyZSBhbmQgdmVsb2NpdHkgY29tcG9uZW50czpcbiAgLy8gSW52ZXJ0aW5nIHNpZ24gaXMgbmVjZXNzYXJ5IGFzIHRoZSBsb3ctcGFzc2VkIGFuZCBoaWdoLXBhc3NlZCBwb3J0aW9uIGFyZVxuICAvLyBvdXQtb2YtcGhhc2UgYWZ0ZXIgdGhlIGZpbHRlcmluZy5cbiAgY29uc3Qgbm93ID0gdGhpcy5fY29udGV4dC5jdXJyZW50VGltZTtcbiAgdGhpcy5fZ2FpbkhpZ2hXLmdhaW4uc2V0VmFsdWVBdFRpbWUoLTEgKiBHQUlOX0NPRUZGSUNJRU5UU1swXSwgbm93KTtcbiAgdGhpcy5fZ2FpbkhpZ2hZLmdhaW4uc2V0VmFsdWVBdFRpbWUoLTEgKiBHQUlOX0NPRUZGSUNJRU5UU1sxXSwgbm93KTtcbiAgdGhpcy5fZ2FpbkhpZ2haLmdhaW4uc2V0VmFsdWVBdFRpbWUoLTEgKiBHQUlOX0NPRUZGSUNJRU5UU1syXSwgbm93KTtcbiAgdGhpcy5fZ2FpbkhpZ2hYLmdhaW4uc2V0VmFsdWVBdFRpbWUoLTEgKiBHQUlOX0NPRUZGSUNJRU5UU1szXSwgbm93KTtcblxuICAvLyBJbnB1dC9vdXRwdXQgUHJveHkuXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9tZXJnZXI7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FQaGFzZU1hdGNoZWRGaWx0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBWaXJ0dWFsIHNwZWFrZXIgYWJzdHJhY3Rpb24gZm9yIGZpcnN0LW9yZGVyLWFtYmlzb25pY3MgZGVjb2RpbmcuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBERVBSRUNBVEVEIGF0IFYxOiBBIHZpcnR1YWwgc3BlYWtlciB3aXRoIGFtYmlzb25pYyBkZWNvZGluZyBnYWluIGNvZWZmaWNpZW50c1xuICogYW5kIEhSVEYgY29udm9sdXRpb24gZm9yIGZpcnN0LW9yZGVyLWFtYmlzb25pY3Mgc3RyZWFtLiBOb3RlIHRoYXQgdGhlXG4gKiBzdWJncmFwaCBkaXJlY3RseSBjb25uZWN0cyB0byBjb250ZXh0J3MgZGVzdGluYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHNwZWFrZXIuXG4gKiBAcGFyYW0ge051bWJlcltdfSBvcHRpb25zLmNvZWZmaWNpZW50cyAtIERlY29kaW5nIGNvZWZmaWNpZW50cyBmb3IgKFcsWSxaLFgpLlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gb3B0aW9ucy5JUiAtIFN0ZXJlbyBJUiBidWZmZXIgZm9yIEhSVEYgY29udm9sdXRpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5nYWluIC0gUG9zdC1nYWluIGZvciB0aGUgc3BlYWtlci5cbiAqL1xuZnVuY3Rpb24gRk9BVmlydHVhbFNwZWFrZXIoY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5JUi5udW1iZXJPZkNoYW5uZWxzICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJUiBkb2VzIG5vdCBoYXZlIDIgY2hhbm5lbHMuIGNhbm5vdCBwcm9jZWVkLicpO1xuICB9XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIHRoaXMuX2lucHV0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoNCk7XG4gIHRoaXMuX2NXID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2NZID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2NaID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2NYID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2NvbnZvbHZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gIHRoaXMuX2dhaW4gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2NXLCAwKTtcbiAgdGhpcy5faW5wdXQuY29ubmVjdCh0aGlzLl9jWSwgMSk7XG4gIHRoaXMuX2lucHV0LmNvbm5lY3QodGhpcy5fY1osIDIpO1xuICB0aGlzLl9pbnB1dC5jb25uZWN0KHRoaXMuX2NYLCAzKTtcbiAgdGhpcy5fY1cuY29ubmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuICB0aGlzLl9jWS5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcik7XG4gIHRoaXMuX2NaLmNvbm5lY3QodGhpcy5fY29udm9sdmVyKTtcbiAgdGhpcy5fY1guY29ubmVjdCh0aGlzLl9jb252b2x2ZXIpO1xuICB0aGlzLl9jb252b2x2ZXIuY29ubmVjdCh0aGlzLl9nYWluKTtcbiAgdGhpcy5fZ2Fpbi5jb25uZWN0KHRoaXMuX2NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gIHRoaXMuZW5hYmxlKCk7XG5cbiAgdGhpcy5fY29udm9sdmVyLm5vcm1hbGl6ZSA9IGZhbHNlO1xuICB0aGlzLl9jb252b2x2ZXIuYnVmZmVyID0gb3B0aW9ucy5JUjtcbiAgdGhpcy5fZ2Fpbi5nYWluLnZhbHVlID0gb3B0aW9ucy5nYWluO1xuXG4gIC8vIFNldCBnYWluIGNvZWZmaWNpZW50cyBmb3IgRk9BIGFtYmlzb25pYyBzdHJlYW1zLlxuICB0aGlzLl9jVy5nYWluLnZhbHVlID0gb3B0aW9ucy5jb2VmZmljaWVudHNbMF07XG4gIHRoaXMuX2NZLmdhaW4udmFsdWUgPSBvcHRpb25zLmNvZWZmaWNpZW50c1sxXTtcbiAgdGhpcy5fY1ouZ2Fpbi52YWx1ZSA9IG9wdGlvbnMuY29lZmZpY2llbnRzWzJdO1xuICB0aGlzLl9jWC5nYWluLnZhbHVlID0gb3B0aW9ucy5jb2VmZmljaWVudHNbM107XG5cbiAgLy8gSW5wdXQgcHJveHkuIE91dHB1dCBkaXJlY3RseSBjb25uZWN0cyB0byB0aGUgZGVzdGluYXRpb24uXG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9pbnB1dDtcbn1cblxuXG5GT0FWaXJ0dWFsU3BlYWtlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dhaW4uY29ubmVjdCh0aGlzLl9jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbn07XG5cblxuRk9BVmlydHVhbFNwZWFrZXIucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZ2Fpbi5kaXNjb25uZWN0KCk7XG4gIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEZPQVZpcnR1YWxTcGVha2VyO1xuXG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogQGZpbGUgQSBjb2xsZWN0aW9uIG9mIGNvbnZvbHZlcnMuIENhbiBiZSB1c2VkIGZvciB0aGUgb3B0aW1pemVkIEhPQSBiaW5hdXJhbFxuICogcmVuZGVyaW5nLiAoZS5nLiBTSC1NYXhSZSBIUlRGcylcbiAqL1xuXG5cblxuXG4vKipcbiAqIEEgY29udm9sdmVyIG5ldHdvcmsgZm9yIE4tY2hhbm5lbCBIT0Egc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIC0gQW1iaXNvbmljIG9yZGVyLiAoMiBvciAzKVxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBbaHJpckJ1ZmZlckxpc3RdIC0gQW4gb3JkZXJlZC1saXN0IG9mIHN0ZXJlb1xuICogQXVkaW9CdWZmZXJzIGZvciBjb252b2x1dGlvbi4gKFNPQTogNSBBdWRpb0J1ZmZlcnMsIFRPQTogOCBBdWRpb0J1ZmZlcnMpXG4gKi9cbmZ1bmN0aW9uIEhPQUNvbnZvbHZlcihjb250ZXh0LCBhbWJpc29uaWNPcmRlciwgaHJpckJ1ZmZlckxpc3QpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2lzQnVmZmVyTG9hZGVkID0gZmFsc2U7XG5cbiAgLy8gVGhlIG51bWJlciBvZiBjaGFubmVscyBLIGJhc2VkIG9uIHRoZSBhbWJpc29uaWMgb3JkZXIgTiB3aGVyZSBLID0gKE4rMSleMi5cbiAgdGhpcy5fYW1iaXNvbmljT3JkZXIgPSBhbWJpc29uaWNPcmRlcjtcbiAgdGhpcy5fbnVtYmVyT2ZDaGFubmVscyA9XG4gICAgICAodGhpcy5fYW1iaXNvbmljT3JkZXIgKyAxKSAqICh0aGlzLl9hbWJpc29uaWNPcmRlciArIDEpO1xuXG4gIHRoaXMuX2J1aWxkQXVkaW9HcmFwaCgpO1xuICBpZiAoaHJpckJ1ZmZlckxpc3QpIHtcbiAgICB0aGlzLnNldEhSSVJCdWZmZXJMaXN0KGhyaXJCdWZmZXJMaXN0KTtcbiAgfVxuXG4gIHRoaXMuZW5hYmxlKCk7XG59XG5cblxuLyoqXG4gKiBCdWlsZCB0aGUgaW50ZXJuYWwgYXVkaW8gZ3JhcGguXG4gKiBGb3IgVE9BIGNvbnZvbHV0aW9uOlxuICogICBpbnB1dCAtPiBzcGxpdHRlcigxNikgLVswLDFdLT4gbWVyZ2VyKDIpIC0+IGNvbnZvbHZlcigyKSAtPiBzcGxpdHRlcigyKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgLVsyLDNdLT4gbWVyZ2VyKDIpIC0+IGNvbnZvbHZlcigyKSAtPiBzcGxpdHRlcigyKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgLVs0LDVdLT4gLi4uICg2IG1vcmUsIDggYnJhbmNoZXMgdG90YWwpXG4gKiBAcHJpdmF0ZVxuICovXG5IT0FDb252b2x2ZXIucHJvdG90eXBlLl9idWlsZEF1ZGlvR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgbnVtYmVyT2ZTdGVyZW9DaGFubmVscyA9IE1hdGguY2VpbCh0aGlzLl9udW1iZXJPZkNoYW5uZWxzIC8gMik7XG5cbiAgdGhpcy5faW5wdXRTcGxpdHRlciA9XG4gICAgICB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcih0aGlzLl9udW1iZXJPZkNoYW5uZWxzKTtcbiAgdGhpcy5fc3RlcmVvTWVyZ2VycyA9IFtdO1xuICB0aGlzLl9jb252b2x2ZXJzID0gW107XG4gIHRoaXMuX3N0ZXJlb1NwbGl0dGVycyA9IFtdO1xuICB0aGlzLl9wb3NpdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX25lZ2F0aXZlSW5kZXhTcGhlcmljYWxIYXJtb25pY3MgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faW52ZXJ0ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fYmluYXVyYWxNZXJnZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gIHRoaXMuX291dHB1dEdhaW4gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3RlcmVvQ2hhbm5lbHM7ICsraSkge1xuICAgIHRoaXMuX3N0ZXJlb01lcmdlcnNbaV0gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gICAgdGhpcy5fY29udm9sdmVyc1tpXSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQ29udm9sdmVyKCk7XG4gICAgdGhpcy5fc3RlcmVvU3BsaXR0ZXJzW2ldID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG4gICAgdGhpcy5fY29udm9sdmVyc1tpXS5ub3JtYWxpemUgPSBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGwgPSAwOyBsIDw9IHRoaXMuX2FtYmlzb25pY09yZGVyOyArK2wpIHtcbiAgICBmb3IgKGxldCBtID0gLWw7IG0gPD0gbDsgbSsrKSB7XG4gICAgICAvLyBXZSBjb21wdXRlIHRoZSBBQ04gaW5kZXggKGspIG9mIGFtYmlzb25pY3MgY2hhbm5lbCB1c2luZyB0aGUgZGVncmVlIChsKVxuICAgICAgLy8gYW5kIGluZGV4IChtKTogayA9IGxeMiArIGwgKyBtXG4gICAgICBjb25zdCBhY25JbmRleCA9IGwgKiBsICsgbCArIG07XG4gICAgICBjb25zdCBzdGVyZW9JbmRleCA9IE1hdGguZmxvb3IoYWNuSW5kZXggLyAyKTtcblxuICAgICAgLy8gU3BsaXQgY2hhbm5lbHMgZnJvbSBpbnB1dCBpbnRvIGFycmF5IG9mIHN0ZXJlbyBjb252b2x2ZXJzLlxuICAgICAgLy8gVGhlbiBjcmVhdGUgYSBuZXR3b3JrIG9mIG1lcmdlcnMgdGhhdCBwcm9kdWNlcyB0aGUgc3RlcmVvIG91dHB1dC5cbiAgICAgIHRoaXMuX2lucHV0U3BsaXR0ZXIuY29ubmVjdChcbiAgICAgICAgICB0aGlzLl9zdGVyZW9NZXJnZXJzW3N0ZXJlb0luZGV4XSwgYWNuSW5kZXgsIGFjbkluZGV4ICUgMik7XG4gICAgICB0aGlzLl9zdGVyZW9NZXJnZXJzW3N0ZXJlb0luZGV4XS5jb25uZWN0KHRoaXMuX2NvbnZvbHZlcnNbc3RlcmVvSW5kZXhdKTtcbiAgICAgIHRoaXMuX2NvbnZvbHZlcnNbc3RlcmVvSW5kZXhdLmNvbm5lY3QodGhpcy5fc3RlcmVvU3BsaXR0ZXJzW3N0ZXJlb0luZGV4XSk7XG5cbiAgICAgIC8vIFBvc2l0aXZlIGluZGV4IChtID49IDApIHNwaGVyaWNhbCBoYXJtb25pY3MgYXJlIHN5bW1ldHJpY2FsIGFyb3VuZCB0aGVcbiAgICAgIC8vIGZyb250IGF4aXMsIHdoaWxlIG5lZ2F0aXZlIGluZGV4IChtIDwgMCkgc3BoZXJpY2FsIGhhcm1vbmljcyBhcmVcbiAgICAgIC8vIGFudGktc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBmcm9udCBheGlzLiBXZSB3aWxsIGV4cGxvaXQgdGhpcyBzeW1tZXRyeVxuICAgICAgLy8gdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgY29udm9sdXRpb25zIHJlcXVpcmVkIHdoZW4gcmVuZGVyaW5nIHRvIGFcbiAgICAgIC8vIHN5bW1ldHJpY2FsIGJpbmF1cmFsIHJlbmRlcmVyLlxuICAgICAgaWYgKG0gPj0gMCkge1xuICAgICAgICB0aGlzLl9zdGVyZW9TcGxpdHRlcnNbc3RlcmVvSW5kZXhdLmNvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLCBhY25JbmRleCAlIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RlcmVvU3BsaXR0ZXJzW3N0ZXJlb0luZGV4XS5jb25uZWN0KFxuICAgICAgICAgICAgdGhpcy5fbmVnYXRpdmVJbmRleFNwaGVyaWNhbEhhcm1vbmljcywgYWNuSW5kZXggJSAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9wb3NpdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLmNvbm5lY3QodGhpcy5fYmluYXVyYWxNZXJnZXIsIDAsIDApO1xuICB0aGlzLl9wb3NpdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLmNvbm5lY3QodGhpcy5fYmluYXVyYWxNZXJnZXIsIDAsIDEpO1xuICB0aGlzLl9uZWdhdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLmNvbm5lY3QodGhpcy5fYmluYXVyYWxNZXJnZXIsIDAsIDApO1xuICB0aGlzLl9uZWdhdGl2ZUluZGV4U3BoZXJpY2FsSGFybW9uaWNzLmNvbm5lY3QodGhpcy5faW52ZXJ0ZXIpO1xuICB0aGlzLl9pbnZlcnRlci5jb25uZWN0KHRoaXMuX2JpbmF1cmFsTWVyZ2VyLCAwLCAxKTtcblxuICAvLyBGb3IgYXN5bW1ldHJpYyBpbmRleC5cbiAgdGhpcy5faW52ZXJ0ZXIuZ2Fpbi52YWx1ZSA9IC0xO1xuXG4gIC8vIElucHV0L091dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2lucHV0U3BsaXR0ZXI7XG4gIHRoaXMub3V0cHV0ID0gdGhpcy5fb3V0cHV0R2Fpbjtcbn07XG5cblxuLyoqXG4gKiBBc3NpZ25zIE4gSFJJUiBBdWRpb0J1ZmZlcnMgdG8gTiBjb252b2x2ZXJzOiBOb3RlIHRoYXQgd2UgdXNlIDIgc3RlcmVvXG4gKiBjb252b2x1dGlvbnMgZm9yIDQtY2hhbm5lbCBkaXJlY3QgY29udm9sdXRpb24uIFVzaW5nIG1vbm8gY29udm9sdmVyIG9yXG4gKiA0LWNoYW5uZWwgY29udm9sdmVyIGlzIG5vdCB2aWFibGUgYmVjYXVzZSBtb25vIGNvbnZvbHV0aW9uIHdhc3RlZnVsbHlcbiAqIHByb2R1Y2VzIHRoZSBzdGVyZW8gb3V0cHV0cywgYW5kIHRoZSA0LWNoIGNvbnZvbHZlciBkb2VzIGNyb3NzLWNoYW5uZWxcbiAqIGNvbnZvbHV0aW9uLiAoU2VlIFdlYiBBdWRpbyBBUEkgc3BlYylcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJbXX0gaHJpckJ1ZmZlckxpc3QgLSBBbiBhcnJheSBvZiBzdGVyZW8gQXVkaW9CdWZmZXJzIGZvclxuICogY29udm9sdmVycy5cbiAqL1xuSE9BQ29udm9sdmVyLnByb3RvdHlwZS5zZXRIUklSQnVmZmVyTGlzdCA9IGZ1bmN0aW9uKGhyaXJCdWZmZXJMaXN0KSB7XG4gIC8vIEFmdGVyIHRoZXNlIGFzc2lnbm1lbnRzLCB0aGUgY2hhbm5lbCBkYXRhIGluIHRoZSBidWZmZXIgaXMgaW1tdXRhYmxlIGluXG4gIC8vIEZpcmVGb3guIChpLmUuIG5ldXRlcmVkKSBTbyB3ZSBzaG91bGQgYXZvaWQgcmUtYXNzaWduaW5nIGJ1ZmZlcnMsIG90aGVyd2lzZVxuICAvLyBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gIGlmICh0aGlzLl9pc0J1ZmZlckxvYWRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaHJpckJ1ZmZlckxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9jb252b2x2ZXJzW2ldLmJ1ZmZlciA9IGhyaXJCdWZmZXJMaXN0W2ldO1xuICB9XG5cbiAgdGhpcy5faXNCdWZmZXJMb2FkZWQgPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIEVuYWJsZSBIT0FDb252b2x2ZXIgaW5zdGFuY2UuIFRoZSBhdWRpbyBncmFwaCB3aWxsIGJlIGFjdGl2YXRlZCBhbmQgcHVsbGVkIGJ5XG4gKiB0aGUgV2ViQXVkaW8gZW5naW5lLiAoaS5lLiBjb25zdW1lIENQVSBjeWNsZSlcbiAqL1xuSE9BQ29udm9sdmVyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYmluYXVyYWxNZXJnZXIuY29ubmVjdCh0aGlzLl9vdXRwdXRHYWluKTtcbiAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEaXNhYmxlIEhPQUNvbnZvbHZlciBpbnN0YW5jZS4gVGhlIGlubmVyIGdyYXBoIHdpbGwgYmUgZGlzY29ubmVjdGVkIGZyb20gdGhlXG4gKiBhdWRpbyBkZXN0aW5hdGlvbiwgdGh1cyBubyBDUFUgY3ljbGUgd2lsbCBiZSBjb25zdW1lZC5cbiAqL1xuSE9BQ29udm9sdmVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2JpbmF1cmFsTWVyZ2VyLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSE9BQ29udm9sdmVyO1xuXG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlIFNvdW5kIGZpZWxkIHJvdGF0b3IgZm9yIGhpZ2hlci1vcmRlci1hbWJpc29uaWNzIGRlY29kaW5nLlxuICovXG5cblxuXG5cbi8qKlxuICogS3JvbmVja2VyIERlbHRhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEtyb25lY2tlckRlbHRhKGksIGopIHtcbiAgcmV0dXJuIGkgPT09IGogPyAxIDogMDtcbn1cblxuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHVzIHRvIGFjY2VzcyBhIG1hdHJpeCBhcnJheSBpbiB0aGUgc2FtZVxuICogbWFubmVyLCBhc3N1bWluZyBpdCBpcyBhICgybCsxKXgoMmwrMSkgbWF0cml4LiBbMl0gdXNlcyBhbiBvZGQgY29udmVudGlvbiBvZlxuICogcmVmZXJyaW5nIHRvIHRoZSByb3dzIGFuZCBjb2x1bW5zIHVzaW5nIGNlbnRlcmVkIGluZGljZXMsIHNvIHRoZSBtaWRkbGUgcm93XG4gKiBhbmQgY29sdW1uIGFyZSAoMCwgMCkgYW5kIHRoZSB1cHBlciBsZWZ0IHdvdWxkIGhhdmUgbmVnYXRpdmUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcGFyYW0ge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IGdhaW5WYWx1ZVxuICovXG5mdW5jdGlvbiBzZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsLCBpLCBqLCBnYWluVmFsdWUpIHtcbiAgY29uc3QgaW5kZXggPSAoaiArIGwpICogKDIgKiBsICsgMSkgKyAoaSArIGwpO1xuICAvLyBSb3ctd2lzZSBpbmRleGluZy5cbiAgbWF0cml4W2wgLSAxXVtpbmRleF0uZ2Fpbi52YWx1ZSA9IGdhaW5WYWx1ZTtcbn1cblxuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdXMgdG8gYWNjZXNzIGEgbWF0cml4IGFycmF5IGluIHRoZSBzYW1lXG4gKiBtYW5uZXIsIGFzc3VtaW5nIGl0IGlzIGEgKDJsKzEpIHggKDJsKzEpIG1hdHJpeC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggKDJuKzEpIHggKDJuKzEpXG4gKiBlbGVtZW50cywgd2hlcmUgbj0xLDIsLi4uLE4uXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwsIGksIGopIHtcbiAgLy8gUm93LXdpc2UgaW5kZXhpbmcuXG4gIGNvbnN0IGluZGV4ID0gKGogKyBsKSAqICgyICogbCArIDEpICsgKGkgKyBsKTtcbiAgcmV0dXJuIG1hdHJpeFtsIC0gMV1baW5kZXhdLmdhaW4udmFsdWU7XG59XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZGVmaW5lZCBpbiBbMl0gdGhhdCBpcyB1c2VkIGJ5IHRoZSBmdW5jdGlvbnMgVSwgViwgVy5cbiAqIFRoaXMgc2hvdWxkIG5vdCBiZSBjYWxsZWQgb24gaXRzIG93biwgYXMgVSwgViwgYW5kIFcgKGFuZCB0aGVpciBjb2VmZmljaWVudHMpXG4gKiBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIG1hdHJpeCBlbGVtZW50cyB0byBhY2Nlc3MgYXJndW1lbnRzIHxhfCBhbmQgfGJ8LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFAobWF0cml4LCBpLCBhLCBiLCBsKSB7XG4gIGlmIChiID09PSBsKSB7XG4gICAgcmV0dXJuIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIDEsIGksIDEpICpcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCAtIDEsIGEsIGwgLSAxKSAtXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIDEsIGksIC0xKSAqXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwgLSAxLCBhLCAtbCArIDEpO1xuICB9IGVsc2UgaWYgKGIgPT09IC1sKSB7XG4gICAgcmV0dXJuIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIDEsIGksIDEpICpcbiAgICAgICAgZ2V0Q2VudGVyZWRFbGVtZW50KG1hdHJpeCwgbCAtIDEsIGEsIC1sICsgMSkgK1xuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCAxLCBpLCAtMSkgKlxuICAgICAgICBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCBsIC0gMSwgYSwgbCAtIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRDZW50ZXJlZEVsZW1lbnQobWF0cml4LCAxLCBpLCAwKSAqXG4gICAgICAgIGdldENlbnRlcmVkRWxlbWVudChtYXRyaXgsIGwgLSAxLCBhLCBiKTtcbiAgfVxufVxuXG5cbi8qKlxuICogVGhlIGZ1bmN0aW9ucyBVLCBWLCBhbmQgVyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIGNvcnJlc3BvbmRpbmdseVxuICogbmFtZWQgY29lZmZpY2llbnQgdSwgdiwgdyBmcm9tIHRoZSBmdW5jdGlvbiBDb21wdXRlVVZXQ29lZmYoKSBpcyBub24temVyby5cbiAqIFdoZW4gdGhlIGNvZWZmaWNpZW50IGlzIDAsIHRoZXNlIHdvdWxkIGF0dGVtcHQgdG8gYWNjZXNzIG1hdHJpeCBlbGVtZW50cyB0aGF0XG4gKiBhcmUgb3V0IG9mIGJvdW5kcy4gVGhlIHZlY3RvciBvZiByb3RhdGlvbnMsIHxyfCwgbXVzdCBoYXZlIHRoZSB8bCAtIDF8XG4gKiBwcmV2aW91c2x5IGNvbXBsZXRlZCBiYW5kIHJvdGF0aW9ucy4gVGhlc2UgZnVuY3Rpb25zIGFyZSB2YWxpZCBmb3IgfGwgPj0gMnwuXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggLSBOIG1hdHJpY2VzIG9mIGdhaW5Ob2RlcywgZWFjaCB3aXRoICgybisxKSB4ICgybisxKVxuICogZWxlbWVudHMsIHdoZXJlIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRVKG1hdHJpeCwgbSwgbiwgbCkge1xuICAvLyBBbHRob3VnaCBbMSwgMl0gc3BsaXQgVSBpbnRvIHRocmVlIGNhc2VzIGZvciBtID09IDAsIG0gPCAwLCBtID4gMFxuICAvLyB0aGUgYWN0dWFsIHZhbHVlcyBhcmUgdGhlIHNhbWUgZm9yIGFsbCB0aHJlZSBjYXNlcy5cbiAgcmV0dXJuIGdldFAobWF0cml4LCAwLCBtLCBuLCBsKTtcbn1cblxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbnMgVSwgViwgYW5kIFcgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBjb3JyZXNwb25kaW5nbHlcbiAqIG5hbWVkIGNvZWZmaWNpZW50IHUsIHYsIHcgZnJvbSB0aGUgZnVuY3Rpb24gQ29tcHV0ZVVWV0NvZWZmKCkgaXMgbm9uLXplcm8uXG4gKiBXaGVuIHRoZSBjb2VmZmljaWVudCBpcyAwLCB0aGVzZSB3b3VsZCBhdHRlbXB0IHRvIGFjY2VzcyBtYXRyaXggZWxlbWVudHMgdGhhdFxuICogYXJlIG91dCBvZiBib3VuZHMuIFRoZSB2ZWN0b3Igb2Ygcm90YXRpb25zLCB8cnwsIG11c3QgaGF2ZSB0aGUgfGwgLSAxfFxuICogcHJldmlvdXNseSBjb21wbGV0ZWQgYmFuZCByb3RhdGlvbnMuIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdmFsaWQgZm9yIHxsID49IDJ8LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0VihtYXRyaXgsIG0sIG4sIGwpIHtcbiAgaWYgKG0gPT09IDApIHtcbiAgICByZXR1cm4gZ2V0UChtYXRyaXgsIDEsIDEsIG4sIGwpICsgZ2V0UChtYXRyaXgsIC0xLCAtMSwgbiwgbCk7XG4gIH0gZWxzZSBpZiAobSA+IDApIHtcbiAgICBjb25zdCBkID0gZ2V0S3JvbmVja2VyRGVsdGEobSwgMSk7XG4gICAgcmV0dXJuIGdldFAobWF0cml4LCAxLCBtIC0gMSwgbiwgbCkgKiBNYXRoLnNxcnQoMSArIGQpIC1cbiAgICAgICAgZ2V0UChtYXRyaXgsIC0xLCAtbSArIDEsIG4sIGwpICogKDEgLSBkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3RlIHRoZXJlIGlzIGFwcGFyZW50IGVycmF0YSBpbiBbMSwyLDJiXSBkZWFsaW5nIHdpdGggdGhpcyBwYXJ0aWN1bGFyXG4gICAgLy8gY2FzZS4gWzJiXSB3cml0ZXMgaXQgc2hvdWxkIGJlIFAqKDEtZCkrUCooMS1kKV4wLjVcbiAgICAvLyBbMV0gd3JpdGVzIGl0IGFzIFAqKDErZCkrUCooMS1kKV4wLjUsIGJ1dCBnb2luZyB0aHJvdWdoIHRoZSBtYXRoIGJ5IGhhbmQsXG4gICAgLy8geW91IG11c3QgaGF2ZSBpdCBhcyBQKigxLWQpK1AqKDErZCleMC41IHRvIGZvcm0gYSAyXi41IHRlcm0sIHdoaWNoXG4gICAgLy8gcGFyYWxsZWxzIHRoZSBjYXNlIHdoZXJlIG0gPiAwLlxuICAgIGNvbnN0IGQgPSBnZXRLcm9uZWNrZXJEZWx0YShtLCAtMSk7XG4gICAgcmV0dXJuIGdldFAobWF0cml4LCAxLCBtICsgMSwgbiwgbCkgKiAoMSAtIGQpICtcbiAgICAgICAgZ2V0UChtYXRyaXgsIC0xLCAtbSAtIDEsIG4sIGwpICogTWF0aC5zcXJ0KDEgKyBkKTtcbiAgfVxufVxuXG5cbi8qKlxuICogVGhlIGZ1bmN0aW9ucyBVLCBWLCBhbmQgVyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIGNvcnJlc3BvbmRpbmdseVxuICogbmFtZWQgY29lZmZpY2llbnQgdSwgdiwgdyBmcm9tIHRoZSBmdW5jdGlvbiBDb21wdXRlVVZXQ29lZmYoKSBpcyBub24temVyby5cbiAqIFdoZW4gdGhlIGNvZWZmaWNpZW50IGlzIDAsIHRoZXNlIHdvdWxkIGF0dGVtcHQgdG8gYWNjZXNzIG1hdHJpeCBlbGVtZW50cyB0aGF0XG4gKiBhcmUgb3V0IG9mIGJvdW5kcy4gVGhlIHZlY3RvciBvZiByb3RhdGlvbnMsIHxyfCwgbXVzdCBoYXZlIHRoZSB8bCAtIDF8XG4gKiBwcmV2aW91c2x5IGNvbXBsZXRlZCBiYW5kIHJvdGF0aW9ucy4gVGhlc2UgZnVuY3Rpb25zIGFyZSB2YWxpZCBmb3IgfGwgPj0gMnwuXG4gKiBAcGFyYW0ge051bWJlcltdfSBtYXRyaXggTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0VyhtYXRyaXgsIG0sIG4sIGwpIHtcbiAgLy8gV2hlbmV2ZXIgdGhpcyBoYXBwZW5zLCB3IGlzIGFsc28gMCBzbyBXIGNhbiBiZSBhbnl0aGluZy5cbiAgaWYgKG0gPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBtID4gMCA/IGdldFAobWF0cml4LCAxLCBtICsgMSwgbiwgbCkgKyBnZXRQKG1hdHJpeCwgLTEsIC1tIC0gMSwgbiwgbCkgOlxuICAgICAgICAgICAgICAgICBnZXRQKG1hdHJpeCwgMSwgbSAtIDEsIG4sIGwpIC0gZ2V0UChtYXRyaXgsIC0xLCAtbSArIDEsIG4sIGwpO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29lZmZpY2llbnRzIGFwcGxpZWQgdG8gdGhlIFUsIFYsIGFuZCBXIGZ1bmN0aW9ucy4gQmVjYXVzZVxuICogdGhlaXIgZXF1YXRpb25zIHNoYXJlIG1hbnkgY29tbW9uIHRlcm1zIHRoZXkgYXJlIGNvbXB1dGVkIHNpbXVsdGFuZW91c2x5LlxuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge051bWJlcn0gbFxuICogQHJldHVybiB7QXJyYXl9IDMgY29lZmZpY2llbnRzIGZvciBVLCBWIGFuZCBXIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVVWV0NvZWZmKG0sIG4sIGwpIHtcbiAgY29uc3QgZCA9IGdldEtyb25lY2tlckRlbHRhKG0sIDApO1xuICBjb25zdCByZWNpcHJvY2FsRGVub21pbmF0b3IgPVxuICAgICAgTWF0aC5hYnMobikgPT09IGwgPyAxIC8gKDIgKiBsICogKDIgKiBsIC0gMSkpIDogMSAvICgobCArIG4pICogKGwgLSBuKSk7XG5cbiAgcmV0dXJuIFtcbiAgICBNYXRoLnNxcnQoKGwgKyBtKSAqIChsIC0gbSkgKiByZWNpcHJvY2FsRGVub21pbmF0b3IpLFxuICAgIDAuNSAqICgxIC0gMiAqIGQpICogTWF0aC5zcXJ0KCgxICsgZCkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsICsgTWF0aC5hYnMobSkgLSAxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGwgKyBNYXRoLmFicyhtKSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2lwcm9jYWxEZW5vbWluYXRvciksXG4gICAgLTAuNSAqICgxIC0gZCkgKiBNYXRoLnNxcnQoKGwgLSBNYXRoLmFicyhtKSAtIDEpICogKGwgLSBNYXRoLmFicyhtKSkpICpcbiAgICAgICAgcmVjaXByb2NhbERlbm9taW5hdG9yLFxuICBdO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgKDJsKzEpIHggKDJsKzEpIHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIGJhbmQgbC5cbiAqIFRoaXMgdXNlcyB0aGUgbWF0cmljZXMgY29tcHV0ZWQgZm9yIGJhbmQgMSBhbmQgYmFuZCBsLTEgdG8gY29tcHV0ZSB0aGVcbiAqIG1hdHJpeCBmb3IgYmFuZCBsLiB8cm90YXRpb25zfCBtdXN0IGNvbnRhaW4gdGhlIHByZXZpb3VzbHkgY29tcHV0ZWQgbC0xXG4gKiByb3RhdGlvbiBtYXRyaWNlcy5cbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gY29tZXMgZnJvbSBwLiA1ICg2MzQ2KSwgVGFibGUgMSBhbmQgMiBpbiBbMl0gdGFraW5nXG4gKiBpbnRvIGFjY291bnQgdGhlIGNvcnJlY3Rpb25zIGZyb20gWzJiXS5cbiAqIEBwYXJhbSB7TnVtYmVyW119IG1hdHJpeCAtIE4gbWF0cmljZXMgb2YgZ2Fpbk5vZGVzLCBlYWNoIHdpdGggd2hlcmVcbiAqIG49MSwyLC4uLixOLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJhbmRSb3RhdGlvbihtYXRyaXgsIGwpIHtcbiAgLy8gVGhlIGx0aCBiYW5kIHJvdGF0aW9uIG1hdHJpeCBoYXMgcm93cyBhbmQgY29sdW1ucyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mXG4gIC8vIGNvZWZmaWNpZW50cyB3aXRoaW4gdGhhdCBiYW5kICgtbCA8PSBtIDw9IGwgaW1wbGllcyAybCArIDEgY29lZmZpY2llbnRzKS5cbiAgZm9yIChsZXQgbSA9IC1sOyBtIDw9IGw7IG0rKykge1xuICAgIGZvciAobGV0IG4gPSAtbDsgbiA8PSBsOyBuKyspIHtcbiAgICAgIGNvbnN0IHV2d0NvZWZmaWNpZW50cyA9IGNvbXB1dGVVVldDb2VmZihtLCBuLCBsKTtcblxuICAgICAgLy8gVGhlIGZ1bmN0aW9ucyBVLCBWLCBXIGFyZSBvbmx5IHNhZmUgdG8gY2FsbCBpZiB0aGUgY29lZmZpY2llbnRzXG4gICAgICAvLyB1LCB2LCB3IGFyZSBub3QgemVyby5cbiAgICAgIGlmIChNYXRoLmFicyh1dndDb2VmZmljaWVudHNbMF0pID4gMCkge1xuICAgICAgICB1dndDb2VmZmljaWVudHNbMF0gKj0gZ2V0VShtYXRyaXgsIG0sIG4sIGwpO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHV2d0NvZWZmaWNpZW50c1sxXSkgPiAwKSB7XG4gICAgICAgIHV2d0NvZWZmaWNpZW50c1sxXSAqPSBnZXRWKG1hdHJpeCwgbSwgbiwgbCk7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnModXZ3Q29lZmZpY2llbnRzWzJdKSA+IDApIHtcbiAgICAgICAgdXZ3Q29lZmZpY2llbnRzWzJdICo9IGdldFcobWF0cml4LCBtLCBuLCBsKTtcbiAgICAgIH1cblxuICAgICAgc2V0Q2VudGVyZWRFbGVtZW50KFxuICAgICAgICAgIG1hdHJpeCwgbCwgbSwgbixcbiAgICAgICAgICB1dndDb2VmZmljaWVudHNbMF0gKyB1dndDb2VmZmljaWVudHNbMV0gKyB1dndDb2VmZmljaWVudHNbMl0pO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgSE9BIHJvdGF0aW9uIG1hdHJpeCBhZnRlciBzZXR0aW5nIHRoZSB0cmFuc2Zvcm0gbWF0cml4LlxuICogQHBhcmFtIHtBcnJheX0gbWF0cml4IC0gTiBtYXRyaWNlcyBvZiBnYWluTm9kZXMsIGVhY2ggd2l0aCAoMm4rMSkgeCAoMm4rMSlcbiAqIGVsZW1lbnRzLCB3aGVyZSBuPTEsMiwuLi4sTi5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUhPQU1hdHJpY2VzKG1hdHJpeCkge1xuICAvLyBXZSBzdGFydCBieSBjb21wdXRpbmcgdGhlIDJuZC1vcmRlciBtYXRyaXggZnJvbSB0aGUgMXN0LW9yZGVyIG1hdHJpeC5cbiAgZm9yIChsZXQgaSA9IDI7IGkgPD0gbWF0cml4Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29tcHV0ZUJhbmRSb3RhdGlvbihtYXRyaXgsIGkpO1xuICB9XG59XG5cblxuLyoqXG4gKiBIaWdoZXItb3JkZXItYW1iaXNvbmljIGRlY29kZXIgYmFzZWQgb24gZ2FpbiBub2RlIG5ldHdvcmsuIFdlIGV4cGVjdFxuICogdGhlIG9yZGVyIG9mIHRoZSBjaGFubmVscyB0byBjb25mb3JtIHRvIEFDTiBvcmRlcmluZy4gQmVsb3cgYXJlIHRoZSBoZWxwZXJcbiAqIG1ldGhvZHMgdG8gY29tcHV0ZSBTSCByb3RhdGlvbiB1c2luZyByZWN1cnNpb24uIFRoZSBjb2RlIHVzZXMgbWF0aHMgZGVzY3JpYmVkXG4gKiBpbiB0aGUgZm9sbG93aW5nIHBhcGVyczpcbiAqICBbMV0gUi4gR3JlZW4sIFwiU3BoZXJpY2FsIEhhcm1vbmljIExpZ2h0aW5nOiBUaGUgR3JpdHR5IERldGFpbHNcIiwgR0RDIDIwMDMsXG4gKiAgICAgIGh0dHA6Ly93d3cucmVzZWFyY2guc2NlYS5jb20vZ2RjMjAwMy9zcGhlcmljYWwtaGFybW9uaWMtbGlnaHRpbmcucGRmXG4gKiAgWzJdIEouIEl2YW5pYyBhbmQgSy4gUnVlZGVuYmVyZywgXCJSb3RhdGlvbiBNYXRyaWNlcyBmb3IgUmVhbFxuICogICAgICBTcGhlcmljYWwgSGFybW9uaWNzLiBEaXJlY3QgRGV0ZXJtaW5hdGlvbiBieSBSZWN1cnNpb25cIiwgSi4gUGh5cy5cbiAqICAgICAgQ2hlbS4sIHZvbC4gMTAwLCBuby4gMTUsIHBwLiA2MzQyLTYzNDcsIDE5OTYuXG4gKiAgICAgIGh0dHA6Ly9wdWJzLmFjcy5vcmcvZG9pL3BkZi8xMC4xMDIxL2pwOTUzMzUwdVxuICogIFsyYl0gQ29ycmVjdGlvbnMgdG8gaW5pdGlhbCBwdWJsaWNhdGlvbjpcbiAqICAgICAgIGh0dHA6Ly9wdWJzLmFjcy5vcmcvZG9pL3BkZi8xMC4xMDIxL2pwOTgzMzM1MFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIC0gQW1iaXNvbmljIG9yZGVyLlxuICovXG5mdW5jdGlvbiBIT0FSb3RhdG9yKGNvbnRleHQsIGFtYmlzb25pY09yZGVyKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbWJpc29uaWNPcmRlciA9IGFtYmlzb25pY09yZGVyO1xuXG4gIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgSyBiYXNlZCBvbiB0aGUgYW1iaXNvbmljIG9yZGVyXG4gIC8vIE4gd2hlcmUgSyA9IChOICsgMSleMi5cbiAgY29uc3QgbnVtYmVyT2ZDaGFubmVscyA9IChhbWJpc29uaWNPcmRlciArIDEpICogKGFtYmlzb25pY09yZGVyICsgMSk7XG5cbiAgdGhpcy5fc3BsaXR0ZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcihudW1iZXJPZkNoYW5uZWxzKTtcbiAgdGhpcy5fbWVyZ2VyID0gdGhpcy5fY29udGV4dC5jcmVhdGVDaGFubmVsTWVyZ2VyKG51bWJlck9mQ2hhbm5lbHMpO1xuXG4gIC8vIENyZWF0ZSBhIHNldCBvZiBwZXItb3JkZXIgcm90YXRpb24gbWF0cmljZXMgdXNpbmcgZ2FpbiBub2Rlcy5cbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXggPSBbXTtcbiAgbGV0IG9yZGVyT2Zmc2V0O1xuICBsZXQgcm93cztcbiAgbGV0IGlucHV0SW5kZXg7XG4gIGxldCBvdXRwdXRJbmRleDtcbiAgbGV0IG1hdHJpeEluZGV4O1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBhbWJpc29uaWNPcmRlcjsgaSsrKSB7XG4gICAgLy8gRWFjaCBhbWJpc29uaWMgb3JkZXIgcmVxdWlyZXMgYSBzZXBhcmF0ZSAoMmwgKyAxKSB4ICgybCArIDEpIHJvdGF0aW9uXG4gICAgLy8gbWF0cml4LiBXZSBjb21wdXRlIHRoZSBvZmZzZXQgdmFsdWUgYXMgdGhlIGZpcnN0IGNoYW5uZWwgaW5kZXggb2YgdGhlXG4gICAgLy8gY3VycmVudCBvcmRlciB3aGVyZVxuICAgIC8vICAga19sYXN0ID0gbF4yICsgbCArIG0sXG4gICAgLy8gYW5kIG0gPSAtbFxuICAgIC8vICAga19sYXN0ID0gbF4yXG4gICAgb3JkZXJPZmZzZXQgPSBpICogaTtcblxuICAgIC8vIFVzZXMgcm93LW1ham9yIGluZGV4aW5nLlxuICAgIHJvd3MgPSAoMiAqIGkgKyAxKTtcblxuICAgIHRoaXMuX2dhaW5Ob2RlTWF0cml4W2kgLSAxXSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgaisrKSB7XG4gICAgICBpbnB1dEluZGV4ID0gb3JkZXJPZmZzZXQgKyBqO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3dzOyBrKyspIHtcbiAgICAgICAgb3V0cHV0SW5kZXggPSBvcmRlck9mZnNldCArIGs7XG4gICAgICAgIG1hdHJpeEluZGV4ID0gaiAqIHJvd3MgKyBrO1xuICAgICAgICB0aGlzLl9nYWluTm9kZU1hdHJpeFtpIC0gMV1bbWF0cml4SW5kZXhdID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QoXG4gICAgICAgICAgICB0aGlzLl9nYWluTm9kZU1hdHJpeFtpIC0gMV1bbWF0cml4SW5kZXhdLCBpbnB1dEluZGV4KTtcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbaSAtIDFdW21hdHJpeEluZGV4XS5jb25uZWN0KFxuICAgICAgICAgICAgdGhpcy5fbWVyZ2VyLCAwLCBvdXRwdXRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVy1jaGFubmVsIGlzIG5vdCBpbnZvbHZlZCBpbiByb3RhdGlvbiwgc2tpcCBzdHJhaWdodCB0byBvdXB1dC5cbiAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9tZXJnZXIsIDAsIDApO1xuXG4gIC8vIERlZmF1bHQgSWRlbnRpdHkgbWF0cml4LlxuICB0aGlzLnNldFJvdGF0aW9uTWF0cml4MyhuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSkpO1xuXG4gIC8vIElucHV0L091dHB1dCBwcm94eS5cbiAgdGhpcy5pbnB1dCA9IHRoaXMuX3NwbGl0dGVyO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX21lcmdlcjtcbn1cblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDN4MyBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDMgLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJvdGF0b3IucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4MyA9IGZ1bmN0aW9uKHJvdGF0aW9uTWF0cml4Mykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDk7ICsraSkge1xuICAgIHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdW2ldLmdhaW4udmFsdWUgPSByb3RhdGlvbk1hdHJpeDNbaV07XG4gIH1cbiAgY29tcHV0ZUhPQU1hdHJpY2VzKHRoaXMuX2dhaW5Ob2RlTWF0cml4KTtcbn07XG5cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByb3RhdGlvbiBtYXRyaXggd2l0aCA0eDQgbWF0cml4LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gcm90YXRpb25NYXRyaXg0IC0gQSA0eDQgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSb3RhdG9yLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDQpIHtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMF0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFswXTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMV0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsxXTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMl0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsyXTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bM10uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs0XTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNF0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs1XTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNV0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs2XTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNl0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs4XTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bN10uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFs5XTtcbiAgdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bOF0uZ2Fpbi52YWx1ZSA9IHJvdGF0aW9uTWF0cml4NFsxMF07XG4gIGNvbXB1dGVIT0FNYXRyaWNlcyh0aGlzLl9nYWluTm9kZU1hdHJpeCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCAzeDMgcm90YXRpb24gbWF0cml4LlxuICogQHJldHVybiB7TnVtYmVyW119IC0gQSAzeDMgcm90YXRpb24gbWF0cml4LiAoY29sdW1uLW1ham9yKVxuICovXG5IT0FSb3RhdG9yLnByb3RvdHlwZS5nZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJvdGF0aW9uTWF0cml4MyA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgKytpKSB7XG4gICAgcm90YXRpb25NYXRyaXgzW2ldID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1baV0uZ2Fpbi52YWx1ZTtcbiAgfVxuICByZXR1cm4gcm90YXRpb25NYXRyaXgzO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgNHg0IHJvdGF0aW9uIG1hdHJpeC5cbiAqIEByZXR1cm4ge051bWJlcltdfSAtIEEgNHg0IHJvdGF0aW9uIG1hdHJpeC4gKGNvbHVtbi1tYWpvcilcbiAqL1xuSE9BUm90YXRvci5wcm90b3R5cGUuZ2V0Um90YXRpb25NYXRyaXg0ID0gZnVuY3Rpb24oKSB7XG4gIGxldCByb3RhdGlvbk1hdHJpeDQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgcm90YXRpb25NYXRyaXg0WzBdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMF0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzFdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMV0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzJdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bMl0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzRdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bM10uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzVdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNF0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzZdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNV0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzhdID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bNl0uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzldID0gdGhpcy5fZ2Fpbk5vZGVNYXRyaXhbMF1bN10uZ2Fpbi52YWx1ZTtcbiAgcm90YXRpb25NYXRyaXg0WzEwXSA9IHRoaXMuX2dhaW5Ob2RlTWF0cml4WzBdWzhdLmdhaW4udmFsdWU7XG4gIHJldHVybiByb3RhdGlvbk1hdHJpeDQ7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGFtYmlzb25pYyBvcmRlci5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSE9BUm90YXRvci5wcm90b3R5cGUuZ2V0QW1iaXNvbmljT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2FtYmlzb25pY09yZGVyO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEhPQVJvdGF0b3I7XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBOYW1lc3BhY2UgZm9yIE9tbml0b25lIGxpYnJhcnkuXG4gKi9cblxuXG5cblxuZXhwb3J0cy5PbW5pdG9uZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSBsaWJyYXJ5IG5hbWUgc3BhY2UgYW5kIHVzZXItZmFjaW5nIEFQSXMuXG4gKi9cblxuXG5cblxuY29uc3QgQnVmZmVyTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb25zdCBGT0FDb252b2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29uc3QgRk9BRGVjb2RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuY29uc3QgRk9BUGhhc2VNYXRjaGVkRmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmNvbnN0IEZPQVJlbmRlcmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5jb25zdCBGT0FSb3RhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvbnN0IEZPQVJvdXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5jb25zdCBGT0FWaXJ0dWFsU3BlYWtlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5jb25zdCBIT0FDb252b2x2ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuY29uc3QgSE9BUmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbmNvbnN0IEhPQVJvdGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuY29uc3QgUG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmNvbnN0IFZlcnNpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuLy8gREVQUkVDQVRFRCBpbiBWMSwgaW4gZmF2b3Igb2YgQnVmZmVyTGlzdC5cbmNvbnN0IEF1ZGlvQnVmZmVyTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblxuLyoqXG4gKiBPbW5pdG9uZSBuYW1lc3BhY2UuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbmxldCBPbW5pdG9uZSA9IHt9O1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQnJvd3NlckluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gQnJvd3NlciBuYW1lLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb24gLSBCcm93c2VyIHZlcnNpb24uXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbnMgdGhlIGRldGVjdGVkIGJyb3dzZXIgbmFtZSBhbmQgdmVyc2lvbi5cbiAqIEBtZW1iZXJPZiBPbW5pdG9uZVxuICogQHN0YXRpYyB7QnJvd3NlckluZm99XG4gKi9cbk9tbml0b25lLmJyb3dzZXJJbmZvID0gUG9seWZpbGwuZ2V0QnJvd3NlckluZm8oKTtcblxuXG4vLyBERVBSRUNBVEVEIGluIFYxLiBETy4gTk9ULiBVU0UuXG5PbW5pdG9uZS5sb2FkQXVkaW9CdWZmZXJzID0gZnVuY3Rpb24oY29udGV4dCwgc3BlYWtlckRhdGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIG5ldyBBdWRpb0J1ZmZlck1hbmFnZXIoY29udGV4dCwgc3BlYWtlckRhdGEsIGZ1bmN0aW9uKGJ1ZmZlcnMpIHtcbiAgICAgIHJlc29sdmUoYnVmZmVycyk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIGFzeW5jIGxvYWRpbmcvZGVjb2Rpbmcgb2YgbXVsdGlwbGUgQXVkaW9CdWZmZXJzIGZyb20gbXVsdGlwbGVcbiAqIFVSTHMuXG4gKiBAcGFyYW0ge0Jhc2VBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEJhc2VBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBidWZmZXJEYXRhIC0gQW4gb3JkZXJlZCBsaXN0IG9mIFVSTHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQnVmZmVyTGlzdCBvcHRpb25zLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRhdGFUeXBlPSd1cmwnXSAtIEJ1ZmZlckxpc3QgZGF0YSB0eXBlLlxuICogQHJldHVybiB7UHJvbWlzZTxBdWRpb0J1ZmZlcltdPn0gLSBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mXG4gKiBBdWRpb0J1ZmZlci5cbiAqL1xuT21uaXRvbmUuY3JlYXRlQnVmZmVyTGlzdCA9IGZ1bmN0aW9uKGNvbnRleHQsIGJ1ZmZlckRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgYnVmZmVyTGlzdCA9XG4gICAgICBuZXcgQnVmZmVyTGlzdChjb250ZXh0LCBidWZmZXJEYXRhLCBvcHRpb25zIHx8IHtkYXRhVHlwZTogJ3VybCd9KTtcbiAgcmV0dXJuIGJ1ZmZlckxpc3QubG9hZCgpO1xufTtcblxuXG4vKipcbiAqIFBlcmZvcm0gY2hhbm5lbC13aXNlIG1lcmdlIG9uIG11bHRpcGxlIEF1ZGlvQnVmZmVycy4gVGhlIHNhbXBsZSByYXRlIGFuZFxuICogdGhlIGxlbmd0aCBvZiBidWZmZXJzIHRvIGJlIG1lcmdlZCBtdXN0IGJlIGlkZW50aWNhbC5cbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtCYXNlQXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBCYXNlQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBidWZmZXJMaXN0IC0gQW4gYXJyYXkgb2YgQXVkaW9CdWZmZXJzIHRvIGJlIG1lcmdlZFxuICogY2hhbm5lbC13aXNlLlxuICogQHJldHVybiB7QXVkaW9CdWZmZXJ9IC0gQSBzaW5nbGUgbWVyZ2VkIEF1ZGlvQnVmZmVyLlxuICovXG5PbW5pdG9uZS5tZXJnZUJ1ZmZlckxpc3RCeUNoYW5uZWwgPSBVdGlscy5tZXJnZUJ1ZmZlckxpc3RCeUNoYW5uZWw7XG5cblxuLyoqXG4gKiBQZXJmb3JtIGNoYW5uZWwtd2lzZSBzcGxpdCBieSB0aGUgZ2l2ZW4gY2hhbm5lbCBjb3VudC4gRm9yIGV4YW1wbGUsXG4gKiAxIHggQXVkaW9CdWZmZXIoOCkgLT4gc3BsaXRCdWZmZXIoY29udGV4dCwgYnVmZmVyLCAyKSAtPiA0IHggQXVkaW9CdWZmZXIoMikuXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQmFzZUF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IGF1ZGlvQnVmZmVyIC0gQW4gQXVkaW9CdWZmZXIgdG8gYmUgc3BsaXR0ZWQuXG4gKiBAcGFyYW0ge051bWJlcn0gc3BsaXRCeSAtIE51bWJlciBvZiBjaGFubmVscyB0byBiZSBzcGxpdHRlZC5cbiAqIEByZXR1cm4ge0F1ZGlvQnVmZmVyW119IC0gQW4gYXJyYXkgb2Ygc3BsaXR0ZWQgQXVkaW9CdWZmZXJzLlxuICovXG5PbW5pdG9uZS5zcGxpdEJ1ZmZlcmJ5Q2hhbm5lbCA9IFV0aWxzLnNwbGl0QnVmZmVyYnlDaGFubmVsO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBGT0EgQ29udm9sdmVyLlxuICogQHNlZSBGT0FDb252b2x2ZXJcbiAqIEBwYXJhbSB7QmFzZUF1ZGlvQ29udGV4dH0gY29udGV4dCBUaGUgYXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyW119IFtocmlyQnVmZmVyTGlzdF0gLSBBbiBvcmRlcmVkLWxpc3Qgb2Ygc3RlcmVvXG4gKiBAcmV0dXJuIHtGT0FDb252b2x2ZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQUNvbnZvbHZlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGhyaXJCdWZmZXJMaXN0KSB7XG4gIHJldHVybiBuZXcgRk9BQ29udm9sdmVyKGNvbnRleHQsIGhyaXJCdWZmZXJMaXN0KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRk9BIFJvdXRlci5cbiAqIEBzZWUgRk9BUm91dGVyXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY2hhbm5lbE1hcCAtIFJvdXRpbmcgZGVzdGluYXRpb24gYXJyYXkuXG4gKiBAcmV0dXJuIHtGT0FSb3V0ZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQVJvdXRlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGNoYW5uZWxNYXApIHtcbiAgcmV0dXJuIG5ldyBGT0FSb3V0ZXIoY29udGV4dCwgY2hhbm5lbE1hcCk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEZPQSBSb3RhdG9yLlxuICogQHNlZSBGT0FSb3RhdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHJldHVybiB7Rk9BUm90YXRvcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BUm90YXRvciA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBGT0FSb3RhdG9yKGNvbnRleHQpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIuXG4gKiBAaWdub3JlXG4gKiBAc2VlIEZPQVBoYXNlTWF0Y2hlZEZpbHRlclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEByZXR1cm4ge0ZPQVBoYXNlTWF0Y2hlZEZpbHRlcn1cbiAqL1xuT21uaXRvbmUuY3JlYXRlRk9BUGhhc2VNYXRjaGVkRmlsdGVyID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEZPQVBoYXNlTWF0Y2hlZEZpbHRlcihjb250ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRk9BVmlydHVhbFNwZWFrZXIuIEZvciBwYXJhbWV0ZXJzLCByZWZlciB0aGVcbiAqIGRlZmluaXRpb24gb2YgVmlydHVhbFNwZWFrZXIgY2xhc3MuXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybiB7Rk9BVmlydHVhbFNwZWFrZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQVZpcnR1YWxTcGVha2VyID0gZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEZPQVZpcnR1YWxTcGVha2VyKGNvbnRleHQsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIERFUFJFQ0FURUQuIFVzZSBGT0FSZW5kZXJlciBpbnN0YW5jZS5cbiAqIEBzZWUgRk9BUmVuZGVyZXJcbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHZpZGVvRWxlbWVudCAtIFZpZGVvIG9yIEF1ZGlvIERPTSBlbGVtZW50IHRvIGJlIHN0cmVhbWVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciBGT0EgZGVjb2Rlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJhc2VSZXNvdXJjZVVybCAtIEJhc2UgVVJMIGZvciByZXNvdXJjZXMuXG4gKiAoYmFzZSBwYXRoIGZvciBIUklSIGZpbGVzKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc3RHYWluPTI2LjBdIC0gUG9zdC1kZWNvZGluZyBnYWluIGNvbXBlbnNhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnJvdXRpbmdEZXN0aW5hdGlvbl0gIEN1c3RvbSBjaGFubmVsIGxheW91dC5cbiAqIEByZXR1cm4ge0ZPQURlY29kZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUZPQURlY29kZXIgPSBmdW5jdGlvbihjb250ZXh0LCB2aWRlb0VsZW1lbnQsIG9wdGlvbnMpIHtcbiAgVXRpbHMubG9nKCdXQVJOSU5HOiBGT0FEZWNvZGVyIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgRk9BUmVuZGVyZXIuJyk7XG4gIHJldHVybiBuZXcgRk9BRGVjb2Rlcihjb250ZXh0LCB2aWRlb0VsZW1lbnQsIG9wdGlvbnMpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIEZPQVJlbmRlcmVyLCB0aGUgZmlyc3Qtb3JkZXIgYW1iaXNvbmljIGRlY29kZXIgYW5kIHRoZSBvcHRpbWl6ZWRcbiAqIGJpbmF1cmFsIHJlbmRlcmVyLlxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuY2hhbm5lbE1hcF0gLSBDdXN0b20gY2hhbm5lbCByb3V0aW5nIG1hcC4gVXNlZnVsIGZvclxuICogaGFuZGxpbmcgdGhlIGluY29uc2lzdGVuY3kgaW4gYnJvd3NlcidzIG11bHRpY2hhbm5lbCBhdWRpbyBkZWNvZGluZy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuaHJpclBhdGhMaXN0XSAtIEEgbGlzdCBvZiBwYXRocyB0byBIUklSIGZpbGVzLiBJdFxuICogb3ZlcnJpZGVzIHRoZSBpbnRlcm5hbCBIUklSIGxpc3QgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IFtjb25maWcucmVuZGVyaW5nTW9kZT0nYW1iaXNvbmljJ10gLSBSZW5kZXJpbmcgbW9kZS5cbiAqIEByZXR1cm4ge0ZPQVJlbmRlcmVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVGT0FSZW5kZXJlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuICByZXR1cm4gbmV3IEZPQVJlbmRlcmVyKGNvbnRleHQsIGNvbmZpZyk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBIT0FSb3RhdG9yIGZvciBoaWdoZXItb3JkZXIgYW1iaXNvbmljcyByb3RhdGlvbi5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge051bWJlcn0gYW1iaXNvbmljT3JkZXIgLSBBbWJpc29uaWMgb3JkZXIuXG4gKiBAcmV0dXJuIHtIT0FSb3RhdG9yfVxuICovXG5PbW5pdG9uZS5jcmVhdGVIT0FSb3RhdG9yID0gZnVuY3Rpb24oY29udGV4dCwgYW1iaXNvbmljT3JkZXIpIHtcbiAgcmV0dXJuIG5ldyBIT0FSb3RhdG9yKGNvbnRleHQsIGFtYmlzb25pY09yZGVyKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIEhPQUNvbnZvbHZlciBwZXJmb3JtcyB0aGUgbXVsdGktY2hhbm5lbCBjb252b2x1dGlvbiBmb3IgdGhlIG9wdG1pemVkXG4gKiBiaW5hdXJhbCByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtYmlzb25pY09yZGVyIC0gQW1iaXNvbmljIG9yZGVyLiAoMiBvciAzKVxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcltdfSBbaHJpckJ1ZmZlckxpc3RdIC0gQW4gb3JkZXJlZC1saXN0IG9mIHN0ZXJlb1xuICogQXVkaW9CdWZmZXJzIGZvciBjb252b2x1dGlvbi4gKFNPQTogNSBBdWRpb0J1ZmZlcnMsIFRPQTogOCBBdWRpb0J1ZmZlcnMpXG4gKiBAcmV0dXJuIHtIT0FDb252b3ZsZXJ9XG4gKi9cbk9tbml0b25lLmNyZWF0ZUhPQUNvbnZvbHZlciA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIGFtYmlzb25pY09yZGVyLCBocmlyQnVmZmVyTGlzdCkge1xuICByZXR1cm4gbmV3IEhPQUNvbnZvbHZlcihjb250ZXh0LCBhbWJpc29uaWNPcmRlciwgaHJpckJ1ZmZlckxpc3QpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgSE9BUmVuZGVyZXIgZm9yIGhpZ2hlci1vcmRlciBhbWJpc29uaWMgZGVjb2RpbmcgYW5kIHRoZSBvcHRpbWl6ZWRcbiAqIGJpbmF1cmFsIHJlbmRlcmluZy5cbiAqIEBwYXJhbSB7QXVkaW9Db250ZXh0fSBjb250ZXh0IC0gQXNzb2NpYXRlZCBBdWRpb0NvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5hbWJpc29uaWNPcmRlcj0zXSAtIEFtYmlzb25pYyBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuaHJpclBhdGhMaXN0XSAtIEEgbGlzdCBvZiBwYXRocyB0byBIUklSIGZpbGVzLiBJdFxuICogb3ZlcnJpZGVzIHRoZSBpbnRlcm5hbCBIUklSIGxpc3QgaWYgZ2l2ZW4uXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IFtjb25maWcucmVuZGVyaW5nTW9kZT0nYW1iaXNvbmljJ10gLSBSZW5kZXJpbmcgbW9kZS5cbiAqIEByZXR1cm4ge0hPQVJlbmRlcmVyfVxuICovXG5PbW5pdG9uZS5jcmVhdGVIT0FSZW5kZXJlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGNvbmZpZykge1xuICByZXR1cm4gbmV3IEhPQVJlbmRlcmVyKGNvbnRleHQsIGNvbmZpZyk7XG59O1xuXG5cbi8vIEhhbmRsZXIgUHJlbG9hZCBUYXNrcy5cbi8vIC0gRGV0ZWN0cyB0aGUgYnJvd3NlciBpbmZvcm1hdGlvbi5cbi8vIC0gUHJpbnRzIG91dCB0aGUgdmVyc2lvbiBudW1iZXIuXG4oZnVuY3Rpb24oKSB7XG4gIFV0aWxzLmxvZygnVmVyc2lvbiAnICsgVmVyc2lvbiArICcgKHJ1bm5pbmcgJyArXG4gICAgICBPbW5pdG9uZS5icm93c2VySW5mby5uYW1lICsgJyAnICsgT21uaXRvbmUuYnJvd3NlckluZm8udmVyc2lvbiArXG4gICAgICAnIG9uICcgKyBPbW5pdG9uZS5icm93c2VySW5mby5wbGF0Zm9ybSArJyknKTtcbiAgaWYgKE9tbml0b25lLmJyb3dzZXJJbmZvLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NhZmFyaScpIHtcbiAgICBQb2x5ZmlsbC5wYXRjaFNhZmFyaSgpO1xuICAgIFV0aWxzLmxvZyhPbW5pdG9uZS5icm93c2VySW5mby5uYW1lICsgJyBkZXRlY3RlZC4gQXBwbGl5aW5nIHBvbHlmaWxsLi4uJyk7XG4gIH1cbn0pKCk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBPbW5pdG9uZTtcblxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSBGT0EgZGVjb2RlciwgREVQUkVDQVRFRCBpbiBmYXZvciBvZiBGT0FSZW5kZXJlci5cbiAqL1xuXG5cblxuY29uc3QgQXVkaW9CdWZmZXJNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmNvbnN0IEZPQVJvdXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5jb25zdCBGT0FSb3RhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvbnN0IEZPQVBoYXNlTWF0Y2hlZEZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb25zdCBGT0FWaXJ0dWFsU3BlYWtlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5jb25zdCBGT0FTcGVha2VyRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBCeSBkZWZhdWx0LCBPbW5pdG9uZSBmZXRjaGVzIElSIGZyb20gdGhlIHNwYXRpYWwgbWVkaWEgcmVwb3NpdG9yeS5cbmNvbnN0IEhSVEZTRVRfVVJMID0gJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9Hb29nbGVDaHJvbWUvb21uaXRvbmUvbWFzdGVyL2J1aWxkL3Jlc291cmNlcy8nO1xuXG4vLyBQb3N0IGdhaW4gY29tcGVuc2F0aW9uIHZhbHVlLlxubGV0IFBPU1RfR0FJTl9EQiA9IDA7XG5cblxuLyoqXG4gKiBPbW5pdG9uZSBGT0EgZGVjb2Rlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBdWRpb0NvbnRleHR9IGNvbnRleHQgLSBBc3NvY2lhdGVkIEF1ZGlvQ29udGV4dC5cbiAqIEBwYXJhbSB7VmlkZW9FbGVtZW50fSB2aWRlb0VsZW1lbnQgLSBUYXJnZXQgdmlkZW8gKG9yIGF1ZGlvKSBlbGVtZW50IGZvclxuICogc3RyZWFtaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLkhSVEZTZXRVcmwgLSBCYXNlIFVSTCBmb3IgdGhlIGN1YmUgSFJURiBzZXRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucG9zdEdhaW5EQiAtIFBvc3QtZGVjb2RpbmcgZ2FpbiBjb21wZW5zYXRpb24gaW4gZEIuXG4gKiBAcGFyYW0ge051bWJlcltdfSBvcHRpb25zLmNoYW5uZWxNYXAgLSBDdXN0b20gY2hhbm5lbCBtYXAuXG4gKi9cbmZ1bmN0aW9uIEZPQURlY29kZXIoY29udGV4dCwgdmlkZW9FbGVtZW50LCBvcHRpb25zKSB7XG4gIHRoaXMuX2lzRGVjb2RlclJlYWR5ID0gZmFsc2U7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl92aWRlb0VsZW1lbnQgPSB2aWRlb0VsZW1lbnQ7XG4gIHRoaXMuX2RlY29kaW5nTW9kZSA9ICdhbWJpc29uaWMnO1xuXG4gIHRoaXMuX3Bvc3RHYWluREIgPSBQT1NUX0dBSU5fREI7XG4gIHRoaXMuX0hSVEZTZXRVcmwgPSBIUlRGU0VUX1VSTDtcbiAgdGhpcy5fY2hhbm5lbE1hcCA9IEZPQVJvdXRlci5DaGFubmVsTWFwLkRFRkFVTFQ7IC8vIEFDTlxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucG9zdEdhaW5EQikge1xuICAgICAgdGhpcy5fcG9zdEdhaW5EQiA9IG9wdGlvbnMucG9zdEdhaW5EQjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuSFJURlNldFVybCkge1xuICAgICAgdGhpcy5fSFJURlNldFVybCA9IG9wdGlvbnMuSFJURlNldFVybDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2hhbm5lbE1hcCkge1xuICAgICAgdGhpcy5fY2hhbm5lbE1hcCA9IG9wdGlvbnMuY2hhbm5lbE1hcDtcbiAgICB9XG4gIH1cblxuICAvLyBSZWFycmFuZ2Ugc3BlYWtlciBkYXRhIGJhc2VkIG9uIHxvcHRpb25zLkhSVEZTZXRVcmx8LlxuICB0aGlzLl9zcGVha2VyRGF0YSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IEZPQVNwZWFrZXJEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fc3BlYWtlckRhdGEucHVzaCh7XG4gICAgICBuYW1lOiBGT0FTcGVha2VyRGF0YVtpXS5uYW1lLFxuICAgICAgdXJsOiB0aGlzLl9IUlRGU2V0VXJsICsgJy8nICsgRk9BU3BlYWtlckRhdGFbaV0udXJsLFxuICAgICAgY29lZjogRk9BU3BlYWtlckRhdGFbaV0uY29lZixcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuX3RlbXBNYXRyaXg0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG59XG5cblxuLyoqXG4gKiBJbml0aWFsaXplIGFuZCBsb2FkIHRoZSByZXNvdXJjZXMgZm9yIHRoZSBkZWNvZGUuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5GT0FEZWNvZGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIFV0aWxzLmxvZygnSW5pdGlhbGl6aW5nLi4uIChtb2RlOiAnICsgdGhpcy5fZGVjb2RpbmdNb2RlICsgJyknKTtcblxuICAvLyBSZXJvdXRpbmcgY2hhbm5lbHMgaWYgbmVjZXNzYXJ5LlxuICBsZXQgY2hhbm5lbE1hcFN0cmluZyA9IHRoaXMuX2NoYW5uZWxNYXAudG9TdHJpbmcoKTtcbiAgbGV0IGRlZmF1bHRDaGFubmVsTWFwU3RyaW5nID0gRk9BUm91dGVyLkNoYW5uZWxNYXAuREVGQVVMVC50b1N0cmluZygpO1xuICBpZiAoY2hhbm5lbE1hcFN0cmluZyAhPT0gZGVmYXVsdENoYW5uZWxNYXBTdHJpbmcpIHtcbiAgICBVdGlscy5sb2coJ1JlbWFwcGluZyBjaGFubmVscyAoWycgKyBkZWZhdWx0Q2hhbm5lbE1hcFN0cmluZyArICddIC0+IFsnXG4gICAgICArIGNoYW5uZWxNYXBTdHJpbmcgKyAnXSknKTtcbiAgfVxuXG4gIHRoaXMuX2F1ZGlvRWxlbWVudFNvdXJjZSA9XG4gICAgICB0aGlzLl9jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZSh0aGlzLl92aWRlb0VsZW1lbnQpO1xuICB0aGlzLl9mb2FSb3V0ZXIgPSBuZXcgRk9BUm91dGVyKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NoYW5uZWxNYXApO1xuICB0aGlzLl9mb2FSb3RhdG9yID0gbmV3IEZPQVJvdGF0b3IodGhpcy5fY29udGV4dCk7XG4gIHRoaXMuX2ZvYVBoYXNlTWF0Y2hlZEZpbHRlciA9IG5ldyBGT0FQaGFzZU1hdGNoZWRGaWx0ZXIodGhpcy5fY29udGV4dCk7XG5cbiAgdGhpcy5fYXVkaW9FbGVtZW50U291cmNlLmNvbm5lY3QodGhpcy5fZm9hUm91dGVyLmlucHV0KTtcbiAgdGhpcy5fZm9hUm91dGVyLm91dHB1dC5jb25uZWN0KHRoaXMuX2ZvYVJvdGF0b3IuaW5wdXQpO1xuICB0aGlzLl9mb2FSb3RhdG9yLm91dHB1dC5jb25uZWN0KHRoaXMuX2ZvYVBoYXNlTWF0Y2hlZEZpbHRlci5pbnB1dCk7XG5cbiAgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzID0gW107XG5cbiAgLy8gQnlwYXNzIHNpZ25hbCBwYXRoLlxuICB0aGlzLl9ieXBhc3MgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fYXVkaW9FbGVtZW50U291cmNlLmNvbm5lY3QodGhpcy5fYnlwYXNzKTtcblxuICAvLyBHZXQgdGhlIGxpbmVhciBhbXBsaXR1ZGUgZnJvbSB0aGUgcG9zdCBnYWluIG9wdGlvbiwgd2hpY2ggaXMgaW4gZGVjaWJlbC5cbiAgY29uc3QgcG9zdEdhaW5MaW5lYXIgPSBNYXRoLnBvdygxMCwgdGhpcy5fcG9zdEdhaW5EQi8yMCk7XG4gIFV0aWxzLmxvZygnR2FpbiBjb21wZW5zYXRpb246ICcgKyBwb3N0R2FpbkxpbmVhciArICcgKCcgKyB0aGlzLl9wb3N0R2FpbkRCXG4gICAgKyAnZEIpJyk7XG5cbiAgLy8gVGhpcyByZXR1cm5zIGEgcHJvbWlzZSBzbyBkZXZlbG9wZXJzIGNhbiB1c2UgdGhlIGRlY29kZXIgd2hlbiBpdCBpcyByZWFkeS5cbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBuZXcgQXVkaW9CdWZmZXJNYW5hZ2VyKHRoYXQuX2NvbnRleHQsIHRoYXQuX3NwZWFrZXJEYXRhLFxuICAgICAgZnVuY3Rpb24oYnVmZmVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoYXQuX3NwZWFrZXJEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhhdC5fZm9hVmlydHVhbFNwZWFrZXJzW2ldID0gbmV3IEZPQVZpcnR1YWxTcGVha2VyKHRoYXQuX2NvbnRleHQsIHtcbiAgICAgICAgICAgIGNvZWZmaWNpZW50czogdGhhdC5fc3BlYWtlckRhdGFbaV0uY29lZixcbiAgICAgICAgICAgIElSOiBidWZmZXJzLmdldCh0aGF0Ll9zcGVha2VyRGF0YVtpXS5uYW1lKSxcbiAgICAgICAgICAgIGdhaW46IHBvc3RHYWluTGluZWFyLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhhdC5fZm9hUGhhc2VNYXRjaGVkRmlsdGVyLm91dHB1dC5jb25uZWN0KFxuICAgICAgICAgICAgdGhhdC5fZm9hVmlydHVhbFNwZWFrZXJzW2ldLmlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgZGVjb2RpbmcgbW9kZS5cbiAgICAgICAgdGhhdC5zZXRNb2RlKHRoYXQuX2RlY29kaW5nTW9kZSk7XG4gICAgICAgIHRoYXQuX2lzRGVjb2RlclJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgVXRpbHMubG9nKCdIUlRGIElScyBhcmUgbG9hZGVkIHN1Y2Nlc3NmdWxseS4gVGhlIGRlY29kZXIgaXMgcmVhZHkuJyk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHJlamVjdCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIHNvdW5kIGZpZWxkIHJvdGF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gcm90YXRpb25NYXRyaXggICAgICAzeDMgcm90YXRpb24gbWF0cml4IChyb3ctbWFqb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwcmVzZW50YXRpb24pXG4gKi9cbkZPQURlY29kZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4ID0gZnVuY3Rpb24ocm90YXRpb25NYXRyaXgpIHtcbiAgdGhpcy5fZm9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbk1hdHJpeCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSByb3RhdGlvbiBtYXRyaXggZnJvbSBhIFRocmVlLmpzIGNhbWVyYSBvYmplY3QuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNhbWVyYU1hdHJpeCAgICAgIFRoZSBNYXRyaXg0IG9iZWpjdCBvZiBUaHJlZS5qcyB0aGUgY2FtZXJhLlxuICovXG5GT0FEZWNvZGVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeEZyb21DYW1lcmEgPSBmdW5jdGlvbihjYW1lcmFNYXRyaXgpIHtcbiAgLy8gRXh0cmFjdCB0aGUgaW5uZXIgYXJyYXkgZWxlbWVudHMgYW5kIGludmVyc2UuIChUaGUgYWN0dWFsIHZpZXcgcm90YXRpb24gaXNcbiAgLy8gdGhlIG9wcG9zaXRlIG9mIHRoZSBjYW1lcmEgbW92ZW1lbnQuKVxuICBVdGlscy5pbnZlcnRNYXRyaXg0KHRoaXMuX3RlbXBNYXRyaXg0LCBjYW1lcmFNYXRyaXguZWxlbWVudHMpO1xuICB0aGlzLl9mb2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4NCh0aGlzLl90ZW1wTWF0cml4NCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZGVjb2RpbmcgbW9kZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlICAgICAgICAgICAgICAgRGVjb2RpbmcgbW9kZS4gV2hlbiB0aGUgbW9kZSBpcyAnYnlwYXNzJ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZGVjb2RlciBpcyBkaXNhYmxlZCBhbmQgYnlwYXNzIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCBzdHJlYW0gdG8gdGhlIG91dHB1dC4gU2V0dGluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSB0byAnYW1iaXNvbmljJyBhY3RpdmF0ZXMgdGhlIGRlY29kZXIuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gdGhlIG1vZGUgaXMgJ29mZicsIGFsbCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZyBpcyBjb21wbGV0ZWx5IHR1cm5lZCBvZmYgc2F2aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBDUFUgcG93ZXIuXG4gKi9cbkZPQURlY29kZXIucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIGlmIChtb2RlID09PSB0aGlzLl9kZWNvZGluZ01vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdieXBhc3MnOlxuICAgICAgdGhpcy5fZGVjb2RpbmdNb2RlID0gJ2J5cGFzcyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLl9mb2FWaXJ0dWFsU3BlYWtlcnNbaV0uZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYnlwYXNzLmNvbm5lY3QodGhpcy5fY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FtYmlzb25pYyc6XG4gICAgICB0aGlzLl9kZWNvZGluZ01vZGUgPSAnYW1iaXNvbmljJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vyc1tpXS5lbmFibGUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29mZic6XG4gICAgICB0aGlzLl9kZWNvZGluZ01vZGUgPSAnb2ZmJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZm9hVmlydHVhbFNwZWFrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuX2ZvYVZpcnR1YWxTcGVha2Vyc1tpXS5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBVdGlscy5sb2coJ0RlY29kaW5nIG1vZGUgY2hhbmdlZC4gKCcgKyBtb2RlICsgJyknKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRk9BRGVjb2RlcjtcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIGRhdGEgZm9yIEZPQVZpcnR1YWxTcGVha2VyLiBFYWNoIGVudHJ5IGNvbnRhaW5zIHRoZSBVUkwgZm9yIElSIGZpbGVzIGFuZFxuICogdGhlIGdhaW4gY29lZmZpY2llbnRzIGZvciB0aGUgYXNzb2NpYXRlZCBJUiBmaWxlcy4gTm90ZSB0aGF0IHRoZSBvcmRlciBvZlxuICogY29lZmZpY2llbnRzIGZvbGxvd3MgdGhlIEFDTiBjaGFubmVsIG9yZGVyaW5nLiAoVyxZLFosWClcbiAqIEB0eXBlIHtPYmplY3RbXX1cbiAqL1xuY29uc3QgRk9BU3BlYWtlckRhdGEgPSBbe1xuICBuYW1lOiAnRTM1X0ExMzUnLFxuICB1cmw6ICdFMzVfQTEzNS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIDAuMjE2NDk1LCAwLjIxNjUzLCAtMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRTM1X0EtMTM1JyxcbiAgdXJsOiAnRTM1X0EtMTM1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgLTAuMjE2NDk1LCAwLjIxNjUzLCAtMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRS0zNV9BMTM1JyxcbiAgdXJsOiAnRS0zNV9BMTM1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgMC4yMTY0OTUsIC0wLjIxNjUzLCAtMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRS0zNV9BLTEzNScsXG4gIHVybDogJ0UtMzVfQS0xMzUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAtMC4yMTY0OTUsIC0wLjIxNjUzLCAtMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRTM1X0E0NScsXG4gIHVybDogJ0UzNV9BNDUud2F2JyxcbiAgZ2FpbkZhY3RvcjogMSxcbiAgY29lZjogWy4xMjUwLCAwLjIxNjQ5NSwgMC4yMTY1MywgMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRTM1X0EtNDUnLFxuICB1cmw6ICdFMzVfQS00NS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIC0wLjIxNjQ5NSwgMC4yMTY1MywgMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRS0zNV9BNDUnLFxuICB1cmw6ICdFLTM1X0E0NS53YXYnLFxuICBnYWluRmFjdG9yOiAxLFxuICBjb2VmOiBbLjEyNTAsIDAuMjE2NDk1LCAtMC4yMTY1MywgMC4yMTY0OTVdLFxufSwge1xuICBuYW1lOiAnRS0zNV9BLTQ1JyxcbiAgdXJsOiAnRS0zNV9BLTQ1LndhdicsXG4gIGdhaW5GYWN0b3I6IDEsXG4gIGNvZWY6IFsuMTI1MCwgLTAuMjE2NDk1LCAtMC4yMTY1MywgMC4yMTY0OTVdLFxufV07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FTcGVha2VyRGF0YTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuLyoqXG4gKiBAZmlsZSBPbW5pdG9uZSBGT0FSZW5kZXJlci4gVGhpcyBpcyB1c2VyLWZhY2luZyBBUEkgZm9yIHRoZSBmaXJzdC1vcmRlclxuICogYW1iaXNvbmljIGRlY29kZXIgYW5kIHRoZSBvcHRpbWl6ZWQgYmluYXVyYWwgcmVuZGVyZXIuXG4gKi9cblxuXG5cbmNvbnN0IEJ1ZmZlckxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgRk9BQ29udm9sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmNvbnN0IEZPQUhyaXJCYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbmNvbnN0IEZPQVJvdGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuY29uc3QgRk9BUm91dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmNvbnN0IFV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFJlbmRlcmluZ01vZGVcbiAqL1xuXG4vKipcbiAqIFJlbmRlcmluZyBtb2RlIEVOVU0uXG4gKiBAZW51bSB7UmVuZGVyaW5nTW9kZX1cbiAqL1xuY29uc3QgUmVuZGVyaW5nTW9kZSA9IHtcbiAgLyoqIEB0eXBlIHtzdHJpbmd9IFVzZSBhbWJpc29uaWMgcmVuZGVyaW5nLiAqL1xuICBBTUJJU09OSUM6ICdhbWJpc29uaWMnLFxuICAvKiogQHR5cGUge3N0cmluZ30gQnlwYXNzLiBObyBhbWJpc29uaWMgcmVuZGVyaW5nLiAqL1xuICBCWVBBU1M6ICdieXBhc3MnLFxuICAvKiogQHR5cGUge3N0cmluZ30gRGlzYWJsZSBhdWRpbyBvdXRwdXQuICovXG4gIE9GRjogJ29mZicsXG59O1xuXG5cbi8qKlxuICogT21uaXRvbmUgRk9BIHJlbmRlcmVyIGNsYXNzLiBVc2VzIHRoZSBvcHRpbWl6ZWQgY29udm9sdXRpb24gdGVjaG5pcXVlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5jaGFubmVsTWFwXSAtIEN1c3RvbSBjaGFubmVsIHJvdXRpbmcgbWFwLiBVc2VmdWwgZm9yXG4gKiBoYW5kbGluZyB0aGUgaW5jb25zaXN0ZW5jeSBpbiBicm93c2VyJ3MgbXVsdGljaGFubmVsIGF1ZGlvIGRlY29kaW5nLlxuICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5ocmlyUGF0aExpc3RdIC0gQSBsaXN0IG9mIHBhdGhzIHRvIEhSSVIgZmlsZXMuIEl0XG4gKiBvdmVycmlkZXMgdGhlIGludGVybmFsIEhSSVIgbGlzdCBpZiBnaXZlbi5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gW2NvbmZpZy5yZW5kZXJpbmdNb2RlPSdhbWJpc29uaWMnXSAtIFJlbmRlcmluZyBtb2RlLlxuICovXG5mdW5jdGlvbiBGT0FSZW5kZXJlcihjb250ZXh0LCBjb25maWcpIHtcbiAgdGhpcy5fY29udGV4dCA9IFV0aWxzLmlzQXVkaW9Db250ZXh0KGNvbnRleHQpID9cbiAgICAgIGNvbnRleHQgOlxuICAgICAgVXRpbHMudGhyb3coJ0ZPQVJlbmRlcmVyOiBJbnZhbGlkIEJhc2VBdWRpb0NvbnRleHQuJyk7XG5cbiAgdGhpcy5fY29uZmlnID0ge1xuICAgIGNoYW5uZWxNYXA6IEZPQVJvdXRlci5DaGFubmVsTWFwLkRFRkFVTFQsXG4gICAgcmVuZGVyaW5nTW9kZTogUmVuZGVyaW5nTW9kZS5BTUJJU09OSUMsXG4gIH07XG5cbiAgaWYgKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuY2hhbm5lbE1hcCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmNoYW5uZWxNYXApICYmIGNvbmZpZy5jaGFubmVsTWFwLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0aGlzLl9jb25maWcuY2hhbm5lbE1hcCA9IGNvbmZpZy5jaGFubmVsTWFwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMudGhyb3coXG4gICAgICAgICAgICAnRk9BUmVuZGVyZXI6IEludmFsaWQgY2hhbm5lbCBtYXAuIChnb3QgJyArIGNvbmZpZy5jaGFubmVsTWFwXG4gICAgICAgICAgICArICcpJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5ocmlyUGF0aExpc3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5ocmlyUGF0aExpc3QpICYmXG4gICAgICAgICAgY29uZmlnLmhyaXJQYXRoTGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLnBhdGhMaXN0ID0gY29uZmlnLmhyaXJQYXRoTGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLnRocm93KFxuICAgICAgICAgICAgJ0ZPQVJlbmRlcmVyOiBJbnZhbGlkIEhSSVIgVVJMcy4gSXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoICcgK1xuICAgICAgICAgICAgJzIgVVJMcyB0byBIUklSIGZpbGVzLiAoZ290ICcgKyBjb25maWcuaHJpclBhdGhMaXN0ICsgJyknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnJlbmRlcmluZ01vZGUpIHtcbiAgICAgIGlmIChPYmplY3QudmFsdWVzKFJlbmRlcmluZ01vZGUpLmluY2x1ZGVzKGNvbmZpZy5yZW5kZXJpbmdNb2RlKSkge1xuICAgICAgICB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSA9IGNvbmZpZy5yZW5kZXJpbmdNb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICAgJ0ZPQVJlbmRlcmVyOiBJbnZhbGlkIHJlbmRlcmluZyBtb2RlIG9yZGVyLiAoZ290JyArXG4gICAgICAgICAgICBjb25maWcucmVuZGVyaW5nTW9kZSArICcpIEZhbGxiYWNrcyB0byB0aGUgbW9kZSBcImFtYmlzb25pY1wiLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2J1aWxkQXVkaW9HcmFwaCgpO1xuXG4gIHRoaXMuX3RlbXBNYXRyaXg0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gIHRoaXMuX2lzUmVuZGVyZXJSZWFkeSA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogQnVpbGRzIHRoZSBpbnRlcm5hbCBhdWRpbyBncmFwaC5cbiAqIEBwcml2YXRlXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5fYnVpbGRBdWRpb0dyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5wdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5vdXRwdXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5fYnlwYXNzID0gdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuX2ZvYVJvdXRlciA9IG5ldyBGT0FSb3V0ZXIodGhpcy5fY29udGV4dCwgdGhpcy5fY29uZmlnLmNoYW5uZWxNYXApO1xuICB0aGlzLl9mb2FSb3RhdG9yID0gbmV3IEZPQVJvdGF0b3IodGhpcy5fY29udGV4dCk7XG4gIHRoaXMuX2ZvYUNvbnZvbHZlciA9IG5ldyBGT0FDb252b2x2ZXIodGhpcy5fY29udGV4dCk7XG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9mb2FSb3V0ZXIuaW5wdXQpO1xuICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fYnlwYXNzKTtcbiAgdGhpcy5fZm9hUm91dGVyLm91dHB1dC5jb25uZWN0KHRoaXMuX2ZvYVJvdGF0b3IuaW5wdXQpO1xuICB0aGlzLl9mb2FSb3RhdG9yLm91dHB1dC5jb25uZWN0KHRoaXMuX2ZvYUNvbnZvbHZlci5pbnB1dCk7XG4gIHRoaXMuX2ZvYUNvbnZvbHZlci5vdXRwdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cbiAgdGhpcy5pbnB1dC5jaGFubmVsQ291bnQgPSA0O1xuICB0aGlzLmlucHV0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuICB0aGlzLmlucHV0LmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdkaXNjcmV0ZSc7XG59O1xuXG5cbi8qKlxuICogSW50ZXJuYWwgY2FsbGJhY2sgaGFuZGxlciBmb3IgfGluaXRpYWxpemV8IG1ldGhvZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlIC0gUmVzb2x1dGlvbiBoYW5kbGVyLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0aW9uIGhhbmRsZXIuXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZUNhbGxiYWNrID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGNvbnN0IGJ1ZmZlckxpc3QgPSB0aGlzLl9jb25maWcucGF0aExpc3RcbiAgICAgID8gbmV3IEJ1ZmZlckxpc3QodGhpcy5fY29udGV4dCwgdGhpcy5fY29uZmlnLnBhdGhMaXN0LCB7ZGF0YVR5cGU6ICd1cmwnfSlcbiAgICAgIDogbmV3IEJ1ZmZlckxpc3QodGhpcy5fY29udGV4dCwgRk9BSHJpckJhc2U2NCk7XG4gIGJ1ZmZlckxpc3QubG9hZCgpLnRoZW4oXG4gICAgICBmdW5jdGlvbihocmlyQnVmZmVyTGlzdCkge1xuICAgICAgICB0aGlzLl9mb2FDb252b2x2ZXIuc2V0SFJJUkJ1ZmZlckxpc3QoaHJpckJ1ZmZlckxpc3QpO1xuICAgICAgICB0aGlzLnNldFJlbmRlcmluZ01vZGUodGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUpO1xuICAgICAgICB0aGlzLl9pc1JlbmRlcmVyUmVhZHkgPSB0cnVlO1xuICAgICAgICBVdGlscy5sb2coJ0ZPQVJlbmRlcmVyOiBIUklScyBsb2FkZWQgc3VjY2Vzc2Z1bGx5LiBSZWFkeS4nKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdGT0FSZW5kZXJlcjogSFJJUiBsb2FkaW5nL2RlY29kaW5nIGZhaWxlZC4nO1xuICAgICAgICBVdGlscy50aHJvdyhlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZWplY3QoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuZCBsb2FkcyB0aGUgcmVzb3VyY2UgZm9yIHRoZSByZW5kZXJlci5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIFV0aWxzLmxvZyhcbiAgICAgICdGT0FSZW5kZXJlcjogSW5pdGlhbGl6aW5nLi4uIChtb2RlOiAnICsgdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUgK1xuICAgICAgJyknKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UodGhpcy5faW5pdGlhbGl6ZUNhbGxiYWNrLmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgVXRpbHMudGhyb3coJ0ZPQVJlbmRlcmVyOiBJbml0aWFsaXphdGlvbiBmYWlsZWQuICgnICsgZXJyb3IgKyAnKScpO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBTZXQgdGhlIGNoYW5uZWwgbWFwLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gY2hhbm5lbE1hcCAtIEN1c3RvbSBjaGFubmVsIHJvdXRpbmcgZm9yIEZPQSBzdHJlYW0uXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRDaGFubmVsTWFwID0gZnVuY3Rpb24oY2hhbm5lbE1hcCkge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGFubmVsTWFwLnRvU3RyaW5nKCkgIT09IHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwLnRvU3RyaW5nKCkpIHtcbiAgICBVdGlscy5sb2coXG4gICAgICAgICdSZW1hcHBpbmcgY2hhbm5lbHMgKFsnICsgdGhpcy5fY29uZmlnLmNoYW5uZWxNYXAudG9TdHJpbmcoKSArXG4gICAgICAgICddIC0+IFsnICsgY2hhbm5lbE1hcC50b1N0cmluZygpICsgJ10pLicpO1xuICAgIHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwID0gY2hhbm5lbE1hcC5zbGljZSgpO1xuICAgIHRoaXMuX2ZvYVJvdXRlci5zZXRDaGFubmVsTWFwKHRoaXMuX2NvbmZpZy5jaGFubmVsTWFwKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDN4MyBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDMgLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDMpIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9mb2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4Myhyb3RhdGlvbk1hdHJpeDMpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDR4NCBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDQgLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkZPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDQpIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9mb2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4NChyb3RhdGlvbk1hdHJpeDQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcm90YXRpb24gbWF0cml4IGZyb20gYSBUaHJlZS5qcyBjYW1lcmEgb2JqZWN0LiBEZXByZWF0ZWQgaW4gVjEsIGFuZFxuICogdGhpcyBleGlzdHMgb25seSBmb3IgdGhlIGJhY2t3YXJkIGNvbXBhdGlibGl0eS4gSW5zdGVhZCwgdXNlXG4gKiB8c2V0Um90YXRhdGlvbk1hdHJpeDQoKXwgd2l0aCBUaHJlZS5qcyB8Y2FtZXJhLndvcmxkTWF0cml4LmVsZW1lbnRzfC5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gY2FtZXJhTWF0cml4IC0gTWF0cml4NCBmcm9tIFRocmVlLmpzIHxjYW1lcmEubWF0cml4fC5cbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJvdGF0aW9uTWF0cml4RnJvbUNhbWVyYSA9IGZ1bmN0aW9uKGNhbWVyYU1hdHJpeCkge1xuICBpZiAoIXRoaXMuX2lzUmVuZGVyZXJSZWFkeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEV4dHJhY3QgdGhlIGlubmVyIGFycmF5IGVsZW1lbnRzIGFuZCBpbnZlcnNlLiAoVGhlIGFjdHVhbCB2aWV3IHJvdGF0aW9uIGlzXG4gIC8vIHRoZSBvcHBvc2l0ZSBvZiB0aGUgY2FtZXJhIG1vdmVtZW50LilcbiAgVXRpbHMuaW52ZXJ0TWF0cml4NCh0aGlzLl90ZW1wTWF0cml4NCwgY2FtZXJhTWF0cml4LmVsZW1lbnRzKTtcbiAgdGhpcy5fZm9hUm90YXRvci5zZXRSb3RhdGlvbk1hdHJpeDQodGhpcy5fdGVtcE1hdHJpeDQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgcmVuZGVyaW5nIG1vZGUuXG4gKiBAcGFyYW0ge1JlbmRlcmluZ01vZGV9IG1vZGUgLSBSZW5kZXJpbmcgbW9kZS5cbiAqICAtICdhbWJpc29uaWMnOiBhY3RpdmF0ZXMgdGhlIGFtYmlzb25pYyBkZWNvZGluZy9iaW5hdXJsIHJlbmRlcmluZy5cbiAqICAtICdieXBhc3MnOiBieXBhc3NlcyB0aGUgaW5wdXQgc3RyZWFtIGRpcmVjdGx5IHRvIHRoZSBvdXRwdXQuIE5vIGFtYmlzb25pY1xuICogICAgZGVjb2Rpbmcgb3IgZW5jb2RpbmcuXG4gKiAgLSAnb2ZmJzogYWxsIHRoZSBwcm9jZXNzaW5nIG9mZiBzYXZpbmcgdGhlIENQVSBwb3dlci5cbiAqL1xuRk9BUmVuZGVyZXIucHJvdG90eXBlLnNldFJlbmRlcmluZ01vZGUgPSBmdW5jdGlvbihtb2RlKSB7XG4gIGlmIChtb2RlID09PSB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5BTUJJU09OSUM6XG4gICAgICB0aGlzLl9mb2FDb252b2x2ZXIuZW5hYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLkJZUEFTUzpcbiAgICAgIHRoaXMuX2ZvYUNvbnZvbHZlci5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuY29ubmVjdCh0aGlzLm91dHB1dCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuT0ZGOlxuICAgICAgdGhpcy5fZm9hQ29udm9sdmVyLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuX2J5cGFzcy5kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgVXRpbHMubG9nKFxuICAgICAgICAgICdGT0FSZW5kZXJlcjogUmVuZGVyaW5nIG1vZGUgXCInICsgbW9kZSArICdcIiBpcyBub3QgJyArXG4gICAgICAgICAgJ3N1cHBvcnRlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2NvbmZpZy5yZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgVXRpbHMubG9nKCdGT0FSZW5kZXJlcjogUmVuZGVyaW5nIG1vZGUgY2hhbmdlZC4gKCcgKyBtb2RlICsgJyknKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGT0FSZW5kZXJlcjtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmNvbnN0IE9tbml0b25lRk9BSHJpckJhc2U2NCA9IFtcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQrL3dJQTl2OFFBUHYvQ3dEKy93Y0EvdjhNQVAvL0FRRDcvd0VBQ0FBRUFQai8rdjhZQUJBQTd2L24vL3YvOVAvTS84RC8vZjM0L1IzOEV2enhBZkVCdEEybERUY0JKUUZKOVQ3MUZQMEQvY0QxdGZWby9Xdjl1UFRPOVBQbU91ZmMvVS8rYWdMM0Fpc2MvUnh1R0tFWkJ2M2ovaVlNelEyZ0F6c0VRUVVBQmlRRnJBU3pBNWNCMlFteUN5MEF0Z1I0QWVZR3RmZ0FBMmo1T1FIUCtzY0FyUHNNQkpnRWdnSUVCdHo2K1FWcS9wai9hUGc4QlBQM2dRRWkrakVBb2YwZkExdjkrLzdTKzhJQmp2d2QveEQ0SUFETC9QZjl6dnMrL2wzK3dnQjcvK0wrN2Z6RkFESDlrZjZBK24zK0RQNisvVFA5eFA2OC9wbit3LzI2L2kzOVlnQTAvdTc5MFB0OS9rRCs3djFzL1diKzhmNEMvMVArcGYveC9jVCs2LzNwL1h6OWZmNUYvMGY5Ry80ci82di80UDVML3NMK2ZmN2MvcGorT3Y3WC9VVCs5UDVHL296KzZ2NkEvMkQrOS82UC84ci9iUDdtL2lqK0MvL2UvdGovR2Y0ZS85ditGd0RQL2x6L3NQN0YvMkgrcnYvRy9zNy9IZjd5LzRQK05BRDkvazBBSy82dy96UC9oQUNoL3NYL2dmNDRBT1ArZGdDbS9pVUFrLzVxQU9EK1B3QysvakVBV1A0Q0FBci9iUUJ3L3Z2L3pmNWlBQ0QvT2dDUy91RC9DdjlvQUFiL0NnREsva3dBLy81dEFDSC9UZ0NnL2g0QUhQOWFBQlAvSkFEUC9oRUFZdjlnQUFqLzNmOG0veXNBWXY4Z0FDWC84LzhrL3lzQVh2OGJBQkgvL3Y4ai95Z0FhLzhxQUFELzlmOWcvMVlBV2Y4SkFDSC9BZ0IyL3o0QVhQL3cvejMvRmdCMi95a0FYLy85L3ovL0V3Q1YvelVBUy8vbi8xVC9HQUNLL3g0QVR2LzAvNFAvUVFCNC8vdi9XUC8yLzNYL0hBQjgvL1AvVi8vMy8yZi9BUUJoLzl2L1RmL3gvNVAvSXdDSS93TUFmLzhoQUtQL0pBQ1oveFVBaXY4bkFLLy9IZ0NyL3lNQW0vOHVBTXovT0FDaS95UUFxZjg3QU1UL013Q1kveVVBdFA5RkFNSC9LZ0N1L3ljQXlQODVBTXYvSXdDei94b0ExZjhxQU1uL0ZnQzgveFFBNC84bkFNWC9Dd0RKL3hRQTRmOFpBTUgvQmdETy94UUE0ZjhXQU1QL0J3RFUveFFBNFA4UUFNSC9BUURiL3hRQTNQOEpBTVAvQWdEaC94SUEydjhFQU1qL0FnRGsvdzBBMWYvKy84di9Bd0RtL3d3QTB2LysvOUgvQmdEbC93a0F6di84LzlUL0J3RGsvd2NBenYvOC85ci9DUURpL3dRQXpmLzgvOS8vQ0FEZi8vLy8wUC85LytML0J3RGQvLzcvMC8vLy8rVC9CZ0RiLy96LzFmOEFBT2YvQlFEWi8vdi8ydjhDQU9iL0F3RFkvL3YvM3Y4RUFPYi9BZ0RZLy8zLzRmOEZBT1gvQVFEWi8vNy81UDhHQU9QL0FBRGIvd0FBNS84R0FPSC8vLy9kL3dJQTUvOEZBT0QvLy8vZi93TUE2UDhGQU9ELy8vL2gvd1FBNlA4RUFONy8vLy9oL3dVQTR2OERBTnYvQVFEZC93UUEzUDhDQU5uL0FnRGIvd01BMi84Q0FOdi9BZ0RkL3dJQTN2OENBT0gvQVFEai93RUFcIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUFBQUFBQS9mOENBUC8vQVFELy93RUEvLzhCQVAzL0FBQUNBUDcvK2Y4QUFBSUEvUDhGQUFRQTgvOEFBQm9BK2YvVi93UUFIUURPL3hvQVFRQk8vb2NBMFB4MS91Y0hXLzRVQ204SExPNmtBanY4L2ZDUkRkQUFZZlBpQklnRlh2ZVVDTTBHQnZoNi9uejdyZjBKL1FjUVNSVmRCZ29CU2dGUjYycjlOUDhtK0xvRUF2cmlCVkFBaUFQbUFCRUdNZjJsK1N3Qmp2YTYvRzRBLy84UC9DWURNZ1htL1IwQ0tBRTYvZmNCQndBdEFORCtrUUEwQTVVRGh3RnMvOElCOGZ5ZEFFUC9BLzh2L2U3L21QOGovMllCSXdFM0F2MEFZdit1QU9EOGxnQWcvd3dBSWYvTC9uMEFlLy9PQUpNQjNQL1hBRi8vWHdDTS8wOEFCLzhOQUVmL3JmNGpBVDMvbGdBSkFQNEFIZ0RwQU84QVVmOUwvMDcvUWY4S0FPRC94LytELzNzQVRRQ0RBTW9BMGY3OS8rTC9FUUR0LzdFQXF2K1MvN0lBdXYvby93Z0FjLy9YLy9IL1N3Q20vKzMvWWYvQi95b0FBQURJLzdYL0F3QmcvNUVBVGdDWC94WUEvUCtxLzAwQVZBQ1kvNnYvQkFERC96d0FMUUNOLzh6L0tRRHUveWdBRWdDWi82Zi9WUURDLy9UL0tRQ3MvN1AvVWdBZkFPNy9OZ0M4LzU3L2F3QVpBUFAvK1AvVi84ei9iUUJCQUwvL0RnRDAvK1QvVEFCQkFNei9Dd0F4QVB6L1NRQnFBTG4vQmdBTEFQei9FQUE3QUl6LzMvOGlBQVVBLy84a0FMZi95LzlWQUJRQSt2ODFBT2ovMFA5Y0FCNEErZjhXQU9yL3Z2ODNBQmdBdy84SkFPai80ZjhuQUNJQXNmL3kvdzRBM3Y4Z0FDUUF4UC9uL3ljQTdQOFdBQzBBeWYvVS95Y0E5di83L3lVQTBQL1AvelVBQkFEYy94VUE1UC9KL3pjQUN3RFMveFVBOVAvbS96QUFDUURYLyszLzl2LzIveVFBQ2dEWi8rUC9Bd0FLQUJZQS8vL2IvOWovRVFBTEFCa0FEZ0Q2Lys3L0d3RDQvdzRBOFAvdy8vai9FZ0FFQUFVQTlmLzEvd1FBR2dENC93QUE1Ly8vL3dBQUdRRDEvLy8vN2Y4RkFBVUFGUUR2L3dBQTZ2OExBQWNBRlFEcy93RUE5UDhTQUFZQUN3RHIvLzcvQVFBU0FBWUFCUUR2L3dJQUF3QVdBQUlBQWdEdi93QUFCZ0FUQUFFQS9mL3Uvd1FBQmdBUUFQci8rUC96L3dVQUNRQUxBUGovOS8vNC93Z0FCd0FLQVBULytmLzUvdzRBQndBSUFQVC8rLy85L3c0QUF3QURBUEgvL2YvLy93OEEvLzhCQVBQLy8vOEJBQTBBL2YvKy8vWC9BZ0FDQUEwQSsvLzgvL2IvQkFBREFBb0ErZi83Ly9uL0JnQURBQWNBK1AvNy8vdi9Cd0FCQUFRQStQLzgvLzMvQ1FBQkFBSUE5Ly85Ly8vL0NRRC8vLy8vK1AvLy93QUFDQUQ5Ly83LytmOEFBQUFBQndEOC8vMy8rdjhDQUFBQUJnRDcvL3ovL1A4RUFBQUFCQUQ2Ly8zLy9QOEZBUC8vQWdENi8vNy8vdjhGQVA3L0FRRDcvLy8vLy84R0FQNy9BQUQ3L3dFQS8vOEVBUDMvQUFEOS93RUEvdjhEQVAzL0FBRDkvd0lBL3Y4Q0FQMy9BUUQ5L3dJQS92OENBUDcvQVFEKy93RUFcIixcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gT21uaXRvbmVGT0FIcmlyQmFzZTY0O1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEBmaWxlIE9tbml0b25lIEhPQVJlbmRlcmVyLiBUaGlzIGlzIHVzZXItZmFjaW5nIEFQSSBmb3IgdGhlIGhpZ2hlci1vcmRlclxuICogYW1iaXNvbmljIGRlY29kZXIgYW5kIHRoZSBvcHRpbWl6ZWQgYmluYXVyYWwgcmVuZGVyZXIuXG4gKi9cblxuXG5cbmNvbnN0IEJ1ZmZlckxpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29uc3QgSE9BQ29udm9sdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmNvbnN0IEhPQVJvdGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuY29uc3QgVE9BSHJpckJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuY29uc3QgU09BSHJpckJhc2U2NCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuY29uc3QgVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge3N0cmluZ30gUmVuZGVyaW5nTW9kZVxuICovXG5cbi8qKlxuICogUmVuZGVyaW5nIG1vZGUgRU5VTS5cbiAqIEBlbnVtIHtSZW5kZXJpbmdNb2RlfVxuICovXG5jb25zdCBSZW5kZXJpbmdNb2RlID0ge1xuICAvKiogQHR5cGUge3N0cmluZ30gVXNlIGFtYmlzb25pYyByZW5kZXJpbmcuICovXG4gIEFNQklTT05JQzogJ2FtYmlzb25pYycsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBCeXBhc3MuIE5vIGFtYmlzb25pYyByZW5kZXJpbmcuICovXG4gIEJZUEFTUzogJ2J5cGFzcycsXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBEaXNhYmxlIGF1ZGlvIG91dHB1dC4gKi9cbiAgT0ZGOiAnb2ZmJyxcbn07XG5cblxuLy8gQ3VycmVudGx5IFNPQSBhbmQgVE9BIGFyZSBvbmx5IHN1cHBvcnRlZC5cbmNvbnN0IFN1cHBvcnRlZEFtYmlzb25pY09yZGVyID0gWzIsIDNdO1xuXG5cbi8qKlxuICogT21uaXRvbmUgSE9BIHJlbmRlcmVyIGNsYXNzLiBVc2VzIHRoZSBvcHRpbWl6ZWQgY29udm9sdXRpb24gdGVjaG5pcXVlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0F1ZGlvQ29udGV4dH0gY29udGV4dCAtIEFzc29jaWF0ZWQgQXVkaW9Db250ZXh0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuYW1iaXNvbmljT3JkZXI9M10gLSBBbWJpc29uaWMgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmhyaXJQYXRoTGlzdF0gLSBBIGxpc3Qgb2YgcGF0aHMgdG8gSFJJUiBmaWxlcy4gSXRcbiAqIG92ZXJyaWRlcyB0aGUgaW50ZXJuYWwgSFJJUiBsaXN0IGlmIGdpdmVuLlxuICogQHBhcmFtIHtSZW5kZXJpbmdNb2RlfSBbY29uZmlnLnJlbmRlcmluZ01vZGU9J2FtYmlzb25pYyddIC0gUmVuZGVyaW5nIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIEhPQVJlbmRlcmVyKGNvbnRleHQsIGNvbmZpZykge1xuICB0aGlzLl9jb250ZXh0ID0gVXRpbHMuaXNBdWRpb0NvbnRleHQoY29udGV4dCkgP1xuICAgICAgY29udGV4dCA6XG4gICAgICBVdGlscy50aHJvdygnSE9BUmVuZGVyZXI6IEludmFsaWQgQmFzZUF1ZGlvQ29udGV4dC4nKTtcblxuICB0aGlzLl9jb25maWcgPSB7XG4gICAgYW1iaXNvbmljT3JkZXI6IDMsXG4gICAgcmVuZGVyaW5nTW9kZTogUmVuZGVyaW5nTW9kZS5BTUJJU09OSUMsXG4gIH07XG5cbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuYW1iaXNvbmljT3JkZXIpIHtcbiAgICBpZiAoU3VwcG9ydGVkQW1iaXNvbmljT3JkZXIuaW5jbHVkZXMoY29uZmlnLmFtYmlzb25pY09yZGVyKSkge1xuICAgICAgdGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyID0gY29uZmlnLmFtYmlzb25pY09yZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy5sb2coXG4gICAgICAgICAgJ0hPQVJlbmRlcmVyOiBJbnZhbGlkIGFtYmlzb25pYyBvcmRlci4gKGdvdCAnICtcbiAgICAgICAgICBjb25maWcuYW1iaXNvbmljT3JkZXIgKyAnKSBGYWxsYmFja3MgdG8gM3JkLW9yZGVyIGFtYmlzb25pYy4nKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jb25maWcubnVtYmVyT2ZDaGFubmVscyA9XG4gICAgICAodGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyICsgMSkgKiAodGhpcy5fY29uZmlnLmFtYmlzb25pY09yZGVyICsgMSk7XG4gIHRoaXMuX2NvbmZpZy5udW1iZXJPZlN0ZXJlb0NoYW5uZWxzID1cbiAgICAgIE1hdGguY2VpbCh0aGlzLl9jb25maWcubnVtYmVyT2ZDaGFubmVscyAvIDIpO1xuXG4gIGlmIChjb25maWcgJiYgY29uZmlnLmhyaXJQYXRoTGlzdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5ocmlyUGF0aExpc3QpICYmXG4gICAgICAgIGNvbmZpZy5ocmlyUGF0aExpc3QubGVuZ3RoID09PSB0aGlzLl9jb25maWcubnVtYmVyT2ZTdGVyZW9DaGFubmVscykge1xuICAgICAgdGhpcy5fY29uZmlnLnBhdGhMaXN0ID0gY29uZmlnLmhyaXJQYXRoTGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMudGhyb3coXG4gICAgICAgICAgJ0hPQVJlbmRlcmVyOiBJbnZhbGlkIEhSSVIgVVJMcy4gSXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoICcgK1xuICAgICAgICAgIHRoaXMuX2NvbmZpZy5udW1iZXJPZlN0ZXJlb0NoYW5uZWxzICsgJyBVUkxzIHRvIEhSSVIgZmlsZXMuJyArXG4gICAgICAgICAgJyAoZ290ICcgKyBjb25maWcuaHJpclBhdGhMaXN0ICsgJyknKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5yZW5kZXJpbmdNb2RlKSB7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoUmVuZGVyaW5nTW9kZSkuaW5jbHVkZXMoY29uZmlnLnJlbmRlcmluZ01vZGUpKSB7XG4gICAgICB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSA9IGNvbmZpZy5yZW5kZXJpbmdNb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy5sb2coXG4gICAgICAgICAgJ0hPQVJlbmRlcmVyOiBJbnZhbGlkIHJlbmRlcmluZyBtb2RlLiAoZ290ICcgK1xuICAgICAgICAgIGNvbmZpZy5yZW5kZXJpbmdNb2RlICsgJykgRmFsbGJhY2tzIHRvIFwiYW1iaXNvbmljXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYnVpbGRBdWRpb0dyYXBoKCk7XG5cbiAgdGhpcy5faXNSZW5kZXJlclJlYWR5ID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGludGVybmFsIGF1ZGlvIGdyYXBoLlxuICogQHByaXZhdGVcbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLl9idWlsZEF1ZGlvR3JhcGggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbnB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLm91dHB1dCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpO1xuICB0aGlzLl9ieXBhc3MgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgdGhpcy5faG9hUm90YXRvciA9IG5ldyBIT0FSb3RhdG9yKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlcik7XG4gIHRoaXMuX2hvYUNvbnZvbHZlciA9XG4gICAgICBuZXcgSE9BQ29udm9sdmVyKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbmZpZy5hbWJpc29uaWNPcmRlcik7XG4gIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9ob2FSb3RhdG9yLmlucHV0KTtcbiAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX2J5cGFzcyk7XG4gIHRoaXMuX2hvYVJvdGF0b3Iub3V0cHV0LmNvbm5lY3QodGhpcy5faG9hQ29udm9sdmVyLmlucHV0KTtcbiAgdGhpcy5faG9hQ29udm9sdmVyLm91dHB1dC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblxuICB0aGlzLmlucHV0LmNoYW5uZWxDb3VudCA9IHRoaXMuX2NvbmZpZy5udW1iZXJPZkNoYW5uZWxzO1xuICB0aGlzLmlucHV0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuICB0aGlzLmlucHV0LmNoYW5uZWxJbnRlcnByZXRhdGlvbiA9ICdkaXNjcmV0ZSc7XG59O1xuXG5cbi8qKlxuICogSW50ZXJuYWwgY2FsbGJhY2sgaGFuZGxlciBmb3IgfGluaXRpYWxpemV8IG1ldGhvZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlIC0gUmVzb2x1dGlvbiBoYW5kbGVyLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVqZWN0IC0gUmVqZWN0aW9uIGhhbmRsZXIuXG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5faW5pdGlhbGl6ZUNhbGxiYWNrID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGxldCBidWZmZXJMaXN0O1xuICBpZiAodGhpcy5fY29uZmlnLnBhdGhMaXN0KSB7XG4gICAgYnVmZmVyTGlzdCA9XG4gICAgICAgIG5ldyBCdWZmZXJMaXN0KHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbmZpZy5wYXRoTGlzdCwge2RhdGFUeXBlOiAndXJsJ30pO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlckxpc3QgPSB0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIgPT09IDJcbiAgICAgICAgPyBuZXcgQnVmZmVyTGlzdCh0aGlzLl9jb250ZXh0LCBTT0FIcmlyQmFzZTY0KVxuICAgICAgICA6IG5ldyBCdWZmZXJMaXN0KHRoaXMuX2NvbnRleHQsIFRPQUhyaXJCYXNlNjQpO1xuICB9XG5cbiAgYnVmZmVyTGlzdC5sb2FkKCkudGhlbihcbiAgICAgIGZ1bmN0aW9uKGhyaXJCdWZmZXJMaXN0KSB7XG4gICAgICAgIHRoaXMuX2hvYUNvbnZvbHZlci5zZXRIUklSQnVmZmVyTGlzdChocmlyQnVmZmVyTGlzdCk7XG4gICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nTW9kZSh0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSk7XG4gICAgICAgIHRoaXMuX2lzUmVuZGVyZXJSZWFkeSA9IHRydWU7XG4gICAgICAgIFV0aWxzLmxvZygnSE9BUmVuZGVyZXI6IEhSSVJzIGxvYWRlZCBzdWNjZXNzZnVsbHkuIFJlYWR5LicpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LmJpbmQodGhpcyksXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0hPQVJlbmRlcmVyOiBIUklSIGxvYWRpbmcvZGVjb2RpbmcgZmFpbGVkLic7XG4gICAgICAgIFV0aWxzLnRocm93KGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJlamVjdChlcnJvck1lc3NhZ2UpO1xuICAgICAgfSk7XG59O1xuXG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIGxvYWRzIHRoZSByZXNvdXJjZSBmb3IgdGhlIHJlbmRlcmVyLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuSE9BUmVuZGVyZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgVXRpbHMubG9nKFxuICAgICAgJ0hPQVJlbmRlcmVyOiBJbml0aWFsaXppbmcuLi4gKG1vZGU6ICcgKyB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSArXG4gICAgICAnLCBhbWJpc29uaWMgb3JkZXI6ICcgKyB0aGlzLl9jb25maWcuYW1iaXNvbmljT3JkZXIgKyAnKScpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSh0aGlzLl9pbml0aWFsaXplQ2FsbGJhY2suYmluZCh0aGlzKSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBVdGlscy50aHJvdygnSE9BUmVuZGVyZXI6IEluaXRpYWxpemF0aW9uIGZhaWxlZC4gKCcgKyBlcnJvciArICcpJyk7XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDN4MyBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDMgLSBBIDN4MyByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDMgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDMpIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9ob2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4Myhyb3RhdGlvbk1hdHJpeDMpO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHJvdGF0aW9uIG1hdHJpeCB3aXRoIDR4NCBtYXRyaXguXG4gKiBAcGFyYW0ge051bWJlcltdfSByb3RhdGlvbk1hdHJpeDQgLSBBIDR4NCByb3RhdGlvbiBtYXRyaXguIChjb2x1bW4tbWFqb3IpXG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSb3RhdGlvbk1hdHJpeDQgPSBmdW5jdGlvbihyb3RhdGlvbk1hdHJpeDQpIHtcbiAgaWYgKCF0aGlzLl9pc1JlbmRlcmVyUmVhZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9ob2FSb3RhdG9yLnNldFJvdGF0aW9uTWF0cml4NChyb3RhdGlvbk1hdHJpeDQpO1xufTtcblxuXG4vKipcbiAqIFNldCB0aGUgZGVjb2RpbmcgbW9kZS5cbiAqIEBwYXJhbSB7UmVuZGVyaW5nTW9kZX0gbW9kZSAtIERlY29kaW5nIG1vZGUuXG4gKiAgLSAnYW1iaXNvbmljJzogYWN0aXZhdGVzIHRoZSBhbWJpc29uaWMgZGVjb2RpbmcvYmluYXVybCByZW5kZXJpbmcuXG4gKiAgLSAnYnlwYXNzJzogYnlwYXNzZXMgdGhlIGlucHV0IHN0cmVhbSBkaXJlY3RseSB0byB0aGUgb3V0cHV0LiBObyBhbWJpc29uaWNcbiAqICAgIGRlY29kaW5nIG9yIGVuY29kaW5nLlxuICogIC0gJ29mZic6IGFsbCB0aGUgcHJvY2Vzc2luZyBvZmYgc2F2aW5nIHRoZSBDUFUgcG93ZXIuXG4gKi9cbkhPQVJlbmRlcmVyLnByb3RvdHlwZS5zZXRSZW5kZXJpbmdNb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICBpZiAobW9kZSA9PT0gdGhpcy5fY29uZmlnLnJlbmRlcmluZ01vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIFJlbmRlcmluZ01vZGUuQU1CSVNPTklDOlxuICAgICAgdGhpcy5faG9hQ29udm9sdmVyLmVuYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUmVuZGVyaW5nTW9kZS5CWVBBU1M6XG4gICAgICB0aGlzLl9ob2FDb252b2x2ZXIuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5fYnlwYXNzLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZW5kZXJpbmdNb2RlLk9GRjpcbiAgICAgIHRoaXMuX2hvYUNvbnZvbHZlci5kaXNhYmxlKCk7XG4gICAgICB0aGlzLl9ieXBhc3MuZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIFV0aWxzLmxvZyhcbiAgICAgICAgICAnSE9BUmVuZGVyZXI6IFJlbmRlcmluZyBtb2RlIFwiJyArIG1vZGUgKyAnXCIgaXMgbm90ICcgK1xuICAgICAgICAgICdzdXBwb3J0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jb25maWcucmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIFV0aWxzLmxvZygnSE9BUmVuZGVyZXI6IFJlbmRlcmluZyBtb2RlIGNoYW5nZWQuICgnICsgbW9kZSArICcpJyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSE9BUmVuZGVyZXI7XG5cblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5jb25zdCBPbW5pdG9uZVRPQUhyaXJCYXNlNjQgPSBbXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFEKy93UUE4LzhZQVAzL0NnQUNBQUFBLy84Q0FBWUE4LzhBQVBIL0NnRHYvOTcvZS8reS85UCtVUUR3QUhVQkV3VjcvcFA4UC95MDlic0R3QWZOQkdZSUZmL1krNzM2K2ZQODkwSHY4QUdjQzNUL3Z3WXkrUzcwQUFJQ0EzQUQ0QWFnQncwUjR3M1pFQWNOOFJWWUFWOFE4UDJ6K2tFQ0h3ZEsvaklHMFFOS0FZVUVsZjhJQ2xqN0JnalgrL2Y4ai9sMy81Zi82ZmtLK3h6OEZQMHYvbmovTWYvbi9GY0JQZnZILzFIMytnQlAvSGY4Y2ZpQ0FSLzU0UUJoK1VRQWN2a3pBV0w4VFAxMytpRC9WLzczK3d2OUt2K1kvaHYreFB6Ny9VTDgzLy9hL3ovOUFQNlIvNUwramYyNi9QMytyUDI2L3REOG5QN0IvUHYrV1AxVi9zUDlndjkxLzNQOXhQM0ovbnYvR1A1Uy9zYitJUDh2LzlqL2R2N1UvcHIrNnYrdS9aMy9zdjVjQU9yOVEvODMvK24velA1eC81NysyLy9rL253QS92MDEvL0wrU0FDQi9zRC9GZjgxQUpUK1RnRHAvb2NBbS81ZEFGVCtNZ0QrL3BNQVcvN28veUgveFFEQS9ra0E5UDZMQUwzK3BBQzAvaVFBei81VUFMRCtVd0F0LzNVQWhmNFVBQS8vcHdDKy9qb0F6LzVhQUF2L2Z3RFkvaU1BSWYrdUFQUCtaQUFjLzBRQXkvNHhBQjcvVGdEcy9nb0FEUDh3QUVML053RG8vdWIvVWY5QkFDMy8rdjlGL3k0QVJQOUhBRlAvRVFBMy94TUFUUDgxQUczL0hRQXUvd2dBYVA5RkFDYi85ZjlCL3kwQVVQOHJBRUQvQ3dCVi96NEFXLzhUQUdIL0JRQksveHNBZnY4ZUFGbi9BZ0IzL3p3QWZmOFJBR2ovL3YrRS95QUFiLy8wLzNuL0Z3QnoveGNBaXY4UEFIbi9GUUNKL3hnQWcvL3gvM2ovRVFDYS95Y0FmZi93LzQ3L0h3Q0kvL1gvaXYvNy80My9KUUNNLytuL2tQOEFBSmIvSkFDai8vNy9vUDhaQU1ML1N3Q28vdzRBdHY4dEFNYi9QQUNyL3hjQXdQOUhBTVAvT0FERi95NEEwZjlJQU5ML053Qy8vekVBMGY5TEFNYi9NQUM4L3k0QTNmOUdBTUgvRlFEUS95WUEyLzhzQU1UL0F3RFgveGtBM3Y4U0FNMy85di9jL3c4QTRmOExBTWovOGYvaC94UUEyUDhDQU1uLzgvL2oveFFBMHYvNy85SC8vUC9pL3hFQTB2LzEvOUwvL2Yvai93MEEwZi94LzlmLy92L2svd2dBei8vdS85ei9Bd0RnL3dNQTBQL3YvOS8vQlFEZi8vLy8wdi95LytEL0NBRGMvLzMvMHYvMi8rTC9DZ0RhLy9yLzF2LzUvK1QvQ2dEWS8vai8yZi85LytUL0NBRFkvL2YvM1A4QUFPVC9Cd0RZLy9mLzRQOEVBT1AvQkFEWi8vai80djhHQU9ML0F3RGEvL3IvNWY4SUFPSC9BUURjLy8zLzV2OEpBT0QvL3YvZi8vLy81djhJQU9ELy92L2gvd0lBNS84SEFPRC8vZi9qL3dNQTUvOEdBT0QvL2YvbC93WUE1djhFQU9ELy92L20vd1lBNWY4Q0FPTC8vLy9uL3dZQTVQOEJBT0gvQUFEbC93VUE0Zi8vLytIL0FRRGsvd01BNGYvLy8rVC9BUURtL3dFQTUvLy8vK3IvQUFEdC93QUE3Ly8vLy9QL0FBRDEvLy8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vdi8vL3dBQUFBQUFBQUFBQVFBQUFBQUEvLy85L3dBQUJBRCsvL24vQWdBSkFBQUErdi8rLy9mL0RBQWRBUHYvK3YrbC84TCtqZi80L3ZnQWR3VlBBUUFDTFFCbytRai9FdjdvL04zL1ZnQ2JBMDhCeGYrTCt5bjlKLzJIQ1U4Rm1nQnZEZTMwUnY1aC9MVDA5Z2k1Q3hrQTVnT2k4LzMwa3dFTSs0WUpNZjJuQm1rSkpBUVFCTG9GdHZ2dittNEE3UEY2L1IwQmlmM3FBdWY4V0FSQUFmNEd5QUJHL0JJQXd2cjRBY3Y4VS8vYy95SUM4QUVuL0I4RGFmMkNBZ01CQWYzTUFOMzh2Z0xLL1VUL1F3Q3lBUFlDbFB5dkFXLytwUUFvQVNEK3pQK1IvSVlDMWY3Qy9uRUJRUDk2QVpiKzFRQUlBTS8veVFFNy90a0FaLzdUQVhML3cvOCtBSXNBdHdCNy8yNEE0djlhL3o0QTd2NGlBRGIvZHdDai8yMy9rZ0JPQU5VQUl2OGxBS0VBeFA5Z0FLNy9Cd0NQLzVrQTcvOXYvMHdBenY5REFHVC8zLzl2QUh2LzZQK3EveFVBN1A4WEFPLy91di9nLzJVQUVnQ1Yvd0VBVEFETS8rNy8rLy9qLytELzl2L2kvL2ovSWdEKy94b0F4Zi82L3o0QTUvKzgvOUQvUXdEcS8rMy9PUURUL3pVQUlnQS9BUFAvUGdBakFQRC9Cd0FHQUNBQURBQzMvL2IvSEFBM0FOLy9SZ0ROL3c4QUlBQUNBTi8vR1FCREFDRUFJd0ErQUNvQUpRQWVBUHovS2dBWUFQci9EZ0FFQUJZQUlnQWNBTVQvN2Y4T0FPTC81UC8yLy9MLzlQOEdBUFQvN3YvOC8rNy82di90Ly96L0FnQVVBT0wvL1A4VkFBTUE0LzhJQVBiLytQOE1BQW9BNXY4TkFBc0E5di8vL3dFQUFBRDkvL24vOS84SkFBWUE3di82L3dNQStmOEdBQUVBN2YvNy94Z0FDQUQ0L3c4QS8vLzMvdzBBK2Y4QkFBSUEvUC81L3hJQS8vLzkvL3IvN3YvKy94WUFDUUQvLy9IL0N3RHovd0VBRGdBSEFQUC9GQURuLyszL0FRRDUvL2YvQWdENy93RUFCd0FNQUFFQURRRDgvL24vOGY4T0FQWC9CQUQrLy9YLyt2OFdBQVFBK2Y4Q0FBRUE3LzhRQUFFQS9QOERBQVVBOWY4S0FBd0E5djhEQUFVQStmOE9BQW9BOWYvNy93MEErdjhFQUFnQThQLzYvd29BKy8vOC93a0ErUC8zL3dvQSsvLzgvd2NBOS8vMS93b0FBd0Q1L3djQS9QLzMvdzBBQXdEMy93RUFCQUQyL3drQUJnRDMvd0VBQlFEMy93VUFCUUQzLy92L0J3RDMvd01BQlFEMy8vci9DUUQ3Ly8vL0JRRDYvL24vQ1FEOS8vMy9CQUQ5Ly9qL0J3QUFBUHYvQXdELy8vai9Cd0FCQVBuL0FRQUJBUG4vQlFBQ0FQbi8vLzhEQVByL0F3QURBUHIvL3Y4RUFQdi9BUUFEQVB2Ly9QOEZBUDMvLy84REFQei8rLzhGQVA3Ly9mOENBUDcvKy84RUFQLy8vUDhCQVAvLysvOERBQUVBKy84QUFBRUErLzhDQUFJQSsvLy8vd0lBL2Y4QUFBSUEvUC8rL3dJQS9mOEFBQUlBL2YvOS93TUEvLy8vL3dFQS8vLysvd0lBLy8vLy93QUFBQUQrL3dBQUFBRC8vLy8vQUFELy93QUEvLzhBQVAvL0FBRC8vd0FBXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vLy8rLy8vLy8vOEFBUC8vLy84QUFQLy9BQUFBQVB6Ly9mOElBQU1BOS8vLy93NEFBUUQ2L3d3QTgvLysveThBZnYvMC8ySC9VUDVnQWJIKzJRRzFCMmNBVkFJaC9sMzJGUHlNL25BQ1BRRFYvK1VFby9RNkFRd0N1L29MRDlrRjhRSkEvVXorV2YyS0NPY0Mrd1VLQnNMNWFRQlE5N3J3T1BpUEF2bjVDQWw4QUhFRGtRUGNBQThCbi9sSUFkejdIUUYxK3h6OWNBTTQvOTRFNGdES0F1bitjZ1BZQVlyOUpnSnIvYmYraXZ4ei9Nb0JndjVVQThFQlNnQVFBSjcvVWdFay9jUUI3ZjYzL3NEL3ZmNFhBaFQvQlFGQ0FEWUFuUUdJLzlFQnR2M2hBTEQvdlArYy8zSC9UZ0lOLzFzQnBmOHlBUDMvNGY4cUFCcisxZjhPQUozL2R3QUdBREVCbnY5SkFQei9JUUJ3QUlIL2pnQVMvNHdBc0FDVEFPbi9EUURDQUxuL1pRQ1NBQUlBQXdEMS85Ly9qdjlhQURRQS92OUVBQjBBZmdBOEFBUUFDZ0I5QVByL0lBQVJBUFQvNXY5eEFDQUFCQUFIQUdVQXQvODlBQzRBQ2dBakFNUC8rdi85L3hZQTdmLzEvK0QvN1A4N0FDMEF1djhSQUFjQTkvOEZBQzhBMi8veS94SUFFd0FhQURRQUpBRHAvem9BQWdBZkFCSUEyZi9lL3pVQStQLzYvdzRBOS8vQS96Y0E0Ly9QLy9ULzVmL1IvLy8vRXdEYi93NEE4LzhCQUJrQU5BRGgveEVBK2YvMC93SUFIQURjLy9qL0d3RDEvL2YvR0FEcy8rdi9FQUFBQVB6L0VnRDMvK3IvRmdBTUFBa0FHQUQ5Lyt6L0lRQVFBUEgvR1FEMy8vei9DZ0FmQU9YL0FnRDgvL0gvQkFBVEFPdi8rdi8vL3dJQUJBQWRBT2ovQlFBUEFBY0FBUUFUQU96LzgvOEpBQWtBNmY4VkFPdi8rZjhRQUJVQS92OE9BTzMvK1A4S0FCVUE5ZjhGQVB2LzUvOFRBQTBBN2Y4WEFBa0FBUUFKQUJZQTQvOFdBQWNBQ2dBTkFCRUE3djhFQVA3L0FBRCsvd01BOS8vNy94QUFBUUQ4L3dRQStmLzcvd01BQmdEcS93QUErdi8zL3dZQUNRRDEvLzMvQkFEOS93Z0FEZ0R3Ly9yL0FnRDYvd0VBQ0FEdi8vai9CUUQvLy9YL0J3RHUvL2ovQWdBQ0FQUC9CQUQyLy9uL0JBQUdBUGIvQkFEOC8vMy9CUUFKQVBML0F3RCsvLzMvQkFBSUFQUC8vZjhEQVB6L0FBQUdBUFAvKy84Q0FQNy8vZjhGQVBYLytmOERBQUFBL1A4RUFQZi8rdjhHQUFNQSsvOEVBUHYvKy84R0FBUUErdjhDQVAvLy9QOEVBQVVBK2Y4QUFQLy8vZjhDQUFVQStQLy8vd0VBL3Y4QkFBVUErZi8rL3dJQUFBRC8vd1VBK3YvOS93TUFBUUQ5L3dRQSsvLzkvd01BQWdEOC93TUEvUC85L3dNQUF3RDcvd0VBL3YvKy93SUFBd0Q2L3dFQS8vLysvd0FBQkFENi93QUFBUUQvL3dBQUF3RDcvLy8vQVFBQUFQLy9Bd0Q4Ly83L0FnQUJBUDMvQWdEOS8vNy9BUUFCQVAzL0FRRCsvLzcvQUFBQ0FQei9BQUQrLy8vLy8vOEJBUDMvQUFELy93QUEvLzhCQVA3L0FBRC8vd0FBL3Y4QUFQNy9BQUQvL3dBQS8vOEFBUC8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFELy8vLy8vUC85Ly8zLy8vLy8vd0FBQUFBQUFBSUFBZ0FDQVAvL0NBQUVBRUVBLy8rY0FBVUFiLzhIQUFIOStQOWVBUmtBb2dRVUFKbjhCd0NkL2dYLytRUU5BS29DOWdGZEF0Yi9iL3ZkLzkzNlRQLzZBc0QvbmZxbi91bjFXLzBkQThJRXNRTHZBSnYyYlA3MitXTUFrUDhkQWNYK25RTzJBSXI2YlAvRUFCWCtOZ0svQmRqMklRdjJBRTRFVUFpRC94UUFud0ltL0IwQi93R05Bb0g3c1FhUC9iOENpUWFrQXFEK1IvOXhBNDc3S1FMLy82cjc1di9PL3BjQ2dRQ3RBaU1DQlFBa0FOQUFSd0hmLy8zOWhnQmwva1VBSmdFdEFVRUFUZ0EvQWdvQVNBREsvelVBSnYyOS92TCtsLzljLzBjQVV3QkJBRThBNlFFNS84Ny9XdjlOQU9mKzV2N1AvNVAvNC85QkFLWUFRd0REL3pZQjV2K3IvellBVHdBcC8xdi9XUUFFQUIwQWh3QTBBQTBBSUFBM0FBRUF6di91LysvLzV2OW0vendBSUFEUS84VC9TQUJpQU5iL1N3QWJBRmYvTVFEWC83TC9oUDhUQVByL0FnQU1BQXNBSHdBWkFJMy9WZ0RDLzl2LzUvL3gvNlAvQXdCbEFNdi95ZjgyQUI0QStQOVdBUGovTndEaS8xRUEwdjlKQU5qL0p3QWNBQUVBREFCWUFOai80ZjhNQUV3QW1QODJBTi8vM1A4VUFEWUE3Ly82L3dJQUNBRFUveWdBeXY4MkFONy85di8yL3lnQXh2LzkvKzMvNS8vbi96VUE2Ly9nL3k0QURnRDUvd3NBQndEdi94SUFEd0FHQUNvQUpRRDMveklBKy84RkFCc0FGZ0RPL3pBQUhBQUlBQlFBTEFEcC94Y0FDQUFBQVBIL0dBRHMvd2tBQ1FBRkFBZ0FGUURwL3dJQUhBRDEvL1AvRVFEdy8rMy9HQUQ5LytmL0hBRDgvL1QvREFBUUFQSC9Id0Q0Ly9yL0R3QVBBT2ovRVFBQ0FPbi9EQUFYQU9YL0JBQU9BTkgvOS84TUFPLy85ZjhMQU5ULzlmOEVBTy8vNmY4TkFOYi8rUDhLQU96LzV2OE1BT0QvN2Y4VUFPLy83Ly8rLy83Lzl2OFlBUGovOWYvei93c0ErdjhTQVBELyt2L3gveFlBK2Y4U0FQYi85Ly8zL3hFQUJRQUNBUG4vOS8veS94UUFDUUQvLy9iLy92LzcveElBQ1FEOS8vSC9BQUQ3L3hFQUFnRDUvL1AvQXdEOS93OEFBZ0QzLy9EL0JBRC8vd1VBL3YvMC8vRC9CZ0FEQUFNQS9QLzIvL2YvQndBR0FQNy8rLy8yLy9qL0NBQUZBUHYvK2YvNS8vdi9Cd0FIQVBuLzkvLzcvLzcvQlFBRkFQZi85Ly8rL3dFQUJBQUNBUGYvK1A4QkFBSUFBZ0FBQVBqLzkvOENBQU1BQUFEKy8vbi8rZjhFQUFRQS92LzgvL3IvKy84RUFBTUEvUC83Ly96Ly9QOEVBQUlBL1AvNS8vNy8vdjhEQUFFQSsvLzUvLy8vLy84Q0FBQUErLy81L3dFQUFBQUJBUC8vKy8vNi93SUFBUUQvLy8zLy9QLzcvd01BQVFELy8vMy8vZi85L3dJQUFRRDkvLzMvL3YvOS93TUFBUUQ5Ly96L0FBRC8vd0VBQUFEOS8vei9BQUFBQUFBQS8vLzkvLzMvQUFELy93QUEvdi8vLy83L0FBRC8vd0FBLy8vLy8vLy9BQUQvL3dBQS8vOEFBUC8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFEKy8vLy8rZi8vLy92Ly92Ly8vd0FBLy8vLy93VUFBUUFJQUFJQUJ3QUNBSGtBVEFBT0FhTUFBZjlDLzlYNlF2d2hBckFBdGdoQUJXMzdudi95KzB3QVdRTmNBRThKUndTT0M2QUVKZThQOFMvenJQV2FCSS8rTFFBLyswTCtQLzRLOEFnQWIvOHVDaDc4QlF0QzYxNEdhUVdmQWluNVVmek44VGYrR1FpekFaNE1DUU1iR0o0Qm9SUzdBdmNIeVFBUkE2bjlad0haL3o0RHZ3QVpBbEFCNmdiTkFTNEdGQURGQVRMN0UvMksrajM3Qy94cC9TRDlVdjBWQU9zRHMvL1dBZDMrYnY3Ri9mNzltUDJYL0tIK0Z3QzAvMW4rVmdGY0FUQUJIUUdhQUVUK25mOFkvaG9Bb3ZwcUFYajlDUUtXL2xzQ2wvNFJBcGorYkFIay9SY0FsdjRCQUcvK0RnRGkvLzMvR3dBT0FFSUFxLyt5LzN6Lzh2OCsvN1QvVHY4Ly8yNy9tZ0RaLzFzQStQK2NBQUFBL1AvaS95TUFpLzg1QU1QL0tnRE0vOU1BOVArUUFCb0E0UUFpQUN3QUN3QmRBUDcvVFFEYi95MEF5ZitTQUEwQVp3RGcvNHdBKy84L0FBTUFnUURwL3cwQURBQVFBQW9BTmdBZ0FBNEFLQUJJQUI0QTR2LzMvK2YvK3YvYy8rbi9FQURuL3dnQUZBQXFBT3ovSXdEYy85Ly8zZjhYQU5ELzJ2L2EvdzBBNXY4QkFOYi85UC9tL3dBQThQOFpBTjMvUndBR0FFc0FCZ0IvQVA3L05BQVNBRWdBQkFBM0FQMy9LZ0Q5LzFzQThQOGxBT3IvRmdEMS94QUE0LzhrQU92L0F3RDQveEVBNWY4TkFQVC8rdi8zL3g4QTdmOFBBUGovSXdENS95QUE5LzhaQUFFQUdnRDQveG9BOWY4SEFBTUFDQUQwL3hnQStQOEFBUHIvSVFEcC93NEE4djhIQVBYL0lnRDEvd1lBK1A4R0FQWC9HZ0QzL3dvQUJRQVNBQWNBR1FEdy8rdi85UDhiQVAzL0hBRHMvK2YvNy84TEFQci8vdi8wLy9UL0FnRDIvd3NBNlAvLy8rUC9DQURZLy83LzV2LzMvd1FBL3Y4TEFQRC9HZ0QxL3lNQS9QOFFBT3YvTEFEdy95UUErUDhYQU83L01RRDkveUVBQVFBY0FQRC9JZ0Q5L3hNQSsvOE9BTy8vRlFBQkFBb0ErLzhQQVBQL0ZRQUJBQVFBOS84UEFQWC9DQUFEQUFFQStQOE5BUHYvQ0FBR0FBVUE5LzhKQVAvL0FBQUZBUHovK2Y4SEFBUUEvZjhGQVAzLy9QOEZBQVlBK1A4REFQNy8rLzhBQUFjQTkvOEJBUC8vL2YvLy93Z0E5Ly8rL3dBQS92Lzgvd1VBOS8vOC93SUEvLy83L3dVQSt2Lzcvd0lBQUFENi93TUEvUC82L3dFQUFRRDYvd0VBL3YvNy93SUFBZ0Q2Ly8vL0FBRDcvd0VBQWdENy8vNy9BUUQ4L3dBQUF3RDgvLzMvQXdEOS93QUFBZ0Q5Ly96L0F3RC8vLy8vQWdEKy8vei9Bd0FBQVA3L0FRRC8vLzMvQWdBQkFQMy9BQUFBQVAzL0FnQUNBUHovLy84QkFQMy9BUUFDQVAzLy92OEJBUDcvQUFBQkFQMy8vdjhDQVA3Ly8vOEJBUDcvL2Y4Q0FQLy8vLzhBQUFBQS92OENBQUFBQUFBQUFBQUEvdjhCQUFBQUFBRC8vd0FBLy84QUFQLy9BQUQvL3dBQS8vOEFBUC8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFBQUFQLy9BQUQvL3dBQS8vOEFBQUFBLy8vLy93QUFBUUQrLy8vL0FBQUdBUDMvT0FBQkFJSUFBd0J2Ly9mL0UvMFFBSzBBRFFDekEvNy84UDR1LzBjQkRRQ0pBNkFCYlFEZy93Ny96LzlvK1ZuL1NQbkwvMS8vRWYrMitqcjlSZlpnQTVRRlp3SUxERmorUEFiMi9uRUZLZ0trL1IwRGx2NmIvRlVEc1A2WUFvajlTZ0FUL2lML3RBUHdBdjhBMFA2ekFyNy9kd0FuQWYzOXVQMjIvc2tBMnYvLy8yWUNvUDRVQVVzQVpnRjJBSkgrNFA3MC9yejkrZitVL1h2Lzh2N0NBY2IrVEFDUy9rd0F2Lyt4L3RYOW9QNzEvb0wvMWY4bkFFVUFad0d0QUFnQUlnQy9BRDRCYVA4R0FHSC9kUURGLzY0QXJmOG5BYWtBaEFIOS8ra0FRUUQzQUZiL3EvOHAveUlBUi84RkFQRC9aQUEvQUlZQTN2OHRBRFFBRFFCcC8zZi9Dd0FCQVAzL1dmOE9BTmovV3dESC94b0FlLzhEQUt6L3p2OTYvejhBM2YvSi81WC9JQUQ1Ly9qL3EvL2MvKy8vUkFEcS8vRC92djhwQURVQUZRREkveThBQ0FBYkFOYi9Pd0QzLyszLzlmL2Uvd2NBSUFBZUFNSC84Lzh4QUMwQUVBRFcvKzMvSEFBREFQdi84UDhEQU9ML093RDMveGNBQ1FBSEFNLy81ZjhYQUFjQXovL1QvOUQvSGdEOS8vLy95Zi9lLy92L0FnRC8vOUgvNi8vLy8vSC8rLzhoQUFJQTkvLzcvdzBBRmdBUUFQTC8ydi84L3hzQUdRQUJBTnovOVA4WUFBUUEvdi95L3dNQTV2OFlBQWtBQUFBQUFBTUE3LzhLQUJnQUR3RHMvL2ovQndBVEFCc0E4UC8xLy96L0JBQU1BQUFBOVAvcy94QUEvdjhHQUFrQS92L3Avd01BQ3dBTEFQNy85UC9wL3djQURRQUZBUGIvNy8vNC93MEFDQUQ4Ly9iLy92LzEvd01BQ3dEMS8vVC84UC84L3dBQUNRRHovK2YvNVA4R0FBa0FCUUQ1Ly9ELyt2OEZBQTBBQXdELy8vVC9BZ0FDQUJBQS92OENBUEQvKy84RkFBb0E5Zi8zLy9mLy92OEdBUDcvOXYvdC8vei8rZjhBQVBqLyt2LzMvd0VBK3Y4SEFQci8vUC81L3dRQS8vOERBUHIvK1AvMy93WUEvLy8rLy9YLysvLzUvd1FBL2YvNy8vWC8rLy80L3dNQS9mLzgvL2ovL3YvOS93WUEvLy84Ly9mL0FnQUFBQVVBL2YvNi8vbi9Bd0FDQUFJQS9mLzcvL3ovQXdBQ0FBQUEvZi82Ly8zL0FnQURBUDcvL2YvNy93QUFBd0FGQVB6Ly8vLzgvd01BQWdBRUFQdi8vdi8rL3dNQUFnQURBUHYvL3YvLy93TUFBUUFCQVB2Ly9mOEFBQUlBQUFELy8vdi8vZjhCQUFJQS8vLysvL3ovL3Y4Q0FBSUEvdi85Ly8zLy8vOENBQUVBL3YvOS8vNy9BQUFDQUFBQS92LzkvLy8vQUFBQkFBQUEvZi85L3dBQUFRQUJBUC8vL2YvKy93RUFBUUFBQVAvLy92Lysvd0VBQVFELy8vNy8vdi8vL3dFQUFRRC8vLzcvL3YvLy93RUFBQUQrLy83Ly8vOEFBQUFBQUFEKy8vNy8vLzhBQUFBQS8vLysvLzcvLy84QUFBQUEvLy8vLy8vL0FBQUFBUC8vLy8vLy8vLy8vLzhBQVAvLy8vLy8vLy8vXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFBQUFBQUFBQUFCQUFBQUFBRC8vLy8vLy8vLy8vLy8vdi8vLy8zLy8vLy8vLy8vKy8vOC8vLy9BUUQ5Ly96LzlmOEJBQUlBK2Y4ZEFDZ0FXUUJ4QUpYL3F2K1kvdXo5YVA5ay83VURVUVFCQWlRQTRQZ2kvQWtCMGdLYUJzRC8rZnhwL3Z6OUNRU3AvSS8reXdETyt2TUQwZnpLL1BBQmNnQmVCZm9Cdi8rdUF1SDlTZjVnQXkzOWF3TW1CV1VCdVA5ZkE5LzlmZ0RqLzIvK0VBQ2FBQ2NDU3Y5Wi8yai9ydjdoQUEwQVdmNTUvN0w4NFA3RS9TSUFULzY3QU12L3RmK0ZBQTcvMXYrNy9ndi9JUCtFL3NRQStQNWFBWHovdFA5WEFGWC90UDhvLzRyL2ovL2UveVFBTXY5bUFKVC9yZ0NyLzlYL0V3Q2IvL0gvOWY3Ri82RC9FQUFvQUszLy92K2UvenNBaC8rQi83ci9pZi9DLzJyLzRQL3ovNi8vSHdDeS8wSUE3LzlaQUxUL3kvODBBQ2dBOXYvSi85Ly9EZ0E1QURVQUxRQVJBRElBQ3dBZkFPZi9OZ0FyQUNNQUNRQkJBRWNBR0FBakFDNEFXUUJVQUhjQUFBQWZBQ0VBSUFBY0FQai9DQURrL3lRQTd2ODlBRUVBRndENS94WUE2ZjhhQU9YL0FBREYvelFBRHdBVUFPVC9CUURyL3lVQTZQOFhBT2YvSEFEUi8wQUE4UDhuQUFnQUNRRHQveWNBS0FBSEFQSC9JUUR6L3hzQUNBRG4vL24vRGdBREFBNEE4UC8vLzh6L0dnRE4veU1BL2Y4UUFOai9Nd0FDQUMwQUN3QU9BTzMvSmdBWkFBVUFDZ0FBQUE0QUlnQWFBQWtBRHdBQ0FBQUFIUUFUQUFVQUJRQUNBQWdBQ3dBakFPLy8vLzhBQUE4QUJRQVBBUEwvL2Y4R0FBc0FCZ0FHQVBELzh2OEdBUHovQ0FENi8vSC82djhQQUFnQUJnRDQvLzMvOXY4YUFBZ0FCd0QxLy83Ly92OFFBQW9BQ0FELy93VUE5djhRQUFvQUJBQUZBQWdBQWdBSkFBb0FBd0QvL3cwQUFnRC8vd2NBL3Y4REFBb0FCUUFGQUJVQUJBQUtBQVlBQndBSEFBOEFDZ0FHQUF3QUR3QU1BQWtBRUFBSkFBZ0FEd0FNQUFnQURnQUpBQVVBQ1FBUEFBVUFDd0FIQUFFQUJnQUlBQUVBQkFBR0FQLy9BZ0FKQUFBQUFnQUVBUDcvLy84SUFBSUEvLzhHQUFFQUFRQUpBQUlBL3Y4RUFBTUEvLzhKQUFFQS92OERBQU1BL3Y4SEFBTUEvZjhCQUFVQS92OEZBQU1BL3Y4QkFBY0EvLzhEQUFNQS92OEJBQVlBLy84Q0FBTUEvLy8vL3djQUFBQUFBQU1BQUFELy93WUFBUUQrL3dNQUFRRC8vd1VBQVFEKy93SUFBZ0QvL3dRQUFnRCsvd0VBQXdELy93TUFBd0QrL3dFQUF3RC8vd0lBQXdELy93RUFCQUFBQUFFQUJBRC8vd0FBQkFBQkFBQUFBd0FBQUFBQUJBQUJBUC8vQXdBQkFBQUFBd0FDQVAvL0FnQUNBQUFBQXdBQ0FQLy9BZ0FDQUFBQUFnQUNBQUFBQVFBREFBQUFBUUFDQUFBQUFRQURBQUFBQVFBQ0FBQUFBQUFDQUFFQUFBQUNBQUVBQUFBQ0FBRUFBQUFCQUFFQUFBQUJBQUVBQUFBQkFBRUFBQUFCQUFFQUFBQUJBQUVBQUFBQkFBRUFBQUFBQUFBQUFBQUFBQUFBXCIsXG5cIlVrbEdSaVFFQUFCWFFWWkZabTEwSUJBQUFBQUJBQUlBZ0xzQUFBRHVBZ0FFQUJBQVpHRjBZUUFFQUFBQUFQLy9BQUQvL3dBQS8vOEFBQUFBLy84QUFQLy9BQUFDQUFBQStmOEJBQVlBLy8vNC93SUEvLzhBQUE4QS92L1Yvd0VBRXdBOUFBRUJSd0EyQUY3L2tmb2cvM2dCd3Y5OUNEWUJVL3F0QVVYL0FQN09BZmtBWC9vOUIzOEZTZndhQXVUMTQvNjBCQXI4Q1FBSS90ZnlJUVR6QVhQK2VnZFVCQndCb2Y3VEJNVDhiQVdpLzVFRVd3QlJBQUFLeWZ4RS84Yjg4dnA2QUNQK1BBRjQvcUQ4TVFOTS95Z0NKLzJYQVBEOWtQNWdBVlQvaVA5SS9sRUI0UDhxQUQwQkZBR2EvKzcvRGdCMkFPUDk4Z0ZtL3UvK1Z2NS9BRzhBU1A5Z0FNLy9xdjl3Ly9vQWN2KzIvaklCSGdBNy82RC9vQUFHQUtIL2xBRFQvd0FBZ2dDOEFBWUFrUDl5QUVjQWtmOEJBT0QvUkFBci96VUFOd0R0L3hRQUpRQWtBTVQvendBL0FPSC94djl6QUdzQU5RQlRBSWNBTEFBdkFDSUFUQUN5L3hNQURBRGcveGNBV0FCdkFKTC83ZjlWQVBiL0VnRHQvd2NBNGY4a0FQUC81UCtoL3dnQUNRRHkvL3IvTGdBUUFNbi84LzlDQU9YLzV2L1MvOS8vM1A4cEFCWUF1UC9zL3c4QUZnRHQvKzMvN3Yvdy85ai81LzhHQU9mLzJQLzIvL1AvL3Y4a0FCTUF1Zi9tL3hvQURBRFovK3IvM1A4S0FBVUFLd0RlL3dzQTNQOFZBQUFBRGdBZkFCMEFDQUFNQUY0QUdnQWhBUEwvTXdEei8wa0FCQUFLQVBYL0x3QWJBQWtBOXYvcy8rMy84LzhDQUJBQUFBRG0vL24vQlFBTEFBVUFBUURqLy9uL0pRQVZBUFgvOXYvKy93SUFFUUFCQVBQLzhQLzEvd0FBQmdENi8rMy83Ly9vLy9qL0RBRDgvK2IvOFA4SUFBa0FCZ0Q0Ly9ELzhQOFVBQW9BQXdENC93QUErZjhPQUFjQUFBQUZBUFgvOXY4VEFBa0E4djhFQVBiLzkvOGRBQTBBNy84Q0FQbi8rZjhTQUFRQTgvOENBT2YvK3Y4REFBZ0E5UC8vLy9ILy9QOElBQVVBOC8vMC93SUFBUUFHQUFnQTkvLzcvd0FBKy84RUFQLy8rUC8rLy8vL0FnQUNBQXNBOHYvKy93SUFCUUQ3L3dnQTl2Lzcvd01BQkFENS93QUEvUC8zL3dFQUFRRDcvLzcvL1AvMS93UUEvLy8zLy9yLy8vLzMvd01BQXdEMS8vci9Bd0Q2Ly8vL0FnRDQvL24vQXdEOC8vNy9BZ0Q0Ly9uL0F3RCsvLzMvQVFENC8vbi9CUUQvLy9uL0FBRDYvL2ovQkFBQkFQai9BQUQ5Ly92L0F3QURBUGovL3YvKy8vei9Bd0FFQVBqLy92OEJBUDcvQVFBREFQai8vZjhDQVAvLy8vOEVBUHIvL1A4REFBQUEvdjhDQVB2Ly9QOERBQUVBL2Y4QkFQMy8vZjhEQUFJQS9QOEFBUDcvL2Y4REFBSUEvUC8vL3dBQS9mOEJBQUlBKy8vKy93RUEvLzhBQUFFQSsvLysvd0VBLy8vLy93RUEvUC8rL3dFQS8vLysvd0FBL2YvOS93RUFBQUQ5L3dBQS9mLysvd0VBQVFEOC8vLy8vdi8rL3dBQUFRRDgvLy8vLy8vLy8vLy9BUUQ5Ly8vL0FBRC8vLy8vQUFEKy8vLy9BQUFBQVAvL0FBRC8vLy8vLy84QUFQLy9BQUQvL3dBQS8vOEFBUC8vXCIsXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9tbml0b25lVE9BSHJpckJhc2U2NDtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmNvbnN0IE9tbml0b25lU09BSHJpckJhc2U2NCA9IFtcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQrL3dRQTgvOFpBUHIvREFEKy93TUEvdjhLQUFRQS9mOERBQU1BQkFEcy8vei84di96LzhmL1IvOTAvb2IrLy96QUFXc0RBd1kzREtuOS8vdHU5M0R2a3dJNkFuNEN1d0owL0JIN1ZQdXg5MlgwR3U3Ti9FWDltZ2ZxQ2trSWlSTWdCZDROUVFHTC9jMEcveEJ4QUtFTFpBVFVBL3NJSFJTeCtma0N5QVVtQk5FSklBUmxBZEh6MkFqTkFDY0lzQVc0QWxFQ3N2dEovUC83Sy90ZisrbjhhUDRXK2cwRlhBRWxBTW44blFIbi9zVCtadjdOKzlYMnh2ek0vTzMrRXZwcUJCRDdTUUxkK3ZiL3NQbHcvSkQ3Mi8zbitScitML3dTL3Z6NlVRR2cvTmYrQXY1TC81WDlHdjIvL1NQK21mM2ovbGYrdi8yQi9aSC81UDA1L2lMOU1QOUYvdWY5VVA0di9xdjltdjdvL1huK3dQMmsvOEwrdVA1Si90RCtEdi9ZL2JMK21QNzIvbjMrcFArNy9oQUErLzV6QUdIK1ovK3UvZzhBenYyeS82TCsvLzlvL2lJQURQOFZBQ3ovQ3dDTi9wYi8xdjR5QUZQK3dmKzQvanNBY2Y1VkFQMytiQURhL25NQTZmNHNBT1QrSVFCZC92Ny83djZhQUlMK1FBRGUvbkVBMFA0eUFLeitDUUNvL21vQXVmNXhBTjcrbUFDOC9qY0FOZjllQVBYK0lBQTEvMWtBQVA5aEFNeitQUUQ1L20wQTIvNGdBUHIrVVFEaC9qUUFFdjlCQVBIK0ZBQk4vemtBU3Y5REFEUC9CQUJlLzFJQUdmOG9BRTMvUlFBdy96SUFRZjhtQURuL0dnQkUveElBUi84aEFENy9CQUJ5L3pFQUtQLzAvMDcvR3dCWC96NEFSZjhtQUZyL1FRQlYvelVBVlA4ZUFGei9KQUJ0LzBFQVVQOE1BSHovS2dCci95Y0FZdjhFQUgzL01BQmwveDhBZ3Y4YkFJai9HZ0J2Ly96L2ZmOEFBSlgvSUFCdS8rVC9qdi9yLzR6LzkvOW4vNzcvcFA4SkFKRC9FUUNKLy9yL3EvOFdBSi8vR1FDVS94WUF0djhxQUtyL1BRQ1cveXNBd2Y4K0FMYi9PZ0MzL3lnQXovOHVBTTcvT2dESC95Z0F6LzhrQU16L09nQy8veHNBMWY4cUFNbi9Md0ROL3hjQTFmOG9BTXYvSlFEUi94TUF6ZjhiQU0vL0hnRFUvd1VBMnY4WkFOTC9Fd0RXL3dFQTFmOFpBTXovQndEWC93SUEwdjhTQU5UL0JRRFcvd01BMC84UEFOVC9BQURZL3dJQTFmOE1BTlgvK2YvYS93VUEwdjhJQU5mLysvL1kvd1VBMC84REFOci8rZi9ZL3dRQTF2OEJBTnIvK2YvWi93VUExLy84Lzl6Lyt2L1kvd1lBMmYvOC85My8vdi9ZL3dVQTJ2LzkvOTMvLy8vWi93VUEzUC84Lzk3L0FnRGEvd01BM3YvOC85Ny9Bd0RiL3dJQTMvLzkvOTcvQkFEZC93RUE0Zi8vLzkvL0JRRGYvd0FBNHY4QUFOLy9CUURmL3dBQTQvOENBTi8vQkFEaC93QUE0LzhEQU9EL0JBRGkvLy8vNC84REFPSC9Bd0RrL3dBQTVQOEZBT0wvQWdEbC93RUE1UDhGQU9ML0FRRGwvd0VBNC84RUFPTC9BUURqL3dJQTRQOERBTi8vQUFEZy93SUEzdjhDQU9EL0FBRGgvd0VBNHY4QUFPUC9BQURtL3dBQTZQOEFBT3ovQUFEdS93QUFcIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy9mLysvLzcvLy84QUFQLy8vLzhCQUFFQS9mOEFBQUVBQVFBRkFBVUE5Ly82L3gwQTJmLzkveE1BM1ArakFFLy9vZjlIQUtQLy9nQ2ovNzcvWi92aS8yOEQ5L3l3REpBSkl2cjZBc1gwWGVjNEJoY0d6ZjIzRFpQN3lmWjZDMS8vbndCREJJSHlZZ29iL1RmM3NRNDFBTm9LUkEvQStFN3lmZkFhOWdENUVRVUJETXdNeWdpcUFITUFxUHFoQUdVQjIvZ0UrYTc4SC8rNEFQVDZEd0lVQUEwSE53TWhCZkw4RS85MEE1bjdkUDljQUxJQyt2NUMvcTBBT3Y5a0FvZ0JIdjAxLyszL3FBUUQvdWI4VC80dkFPVUE1UDZLQVR2K3l3RVlBZVQrS1A2aS8zZ0NGUDZoL2hyLytQODNBQ0wvVkFEbi84VUFSUUpJLzRNQXUvOHFBbGord2Y0aUFQYi9MZ0ZKLzhRQVVBQkFBSTRBQmYray8zWC9ZZ0ZLL2lqL2ovOUhBRG9BaS8rV0FBMEJWd0MvQUNML0xBQ2UvL2NBUnY5aS94Z0FVZ0EwQUNqL0ZnQmdBSWovNVA5TS83ei96djgvQUt6L2d2OHNBRVFBNi8rSS95WUFhd0RMLzdUL3hmOHFBT3YvRlFDdS81bi9FZ0F5QU8zL2kvOUxBRTRBKy8vUi8vUC9GZ0RlLzh6L3UvOERBRElBTEFBWkFMTC9UQUE4QUJ3QW8vLzEveHdBL1AvTC96MEE2UDhqQU43Lzd2K2EvekFBd2YvNy8zLy9LUUF1QUN3QTl2OFJBR1lBSXdCTkFEZ0FLZ0FTQUYwQURnQU5BQ0VBTVFESC8vSC9MUUFDQUIwQXkvLy8veDBBUEFBQkFBUUEydjhpQUFjQUVnREUvK3YvRlFEKy8rUC9EQUQxLzk3LzZ2LzQvL1gvRXdENC8rNy81UDhjQUEwQUNRREgvLzcvQ1FBWEFBRUEvUC81Ly9qL0N3QVdBQUVBQlFEOS8vbi9BUUFXQUIwQTd2L2svd0FBQ1FBbUFQLy85LzhBQVBuLzgvOGFBTy8vNi84ZkFPdi81djhoQVAvLzUvOFBBT2YvQUFBR0FQbi82djhKQUFZQUJnQUJBT3YvMS8vMS8vTC8rUDhEQUJjQTZmLzgvd01BQ2dENy94QUEzdi8yLy96L0RBRHUvL3ovNXYvNS93RUEvUC82Ly83Lzd2L3gvd1FBQmdENS93QUE4di93L3drQUVRRDIvL2ovK3Y4RUFBY0FFQUQzLy92Lyt2OENBQUFBQ1FEMy8vdi8vdi85L3dVQURBRDIvL1gvQWdBSEFBQUFCd0QyLy9UL0JnQUtBUDcvQVFENC8vci9CQUFJQVBuL0FBRDMvL2YvQlFBSEFQdi8vdi83Ly9uL0JRQUpBUGovK3YvOS8vNy9BZ0FHQVBqLytmOEJBQUVBQWdBRkFQbi8rdjhCQUFJQUFBQUVBUG4vK2Y4Q0FBUUEvdjhCQVByLyt2OENBQVFBL1AvLy8vdi8vUDhDQUFRQSsvLysvLzMvL2Y4Q0FBVUErdi85Ly8vLy8vOEFBQVFBK3YvOC8vLy9BQUQvL3dJQSsvLzgvd0FBQVFEKy93RUErLy84L3dBQUFnRDkvLy8vL1AvOS93RUFBZ0Q4Ly83Ly9mLzkvd0FBQWdEOC8vMy8vdi8rLy8vL0FRRDgvL3ovLy8vLy8vLy9BQUQ4Ly8zLy8vOEFBUDcvQUFEOS8vNy8vLzhBQVA3Ly8vLysvLy8vLy84QUFQNy8vLy8rLy8vLy8vLy8vLy8vLy8vLy8vLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy92OEFBUC8vLy8vLy93QUFBQUFBQVA3L0FRQUJBQUFBQndELy8vWC9CUUFqQVBML0NRRGIvOUQvR0FBYi83c0FZd0NXL3owQmNQL1gvN1QvMlFEVyt3SDh5QU5DQ0NVSjVRVCsrVVhtaFB3aEE3OEZ1QXhIK3A3OGlmdWRCbEFHOXZtdS9sQUsyZmRsQi8vL2Nmam9DYTBFN0FrbjlZYi96dmJhK0FrQUhQeXdCR0VCRndVTkFMOEFYQUFHQTIwREZ2bVIva3orRi8wNkFnLytHd0hsLzVFRUtnSmQvcTBBUC95bS85bjZFZnhZLzJIKy9RRnRBQzRDNlFCREFhTUNvLzIwLyszLzNmL3AvZkw5cnY5Vi82Y0JoUUh1QVg0QWN3SllBYUgvSVAvUC9nc0FwUDBMQWU3L3NRQnVBSTBBQWdHREFFNEJ6QUNlLzVYLy92K3YvK2YrWmYrZ0FPdi81UUJoQU9JQXBBQU5BU1lBdVAraC84Yi9IUUJyLzkvL2JBQ1dBR0VBRkFCNUFEMEFXUURVLytEL1lmL3AvL0Qvcy8rUi80UUFNUUJ2QUJFQWtRQmZBQlFBSmdEVy93d0E4LzhYQUx6L3ZmOHpBRkFBS3dEMS96RUFQd0RKL3gwQTcvOExBT1gvRndEUi8vSC9FUUFkQU8vLzZQOFFBRkVBMmY4V0FCRUFNZ0R5L3hJQStmL3MveEFBTGdEdi8vLy9IUUF2QVBULytmOGlBQVlBRWdBRkFCb0FHZ0QvL3cwQStmLzAveHNBSGdEeC85Zi9HQUFDQVBILzhmOEpBUGYvR3dBTEFCRUE3LzhjQVBUL0NnRDIvL2ovQlFEOC8rMy9PZ0FnQUFZQTlmOFBBTjcvRGdEOS85ci8xLy8zLyszLzkvLzEvL2IvOC8vNS8vZi9BZ0FKQU9mLyt2OE9BQU1BQ3dEOS8rNy81ZjhlQUFFQTkvL3EvLzcvOFA4V0FQNy8rLy80L3dJQStmOFRBQUlBOWYvNS93Y0ErUDhpQUFnQTl2L24veG9BLy84Z0FBVUFCd0RqL3dBQTl2OEJBQVVBRlFEbi93TUE3djhRQUJBQUVRRG0vd3dBOGY4YUFBQUFCd0R1L3djQUNnQVNBQUVBNy8vdy8vZi9CZ0FSQUFrQTZQLzMvd2NBRGdBS0FBWUE0Zi80L3dZQURnQUFBUHIvOFAvOS94UUFDZ0FIQVBuLzcvLzkveEVBQWdEKy8vTC84di84L3hVQUF3RHcvL0gvOWY4Q0FBc0Evdi9xLy9MLytmOEZBQVlBL1Avci8vai8vLzhHQUFrQSsvL28vL2ovQVFBSUFQLy8rdi9vLy92L0NBQUlBUHYvK1Avdy93RUFDUUFIQVBqLytmLzAvd0lBQ3dBRkFQYi8rZi80L3dRQUN3QUNBUFAvK2YvKy93WUFDQUQvLy9MLysvOEJBQVlBQlFEOS8vUC8vUDhGQUFVQUFnRDcvL1QvL2Y4SEFBUUEvLy83Ly9mLy8vOElBQU1BL1AvNi8vci9BUUFJQUFFQSt2LzYvLzMvQWdBSEFBQUErZi83L3dBQUF3QUZBUDcvK1AvOC93SUFBZ0FDQVAzLytmLzkvd01BQXdBQUFQei8rdi8rL3dRQUFnRCsvL3ovKy84QUFBUUFBUUQ4Ly96Ly9mOEJBQVFBQUFENy8vMy8vLzhCQUFNQS8vLzcvLzMvQUFBQ0FBRUEvdi83Ly83L0FRQUJBQUFBL3YvOS8vLy9BUUFBQVAvLy92LysvLy8vQUFELy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQvLy8vLy8vLysvLy8vLy84QUFBQUEvdi8rL3dBQUFRRDgvLzMvQ1FBSkFQMy8rdjhQQUFjQXBBQmxBQmtCa3dDTy9pLy9sZnFhL0hRQWNmLzNCZGtDendKY0JDTUMwd01OLzkvOXdnSTdBYUVDWWZ4Vi9UZjgzdmhuL3hydDhPd3gvOG43Y2dIQUJZYjQzUWNaRGg0V3VnTnJBN1A3NGdIdS85ei96djB0L2FjQ2lRSFkvaXY0cVFPbC95c0NFLzAvL1hUOVNmNE8vL2o5eGZ1cEFuMzk0Z0hPK3JzQ1hBRklBeFFDOXdJWEJnY0QyQVF1QW5iLzlnSmgvNndBVmZ4RUFJNEJ2ZjdvQUZ2L2JBTHNBTVFCZS84OC9qb0FULzRkQUgzOS92OUxBWG4vZ3dESS8vUUJkQUJjQUEwQTdmNGxBTW4vLy8rOS90di9pQUJwLzEzL3BQL2RBTHYvdy84TUFIdi8vZit5LzYvLy8vN1UvNUFBWlArWi84ci9uUURSLzVyL0R3RHIveEFBNHYrcy8zei8rUDl1QU92L3QvODJBR2NBSGdDYi95UUFGUUJHQU03L0NnRDMveG9BZWdBYUFPei9DZ0JIQUE4QWR2OC9BQUFBQlFDMi94SUFBQUE3QUJRQUtnQ2ovejRBQVFBWEFKei9KQUFEQUFjQThmLzEvMkFBQVFBbEFQRC9OZ0R4LzF3QTd2LzQvd01BWkFEdi8vMy9IUUFrQUZvQThQOUZBUHYvRmdCSUFQZi9XUUFIQUVVQUNRRDAveElBUXdEdS93TUF3UDlWQUxuL1h3Q3cveUVBNWY4c0FQai9GZ0RELzFZQXl2OHJBT1gvSFFEby8vai9JUUFRQUNBQUh3RDkveVFBSFFCQUFCZ0FCUUFpQUFVQUtBRDMvd2tBQ3dBS0FBTUFCd0FKQVBiLytmOEdBT3IvSlFBSEFCTUE2UDhUQUE0QUdnRC8vd29BOC84WkFQLy9HQUR1L3cwQTl2OFNBQU1BQndENC93UUE1UDhYQUFRQUNnRHEvd1VBKy84VkFBY0FDQURzL3hJQUFBQVRBUEgvK3YvMS8vVC83Zi8vLyt6Lyt2L3kvKy8vOS84S0FBY0FDZ0FKQVBUL0JBQUtBQUFBQmdBSUFQTC85djhLQUFNQUJBQUNBUHIvOXY4T0FBSUErUC94Ly92LytmOE1BUGIvK1Avdy93UUE5ZjhNQVBuLy8vLzcvd29BL3Y4UEFBRUFBZ0QxL3hBQUFRQVBBUC8vQXdELy94UUFCd0FMQUFBQUJnQURBQkFBQWdBSEFBQUFDQUFCQUE4QUJRQUZBQU1BQndBRUFBNEFCd0FEQUFFQUNRQUZBQW9BQXdELy93QUFDUUFEQUFVQUFRRC8vLy8vQ0FBQkFBTUFBQUQvLy8vL0J3QUNBQUVBQUFELy8vLy9Cd0FDQVA3Ly8vOEJBQUFBQmdBQkFQNy8vLzhDQUFBQUJBQUFBUDcvLy84REFBQUFBd0FBQVAzLy8vOERBQUFBQVFBQUFQMy8vdjhFQUFBQUFBRCsvLy8vLy84RUFQLy8vLy8rL3dBQS92OEVBUC8vLy8vKy93RUEvdjhFQVAvLy92Lysvd0lBLy84REFQLy8vdi8rL3dJQS8vOEJBUC8vL3YvKy93TUEvLzhCQVAvLy8vLysvd01BLy84QUFQLy9BQUQrL3dRQS8vOEFBUDcvQVFELy93SUEvLy8vLy8vL0FRRC8vd0lBLy8vLy8vLy9BUUFBQUFFQUFBQUFBUC8vQVFELy93RUFBQUFBQVAvL0FRQUFBQUVBQUFBQUFBQUFcIixcblwiVWtsR1JpUUVBQUJYUVZaRlptMTBJQkFBQUFBQkFBSUFnTHNBQUFEdUFnQUVBQkFBWkdGMFlRQUVBQUQrL3dBQSt2OEFBUHovQUFELy93QUEvZjhBQUFFQUFBRCsvd0FBQ1FBQUFBUUFBQUFaQUFBQXRnQUFBRnNCQUFCVy9nQUFIL29BQUdjQkFBQm9Cd0FBbEFBQUFPMy9BQUFSQVFBQSt3SUFBRW9FQUFDZS9nQUFpdjRBQUxEMEFBREo4d0FBa1FRQUFGMzRBQUJpOFFBQVBRQUFBQUgyQUFEMTlBQUFEQU1BQUp3R0FBQ1RFQUFBMEF3QUFKa0hBQUNPQndBQXVRRUFBTmNEQUFDNkFnQUFId1VBQUhFRkFBQjBBd0FBYmdFQUFEeitBQURZQVFBQUdBQUFBSndDQUFEZ0FBQUEvLzBBQU1uK0FBQVQvQUFBd1A4QUFPbjlBQUFKQUFBQWV3RUFBT24rQUFDTi93QUFPdjBBQU8zK0FBRE4vZ0FBY1A4QUFDai9BQUNxL2dBQStmNEFBTUw5QUFDYS93QUEvZjRBQU43L0FBQm8vd0FBNi80QUFFLy9BQUFDL3dBQUVRQUFBSFgvQUFCMEFBQUE1ZjhBQUV3QUFBQjNBQUFBNS84QUFNSUFBQUJDQUFBQXpnQUFBRThBQUFCM0FBQUFLQUFBQURNQUFBQ3FBQUFBTHdBQUFLNEFBQUFTQUFBQVZnQUFBQ2dBQUFBdEFBQUFUQUFBQVAzL0FBQTdBQUFBMi84QUFDUUFBQUR3L3dBQUxRQUFBREVBQUFBbEFBQUFiQUFBQURNQUFBQlVBQUFBRUFBQUFDZ0FBQUQxL3dBQTl2OEFBUHIvQUFEdS93QUFMZ0FBQUJJQUFBQlVBQUFBUkFBQUFHVUFBQUJHQUFBQU9BQUFBR0FBQUFBdUFBQUFSUUFBQUNFQUFBQWZBQUFBQUFBQUFBa0FBQUFRQUFBQUF3QUFBQklBQUFEcy93QUFFQUFBQUFZQUFBQVNBQUFBSWdBQUFCRUFBQUFEQUFBQUJBQUFBQThBQUFENC93QUFIUUFBQUFzQUFBQUlBQUFBRGdBQUFQLy9BQUFjQUFBQUR3QUFBQVlBQUFBU0FBQUFGd0FBQUFNQUFBQVlBQUFBRWdBQUFQci9BQUFRQUFBQURRQUFBQW9BQUFEMy93QUFCZ0FBQVBiL0FBRGYvd0FBL3Y4QUFQTC9BQUQ2L3dBQUZBQUFBQVFBQUFBRUFBQUFHd0FBQUFFQUFBQU1BQUFBSUFBQUFBSUFBQUFkQUFBQUdBQUFBQUlBQUFBY0FBQUFFZ0FBQUFjQUFBQWVBQUFBRHdBQUFBUUFBQUFlQUFBQUJBQUFBQVlBQUFBWkFBQUFBUUFBQUE0QUFBQVRBQUFBL3Y4QUFBb0FBQUFPQUFBQSsvOEFBQXNBQUFBSkFBQUErZjhBQUFzQUFBQUJBQUFBK2Y4QUFBb0FBQUQ5L3dBQSt2OEFBQWNBQUFENS93QUErdjhBQUFVQUFBRDMvd0FBL2Y4QUFBUUFBQUQyL3dBQUFBQUFBQUVBQUFEMy93QUFBZ0FBQUFBQUFBRDQvd0FBQXdBQUFQNy9BQUQ2L3dBQUJBQUFBUDMvQUFEOC93QUFCQUFBQVB2L0FBRCsvd0FBQXdBQUFQdi9BQUQvL3dBQUFRQUFBUHYvQUFBQUFBQUFBQUFBQVB2L0FBQUNBQUFBLy84QUFQei9BQUFDQUFBQS92OEFBUDMvQUFBQ0FBQUEvZjhBQVA3L0FBQUJBQUFBL2Y4QUFQLy9BQUFCQUFBQS9mOEFBQUFBQUFBQUFBQUEvdjhBQUFFQUFBQUFBQUFBLy84QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIixcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gT21uaXRvbmVTT0FIcmlyQmFzZTY0O1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAZmlsZSBDcm9zcy1icm93c2VyIHN1cHBvcnQgcG9seWZpbGwgZm9yIE9tbml0b25lIGxpYnJhcnkuXG4gKi9cblxuXG5cblxuLyoqXG4gKiBEZXRlY3RzIGJyb3dzZXIgdHlwZSBhbmQgdmVyc2lvbi5cbiAqIEByZXR1cm4ge3N0cmluZ1tdfSAtIEFuIGFycmF5IGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBicm93c2VyIG5hbWUgYW5kIHZlcnNpb24uXG4gKi9cbmV4cG9ydHMuZ2V0QnJvd3NlckluZm8gPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICBsZXQgTSA9IHVhLm1hdGNoKFxuICAgICAgLyhvcGVyYXxjaHJvbWV8c2FmYXJpfGZpcmVmb3h8bXNpZXx0cmlkZW50KD89XFwvKSlcXC8/XFxzKihbXFxkXFwuXSspL2kpIHx8XG4gICAgICBbXTtcbiAgbGV0IHRlbTtcblxuICBpZiAoL3RyaWRlbnQvaS50ZXN0KE1bMV0pKSB7XG4gICAgdGVtID0gL1xcYnJ2WyA6XSsoXFxkKykvZy5leGVjKHVhKSB8fCBbXTtcbiAgICByZXR1cm4ge25hbWU6ICdJRScsIHZlcnNpb246ICh0ZW1bMV0gfHwgJycpfTtcbiAgfVxuXG4gIGlmIChNWzFdID09PSAnQ2hyb21lJykge1xuICAgIHRlbSA9IHVhLm1hdGNoKC9cXGJPUFJ8RWRnZVxcLyhcXGQrKS8pO1xuICAgIGlmICh0ZW0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtuYW1lOiAnT3BlcmEnLCB2ZXJzaW9uOiB0ZW1bMV19O1xuICAgIH1cbiAgfVxuXG4gIE0gPSBNWzJdID8gW01bMV0sIE1bMl1dIDogW25hdmlnYXRvci5hcHBOYW1lLCBuYXZpZ2F0b3IuYXBwVmVyc2lvbiwgJy0/J107XG4gIGlmICgodGVtID0gdWEubWF0Y2goL3ZlcnNpb25cXC8oW1xcZC5dKykvaSkpICE9IG51bGwpIHtcbiAgICBNLnNwbGljZSgxLCAxLCB0ZW1bMV0pO1xuICB9XG5cbiAgbGV0IHBsYXRmb3JtID0gdWEubWF0Y2goL2FuZHJvaWR8aXBhZHxpcGhvbmUvaSk7XG4gIGlmICghcGxhdGZvcm0pIHtcbiAgICBwbGF0Zm9ybSA9IHVhLm1hdGNoKC9jcm9zfGxpbnV4fG1hYyBvcyB4fHdpbmRvd3MvaSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IE1bMF0sXG4gICAgdmVyc2lvbjogTVsxXSxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm0gPyBwbGF0Zm9ybVswXSA6ICd1bmtub3duJyxcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBQYXRjaGVzIEF1ZGlvQ29udGV4dCBpZiB0aGUgcHJlZml4ZWQgQVBJIGlzIGZvdW5kLlxuICovXG5leHBvcnRzLnBhdGNoU2FmYXJpID0gZnVuY3Rpb24oKSB7XG4gIGlmICh3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICYmIHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0KSB7XG4gICAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgd2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQgPSB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgT21uaXRvbmUgdmVyc2lvbi5cbiAqL1xuXG5cblxuXG4vKipcbiAqIE9tbml0b25lIGxpYnJhcnkgdmVyc2lvblxuICogQHR5cGUge1N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAnMS4wLjYnO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGZpbGUgUmVzb25hbmNlQXVkaW8gdmVyc2lvbi5cbiAqIEBhdXRob3IgQW5kcmV3IEFsbGVuIDxiaXRsbGFtYUBnb29nbGUuY29tPlxuICovXG5cblxuXG5cbi8qKlxuICogUmVzb25hbmNlQXVkaW8gbGlicmFyeSB2ZXJzaW9uXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9ICcwLjAuNCc7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7IiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4vUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbmNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi8gbmV3IFF1YXRlcm5pb24oKTtcblxuY2xhc3MgRXVsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCBvcmRlciA9IEV1bGVyLkRlZmF1bHRPcmRlciApIHtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0fVxuXG5cdGdldCB4KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cblx0fVxuXG5cdHNldCB4KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB5KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cblx0fVxuXG5cdHNldCB5KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCB6KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3o7XG5cblx0fVxuXG5cdHNldCB6KCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fVxuXG5cdGdldCBvcmRlcigpIHtcblxuXHRcdHJldHVybiB0aGlzLl9vcmRlcjtcblxuXHR9XG5cblx0c2V0IG9yZGVyKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRzZXQoIHgsIHksIHosIG9yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3kgPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUXVhdGVybmlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuXHRcdF9tYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX21hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdH1cblxuXHRzZXRGcm9tVmVjdG9yMyggdiwgb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fVxuXG5cdGVxdWFscyggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdHRvVmVjdG9yMyggb3B0aW9uYWxSZXN1bHQgKSB7XG5cblx0XHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0X29uQ2hhbmdlKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRfb25DaGFuZ2VDYWxsYmFjaygpIHt9XG5cbn1cblxuRXVsZXIucHJvdG90eXBlLmlzRXVsZXIgPSB0cnVlO1xuXG5FdWxlci5EZWZhdWx0T3JkZXIgPSAnWFlaJztcbkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XG5cbmV4cG9ydCB7IEV1bGVyIH07XG4iLCJjb25zdCBfbHV0ID0gW107XG5cbmZvciAoIGxldCBpID0gMDsgaSA8IDI1NjsgaSArKyApIHtcblxuXHRfbHV0WyBpIF0gPSAoIGkgPCAxNiA/ICcwJyA6ICcnICkgKyAoIGkgKS50b1N0cmluZyggMTYgKTtcblxufVxuXG5sZXQgX3NlZWQgPSAxMjM0NTY3O1xuXG5cbmNvbnN0IERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG5cdGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCB1dWlkID0gX2x1dFsgZDAgJiAweGZmIF0gKyBfbHV0WyBkMCA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRfbHV0WyBkMSAmIDB4ZmYgXSArIF9sdXRbIGQxID4+IDggJiAweGZmIF0gKyAnLScgKyBfbHV0WyBkMSA+PiAxNiAmIDB4MGYgfCAweDQwIF0gKyBfbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXG5cdFx0XHRfbHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBfbHV0WyBkMiA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDIgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXG5cdFx0XHRfbHV0WyBkMyAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDggJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAxNiAmIDB4ZmYgXSArIF9sdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xuXG5cdC8vIC50b1VwcGVyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cblx0cmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKTtcblxufVxuXG5mdW5jdGlvbiBjbGFtcCggdmFsdWUsIG1pbiwgbWF4ICkge1xuXG5cdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XG5cbn1cblxuLy8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5mdW5jdGlvbiBldWNsaWRlYW5Nb2R1bG8oIG4sIG0gKSB7XG5cblx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcblxufVxuXG4vLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5mdW5jdGlvbiBtYXBMaW5lYXIoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG59XG5cbi8vIGh0dHBzOi8vd3d3LmdhbWVkZXYubmV0L3R1dG9yaWFscy9wcm9ncmFtbWluZy9nZW5lcmFsLWFuZC1nYW1lcGxheS1wcm9ncmFtbWluZy9pbnZlcnNlLWxlcnAtYS1zdXBlci11c2VmdWwteWV0LW9mdGVuLW92ZXJsb29rZWQtZnVuY3Rpb24tcjUyMzAvXG5mdW5jdGlvbiBpbnZlcnNlTGVycCggeCwgeSwgdmFsdWUgKSB7XG5cblx0aWYgKCB4ICE9PSB5ICkge1xuXG5cdFx0cmV0dXJuICggdmFsdWUgLSB4ICkgLyAoIHkgLSB4ICk7XG5cblx0XHQgfSBlbHNlIHtcblxuXHRcdHJldHVybiAwO1xuXG5cdFx0IH1cblxufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxuZnVuY3Rpb24gbGVycCggeCwgeSwgdCApIHtcblxuXHRyZXR1cm4gKCAxIC0gdCApICogeCArIHQgKiB5O1xuXG59XG5cbi8vIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xuZnVuY3Rpb24gZGFtcCggeCwgeSwgbGFtYmRhLCBkdCApIHtcblxuXHRyZXR1cm4gbGVycCggeCwgeSwgMSAtIE1hdGguZXhwKCAtIGxhbWJkYSAqIGR0ICkgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdmNzam55ejd4NFxuZnVuY3Rpb24gcGluZ3BvbmcoIHgsIGxlbmd0aCA9IDEgKSB7XG5cblx0cmV0dXJuIGxlbmd0aCAtIE1hdGguYWJzKCBldWNsaWRlYW5Nb2R1bG8oIHgsIGxlbmd0aCAqIDIgKSAtIGxlbmd0aCApO1xuXG59XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxuZnVuY3Rpb24gc21vb3Roc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG59XG5cbmZ1bmN0aW9uIHNtb290aGVyc3RlcCggeCwgbWluLCBtYXggKSB7XG5cblx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XG5cblx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcblxuXHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG59XG5cbi8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcbmZ1bmN0aW9uIHJhbmRJbnQoIGxvdywgaGlnaCApIHtcblxuXHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG59XG5cbi8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXQoIGxvdywgaGlnaCApIHtcblxuXHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG59XG5cbi8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcbmZ1bmN0aW9uIHJhbmRGbG9hdFNwcmVhZCggcmFuZ2UgKSB7XG5cblx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XG5cbn1cblxuLy8gRGV0ZXJtaW5pc3RpYyBwc2V1ZG8tcmFuZG9tIGZsb2F0IGluIHRoZSBpbnRlcnZhbCBbIDAsIDEgXVxuZnVuY3Rpb24gc2VlZGVkUmFuZG9tKCBzICkge1xuXG5cdGlmICggcyAhPT0gdW5kZWZpbmVkICkgX3NlZWQgPSBzICUgMjE0NzQ4MzY0NztcblxuXHQvLyBQYXJrLU1pbGxlciBhbGdvcml0aG1cblxuXHRfc2VlZCA9IF9zZWVkICogMTY4MDcgJSAyMTQ3NDgzNjQ3O1xuXG5cdHJldHVybiAoIF9zZWVkIC0gMSApIC8gMjE0NzQ4MzY0NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuXG5cblxuZXhwb3J0IHtcblx0REVHMlJBRCxcblx0UkFEMkRFRyxcblx0Z2VuZXJhdGVVVUlELFxuXHRjbGFtcCxcblx0ZXVjbGlkZWFuTW9kdWxvLFxuXHRtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwLFxuXHRsZXJwLFxuXHRkYW1wLFxuXHRwaW5ncG9uZyxcblx0c21vb3Roc3RlcCxcblx0c21vb3RoZXJzdGVwLFxuXHRyYW5kSW50LFxuXHRyYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZCxcblx0c2VlZGVkUmFuZG9tLFxuXHRkZWdUb1JhZCxcblx0cmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3byxcblx0Y2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3byxcblx0c2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcixcbn07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgTWF0cml4NCB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRdO1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sIDAsXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWCA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG5cdFx0Y29uc3QgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggeSApLCBkID0gTWF0aC5zaW4oIHkgKTtcblx0XHRjb25zdCBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cblx0XHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuXHRcdFx0Y29uc3QgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSBkZSAqIGIgLSBjZjtcblx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuXHRcdFx0dGVbIDEgXSA9IGEgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuXHRcdFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xuXHRcdFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuXHRcdFx0Y29uc3QgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGNlIC0gZGYgKiBiO1xuXHRcdFx0dGVbIDQgXSA9IC0gYSAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cblx0XHRcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuXHRcdFx0dGVbIDIgXSA9IC0gYSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0Y29uc3QgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IGJkIC0gYWMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG5cdFx0XHR0ZVsgMSBdID0gZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkICogZTtcblx0XHRcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcblx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGY7XG5cdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cblx0XHRcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuXHRcdFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBlO1xuXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuXHRcdH1cblxuXHRcdC8vIGJvdHRvbSByb3dcblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBsYXN0IGNvbHVtblxuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApIHtcblxuXHRcdHJldHVybiB0aGlzLmNvbXBvc2UoIF96ZXJvLCBxLCBfb25lICk7XG5cblx0fVxuXG5cdGxvb2tBdCggZXllLCB0YXJnZXQsIHVwICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0X3ouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcblxuXHRcdGlmICggX3oubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXG5cblx0XHRcdF96LnogPSAxO1xuXG5cdFx0fVxuXG5cdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0X3guY3Jvc3NWZWN0b3JzKCB1cCwgX3ogKTtcblxuXHRcdGlmICggX3gubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gdXAgYW5kIHogYXJlIHBhcmFsbGVsXG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcblxuXHRcdFx0XHRfei54ICs9IDAuMDAwMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfei56ICs9IDAuMDAwMTtcblxuXHRcdFx0fVxuXG5cdFx0XHRfei5ub3JtYWxpemUoKTtcblx0XHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHR9XG5cblx0XHRfeC5ub3JtYWxpemUoKTtcblx0XHRfeS5jcm9zc1ZlY3RvcnMoIF96LCBfeCApO1xuXG5cdFx0dGVbIDAgXSA9IF94Lng7IHRlWyA0IF0gPSBfeS54OyB0ZVsgOCBdID0gX3oueDtcblx0XHR0ZVsgMSBdID0gX3gueTsgdGVbIDUgXSA9IF95Lnk7IHRlWyA5IF0gPSBfei55O1xuXHRcdHRlWyAyIF0gPSBfeC56OyB0ZVsgNiBdID0gX3kuejsgdGVbIDEwIF0gPSBfei56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtLCBuICkge1xuXG5cdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XG5cdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcblx0XHRjb25zdCBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHRjb25zdCBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0Y29uc3QgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZXRlcm1pbmFudCgpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuXHRcdGNvbnN0IG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuXHRcdGNvbnN0IG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHRjb25zdCBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdG40MSAqIChcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0KSArXG5cdFx0XHRuNDIgKiAoXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQzICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40NCAqIChcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0KVxuXG5cdFx0KTtcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGxldCB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UG9zaXRpb24oIHgsIHksIHogKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLCBuNDEgPSB0ZVsgMyBdLFxuXHRcdFx0bjEyID0gdGVbIDQgXSwgbjIyID0gdGVbIDUgXSwgbjMyID0gdGVbIDYgXSwgbjQyID0gdGVbIDcgXSxcblx0XHRcdG4xMyA9IHRlWyA4IF0sIG4yMyA9IHRlWyA5IF0sIG4zMyA9IHRlWyAxMCBdLCBuNDMgPSB0ZVsgMTEgXSxcblx0XHRcdG4xNCA9IHRlWyAxMiBdLCBuMjQgPSB0ZVsgMTMgXSwgbjM0ID0gdGVbIDE0IF0sIG40NCA9IHRlWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHRjb25zdCBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDMgXSA9ICggbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDEyIF0gPSB0MTQgKiBkZXRJbnY7XG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTUgXSA9ICggbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHYgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXhTY2FsZU9uQXhpcygpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdGNvbnN0IHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cblx0fVxuXG5cdG1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLCB4LFxuXHRcdFx0MCwgMSwgMCwgeSxcblx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblgoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIGMsIC0gcywgMCxcblx0XHRcdDAsIHMsIGMsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblkoIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0IGMsIDAsIHMsIDAsXG5cdFx0XHQgMCwgMSwgMCwgMCxcblx0XHRcdC0gcywgMCwgYywgMCxcblx0XHRcdCAwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvblooIHRoZXRhICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0YywgLSBzLCAwLCAwLFxuXHRcdFx0cywgYywgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkF4aXMoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0Y29uc3QgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXHRcdGNvbnN0IHQgPSAxIC0gYztcblx0XHRjb25zdCB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdGNvbnN0IHR4ID0gdCAqIHgsIHR5ID0gdCAqIHk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0dHggKiB4ICsgYywgdHggKiB5IC0gcyAqIHosIHR4ICogeiArIHMgKiB5LCAwLFxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxuXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCwgMCxcblx0XHRcdDAsIHksIDAsIDAsXG5cdFx0XHQwLCAwLCB6LCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2hlYXIoIHgsIHksIHogKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgeSwgeiwgMCxcblx0XHRcdHgsIDEsIHosIDAsXG5cdFx0XHR4LCB5LCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gcXVhdGVybmlvbi5feCwgeSA9IHF1YXRlcm5pb24uX3ksIHogPSBxdWF0ZXJuaW9uLl96LCB3ID0gcXVhdGVybmlvbi5fdztcblx0XHRjb25zdCB4MiA9IHggKyB4LFx0eTIgPSB5ICsgeSwgejIgPSB6ICsgejtcblx0XHRjb25zdCB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG5cdFx0Y29uc3Qgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcblxuXHRcdGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XG5cblx0XHR0ZVsgMCBdID0gKCAxIC0gKCB5eSArIHp6ICkgKSAqIHN4O1xuXHRcdHRlWyAxIF0gPSAoIHh5ICsgd3ogKSAqIHN4O1xuXHRcdHRlWyAyIF0gPSAoIHh6IC0gd3kgKSAqIHN4O1xuXHRcdHRlWyAzIF0gPSAwO1xuXG5cdFx0dGVbIDQgXSA9ICggeHkgLSB3eiApICogc3k7XG5cdFx0dGVbIDUgXSA9ICggMSAtICggeHggKyB6eiApICkgKiBzeTtcblx0XHR0ZVsgNiBdID0gKCB5eiArIHd4ICkgKiBzeTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSAoIHh6ICsgd3kgKSAqIHN6O1xuXHRcdHRlWyA5IF0gPSAoIHl6IC0gd3ggKSAqIHN6O1xuXHRcdHRlWyAxMCBdID0gKCAxIC0gKCB4eCArIHl5ICkgKSAqIHN6O1xuXHRcdHRlWyAxMSBdID0gMDtcblxuXHRcdHRlWyAxMiBdID0gcG9zaXRpb24ueDtcblx0XHR0ZVsgMTMgXSA9IHBvc2l0aW9uLnk7XG5cdFx0dGVbIDE0IF0gPSBwb3NpdGlvbi56O1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGxldCBzeCA9IF92MS5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IF92MS5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IF92MS5zZXQoIHRlWyA4IF0sIHRlWyA5IF0sIHRlWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdGNvbnN0IGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XG5cblx0XHRwb3NpdGlvbi54ID0gdGVbIDEyIF07XG5cdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuXHRcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG5cdFx0X20xLmNvcHkoIHRoaXMgKTtcblxuXHRcdGNvbnN0IGludlNYID0gMSAvIHN4O1xuXHRcdGNvbnN0IGludlNZID0gMSAvIHN5O1xuXHRcdGNvbnN0IGludlNaID0gMSAvIHN6O1xuXG5cdFx0X20xLmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAxIF0gKj0gaW52U1g7XG5cdFx0X20xLmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRfbTEuZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcblx0XHRfbTEuZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdF9tMS5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgOSBdICo9IGludlNaO1xuXHRcdF9tMS5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblxuXHRcdHNjYWxlLnggPSBzeDtcblx0XHRzY2FsZS55ID0gc3k7XG5cdFx0c2NhbGUueiA9IHN6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRpZiAoIGZhciA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cdFx0Y29uc3QgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRjb25zdCBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhO1x0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjtcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXHRcdGNvbnN0IHogPSAoIGZhciArIG5lYXIgKSAqIHA7XG5cblx0XHR0ZVsgMCBdID0gMiAqIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XG5cdFx0dGVbIDEgXSA9IDA7XHR0ZVsgNSBdID0gMiAqIGg7XHR0ZVsgOSBdID0gMDtcdHRlWyAxMyBdID0gLSB5O1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IC0gMiAqIHA7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gPSB0ZVsgOSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG59XG5cbk1hdHJpeDQucHJvdG90eXBlLmlzTWF0cml4NCA9IHRydWU7XG5cbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9tMSA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF96ZXJvID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMCwgMCApO1xuY29uc3QgX29uZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcbmNvbnN0IF94ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3kgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuZXhwb3J0IHsgTWF0cml4NCB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgUXVhdGVybmlvbiB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0fVxuXG5cdHN0YXRpYyBzbGVycCggcWEsIHFiLCBxbSwgdCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IFN0YXRpYyAuc2xlcnAoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgcW0uc2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIHFtLnNsZXJwUXVhdGVybmlvbnMoIHFhLCBxYiwgdCApO1xuXG5cdH1cblxuXHRzdGF0aWMgc2xlcnBGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdGxldCB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG5cdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRpZiAoIHQgPT09IDAgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzE7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcblxuXHRcdFx0bGV0IHMgPSAxIC0gdDtcblx0XHRcdGNvbnN0IGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0eTAgKj0gZjtcblx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0dzAgKj0gZjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG5cdH1cblxuXHRzdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxICkge1xuXG5cdFx0Y29uc3QgeDAgPSBzcmMwWyBzcmNPZmZzZXQwIF07XG5cdFx0Y29uc3QgeTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdO1xuXHRcdGNvbnN0IHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXTtcblx0XHRjb25zdCB3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgXTtcblx0XHRjb25zdCB5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF07XG5cdFx0Y29uc3QgejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdO1xuXHRcdGNvbnN0IHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MCAqIHcxICsgdzAgKiB4MSArIHkwICogejEgLSB6MCAqIHkxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowICogdzEgKyB3MCAqIHoxICsgeDAgKiB5MSAtIHkwICogeDE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MCAqIHcxIC0geDAgKiB4MSAtIHkwICogeTEgLSB6MCAqIHoxO1xuXG5cdFx0cmV0dXJuIGRzdDtcblxuXHR9XG5cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9XG5cblx0c2V0IHkoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHooKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9XG5cblx0c2V0IHooIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9XG5cblx0c2V0IHcoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cblx0Y29weSggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUV1bGVyKCBldWxlciwgdXBkYXRlICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cblx0XHQvLyBcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xuXHRcdC8vXHRjb250ZW50L1NwaW5DYWxjLm1cblxuXHRcdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRcdGNvbnN0IHNpbiA9IE1hdGguc2luO1xuXG5cdFx0Y29uc3QgYzEgPSBjb3MoIHggLyAyICk7XG5cdFx0Y29uc3QgYzIgPSBjb3MoIHkgLyAyICk7XG5cdFx0Y29uc3QgYzMgPSBjb3MoIHogLyAyICk7XG5cblx0XHRjb25zdCBzMSA9IHNpbiggeCAvIDIgKTtcblx0XHRjb25zdCBzMiA9IHNpbiggeSAvIDIgKTtcblx0XHRjb25zdCBzMyA9IHNpbiggeiAvIDIgKTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0Y29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLCBzID0gTWF0aC5zaW4oIGhhbGZBbmdsZSApO1xuXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XG5cdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG5cdFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdGNvbnN0IHRlID0gbS5lbGVtZW50cyxcblxuXHRcdFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcblx0XHRcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG5cblx0XHRpZiAoIHRyYWNlID4gMCApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuXHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuXHRcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuXHRcdFx0Y29uc3QgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAwLjI1ICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cblx0XHRsZXQgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG5cdFx0aWYgKCByIDwgTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdC8vIHZGcm9tIGFuZCB2VG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuXG5cdFx0XHRyID0gMDtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gLSB2RnJvbS55O1xuXHRcdFx0XHR0aGlzLl95ID0gdkZyb20ueDtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0XHR0aGlzLl95ID0gLSB2RnJvbS56O1xuXHRcdFx0XHR0aGlzLl96ID0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApOyAvLyBpbmxpbmVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmN5IG9uIFZlY3RvcjNcblxuXHRcdFx0dGhpcy5feCA9IHZGcm9tLnkgKiB2VG8ueiAtIHZGcm9tLnogKiB2VG8ueTtcblx0XHRcdHRoaXMuX3kgPSB2RnJvbS56ICogdlRvLnggLSB2RnJvbS54ICogdlRvLno7XG5cdFx0XHR0aGlzLl96ID0gdkZyb20ueCAqIHZUby55IC0gdkZyb20ueSAqIHZUby54O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YW5nbGVUbyggcSApIHtcblxuXHRcdHJldHVybiAyICogTWF0aC5hY29zKCBNYXRoLmFicyggTWF0aFV0aWxzLmNsYW1wKCB0aGlzLmRvdCggcSApLCAtIDEsIDEgKSApICk7XG5cblx0fVxuXG5cdHJvdGF0ZVRvd2FyZHMoIHEsIHN0ZXAgKSB7XG5cblx0XHRjb25zdCBhbmdsZSA9IHRoaXMuYW5nbGVUbyggcSApO1xuXG5cdFx0aWYgKCBhbmdsZSA9PT0gMCApIHJldHVybiB0aGlzO1xuXG5cdFx0Y29uc3QgdCA9IE1hdGgubWluKCAxLCBzdGVwIC8gYW5nbGUgKTtcblxuXHRcdHRoaXMuc2xlcnAoIHEsIHQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMSApO1xuXG5cdH1cblxuXHRpbnZlcnQoKSB7XG5cblx0XHQvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG5cblx0fVxuXG5cdGNvbmp1Z2F0ZSgpIHtcblxuXHRcdHRoaXMuX3ggKj0gLSAxO1xuXHRcdHRoaXMuX3kgKj0gLSAxO1xuXHRcdHRoaXMuX3ogKj0gLSAxO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRvdCggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9XG5cblx0bGVuZ3RoU3EoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fVxuXG5cdGxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdGxldCBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggcSwgcCApIHtcblxuXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCBwICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0dGhpcy5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG5cdH1cblxuXHRlcXVhbHMoIHF1YXRlcm5pb24gKSB7XG5cblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMuX3kgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4ICkge1xuXG5cdFx0dGhpcy5feCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMuX3kgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblx0XHR0aGlzLl96ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cdFx0dGhpcy5fdyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG59XG5cblF1YXRlcm5pb24ucHJvdG90eXBlLmlzUXVhdGVybmlvbiA9IHRydWU7XG5cbmV4cG9ydCB7IFF1YXRlcm5pb24gfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcblxuY2xhc3MgVmVjdG9yMyB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6ICkge1xuXG5cdFx0aWYgKCB6ID09PSB1bmRlZmluZWQgKSB6ID0gdGhpcy56OyAvLyBzcHJpdGUuc2NhbGUuc2V0KHgseSlcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WiggeiApIHtcblxuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fVxuXG5cdGNvcHkoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGQoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhZGRTY2FsZWRWZWN0b3IoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWIoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHlTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5VmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKiBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG5cdFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMoIG0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0Y29uc3QgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdGhpcywgdiApO1xuXG5cdH1cblxuXHRjcm9zc1ZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xuXHRcdGNvbnN0IGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cblx0XHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcblx0XHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRwcm9qZWN0T25WZWN0b3IoIHYgKSB7XG5cblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHYubGVuZ3RoU3EoKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IHNjYWxhciA9IHYuZG90KCB0aGlzICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdHJldHVybiB0aGlzLmNvcHkoIHYgKS5tdWx0aXBseVNjYWxhciggc2NhbGFyICk7XG5cblx0fVxuXG5cdHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdF92ZWN0b3IuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcblxuXHRcdHJldHVybiB0aGlzLnN1YiggX3ZlY3RvciApO1xuXG5cdH1cblxuXHRyZWZsZWN0KCBub3JtYWwgKSB7XG5cblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcblx0XHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG5cdH1cblxuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIE1hdGhVdGlscy5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9XG5cblx0bWFuaGF0dGFuRGlzdGFuY2VUbyggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICkgKyBNYXRoLmFicyggdGhpcy56IC0gdi56ICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWwoIHMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tU3BoZXJpY2FsQ29vcmRzKCBzLnJhZGl1cywgcy5waGksIHMudGhldGEgKTtcblxuXHR9XG5cblx0c2V0RnJvbVNwaGVyaWNhbENvb3JkcyggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG5cdFx0Y29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHBoaSApICogcmFkaXVzO1xuXG5cdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0gTWF0aC5jb3MoIHBoaSApICogcmFkaXVzO1xuXHRcdHRoaXMueiA9IHNpblBoaVJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DeWxpbmRyaWNhbCggYyApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3JkcyggYy5yYWRpdXMsIGMudGhldGEsIGMueSApO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIHJhZGl1cywgdGhldGEsIHkgKSB7XG5cblx0XHR0aGlzLnggPSByYWRpdXMgKiBNYXRoLnNpbiggdGhldGEgKTtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxMyBdO1xuXHRcdHRoaXMueiA9IGVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeFNjYWxlKCBtICkge1xuXG5cdFx0Y29uc3Qgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XG5cblx0XHR0aGlzLnggPSBzeDtcblx0XHR0aGlzLnkgPSBzeTtcblx0XHR0aGlzLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4Q29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXgzQ29sdW1uKCBtLCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiAzICk7XG5cblx0fVxuXG5cdGVxdWFscyggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRmcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XG5cdFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy56ID0gYXR0cmlidXRlLmdldFooIGluZGV4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuXHRcdHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuVmVjdG9yMy5wcm90b3R5cGUuaXNWZWN0b3IzID0gdHJ1ZTtcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5leHBvcnQgeyBWZWN0b3IzIH07XG4iLCJpbXBvcnQgeyBkZXRlY3QgfSBmcm9tIFwiZGV0ZWN0LWJyb3dzZXJcIjtcbmltcG9ydCB7IGlzSW9zIH0gZnJvbSBcIi4vaXNJb3NcIjtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgY29uc3QgYnJvd3NlciA9IGRldGVjdCgpO1xuICBjb25zb2xlLmxvZyhicm93c2VyKTtcbiAgY29uc29sZS5sb2cobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIC8vaU9TIHdlIHdpbGwgcmVkaXJlY3QgdG8gbm9uIGFyIHZlcnNpb24gYW55d2F5XG4gIGlmIChpc0lvcykgcmV0dXJuO1xuICBpZiAoYnJvd3Nlci5vcyAhPT0gXCJBbmRyb2lkIE9TXCIgJiYgYnJvd3Nlci5vcyAhPT0gXCJhbmRyb2lkXCIpIHJldHVybjtcbiAgaWYgKGJyb3dzZXIubmFtZSAhPT0gXCJjaHJvbWVcIiAmJiBicm93c2VyLm5hbWUgIT09IFwiY2hyb21pdW0td2Vidmlld1wiKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlcnJvci1vdmVybGF5XCIpLmlubmVySFRNTCA9IGBcbiAgICA8ZGl2PlRoaXMgc2l0ZSBvbmx5IHN1cHBvcnRzIHRoZSA8YSBocmVmPSdodHRwczovL3BsYXkuZ29vZ2xlLmNvbS9zdG9yZS9hcHBzL2RldGFpbHM/aWQ9Y29tLmFuZHJvaWQuY2hyb21lJz5DaHJvbWUgd2ViIGJyb3dzZXIgb24gQW5kcm9pZC48L2E+PC9kaXY+O1xuICAgIGA7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNlcnJvci1vdmVybGF5XCIpLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgfVxufSk7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGV2ZW50KSA9PiB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgXCIjZXJyb3Itb3ZlcmxheVwiLFxuICApLmlubmVySFRNTCA9IGA8ZGl2Pk9vcHMhIEFuIGVycm9yPGJyPjxicj5QbGVhc2UgcmVmcmVzaCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLjxicj48YnI+PHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDAuNWVtXCI+JHtldmVudC5tZXNzYWdlfTwvc3Bhbj48L2Rpdj5gO1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Vycm9yLW92ZXJsYXlcIikuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xufSk7XG4iLCJleHBvcnQgY29uc3QgaXNJb3MgPVxuICBbXCJpUGFkIFNpbXVsYXRvclwiLCBcImlQaG9uZSBTaW11bGF0b3JcIiwgXCJpUG9kIFNpbXVsYXRvclwiLCBcImlQYWRcIiwgXCJpUGhvbmVcIiwgXCJpUG9kXCJdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSkgfHxcbiAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJNYWNcIikgJiYgXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQpO1xuIiwiZXhwb3J0IGludGVyZmFjZSBMb2FkTWVkaWFTdGF0ZSB7XG4gIGxvYWRlZD86IGJvb2xlYW47XG4gIG51bUxvYWRlZD86IG51bWJlcjtcbiAgbnVtSXRlbXM/OiBudW1iZXI7XG4gIGJ1ZmZlclNvdXJjZXM/OiBBdWRpb0J1ZmZlclNvdXJjZU5vZGVbXTtcbiAgcmVxdWVzdHM/OiBYTUxIdHRwUmVxdWVzdFtdO1xuICBwcm9ncmVzcz86IG51bWJlcltdO1xufVxuXG5pbnRlcmZhY2UgTG9hZE1lZGlhUGFyYW1zIHtcbiAgZWw6IEhUTUxFbGVtZW50O1xuICBhdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dDtcbiAgb25TdWNjZXNzKGJhcmNvZGVEYXRhOiBzdHJpbmcsIGJ1ZmZlclNvdXJjZXM6IEF1ZGlvQnVmZmVyU291cmNlTm9kZVtdKTogdm9pZDtcbiAgb25Qcm9ncmVzcyhwZXJjZW50OiBudW1iZXIpOiB2b2lkO1xuICBiYXJjb2RlRGF0YTogc3RyaW5nO1xuICBsb2FkaW5nQmFyY29kZUNvbnRhaW5lcjogeyBsb2FkaW5nQmFyY29kZTogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkTWVkaWEoc3RhdGU6IExvYWRNZWRpYVN0YXRlLCBwYXJhbXM6IExvYWRNZWRpYVBhcmFtcyk6IHZvaWQge1xuICBzdGF0ZS5sb2FkZWQgPSBmYWxzZTtcbiAgc3RhdGUubnVtTG9hZGVkID0gMDtcbiAgc3RhdGUubnVtSXRlbXMgPSBwYXJhbXMuZWwuY2hpbGRyZW4ubGVuZ3RoO1xuICBzdGF0ZS5idWZmZXJTb3VyY2VzID0gW107XG4gIGNvbnNvbGUubG9nKHBhcmFtcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XG4gIHN0YXRlLnJlcXVlc3RzID0gW107XG5cbiAgY29uc29sZS5sb2coYExvYWRpbmcgJHtzdGF0ZS5udW1JdGVtc30gYXVkaW8gZWxlbWVudHNgKTtcblxuICBjb25zdCBzYW1wbGVSYXRlID0gcGFyYW1zLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO1xuICBzdGF0ZS5wcm9ncmVzcyA9IEFycmF5KHBhcmFtcy5lbC5jaGlsZHJlbi5sZW5ndGgpLmZpbGwoMCk7XG4gIEFycmF5LmZyb20ocGFyYW1zLmVsLmNoaWxkcmVuKS5mb3JFYWNoKChhbmNob3JFbCwgaW5kZXgpID0+IHtcbiAgICBpZiAoYW5jaG9yRWwudGFnTmFtZSAhPT0gXCJBXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgbG9hZGVyIHNob3VsZCBvbmx5IGhhdmUgPGE+IGNoaWxkcmVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbFVybDogc3RyaW5nID0gYW5jaG9yRWwuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBjb25zdCB1cmwgPVxuICAgICAgc2FtcGxlUmF0ZSA9PT0gNDgwMDBcbiAgICAgICAgPyBvcmlnaW5hbFVybC5zbGljZSgwLCAtMykgKyBcIjQ4LlwiICsgb3JpZ2luYWxVcmwuc2xpY2UoLTMpXG4gICAgICAgIDogc2FtcGxlUmF0ZSA9PT0gNDQxMDBcbiAgICAgICAgPyBvcmlnaW5hbFVybC5zbGljZSgwLCAtMykgKyBcIjQ0LlwiICsgb3JpZ2luYWxVcmwuc2xpY2UoLTMpXG4gICAgICAgIDogbnVsbDtcbiAgICBpZiAoIXVybCkgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHNhbXBsZSByYXRlICR7c2FtcGxlUmF0ZX1gKTtcblxuICAgIHN0YXRlLmJ1ZmZlclNvdXJjZXMucHVzaChwYXJhbXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgc3RhdGUucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBjaGlsZFByb2dyZXNzLmJpbmQodGhpcywgc3RhdGUsIHBhcmFtcywgaW5kZXgpKTtcbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNoaWxkTG9hZFN1Y2Nlc3MuYmluZCh0aGlzLCBzdGF0ZSwgcGFyYW1zLCBpbmRleCkpO1xuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGNoaWxkRXJyb3IuYmluZCh0aGlzLCBpbmRleCkpO1xuICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNoaWxkQWJvcnQuYmluZCh0aGlzLCBpbmRleCkpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIHJlcXVlc3Quc2VuZCgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hpbGRQcm9ncmVzcyhzdGF0ZTogTG9hZE1lZGlhU3RhdGUsIHBhcmFtczogTG9hZE1lZGlhUGFyYW1zLCBpbmRleDogbnVtYmVyLCBldmVudDogUHJvZ3Jlc3NFdmVudCkge1xuICBjb25zdCBwZXJjZW50ID0gZXZlbnQudG90YWwgPyBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCA6IDA7XG4gIHN0YXRlLnByb2dyZXNzW2luZGV4XSA9IHBlcmNlbnQ7XG4gIGNvbnN0IHRvdGFsUGVyY2VudCA9IHN0YXRlLnByb2dyZXNzLnJlZHVjZSgocHJldjogbnVtYmVyLCBjdXI6IG51bWJlcikgPT4gcHJldiArIGN1cikgLyBzdGF0ZS5wcm9ncmVzcy5sZW5ndGg7XG4gIHBhcmFtcy5vblByb2dyZXNzKHRvdGFsUGVyY2VudCk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkTG9hZFN1Y2Nlc3Moc3RhdGU6IExvYWRNZWRpYVN0YXRlLCBwYXJhbXM6IExvYWRNZWRpYVBhcmFtcywgaW5kZXg6IG51bWJlcikge1xuICBjb25zb2xlLmxvZyhgTG9hZGVkICR7aW5kZXh9YCk7XG4gIGNvbnN0IGRhdGEgPSBzdGF0ZS5yZXF1ZXN0c1tpbmRleF0ucmVzcG9uc2U7XG4gIC8vc2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBwcm9taXNlIGJhc2VkIGRlY29kZVxuICBwYXJhbXMuYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShcbiAgICBkYXRhLFxuICAgIChidWZmZXI6IEF1ZGlvQnVmZmVyKSA9PiB7XG4gICAgICBzdGF0ZS5idWZmZXJTb3VyY2VzW2luZGV4XS5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgIHN0YXRlLm51bUxvYWRlZCArPSAxO1xuICAgICAgaWYgKHN0YXRlLm51bUxvYWRlZCA+PSBzdGF0ZS5udW1JdGVtcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRlZCBhbGwgaXRlbXNcIik7XG4gICAgICAgIHN0YXRlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIHBhcmFtcy5vblN1Y2Nlc3MocGFyYW1zLmJhcmNvZGVEYXRhLCBzdGF0ZS5idWZmZXJTb3VyY2VzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGNoaWxkRXJyb3IoaW5kZXgpO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkRXJyb3IoaW5kZXg6IG51bWJlciwgZXZlbnQ/OiBQcm9ncmVzc0V2ZW50KSB7XG4gIHRocm93IEVycm9yKGBDb3VsZG4ndCBsb2FkIHBpZWNlICR7aW5kZXh9LmApO1xufVxuXG5mdW5jdGlvbiBjaGlsZEFib3J0KGluZGV4OiBudW1iZXIpIHtcbiAgY29uc29sZS5sb2coYEFib3J0aW5nIGxvYWQgaXRlbSAke2luZGV4fWApO1xufVxuIiwiaW1wb3J0IHsgUmVzb25hbmNlQXVkaW8gfSBmcm9tIFwicmVzb25hbmNlLWF1ZGlvXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVzb25hbmNlKGF1ZGlvQ29udGV4dDogQXVkaW9Db250ZXh0KTogUmVzb25hbmNlQXVkaW8ge1xuICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgcmVzb25hbmNlXCIpO1xuICBjb25zdCBhbWJpc29uaWNPcmRlciA9IDE7XG4gIGNvbnN0IHJlc29uYW5jZUF1ZGlvU2NlbmUgPSBuZXcgUmVzb25hbmNlQXVkaW8oYXVkaW9Db250ZXh0LCB7IGFtYmlzb25pY09yZGVyIH0pO1xuICByZXNvbmFuY2VBdWRpb1NjZW5lLnNldFJvb21Qcm9wZXJ0aWVzKFxuICAgIHsgd2lkdGg6IDEwLCBoZWlnaHQ6IDgsIGRlcHRoOiAxMCB9LFxuICAgIHtcbiAgICAgIGJhY2s6IFwiYnJpY2stYmFyZVwiLFxuICAgICAgbGVmdDogXCJicmljay1iYXJlXCIsXG4gICAgICByaWdodDogXCJicmljay1iYXJlXCIsXG4gICAgICBmcm9udDogXCJicmljay1iYXJlXCIsXG4gICAgICBkb3duOiBcInBseXdvb2QtcGFuZWxcIixcbiAgICAgIHVwOiBcInRyYW5zcGFyZW50XCIsXG4gICAgfSxcbiAgKTtcbiAgcmVzb25hbmNlQXVkaW9TY2VuZS5vdXRwdXQuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICByZXR1cm4gcmVzb25hbmNlQXVkaW9TY2VuZTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBFdWxlciB9IGZyb20gXCJ0aHJlZS9zcmMvbWF0aC9FdWxlclwiO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZS9zcmMvbWF0aC9WZWN0b3IzXCI7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSBcInRocmVlL3NyYy9tYXRoL1F1YXRlcm5pb25cIjtcbmltcG9ydCB7IFJlc29uYW5jZUF1ZGlvLCBTb3VyY2UgfSBmcm9tIFwicmVzb25hbmNlLWF1ZGlvXCI7XG5pbXBvcnQgKiBhcyBOdW5qdWNrcyBmcm9tIFwibnVuanVja3NcIjtcbmltcG9ydCBcIi4vZ2xvYmFsXCI7XG5pbXBvcnQgeyBsb2FkUmVzb25hbmNlIH0gZnJvbSBcIi4vbG9hZFJlc29uYW5jZVwiO1xuaW1wb3J0IHsgbG9hZE1lZGlhLCBMb2FkTWVkaWFTdGF0ZSB9IGZyb20gXCIuL2xvYWRNZWRpYVwiO1xuaW1wb3J0IHsgQW5pbWF0aW9uTG9hZGVyIH0gZnJvbSBcInRocmVlXCI7XG5cbmNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5tYXRjaCgvXFwvPyhcXGQrKVxcLmh0bWwvKVsxXSk7XG5cbk51bmp1Y2tzLmNvbmZpZ3VyZShcInRlbXBsYXRlc1wiLCB7IGF1dG9lc2NhcGU6IHRydWUgfSk7XG5kb2N1bWVudC53cml0ZShOdW5qdWNrcy5yZW5kZXIoYGxvYWRlci0ke2luZGV4fS5uamtgKSk7XG5kb2N1bWVudC53cml0ZShOdW5qdWNrcy5yZW5kZXIoYHNjZW5lLSR7aW5kZXh9Lm5qa2ApKTtcblxuY29uc3QgbG9hZE1lZGlhU3RhdGU6IExvYWRNZWRpYVN0YXRlID0ge307XG5sZXQgcmVzb25hbmNlQXVkaW9TY2VuZTogUmVzb25hbmNlQXVkaW8gfCB1bmRlZmluZWQ7XG5sZXQgYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQgfCB1bmRlZmluZWQ7XG5sZXQgb3JpZW50YXRpb25QZXJtaXNzaW9uOiBQZXJtaXNzaW9uU3RhdGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbmNvbnN0IGRlZ3RvcmFkID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IHhBeGlzID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG5jb25zdCB5QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuY29uc3QgekF4aXMgPSBuZXcgVmVjdG9yMygwLCAwLCAxKTtcbmNvbnN0IHVwQXhpcyA9IG5ldyBWZWN0b3IzKDAsIC0xLCAwKTtcbmNvbnN0IGZvcndhcmRBeGlzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG5sZXQgaW5pdGlhbERpcmVjdGlvbjogdW5kZWZpbmVkIHwgVmVjdG9yMyA9IHVuZGVmaW5lZDtcbmNvbnN0IHEwID0gbmV3IFF1YXRlcm5pb24oKTtcbmNvbnN0IHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgYWxwaGFPZmZzZXQgPSAwO1xuY29uc3QgZm9yd2FyZCA9IG5ldyBWZWN0b3IzKDAsIDAsIC0xKTtcbmNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG5jb25zdCBldWxlck9yaWdpbiA9IG5ldyBFdWxlcihNYXRoLlBJIC8gMiwgMCwgMCwgXCJZWlhcIik7XG5cbmNvbnN0IGZyZWV6ZUNoZWNrYm94RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZyZWV6ZS1jaGVja2JveFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG5pbnRlcmZhY2UgQW5pbWF0aW9uVGltZWxpbmVJdGVtIHtcbiAgYW5pbWF0aW9uOiBFbnRpdHlBbmltYXRpb247XG4gIGVudGl0eTogQXVkaW9FbnRpdHk7XG4gIHN0YXJ0VGltZTogbnVtYmVyO1xuICBmaW5pc2hUaW1lOiBudW1iZXI7XG59XG5pbnRlcmZhY2UgQW5pbWF0aW9uVGltZWxpbmVHcm91cCB7XG4gIGl0ZW1zOiBBbmltYXRpb25UaW1lbGluZUl0ZW1bXTtcbiAgZmluaXNoVGltZTogbnVtYmVyO1xufVxuY29uc3QgYW5pbWF0aW9uVGltZWxpbmU6IChBbmltYXRpb25UaW1lbGluZUl0ZW0gfCBBbmltYXRpb25UaW1lbGluZUdyb3VwKVtdID0gW107XG5sZXQgdGltZWxpbmVMb29wOiBudWxsIHwgYm9vbGVhbiA9IG51bGw7XG5sZXQgYW5pbWF0aW9uVGltZWxpbmVJbmRleCA9IC0xO1xubGV0IGFuaW1hdGlvblN0YXJ0VGltZSA9IDA7XG5cbmludGVyZmFjZSBFbnRpdHlBbmltYXRpb24ge1xuICBkdXI6IG51bWJlcjtcbiAgZnJvbTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB0bzogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBkZWxheT86IG51bWJlcjtcbiAgZWFzaW5nOiBcImxpbmVhclwiO1xufVxuXG5pbnRlcmZhY2UgQXVkaW9FbnRpdHkge1xuICBlbDogRWxlbWVudDtcbiAgcG9zaXRpb246IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgaW5kZXg6IG51bWJlcjtcbiAgYnVmZmVyU291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gIHJlc29uYW5jZVNvdXJjZTogU291cmNlO1xuICBhbmltYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBFbnRpdHlBbmltYXRpb24+O1xufVxuY29uc3QgZW50aXRpZXM6IEF1ZGlvRW50aXR5W10gPSBbXTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKFwiI3BsYXktb3ZlcmxheVwiKS5jbGFzc0xpc3QucmVtb3ZlKFwiZmFkZS1vdXRcIik7XG4gIGF1ZGlvQ29udGV4dCA9IG5ldyB3aW5kb3cuQXVkaW9Db250ZXh0KCk7XG4gIHJlc29uYW5jZUF1ZGlvU2NlbmUgPSBsb2FkUmVzb25hbmNlKGF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IGxvYWRlckVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltsb2FkZXJdXCIpO1xuICBsb2FkTWVkaWEobG9hZE1lZGlhU3RhdGUsIHtcbiAgICBlbDogbG9hZGVyRWwsXG4gICAgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQsXG4gICAgb25TdWNjZXNzOiBtZWRpYUxvYWRlZCxcbiAgICBvblByb2dyZXNzOiAocGVyY2VudCkgPT4ge1xuICAgICAgY29uc3QgbG9hZGluZ0J1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGxheS1idXR0b25cIik7XG4gICAgICBpZiAobG9hZGluZ0J1dHRvbikgbG9hZGluZ0J1dHRvbi5pbm5lclRleHQgPSBgTG9hZGluZyAke01hdGgucm91bmQocGVyY2VudCAqIDk4KX0lLi4uYDtcbiAgICB9LFxuICAgIGJhcmNvZGVEYXRhOiBpbmRleC50b1N0cmluZygpLFxuICAgIGxvYWRpbmdCYXJjb2RlQ29udGFpbmVyOiB7IGxvYWRpbmdCYXJjb2RlOiBpbmRleCB9LFxuICB9KTtcblxuICBsb2FkRW50aXRpZXMoKTtcbn0pO1xuXG5mdW5jdGlvbiBsb2FkRW50aXRpZXMoKSB7XG4gIGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbChcIltyZXNvbmFuY2Utc291cmNlXVwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBOdW1iZXIucGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoXCJyZXNvbmFuY2Utc291cmNlXCIpKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGVcbiAgICAgIC5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKVxuICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgLm1hcCgoaSkgPT4gTnVtYmVyLnBhcnNlRmxvYXQoaSkpIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBjb25zdCBidWZmZXJTb3VyY2UgPSBsb2FkTWVkaWFTdGF0ZS5idWZmZXJTb3VyY2VzPy5baW5kZXhdO1xuICAgIGNvbnN0IHJlc29uYW5jZVNvdXJjZSA9IHJlc29uYW5jZUF1ZGlvU2NlbmUuY3JlYXRlU291cmNlKCk7XG4gICAgYnVmZmVyU291cmNlLmNvbm5lY3QocmVzb25hbmNlU291cmNlLmlucHV0KTtcbiAgICByZXNvbmFuY2VTb3VyY2Uuc2V0UG9zaXRpb24ocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCBwb3NpdGlvblsyXSk7XG5cbiAgICBjb25zdCBhbmltYXRpb25zID0gZXh0cmFjdEFuaW1hdGlvbnMoZSk7XG4gICAgY29uc3QgbWl4aW5BbmltYXRpb25zID0gZS5oYXNBdHRyaWJ1dGUoXCJtaXhpblwiKVxuICAgICAgPyBleHRyYWN0QW5pbWF0aW9ucyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlLmdldEF0dHJpYnV0ZShcIm1peGluXCIpKSlcbiAgICAgIDoge307XG5cbiAgICBjb25zdCBlbnRpdHkgPSB7XG4gICAgICBlbDogZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgaW5kZXgsXG4gICAgICBidWZmZXJTb3VyY2UsXG4gICAgICByZXNvbmFuY2VTb3VyY2UsXG4gICAgICBhbmltYXRpb25zOiB7IC4uLm1peGluQW5pbWF0aW9ucywgLi4uYW5pbWF0aW9ucyB9LFxuICAgIH07XG4gICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xuICB9KTtcblxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiYS1lbnRpdHlcIikuZm9yRWFjaCgoZSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSBBcnJheS5mcm9tKGUuYXR0cmlidXRlcykuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lLnN0YXJ0c1dpdGgoXCJhbmltYXRpb24tdGltZWxpbmVcIikpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBpZiAodGltZWxpbmVMb29wICE9PSBudWxsKSB0aHJvdyBFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgZW50aXR5IHdpdGggYW5pbWF0aW9uLXRpbWVsaW5lIGF0dHJpYnV0ZVwiKTtcbiAgICAgIGlmIChhdHRyLnZhbHVlLm1hdGNoKC9sb29wOlxccz90cnVlLykpIHRpbWVsaW5lTG9vcCA9IHRydWU7XG4gICAgICBlbHNlIHRpbWVsaW5lTG9vcCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnNvbGUubG9nKGBsb29wOiAke3RpbWVsaW5lTG9vcH1gKTtcblxuICBjb25zdCB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImEtdGltZWxpbmVcIik7XG4gIGlmICghdCkgdGhyb3cgRXJyb3IoXCJObyBhbmltYXRpb24gdGltZWxpbmUgZm91bmRcIik7XG4gIGxldCB0aW1lID0gMDtcbiAgQXJyYXkuZnJvbSh0LmNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGlmIChjaGlsZC50YWdOYW1lID09PSBcIkEtVElNRUxJTkUtQU5JTUFUSU9OXCIpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hpbGQuZ2V0QXR0cmlidXRlKFwic2VsZWN0XCIpO1xuICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXMuZmluZCgoZSkgPT4gZS5lbCA9PT0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpKTtcbiAgICAgIGlmICghZW50aXR5KSB0aHJvdyBFcnJvcihgQ291bGRuJ3QgZmluZCBlbnRpdHkgJHt0YXJnZXR9YCk7XG4gICAgICBjb25zdCBhbmltYXRpb24gPSBlbnRpdHkuYW5pbWF0aW9uc1tuYW1lXTtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUgKyAoYW5pbWF0aW9uLmRlbGF5ID8/IDApO1xuICAgICAgY29uc3QgZmluaXNoVGltZSA9IHN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXI7XG4gICAgICBhbmltYXRpb25UaW1lbGluZS5wdXNoKHtcbiAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICBlbnRpdHksXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZmluaXNoVGltZSxcbiAgICAgIH0pO1xuICAgICAgdGltZSA9IGZpbmlzaFRpbWU7XG4gICAgfSBlbHNlIGlmIChjaGlsZC50YWdOYW1lID09PSBcIkEtVElNRUxJTkUtR1JPVVBcIikge1xuICAgICAgY29uc3QgZ3JvdXA6IEFuaW1hdGlvblRpbWVsaW5lR3JvdXAgPSB7IGl0ZW1zOiBbXSwgZmluaXNoVGltZTogMCB9O1xuICAgICAgQXJyYXkuZnJvbShjaGlsZC5jaGlsZHJlbikuZm9yRWFjaCgoZ3JhbmRjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoZ3JhbmRjaGlsZC50YWdOYW1lID09PSBcIkEtVElNRUxJTkUtQU5JTUFUSU9OXCIpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYGFuaW1hdGlvbl9fJHtncmFuZGNoaWxkLmdldEF0dHJpYnV0ZShcIm5hbWVcIil9YDtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBncmFuZGNoaWxkLmdldEF0dHJpYnV0ZShcInNlbGVjdFwiKTtcbiAgICAgICAgICBjb25zdCBlbnRpdHkgPSBlbnRpdGllcy5maW5kKChlKSA9PiBlLmVsID09PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkpO1xuICAgICAgICAgIGlmICghZW50aXR5KSB0aHJvdyBFcnJvcihgQ291bGRuJ3QgZmluZCBlbnRpdHkgJHt0YXJnZXR9YCk7XG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gZW50aXR5LmFuaW1hdGlvbnNbbmFtZV07XG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGltZSArIChhbmltYXRpb24uZGVsYXkgPz8gMCk7XG4gICAgICAgICAgY29uc3QgZmluaXNoVGltZSA9IHN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXI7XG4gICAgICAgICAgZ3JvdXAuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhbmltYXRpb24sXG4gICAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICBmaW5pc2hUaW1lLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGdyb3VwLmZpbmlzaFRpbWUgPSBNYXRoLm1heChncm91cC5maW5pc2hUaW1lLCBmaW5pc2hUaW1lKTtcbiAgICAgICAgfSBlbHNlIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCB0aW1lbGluZSB0YWcgJHtncmFuZGNoaWxkLnRhZ05hbWV9YCk7XG4gICAgICB9KTtcbiAgICAgIGFuaW1hdGlvblRpbWVsaW5lLnB1c2goZ3JvdXApO1xuICAgICAgdGltZSA9IGdyb3VwLmZpbmlzaFRpbWU7XG4gICAgfSBlbHNlIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCB0aW1lbGluZSB0YWcgJHtjaGlsZC50YWdOYW1lfWApO1xuICB9KTtcbiAgY29uc29sZS5sb2coYW5pbWF0aW9uVGltZWxpbmUpO1xufVxuXG5mdW5jdGlvbiBtZWRpYUxvYWRlZCgpIHtcbiAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yPEhUTUxCdXR0b25FbGVtZW50PihcIiNwbGF5LWJ1dHRvblwiKTtcbiAgYnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gIGJ1dHRvbi5pbm5lclRleHQgPSBcIlBsYXlcIjtcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIDE7XG4gICAgYW5pbWF0aW9uU3RhcnRUaW1lID0gRGF0ZS5ub3coKSArIDEwMDA7XG4gICAgZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiBlbnRpdHkuYnVmZmVyU291cmNlLnN0YXJ0KHN0YXJ0VGltZSkpO1xuICAgIHdpbmRvdy5zZXRJbnRlcnZhbChtYWluTG9vcCwgNTApO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGl0bGVcIikuaW5uZXJUZXh0ID0gXCJZb3UgYXJlIGxpc3RlbmluZyB0byB0aGUgc3BhdGlhbCBleHBlcmllbmNlLlwiO1xuICAgIGJ1dHRvbi5yZW1vdmUoKTtcbiAgICBpZiAod2luZG93LkRldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgRGV2aWNlT3JpZW50YXRpb25FdmVudC5yZXF1ZXN0UGVybWlzc2lvbiAmJlxuICAgICAgICBvcmllbnRhdGlvblBlcm1pc3Npb24gIT09IFwiZGVuaWVkXCIgJiZcbiAgICAgICAgb3JpZW50YXRpb25QZXJtaXNzaW9uICE9PSBcImdyYW50ZWRcIlxuICAgICAgKSB7XG4gICAgICAgIG9yaWVudGF0aW9uUGVybWlzc2lvbiA9IGF3YWl0IERldmljZU9yaWVudGF0aW9uRXZlbnQucmVxdWVzdFBlcm1pc3Npb24oKTtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uUGVybWlzc2lvbiA9PT0gXCJkZW5pZWRcIikge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKTtcbiAgICAgICAgICBtZXNzYWdlLmlubmVyVGV4dCA9IFwiWW91IGRpZCBub3QgZ2l2ZSBwZXJtaXNzaW9uIHRvIHVzZSBkZXZpY2UgbW90aW9uLiBZb3VyIHZpZXdwb2ludCB3aWxsIHJlbWFpbiBzdGF0aWMuXCI7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsIHRocm90dGxlKHVwZGF0ZUxpc3RlbmVyLCA1MCkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1haW5Mb29wKCkge1xuICB1cGRhdGVFbnRpdGllcygpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFbnRpdGllcygpIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgLy9pbmNyZW1lbnQgdGhlIHRpbWVsaW5lIGlmIG5lY2Vzc2FyeVxuICB3aGlsZSAobm93ID4gKGFuaW1hdGlvblRpbWVsaW5lPy5bYW5pbWF0aW9uVGltZWxpbmVJbmRleF0/LmZpbmlzaFRpbWUgPz8gMCkgKyBhbmltYXRpb25TdGFydFRpbWUpIHtcbiAgICBhbmltYXRpb25UaW1lbGluZUluZGV4Kys7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPj0gYW5pbWF0aW9uVGltZWxpbmUubGVuZ3RoKSB7XG4gICAgICBpZiAoIXRpbWVsaW5lTG9vcCkgcmV0dXJuO1xuICAgICAgYW5pbWF0aW9uU3RhcnRUaW1lID0gYW5pbWF0aW9uU3RhcnRUaW1lICsgYW5pbWF0aW9uVGltZWxpbmVbYW5pbWF0aW9uVGltZWxpbmVJbmRleCAtIDFdLmZpbmlzaFRpbWU7XG4gICAgICBhbmltYXRpb25UaW1lbGluZUluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgLy9pbmRleCBpcyBsZXNzIHRoYW4gemVybyBhdCB0aGUgc3RhcnQgYmVjYXVzZSB0aGUgYXVkaW8gcGxheXMgYWZ0ZXIgMSBzZWNcbiAgaWYgKGFuaW1hdGlvblRpbWVsaW5lSW5kZXggPCAwKSByZXR1cm47XG5cbiAgLy9wbGFjZSBpdGVtc1xuICBjb25zdCBhID0gYW5pbWF0aW9uVGltZWxpbmVbYW5pbWF0aW9uVGltZWxpbmVJbmRleF07XG4gIC8vaXMgYXJyYXlcbiAgaWYgKFwiaXRlbXNcIiBpbiBhKSB7XG4gICAgYS5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpbnRlcnBvbGF0ZShcbiAgICAgICAgaXRlbS5lbnRpdHkucmVzb25hbmNlU291cmNlLFxuICAgICAgICBNYXRoLm1heCgwLCAobm93IC0gYW5pbWF0aW9uU3RhcnRUaW1lIC0gaXRlbS5zdGFydFRpbWUpIC8gKGl0ZW0uZmluaXNoVGltZSAtIGl0ZW0uc3RhcnRUaW1lKSksXG4gICAgICAgIGl0ZW0uYW5pbWF0aW9uLmZyb20sXG4gICAgICAgIGl0ZW0uYW5pbWF0aW9uLnRvLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvL3NpbmdsZSBpdGVtLCBub3QgYXJyYXlcbiAgICBpbnRlcnBvbGF0ZShcbiAgICAgIGEuZW50aXR5LnJlc29uYW5jZVNvdXJjZSxcbiAgICAgIE1hdGgubWF4KDAsIChub3cgLSBhbmltYXRpb25TdGFydFRpbWUgLSBhLnN0YXJ0VGltZSkgLyAoYS5maW5pc2hUaW1lIC0gYS5zdGFydFRpbWUpKSxcbiAgICAgIGEuYW5pbWF0aW9uLmZyb20sXG4gICAgICBhLmFuaW1hdGlvbi50byxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVyKGU6IERldmljZU9yaWVudGF0aW9uRXZlbnQpIHtcbiAgaWYgKGZyZWV6ZUNoZWNrYm94RWwuY2hlY2tlZCkgcmV0dXJuO1xuICBjb25zdCBhbHBoYSA9IGUuYWxwaGEgPyBlLmFscGhhICogZGVndG9yYWQgKyBhbHBoYU9mZnNldCA6IDA7IC8vIFpcbiAgY29uc3QgYmV0YSA9IGUuYmV0YSA/IGUuYmV0YSAqIGRlZ3RvcmFkIDogMDsgLy8gWCdcbiAgY29uc3QgZ2FtbWEgPSBlLmdhbW1hID8gZS5nYW1tYSAqIGRlZ3RvcmFkIDogMDsgLy8gWScnXG4gIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyT3JpZ2luKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh6QXhpcywgYWxwaGEpO1xuICBxdWF0ZXJuaW9uLm11bHRpcGx5KHEwKTtcbiAgcTAuc2V0RnJvbUF4aXNBbmdsZSh4QXhpcywgYmV0YSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuICBxMC5zZXRGcm9tQXhpc0FuZ2xlKHlBeGlzLCBnYW1tYSk7XG4gIHF1YXRlcm5pb24ubXVsdGlwbHkocTApO1xuXG4gIHVwLmNvcHkodXBBeGlzKS5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gIGZvcndhcmQuY29weShmb3J3YXJkQXhpcykuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuXG4gIGlmICghaW5pdGlhbERpcmVjdGlvbikge1xuICAgIGluaXRpYWxEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMygpLnByb2plY3RPblBsYW5lKHVwQXhpcykubm9ybWFsaXplKCk7XG4gICAgY29uc3QgYW5nbGUgPSBpbml0aWFsRGlyZWN0aW9uLmFuZ2xlVG8oZm9yd2FyZEF4aXMpO1xuICAgIGV1bGVyT3JpZ2luLnkgPSBhbmdsZTtcbiAgfVxuICAvKmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWdcIikuaW5uZXJIVE1MID0gYCR7Zm9yd2FyZC54LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC55LnRvRml4ZWQoMil9ICR7Zm9yd2FyZC56LnRvRml4ZWQoXG4gICAgMixcbiAgKX08YnI+JHt1cC54LnRvRml4ZWQoMil9ICR7dXAueS50b0ZpeGVkKDIpfSAke3VwLnoudG9GaXhlZCgyKX08YnI+XG4gICR7YWxwaGEudG9GaXhlZCgyKX0gJHtiZXRhLnRvRml4ZWQoMil9ICR7Z2FtbWEudG9GaXhlZCgyKX08YnI+XG4gICR7ZXVsZXJPcmlnaW4ueC50b0ZpeGVkKDIpfSAke2V1bGVyT3JpZ2luLnkudG9GaXhlZCgyKX0gJHtldWxlck9yaWdpbi56LnRvRml4ZWQoMil9YDsqL1xuXG4gIC8vQHRzLWV4cGVjdC1lcnJvciAtIGJhZCB0eXBpbmdcbiAgcmVzb25hbmNlQXVkaW9TY2VuZS5zZXRMaXN0ZW5lck9yaWVudGF0aW9uKGZvcndhcmQueCwgZm9yd2FyZC55LCBmb3J3YXJkLnosIHVwLngsIHVwLnksIHVwLnopO1xufVxuXG5mdW5jdGlvbiB0aHJvdHRsZShjYWxsYmFjazogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93biwgZGVsYXk6IG51bWJlcikge1xuICBsZXQgcHJldiA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKG5vdyAtIHByZXYgPCBkZWxheSkgcmV0dXJuO1xuICAgIHByZXYgPSBub3c7XG4gICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QW5pbWF0aW9ucyhlbGVtZW50OiBFbGVtZW50KTogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiB7XG4gIGNvbnN0IHJlc3VsdDogUmVjb3JkPHN0cmluZywgRW50aXR5QW5pbWF0aW9uPiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBlbGVtZW50LmF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKFwiYW5pbWF0aW9uX19cIikgfHwgYXR0ci5uYW1lID09PSBcImFuaW1hdGlvblwiKSB7XG4gICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IHBhcnNlQW5pbWF0aW9uKGF0dHIudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUFuaW1hdGlvbihhOiBzdHJpbmcpIHtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gIGNvbnN0IGRhdGEgPSBhLnNwbGl0KFwiO1wiKS5tYXAoKGUpID0+XG4gICAgZVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFwiOlwiKVxuICAgICAgLm1hcCgoZTIpID0+IGUyLnRyaW0oKSksXG4gICk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkYXRhW2ldLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuICAgIGlmIChkYXRhW2ldWzBdID09PSBcImZyb21cIiB8fCBkYXRhW2ldWzBdID09PSBcInRvXCIpIHtcbiAgICAgIHJlc3VsdFtkYXRhW2ldWzBdXSA9IGRhdGFbaV1bMV0uc3BsaXQoXCIgXCIpLm1hcCgobikgPT4gTnVtYmVyLnBhcnNlRmxvYXQobikpO1xuICAgIH0gZWxzZSBpZiAoZGF0YVtpXVswXSA9PT0gXCJkdXJcIiB8fCBkYXRhW2ldWzBdID09PSBcImRlbGF5XCIpIHtcbiAgICAgIHJlc3VsdFtkYXRhW2ldWzBdXSA9IE51bWJlci5wYXJzZUludChkYXRhW2ldWzFdKTtcbiAgICB9IGVsc2UgaWYgKGRhdGFbaV1bMV0gPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXN1bHRbZGF0YVtpXVswXV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YVtpXVsxXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXN1bHRbZGF0YVtpXVswXV0gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2RhdGFbaV1bMF1dID0gZGF0YVtpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCBhcyBFbnRpdHlBbmltYXRpb247XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKFxuICByZXNvbmFuY2VTb3VyY2U6IFNvdXJjZSxcbiAgdDogbnVtYmVyLFxuICBmcm9tOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIHRvOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGVhc2luZzogRW50aXR5QW5pbWF0aW9uW1wiZWFzaW5nXCJdID0gXCJsaW5lYXJcIixcbikge1xuICBzd2l0Y2ggKGVhc2luZykge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHJlc29uYW5jZVNvdXJjZS5zZXRQb3NpdGlvbihcbiAgICAgICAgZnJvbVswXSArIHQgKiAodG9bMF0gLSBmcm9tWzBdKSxcbiAgICAgICAgZnJvbVsxXSArIHQgKiAodG9bMV0gLSBmcm9tWzFdKSxcbiAgICAgICAgZnJvbVsyXSArIHQgKiAodG9bMl0gLSBmcm9tWzJdKSxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3IoYFVuaGFuZGxlZCBlYXNpbmcgJHtlYXNpbmd9YCk7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=